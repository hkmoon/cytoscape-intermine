(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],3:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":4}],4:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],5:[function(require,module,exports){
(function (process,__dirname){
/*!
 * This file is part of Cytoscape.js 2.4.4.
 * 
 * Cytoscape.js is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 * 
 * Cytoscape.js is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
 * details.
 * 
 * You should have received a copy of the GNU Lesser General Public License along with
 * Cytoscape.js. If not, see <http://www.gnu.org/licenses/>.
 */
 

// this is put as a global var in the browser
// or it's just a global to this module if commonjs

var cytoscape;

(function(window){ 'use strict';

  // the object iteself is a function that init's an instance of cytoscape

  var $$ = cytoscape = function(){ // jshint ignore:line
    return cytoscape.init.apply(cytoscape, arguments);
  };

  $$.version = '2.4.4';
  
  // allow functional access to cytoscape.js
  // e.g. var cyto = $.cytoscape({ selector: "#foo", ... });
  //      var nodes = cyto.nodes();
  $$.init = function( options ){
    
    // if no options specified, use default
    if( options === undefined ){
      options = {};
    }

    // create instance
    if( $$.is.plainObject( options ) ){
      return new $$.Core( options );
    } 
    
    // allow for registration of extensions
    // e.g. $.cytoscape('renderer', 'svg', SvgRenderer);
    // e.g. $.cytoscape('renderer', 'svg', 'nodeshape', 'ellipse', SvgEllipseNodeShape);
    // e.g. $.cytoscape('core', 'doSomething', function(){ /* doSomething code */ });
    // e.g. $.cytoscape('collection', 'doSomething', function(){ /* doSomething code */ });
    else if( $$.is.string( options ) ) {
      return $$.extension.apply($$.extension, arguments);
    }
  };

  // define the function namespace here, since it has members in many places
  $$.fn = {};

  if( typeof module !== 'undefined' && module.exports ){ // expose as a commonjs module
    module.exports = cytoscape;
  }

  if( typeof define !== 'undefined' && define.amd ){ // expose as an amd/requirejs module
    define('cytoscape', function(){
      return cytoscape;
    });
  }

  // make sure we always register in the window just in case (e.g. w/ derbyjs)
  if( window ){
    window.cytoscape = cytoscape;
  }
  
})( typeof window === 'undefined' ? null : window );

// extra set to `this` is necessary for meteor
this.cytoscape = cytoscape;

// internal, minimal Promise impl s.t. apis can return promises in old envs
// based on thenable (http://github.com/rse/thenable)

// NB: you must use `new $$.Promise`, because you may have native promises that don't autonew for you

;(function($$){ 'use strict';
  
  /*  promise states [Promises/A+ 2.1]  */
  var STATE_PENDING   = 0;                                         /*  [Promises/A+ 2.1.1]  */
  var STATE_FULFILLED = 1;                                         /*  [Promises/A+ 2.1.2]  */
  var STATE_REJECTED  = 2;                                         /*  [Promises/A+ 2.1.3]  */

  /*  promise object constructor  */
  var api = function (executor) {
    /*  optionally support non-constructor/plain-function call  */
    if (!(this instanceof api))
      return new api(executor);

    /*  initialize object  */
    this.id           = "Thenable/1.0.7";
    this.state        = STATE_PENDING; /*  initial state  */
    this.fulfillValue = undefined;     /*  initial value  */     /*  [Promises/A+ 1.3, 2.1.2.2]  */
    this.rejectReason = undefined;     /*  initial reason */     /*  [Promises/A+ 1.5, 2.1.3.2]  */
    this.onFulfilled  = [];            /*  initial handlers  */
    this.onRejected   = [];            /*  initial handlers  */

    /*  provide optional information-hiding proxy  */
    this.proxy = {
      then: this.then.bind(this)
    };

    /*  support optional executor function  */
    if (typeof executor === "function")
      executor.call(this, this.fulfill.bind(this), this.reject.bind(this));
  };

  /*  promise API methods  */
  api.prototype = {
    /*  promise resolving methods  */
    fulfill: function (value) { return deliver(this, STATE_FULFILLED, "fulfillValue", value); },
    reject:  function (value) { return deliver(this, STATE_REJECTED,  "rejectReason", value); },

    /*  "The then Method" [Promises/A+ 1.1, 1.2, 2.2]  */
    then: function (onFulfilled, onRejected) {
      var curr = this;
      var next = new api();                                    /*  [Promises/A+ 2.2.7]  */
      curr.onFulfilled.push(
        resolver(onFulfilled, next, "fulfill"));             /*  [Promises/A+ 2.2.2/2.2.6]  */
      curr.onRejected.push(
        resolver(onRejected,  next, "reject" ));             /*  [Promises/A+ 2.2.3/2.2.6]  */
      execute(curr);
      return next.proxy;                                       /*  [Promises/A+ 2.2.7, 3.3]  */
    }
  };

  /*  deliver an action  */
  var deliver = function (curr, state, name, value) {
    if (curr.state === STATE_PENDING) {
      curr.state = state;                                      /*  [Promises/A+ 2.1.2.1, 2.1.3.1]  */
      curr[name] = value;                                      /*  [Promises/A+ 2.1.2.2, 2.1.3.2]  */
      execute(curr);
    }
    return curr;
  };

  /*  execute all handlers  */
  var execute = function (curr) {
    if (curr.state === STATE_FULFILLED)
      execute_handlers(curr, "onFulfilled", curr.fulfillValue);
    else if (curr.state === STATE_REJECTED)
      execute_handlers(curr, "onRejected",  curr.rejectReason);
  };

  /*  execute particular set of handlers  */
  var execute_handlers = function (curr, name, value) {
    /* global process: true */
    /* global setImmediate: true */
    /* global setTimeout: true */

    /*  short-circuit processing  */
    if (curr[name].length === 0)
      return;

    /*  iterate over all handlers, exactly once  */
    var handlers = curr[name];
    curr[name] = [];                                             /*  [Promises/A+ 2.2.2.3, 2.2.3.3]  */
    var func = function () {
      for (var i = 0; i < handlers.length; i++)
        handlers[i](value);                                  /*  [Promises/A+ 2.2.5]  */
    };

    /*  execute procedure asynchronously  */                     /*  [Promises/A+ 2.2.4, 3.1]  */
    if (typeof process === "object" && typeof process.nextTick === "function")
      process.nextTick(func);
    else if (typeof setImmediate === "function")
      setImmediate(func);
    else
      setTimeout(func, 0);
  };

  /*  generate a resolver function  */
  var resolver = function (cb, next, method) {
    return function (value) {
      if (typeof cb !== "function")                            /*  [Promises/A+ 2.2.1, 2.2.7.3, 2.2.7.4]  */
        next[method].call(next, value);                      /*  [Promises/A+ 2.2.7.3, 2.2.7.4]  */
      else {
        var result;
        try { result = cb(value); }                          /*  [Promises/A+ 2.2.2.1, 2.2.3.1, 2.2.5, 3.2]  */
        catch (e) {
          next.reject(e);                                  /*  [Promises/A+ 2.2.7.2]  */
          return;
        }
        resolve(next, result);                               /*  [Promises/A+ 2.2.7.1]  */
      }
    };
  };

  /*  "Promise Resolution Procedure"  */                           /*  [Promises/A+ 2.3]  */
  var resolve = function (promise, x) {
    /*  sanity check arguments  */                               /*  [Promises/A+ 2.3.1]  */
    if (promise === x || promise.proxy === x) {
      promise.reject(new TypeError("cannot resolve promise with itself"));
      return;
    }

    /*  surgically check for a "then" method
      (mainly to just call the "getter" of "then" only once)  */
    var then;
    if ((typeof x === "object" && x !== null) || typeof x === "function") {
      try { then = x.then; }                                   /*  [Promises/A+ 2.3.3.1, 3.5]  */
      catch (e) {
        promise.reject(e);                                   /*  [Promises/A+ 2.3.3.2]  */
        return;
      }
    }

    /*  handle own Thenables    [Promises/A+ 2.3.2]
      and similar "thenables" [Promises/A+ 2.3.3]  */
    if (typeof then === "function") {
      var resolved = false;
      try {
        /*  call retrieved "then" method */                  /*  [Promises/A+ 2.3.3.3]  */
        then.call(x,
          /*  resolvePromise  */                           /*  [Promises/A+ 2.3.3.3.1]  */
          function (y) {
            if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
            if (y === x)                                 /*  [Promises/A+ 3.6]  */
              promise.reject(new TypeError("circular thenable chain"));
            else
              resolve(promise, y);
          },

          /*  rejectPromise  */                            /*  [Promises/A+ 2.3.3.3.2]  */
          function (r) {
            if (resolved) return; resolved = true;       /*  [Promises/A+ 2.3.3.3.3]  */
            promise.reject(r);
          }
        );
      }
      catch (e) {
        if (!resolved)                                       /*  [Promises/A+ 2.3.3.3.3]  */
          promise.reject(e);                               /*  [Promises/A+ 2.3.3.3.4]  */
      }
      return;
    }

    /*  handle other values  */
    promise.fulfill(x);                                          /*  [Promises/A+ 2.3.4, 2.3.3.4]  */
  };

  // use native promises where possible
  $$.Promise = typeof Promise === 'undefined' ? api : Promise;

  // so we always have Promise.all()
  $$.Promise.all = $$.Promise.all || function( ps ){
    return new $$.Promise(function( resolveAll, rejectAll ){
      var vals = new Array( ps.length );
      var doneCount = 0;

      var fulfill = function( i, val ){
        vals[i] = val;
        doneCount++;

        if( doneCount === ps.length ){
          resolveAll( vals );
        }
      };

      for( var i = 0; i < ps.length; i++ ){
        (function( i ){
          var p = ps[i];
          var isPromise = p.then != null;

          if( isPromise ){
            p.then(function( val ){
              fulfill( i, val );
            }, function( err ){
              rejectAll( err );
            });
          } else {
            var val = p;
            fulfill( i, val );
          }
        })( i );
      }

    });
  };

})( cytoscape );
// type testing utility functions

;(function($$, window){ 'use strict';

  var typeofstr = typeof '';
  var typeofobj = typeof {};
  var typeoffn = typeof function(){};

  $$.is = {
    defined: function(obj){
      return obj != null; // not undefined or null
    },

    string: function(obj){
      return obj != null && typeof obj == typeofstr;
    },
    
    fn: function(obj){
      return obj != null && typeof obj === typeoffn;
    },
    
    array: function(obj){
      return Array.isArray ? Array.isArray(obj) : obj != null && obj instanceof Array;
    },
    
    plainObject: function(obj){
      return obj != null && typeof obj === typeofobj && !$$.is.array(obj) && obj.constructor === Object;
    },

    object: function(obj){
      return obj != null && typeof obj === typeofobj;
    },
    
    number: function(obj){
      return obj != null && typeof obj === typeof 1 && !isNaN(obj);
    },

    integer: function( obj ){
      return $$.is.number(obj) && Math.floor(obj) === obj;
    },
    
    color: function(obj){
      return obj != null && typeof obj === typeof '' && $.Color(obj).toString() !== '';
    },
    
    bool: function(obj){
      return obj != null && typeof obj === typeof true;
    },
    
    elementOrCollection: function(obj){
      return $$.is.element(obj) || $$.is.collection(obj);
    },
    
    element: function(obj){
      return obj instanceof $$.Element && obj._private.single;
    },
    
    collection: function(obj){
      return obj instanceof $$.Collection && !obj._private.single;
    },
    
    core: function(obj){
      return obj instanceof $$.Core;
    },

    style: function(obj){
      return obj instanceof $$.Style;
    },

    stylesheet: function(obj){
      return obj instanceof $$.Stylesheet;
    },

    event: function(obj){
      return obj instanceof $$.Event;
    },

    thread: function(obj){
      return obj instanceof $$.Thread;
    },

    fabric: function(obj){
      return obj instanceof $$.Fabric;
    },

    emptyString: function(obj){
      if( !obj ){ // null is empty
        return true; 
      } else if( $$.is.string(obj) ){
        if( obj === '' || obj.match(/^\s+$/) ){
          return true; // empty string is empty
        }
      }
      
      return false; // otherwise, we don't know what we've got
    },
    
    nonemptyString: function(obj){
      if( obj && $$.is.string(obj) && obj !== '' && !obj.match(/^\s+$/) ){
        return true;
      }

      return false;
    },

    domElement: function(obj){
      if( typeof HTMLElement === 'undefined' ){
        return false; // we're not in a browser so it doesn't matter
      } else {
        return obj instanceof HTMLElement;
      }
    },

    boundingBox: function(obj){
      return $$.is.plainObject(obj) && 
        $$.is.number(obj.x1) && $$.is.number(obj.x2) &&
        $$.is.number(obj.y1) && $$.is.number(obj.y2)
      ;
    },

    promise: function(obj){
      return $$.is.object(obj) && $$.is.fn(obj.then);
    },

    touch: function(){
      return window && ( ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch );
    },

    gecko: function(){
      return typeof InstallTrigger !== 'undefined' || ('MozAppearance' in document.documentElement.style);
    },

    webkit: function(){
      return typeof webkitURL !== 'undefined' || ('WebkitAppearance' in document.documentElement.style);
    },

    chromium: function(){
      return typeof chrome !== 'undefined';
    },

    khtml: function(){
      return navigator.vendor.match(/kde/i); // TODO probably a better way to detect this...
    },

    khtmlEtc: function(){
      return $$.is.khtml() || $$.is.webkit() || $$.is.chromium();
    },

    trident: function(){
       return typeof ActiveXObject !== 'undefined' || /*@cc_on!@*/false;
    },

    windows: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Win/i);
    },

    mac: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Mac/i);
    },

    linux: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/Linux/i);
    },

    unix: function(){
      return typeof navigator !== 'undefined' && navigator.appVersion.match(/X11/i);
    }
  };  
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';
  
  // utility functions only for internal use

  $$.util = {

    // the jquery extend() function
    // NB: modified to use $$.is etc since we can't use jquery functions
    extend: function() {
      var options, name, src, copy, copyIsArray, clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;

      // Handle a deep copy situation
      if ( typeof target === 'boolean' ) {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
      }

      // Handle case when target is a string or something (possible in deep copy)
      if ( typeof target !== 'object' && !$$.is.fn(target) ) {
        target = {};
      }

      // extend jQuery itself if only one argument is passed
      if ( length === i ) {
        target = this;
        --i;
      }

      for ( ; i < length; i++ ) {
        // Only deal with non-null/undefined values
        if ( (options = arguments[ i ]) != null ) {
          // Extend the base object
          for ( name in options ) {
            src = target[ name ];
            copy = options[ name ];

            // Prevent never-ending loop
            if ( target === copy ) {
              continue;
            }

            // Recurse if we're merging plain objects or arrays
            if ( deep && copy && ( $$.is.plainObject(copy) || (copyIsArray = $$.is.array(copy)) ) ) {
              if ( copyIsArray ) {
                copyIsArray = false;
                clone = src && $$.is.array(src) ? src : [];

              } else {
                clone = src && $$.is.plainObject(src) ? src : {};
              }

              // Never move original objects, clone them
              target[ name ] = $$.util.extend( deep, clone, copy );

            // Don't bring in undefined values
            } else if ( copy !== undefined ) {
              target[ name ] = copy;
            }
          }
        }
      }

      // Return the modified object
      return target;
    },

    // require that pulls in module from commonjs, amd, or window (falling back until found)
    require: function( name, callback, options ){
      var ret;
      options = $$.util.extend({
        msgIfNotFound: true
      }, options);

      var done = false;
      var fulfil = function( ret ){
        done = true;
        callback( ret );
      };

      var checkWindow = function( next ){
        if( window ){ // detected browser/window env
          ret = window[ name ];
        }

        if( ret !== undefined ){ fulfil(ret); }
        if( next ){ next(); }
      };
      var onCheckWindowDone = function(){
        if( !done ){
          checkCommonJs( onCheckCommonJsDone );
        }
      };

      var checkCommonJs = function( next ){
        if( typeof module !== 'undefined' && module.exports && require ){ // detected commonjs env
          ret = require( name ); // regular require
        }

        if( ret !== undefined ){ fulfil(ret); }
        if( next ){ next(); }
      };
      var onCheckCommonJsDone = function(){
        if( !done ){
          checkAmd( onCheckAmdDone );
        }
      };

      var checkAmd = function( next ){
        if( typeof define !== 'undefined' && define.amd && require ){ // detected amd env w/ defined module
          require([ name ], function( nameImpl ){
            ret = nameImpl;
            
            if( ret !== undefined ){ fulfil(ret); }
            if( next ){ next(); }
          });
        }
      };
      var onCheckAmdDone = function(){
        if( !done && options.msgIfNotFound ){
          $$.util.error('Cytoscape.js tried to pull in dependency `' + name + '` but no module (i.e. CommonJS, AMD, or window) was found');
        }
      };

      // kick off 1st check: window
      checkWindow( onCheckWindowDone );

    },

    // multiple requires in one callback
    requires: function( names, callback ){
      var impls = [];
      var gotImpl = [];

      var checkDone = function(){
        for( var i = 0; i < names.length; i++ ){ // check have all impls
          if( !gotImpl[i] ){ return; }
        }

        // otherwise, all got all impls => done
        callback.apply( callback, impls ); 
      };

      for( var i = 0; i < names.length; i++ ){ (function(){ // w/scope
        var name = names[i];
        var index = i;

        $$.util.require(name, function(impl){
          impls[index] = impl;
          gotImpl[index] = true;

          checkDone();
        });
      })(); }
    },

    // ported lodash throttle function
    throttle: function(func, wait, options) {
      var leading = true,
          trailing = true;

      if (options === false) {
        leading = false;
      } else if ($$.is.plainObject(options)) {
        leading = 'leading' in options ? options.leading : leading;
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      options = options || {};
      options.leading = leading;
      options.maxWait = wait;
      options.trailing = trailing;

      return $$.util.debounce(func, wait, options);
    },

    now: function(){
      return +new Date();
    },

    // ported lodash debounce function
    debounce: function(func, wait, options) {
      var args,
          maxTimeoutId,
          result,
          stamp,
          thisArg,
          timeoutId,
          trailingCall,
          lastCalled = 0,
          maxWait = false,
          trailing = true;

      if (!$$.is.fn(func)) {
        return;
      }
      wait = Math.max(0, wait) || 0;
      if (options === true) {
        var leading = true;
        trailing = false;
      } else if ($$.is.plainObject(options)) {
        leading = options.leading;
        maxWait = 'maxWait' in options && (Math.max(wait, options.maxWait) || 0);
        trailing = 'trailing' in options ? options.trailing : trailing;
      }
      var delayed = function() {
        var remaining = wait - ($$.util.now() - stamp);
        if (remaining <= 0) {
          if (maxTimeoutId) {
            clearTimeout(maxTimeoutId);
          }
          var isCalled = trailingCall;
          maxTimeoutId = timeoutId = trailingCall = undefined;
          if (isCalled) {
            lastCalled = $$.util.now();
            result = func.apply(thisArg, args);
            if (!timeoutId && !maxTimeoutId) {
              args = thisArg = null;
            }
          }
        } else {
          timeoutId = setTimeout(delayed, remaining);
        }
      };

      var maxDelayed = function() {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (trailing || (maxWait !== wait)) {
          lastCalled = $$.util.now();
          result = func.apply(thisArg, args);
          if (!timeoutId && !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      };

      return function() {
        args = arguments;
        stamp = $$.util.now();
        thisArg = this;
        trailingCall = trailing && (timeoutId || !leading);

        if (maxWait === false) {
          var leadingCall = leading && !timeoutId;
        } else {
          if (!maxTimeoutId && !leading) {
            lastCalled = stamp;
          }
          var remaining = maxWait - (stamp - lastCalled),
              isCalled = remaining <= 0;

          if (isCalled) {
            if (maxTimeoutId) {
              maxTimeoutId = clearTimeout(maxTimeoutId);
            }
            lastCalled = stamp;
            result = func.apply(thisArg, args);
          }
          else if (!maxTimeoutId) {
            maxTimeoutId = setTimeout(maxDelayed, remaining);
          }
        }
        if (isCalled && timeoutId) {
          timeoutId = clearTimeout(timeoutId);
        }
        else if (!timeoutId && wait !== maxWait) {
          timeoutId = setTimeout(delayed, wait);
        }
        if (leadingCall) {
          isCalled = true;
          result = func.apply(thisArg, args);
        }
        if (isCalled && !timeoutId && !maxTimeoutId) {
          args = thisArg = null;
        }
        return result;
      };
    },

    error: function( msg ){
      if( console ){
        if( console.error ){
          console.error.apply( console, arguments );
        } else if( console.log ){
          console.log.apply( console, arguments );
        } else {
          throw msg;
        }
      } else {
        throw msg;
      }
    },    

    clone: function( obj ){
      var target = {};
      for (var i in obj) {
        if ( obj.hasOwnProperty(i) ) { // TODO is this hasOwnProperty() call necessary for our use?
          target[i] = obj[i];
        }
      }
      return target;
    },

    // gets a shallow copy of the argument
    copy: function( obj ){
      if( obj == null ){
        return obj;
      } if( $$.is.array(obj) ){
        return obj.slice();
      } else if( $$.is.plainObject(obj) ){
        return $$.util.clone( obj );
      } else {
        return obj;
      }
    },
    
    // makes a full bb (x1, y1, x2, y2, w, h) from implicit params
    makeBoundingBox: function( bb ){
      if( bb.x1 != null && bb.y1 != null ){
        if( bb.x2 != null && bb.y2 != null && bb.x2 >= bb.x1 && bb.y2 >= bb.y1 ){
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x2,
            y2: bb.y2,
            w: bb.x2 - bb.x1,
            h: bb.y2 - bb.y1
          };
        } else if( bb.w != null && bb.h != null && bb.w >= 0 && bb.h >= 0 ){
          return {
            x1: bb.x1,
            y1: bb.y1,
            x2: bb.x1 + bb.w,
            y2: bb.y1 + bb.h,
            w: bb.w,
            h: bb.h
          };
        }
      } 
    },

    // has anything been set in the map
    mapEmpty: function( map ){
      var empty = true;

      if( map != null ){
        for(var i in map){ // jshint ignore:line
          empty = false;
          break;
        }
      }

      return empty;
    },

    // pushes to the array at the end of a map (map may not be built)
    pushMap: function( options ){
      var array = $$.util.getMap(options);

      if( array == null ){ // if empty, put initial array
        $$.util.setMap( $.extend({}, options, {
          value: [ options.value ]
        }) );
      } else {
        array.push( options.value );
      }
    },

    // sets the value in a map (map may not be built)
    setMap: function( options ){
      var obj = options.map;
      var key;
      var keys = options.keys;
      var l = keys.length;

      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to set map with object key');
        }

        if( i < keys.length - 1 ){
          
          // extend the map if necessary
          if( obj[key] == null ){
            obj[key] = {};
          }
          
          obj = obj[key];
        } else {
          // set the value
          obj[key] = options.value;
        }
      }
    },
    
    // gets the value in a map even if it's not built in places
    getMap: function( options ){
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
      
      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to get map with object key');
        }

        obj = obj[key];
        
        if( obj == null ){
          return obj;
        }
      }
      
      return obj;
    },

    // deletes the entry in the map
    deleteMap: function( options ){
      var obj = options.map;
      var keys = options.keys;
      var l = keys.length;
      var keepChildren = options.keepChildren;
      
      for(var i = 0; i < l; i++){
        var key = keys[i];

        if( $$.is.plainObject( key ) ){
          $$.util.error('Tried to delete map with object key');
        }

        var lastKey = i === options.keys.length - 1;
        if( lastKey ){
          
          if( keepChildren ){ // then only delete child fields not in keepChildren
            for( var child in obj ){
              if( !keepChildren[child] ){
                obj[child] = undefined;
              }
            }
          } else {
            obj[key] = undefined;
          }

        } else {
          obj = obj[key];
        }
      }
    },
    
    capitalize: function(str){
      if( $$.is.emptyString(str) ){
        return str;
      }
      
      return str.charAt(0).toUpperCase() + str.substring(1);
    },

    camel2dash: function( str ){
      var ret = [];

      for( var i = 0; i < str.length; i++ ){
        var ch = str[i];
        var chLowerCase = ch.toLowerCase();
        var isUpperCase = ch !== chLowerCase;

        if( isUpperCase ){
          ret.push( '-' );
          ret.push( chLowerCase );
        } else {
          ret.push( ch );
        }
      }

      var noUpperCases = ret.length === str.length;
      if( noUpperCases ){ return str; } // cheaper than .join()

      return ret.join('');
    },

    dash2camel: function( str ){
      var ret = [];
      var nextIsUpper = false;

      for( var i = 0; i < str.length; i++ ){
        var ch = str[i];
        var isDash = ch === '-';

        if( isDash ){
          nextIsUpper = true;
        } else {
          if( nextIsUpper ){
            ret.push( ch.toUpperCase() );
          } else {
            ret.push( ch );
          }

          nextIsUpper = false;
        }
      }

      return ret.join('');
    },

    // strip spaces from beginning of string and end of string
    trim: function( str ){
      var first, last;

      // find first non-space char
      for( first = 0; first < str.length && str[first] === ' '; first++ ){}

      // find last non-space char
      for( last = str.length - 1; last > first && str[last] === ' '; last-- ){}

      return str.substring(first, last + 1);
    },

    // get [r, g, b] from #abc or #aabbcc
    hex2tuple: function( hex ){
      if( !(hex.length === 4 || hex.length === 7) || hex[0] !== "#" ){ return; }

      var shortHex = hex.length === 4;
      var r, g, b;
      var base = 16;

      if( shortHex ){
        r = parseInt( hex[1] + hex[1], base );
        g = parseInt( hex[2] + hex[2], base );
        b = parseInt( hex[3] + hex[3], base );
      } else {
        r = parseInt( hex[1] + hex[2], base );
        g = parseInt( hex[3] + hex[4], base );
        b = parseInt( hex[5] + hex[6], base );
      }

      return [r, g, b];
    },

    // get [r, g, b, a] from hsl(0, 0, 0) or hsla(0, 0, 0, 0)
    hsl2tuple: function( hsl ){
      var ret;
      var h, s, l, a, r, g, b;
      function hue2rgb(p, q, t){
        if(t < 0) t += 1;
        if(t > 1) t -= 1;
        if(t < 1/6) return p + (q - p) * 6 * t;
        if(t < 1/2) return q;
        if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      }

      var m = new RegExp("^" + $$.util.regex.hsla + "$").exec(hsl);
      if( m ){

        // get hue
        h = parseInt( m[1] ); 
        if( h < 0 ){
          h = ( 360 - (-1*h % 360) ) % 360;
        } else if( h > 360 ){
          h = h % 360;
        }
        h /= 360; // normalise on [0, 1]

        s = parseFloat( m[2] );
        if( s < 0 || s > 100 ){ return; } // saturation is [0, 100]
        s = s/100; // normalise on [0, 1]

        l = parseFloat( m[3] );
        if( l < 0 || l > 100 ){ return; } // lightness is [0, 100]
        l = l/100; // normalise on [0, 1]

        a = m[4];
        if( a !== undefined ){
          a = parseFloat( a );

          if( a < 0 || a > 1 ){ return; } // alpha is [0, 1]
        }

        // now, convert to rgb
        // code from http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
        if( s === 0 ){
          r = g = b = Math.round(l * 255); // achromatic
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = Math.round( 255 * hue2rgb(p, q, h + 1/3) );
          g = Math.round( 255 * hue2rgb(p, q, h) );
          b = Math.round( 255 * hue2rgb(p, q, h - 1/3) );
        }

        ret = [r, g, b, a];
      }

      return ret;
    },

    // get [r, g, b, a] from rgb(0, 0, 0) or rgba(0, 0, 0, 0)
    rgb2tuple: function( rgb ){
      var ret;

      var m = new RegExp("^" + $$.util.regex.rgba + "$").exec(rgb);
      if( m ){
        ret = [];

        var isPct = [];
        for( var i = 1; i <= 3; i++ ){
          var channel = m[i];

          if( channel[ channel.length - 1 ] === "%" ){
            isPct[i] = true;
          }
          channel = parseFloat( channel );

          if( isPct[i] ){
            channel = channel/100 * 255; // normalise to [0, 255]
          }

          if( channel < 0 || channel > 255 ){ return; } // invalid channel value

          ret.push( Math.floor(channel) );
        }

        var atLeastOneIsPct = isPct[1] || isPct[2] || isPct[3];
        var allArePct = isPct[1] && isPct[2] && isPct[3];
        if( atLeastOneIsPct && !allArePct ){ return; } // must all be percent values if one is

        var alpha = m[4];
        if( alpha !== undefined ){
          alpha = parseFloat( alpha );

          if( alpha < 0 || alpha > 1 ){ return; } // invalid alpha value

          ret.push( alpha );
        }
      }

      return ret;
    },

    colorname2tuple: function( color ){
      return $$.util.colors[ color.toLowerCase() ];
    },

    color2tuple: function( color ){
      return ( $$.is.array(color) ? color : null ) 
        || $$.util.colorname2tuple(color)
        || $$.util.hex2tuple(color)
        || $$.util.rgb2tuple(color)
        || $$.util.hsl2tuple(color);
    },

    tuple2hex: function( tuple ){
      var r = tuple[0];
      var g = tuple[1];
      var b = tuple[2];

      function ch2hex( ch ){
        var hex = ch.toString(16);

        if( hex.length === 1 ){
          hex = '0' + hex;
        }

        return hex;
      }

      return '#' + ch2hex(r) + ch2hex(g) + ch2hex(b);
    },

    colors: {
      // special colour names
      transparent:      [0,0,0,0], // NB alpha === 0

      // regular colours
      aliceblue:        [240,248,255],
      antiquewhite:      [250,235,215],
      aqua:          [0,255,255],
      aquamarine:        [127,255,212],
      azure:          [240,255,255],
      beige:          [245,245,220],
      bisque:          [255,228,196],
      black:          [0,0,0],
      blanchedalmond:      [255,235,205],
      blue:          [0,0,255],
      blueviolet:        [138,43,226],
      brown:          [165,42,42],
      burlywood:        [222,184,135],
      cadetblue:        [95,158,160],
      chartreuse:        [127,255,0],
      chocolate:        [210,105,30],
      coral:          [255,127,80],
      cornflowerblue:      [100,149,237],
      cornsilk:        [255,248,220],
      crimson:        [220,20,60],
      cyan:          [0,255,255],
      darkblue:        [0,0,139],
      darkcyan:        [0,139,139],
      darkgoldenrod:      [184,134,11],
      darkgray:        [169,169,169],
      darkgreen:        [0,100,0],
      darkgrey:        [169,169,169],
      darkkhaki:        [189,183,107],
      darkmagenta:      [139,0,139],
      darkolivegreen:      [85,107,47],
      darkorange:        [255,140,0],
      darkorchid:        [153,50,204],
      darkred:        [139,0,0],
      darksalmon:        [233,150,122],
      darkseagreen:      [143,188,143],
      darkslateblue:      [72,61,139],
      darkslategray:      [47,79,79],
      darkslategrey:      [47,79,79],
      darkturquoise:      [0,206,209],
      darkviolet:        [148,0,211],
      deeppink:        [255,20,147],
      deepskyblue:      [0,191,255],
      dimgray:        [105,105,105],
      dimgrey:        [105,105,105],
      dodgerblue:        [30,144,255],
      firebrick:        [178,34,34],
      floralwhite:      [255,250,240],
      forestgreen:      [34,139,34],
      fuchsia:        [255,0,255],
      gainsboro:        [220,220,220],
      ghostwhite:        [248,248,255],
      gold:          [255,215,0],
      goldenrod:        [218,165,32],
      gray:          [128,128,128],
      grey:          [128,128,128],
      green:          [0,128,0],
      greenyellow:      [173,255,47],
      honeydew:        [240,255,240],
      hotpink:        [255,105,180],
      indianred:        [205,92,92],
      indigo:          [75,0,130],
      ivory:          [255,255,240],
      khaki:          [240,230,140],
      lavender:        [230,230,250],
      lavenderblush:      [255,240,245],
      lawngreen:        [124,252,0],
      lemonchiffon:      [255,250,205],
      lightblue:        [173,216,230],
      lightcoral:        [240,128,128],
      lightcyan:        [224,255,255],
      lightgoldenrodyellow:  [250,250,210],
      lightgray:        [211,211,211],
      lightgreen:        [144,238,144],
      lightgrey:        [211,211,211],
      lightpink:        [255,182,193],
      lightsalmon:      [255,160,122],
      lightseagreen:      [32,178,170],
      lightskyblue:      [135,206,250],
      lightslategray:      [119,136,153],
      lightslategrey:      [119,136,153],
      lightsteelblue:      [176,196,222],
      lightyellow:      [255,255,224],
      lime:          [0,255,0],
      limegreen:        [50,205,50],
      linen:          [250,240,230],
      magenta:        [255,0,255],
      maroon:          [128,0,0],
      mediumaquamarine:    [102,205,170],
      mediumblue:        [0,0,205],
      mediumorchid:      [186,85,211],
      mediumpurple:      [147,112,219],
      mediumseagreen:      [60,179,113],
      mediumslateblue:    [123,104,238],
      mediumspringgreen:    [0,250,154],
      mediumturquoise:    [72,209,204],
      mediumvioletred:    [199,21,133],
      midnightblue:      [25,25,112],
      mintcream:        [245,255,250],
      mistyrose:        [255,228,225],
      moccasin:        [255,228,181],
      navajowhite:      [255,222,173],
      navy:          [0,0,128],
      oldlace:        [253,245,230],
      olive:          [128,128,0],
      olivedrab:        [107,142,35],
      orange:          [255,165,0],
      orangered:        [255,69,0],
      orchid:          [218,112,214],
      palegoldenrod:      [238,232,170],
      palegreen:        [152,251,152],
      paleturquoise:      [175,238,238],
      palevioletred:      [219,112,147],
      papayawhip:        [255,239,213],
      peachpuff:        [255,218,185],
      peru:          [205,133,63],
      pink:          [255,192,203],
      plum:          [221,160,221],
      powderblue:        [176,224,230],
      purple:          [128,0,128],
      red:          [255,0,0],
      rosybrown:        [188,143,143],
      royalblue:        [65,105,225],
      saddlebrown:      [139,69,19],
      salmon:          [250,128,114],
      sandybrown:        [244,164,96],
      seagreen:        [46,139,87],
      seashell:        [255,245,238],
      sienna:          [160,82,45],
      silver:          [192,192,192],
      skyblue:        [135,206,235],
      slateblue:        [106,90,205],
      slategray:        [112,128,144],
      slategrey:        [112,128,144],
      snow:          [255,250,250],
      springgreen:      [0,255,127],
      steelblue:        [70,130,180],
      tan:          [210,180,140],
      teal:          [0,128,128],
      thistle:        [216,191,216],
      tomato:          [255,99,71],
      turquoise:        [64,224,208],
      violet:          [238,130,238],
      wheat:          [245,222,179],
      white:          [255,255,255],
      whitesmoke:        [245,245,245],
      yellow:          [255,255,0],
      yellowgreen:      [154,205,50]
    }
      
  };

  $$.util.regex = {};
  
  $$.util.regex.number = "(?:[-]?\\d*\\.\\d+|[-]?\\d+|[-]?\\d*\\.\\d+[eE]\\d+)";
  
  $$.util.regex.rgba = "rgb[a]?\\(("+ $$.util.regex.number +"[%]?)\\s*,\\s*("+ $$.util.regex.number +"[%]?)\\s*,\\s*("+ $$.util.regex.number +"[%]?)(?:\\s*,\\s*("+ $$.util.regex.number +"))?\\)";
  $$.util.regex.rgbaNoBackRefs = "rgb[a]?\\((?:"+ $$.util.regex.number +"[%]?)\\s*,\\s*(?:"+ $$.util.regex.number +"[%]?)\\s*,\\s*(?:"+ $$.util.regex.number +"[%]?)(?:\\s*,\\s*(?:"+ $$.util.regex.number +"))?\\)";
  
  $$.util.regex.hsla = "hsl[a]?\\(("+ $$.util.regex.number +")\\s*,\\s*("+ $$.util.regex.number +"[%])\\s*,\\s*("+ $$.util.regex.number +"[%])(?:\\s*,\\s*("+ $$.util.regex.number +"))?\\)";
  $$.util.regex.hslaNoBackRefs = "hsl[a]?\\((?:"+ $$.util.regex.number +")\\s*,\\s*(?:"+ $$.util.regex.number +"[%])\\s*,\\s*(?:"+ $$.util.regex.number +"[%])(?:\\s*,\\s*(?:"+ $$.util.regex.number +"))?\\)";
  
  $$.util.regex.hex3 = "\\#[0-9a-fA-F]{3}";
  $$.util.regex.hex6 = "\\#[0-9a-fA-F]{6}";

  var raf = !window ? null : ( window.requestAnimationFrame || window.mozRequestAnimationFrame ||  
        window.webkitRequestAnimationFrame || window.msRequestAnimationFrame );

  raf = raf || function(fn){ if(fn){ setTimeout(fn, 1000/60); } };

  $$.util.requestAnimationFrame = function(fn){
    raf( fn );
  };

})( cytoscape, typeof window === 'undefined' ? null : window  );

;(function($$){ 'use strict';
  
  $$.math = {};
  
  $$.math.signum = function(x){
    if( x > 0 ){
      return 1;
    } else if( x < 0 ){
      return -1;
    } else {
      return 0;
    }
  };

  $$.math.distance = function( p1, p2 ){
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;

    return Math.sqrt( dx*dx + dy*dy );
  };

  // from http://en.wikipedia.org/wiki/Bézier_curve#Quadratic_curves
  $$.math.qbezierAt = function(p0, p1, p2, t){
    return (1 - t)*(1 - t)*p0 + 2*(1 - t)*t*p1 + t*t*p2;
  };

  $$.math.qbezierPtAt = function(p0, p1, p2, t){
    return {
      x: $$.math.qbezierAt( p0.x, p1.x, p2.x, t ),
      y: $$.math.qbezierAt( p0.y, p1.y, p2.y, t )
    };
  };

  $$.math.boundingBoxesIntersect = function( bb1, bb2 ){
    // case: one bb to right of other
    if( bb1.x1 > bb2.x2 ){ return false; }
    if( bb2.x1 > bb1.x2 ){ return false; }

    // case: one bb to left of other
    if( bb1.x2 < bb2.x1 ){ return false; }
    if( bb2.x2 < bb1.x1 ){ return false; }

    // case: one bb above other
    if( bb1.y2 < bb2.y1 ){ return false; }
    if( bb2.y2 < bb1.y1 ){ return false; }

    // case: one bb below other
    if( bb1.y1 > bb2.y2 ){ return false; }
    if( bb2.y1 > bb1.y2 ){ return false; }

    // otherwise, must have some overlap
    return true;
  };

  $$.math.inBoundingBox = function( bb, x, y ){
    return bb.x1 <= x && x <= bb.x2 && bb.y1 <= y && y <= bb.y2;
  };

  $$.math.pointInBoundingBox = function( bb, pt ){
    return this.inBoundingBox( bb, pt.x, pt.y );
  };

  $$.math.roundRectangleIntersectLine = function(
    x, y, nodeX, nodeY, width, height, padding) {
    
    var cornerRadius = this.getRoundRectangleRadius(width, height);
    
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    
    // Check intersections with straight line segments
    var straightLineIntersections;
    
    // Top segment, left to right
    {
      var topStartX = nodeX - halfWidth + cornerRadius - padding;
      var topStartY = nodeY - halfHeight - padding;
      var topEndX = nodeX + halfWidth - cornerRadius + padding;
      var topEndY = topStartY;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, topStartX, topStartY, topEndX, topEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Right segment, top to bottom
    {
      var rightStartX = nodeX + halfWidth + padding;
      var rightStartY = nodeY - halfHeight + cornerRadius - padding;
      var rightEndX = rightStartX;
      var rightEndY = nodeY + halfHeight - cornerRadius + padding;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, rightStartX, rightStartY, rightEndX, rightEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Bottom segment, left to right
    {
      var bottomStartX = nodeX - halfWidth + cornerRadius - padding;
      var bottomStartY = nodeY + halfHeight + padding;
      var bottomEndX = nodeX + halfWidth - cornerRadius + padding;
      var bottomEndY = bottomStartY;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, bottomStartX, bottomStartY, bottomEndX, bottomEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Left segment, top to bottom
    {
      var leftStartX = nodeX - halfWidth - padding;
      var leftStartY = nodeY - halfHeight + cornerRadius - padding;
      var leftEndX = leftStartX;
      var leftEndY = nodeY + halfHeight - cornerRadius + padding;
      
      straightLineIntersections = this.finiteLinesIntersect(
        x, y, nodeX, nodeY, leftStartX, leftStartY, leftEndX, leftEndY, false);
      
      if (straightLineIntersections.length > 0) {
        return straightLineIntersections;
      }
    }
    
    // Check intersections with arc segments
    var arcIntersections;
    
    // Top Left
    {
      var topLeftCenterX = nodeX - halfWidth + cornerRadius;
      var topLeftCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        topLeftCenterX, topLeftCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] <= topLeftCenterX
        && arcIntersections[1] <= topLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Top Right
    {
      var topRightCenterX = nodeX + halfWidth - cornerRadius;
      var topRightCenterY = nodeY - halfHeight + cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        topRightCenterX, topRightCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] >= topRightCenterX
        && arcIntersections[1] <= topRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Bottom Right
    {
      var bottomRightCenterX = nodeX + halfWidth - cornerRadius;
      var bottomRightCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        bottomRightCenterX, bottomRightCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] >= bottomRightCenterX
        && arcIntersections[1] >= bottomRightCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }
    
    // Bottom Left
    {
      var bottomLeftCenterX = nodeX - halfWidth + cornerRadius;
      var bottomLeftCenterY = nodeY + halfHeight - cornerRadius;
      arcIntersections = this.intersectLineCircle(
        x, y, nodeX, nodeY, 
        bottomLeftCenterX, bottomLeftCenterY, cornerRadius + padding);
      
      // Ensure the intersection is on the desired quarter of the circle
      if (arcIntersections.length > 0
        && arcIntersections[0] <= bottomLeftCenterX
        && arcIntersections[1] >= bottomLeftCenterY) {
        return [arcIntersections[0], arcIntersections[1]];
      }
    }

    return []; // if nothing
  };
  
  $$.math.roundRectangleIntersectBox = function(
    boxX1, boxY1, boxX2, boxY2, width, height, centerX, centerY, padding) {
    
    // We have the following shpae
    
    //    _____
    //  _|     |_
    // |         |
    // |_       _|
    //   |_____|
    //
    // With a quarter circle at each corner.
    
    var cornerRadius = this.getRoundRectangleRadius(width, height);
    
    var hBoxTopLeftX = centerX - width / 2 - padding;
    var hBoxTopLeftY = centerY - height / 2 + cornerRadius - padding;
    var hBoxBottomRightX = centerX + width / 2 + padding;
    var hBoxBottomRightY = centerY + height / 2 - cornerRadius + padding;
    
    var vBoxTopLeftX = centerX - width / 2 + cornerRadius - padding;
    var vBoxTopLeftY = centerY - height / 2 - padding;
    var vBoxBottomRightX = centerX + width / 2 - cornerRadius + padding;
    var vBoxBottomRightY = centerY + height / 2 + padding;
    
    // Check if the box is out of bounds
    var boxMinX = Math.min(boxX1, boxX2);
    var boxMaxX = Math.max(boxX1, boxX2);
    var boxMinY = Math.min(boxY1, boxY2);
    var boxMaxY = Math.max(boxY1, boxY2);
    
    if (boxMaxX < hBoxTopLeftX) {
      return false;
    } else if (boxMinX > hBoxBottomRightX) {
      return false;
    }
    
    if (boxMaxY < vBoxTopLeftY) {
      return false;
    } else if (boxMinY > vBoxBottomRightY) {
      return false;
    }
    
    // Check if an hBox point is in given box
    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX
        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX
        && hBoxTopLeftY >= boxMinY && hBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (hBoxBottomRightX >= boxMinX && hBoxBottomRightX <= boxMaxX
        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    if (hBoxTopLeftX >= boxMinX && hBoxTopLeftX <= boxMaxX
        && hBoxBottomRightY >= boxMinY && hBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    // Check if a given point box is in the hBox
    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX
      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX
      && boxMinY >= hBoxTopLeftY && boxMinY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= hBoxTopLeftX && boxMaxX <= hBoxBottomRightX
      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {
      return true;
    }
    
    if (boxMinX >= hBoxTopLeftX && boxMinX <= hBoxBottomRightX
      && boxMaxY >= hBoxTopLeftY && boxMaxY <= hBoxBottomRightY) {
      return true;
    }
    
    // Check if an vBox point is in given box
    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX
        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX
        && vBoxTopLeftY >= boxMinY && vBoxTopLeftY <= boxMaxY) {
      return true;
    }
    
    if (vBoxBottomRightX >= boxMinX && vBoxBottomRightX <= boxMaxX
        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    if (vBoxTopLeftX >= boxMinX && vBoxTopLeftX <= boxMaxX
        && vBoxBottomRightY >= boxMinY && vBoxBottomRightY <= boxMaxY) {
      return true;
    }
    
    // Check if a given point box is in the vBox
    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX
      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX
      && boxMinY >= vBoxTopLeftY && boxMinY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMaxX >= vBoxTopLeftX && boxMaxX <= vBoxBottomRightX
      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {
      return true;
    }
    
    if (boxMinX >= vBoxTopLeftX && boxMinX <= vBoxBottomRightX
      && boxMaxY >= vBoxTopLeftY && boxMaxY <= vBoxBottomRightY) {
      return true;
    }
    
    // Lastly, check if one of the ellipses coincide with the box
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxTopLeftY + padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxBottomRightX - padding, hBoxBottomRightY - padding)) {
      return true;
    }
    
    if (this.boxIntersectEllipse(boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
        cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxBottomRightY - padding)) {
      return true;
    }
    
    return false;
  };
  
  // @O Approximate collision functions
  $$.math.checkInBoundingCircle = function(
    x, y, farthestPointSqDistance, padding, width, height, centerX, centerY) {
    
    x = (x - centerX) / (width + padding);
    y = (y - centerY) / (height + padding);
    
    return (x * x + y * y) <= farthestPointSqDistance;
  };
  
  $$.math.boxInBezierVicinity = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {
    
    // Return values:
    // 0 - curve is not in box
    // 1 - curve may be in box; needs precise check
    // 2 - curve is in box
    
    // midpoint
    var midX = 0.25 * x1 + 0.5 * x2 + 0.25 * x3;
    var midY = 0.25 * y1 + 0.5 * y2 + 0.25 * y3;

    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) { // (x1, y1) in box
      return 1;
    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) { // (x3, y3) in box
      return 1;
    } else if (midX >= boxMinX && midX <= boxMaxX && midY >= boxMinY && midY <= boxMaxY) { // (midX, midY) in box
      return 1;
    } else if (x2 >= boxMinX && x2 <= boxMaxX && y2 >= boxMinY && y2 <= boxMaxY) { // ctrl pt in box
      return 1;
    }
    
    var curveMinX = Math.min(x1, midX, x3);
    var curveMinY = Math.min(y1, midY, y3);
    var curveMaxX = Math.max(x1, midX, x3);
    var curveMaxY = Math.max(y1, midY, y3);
    
    /*
    console.log(curveMinX + ", " + curveMinY + ", " + curveMaxX 
      + ", " + curveMaxY);
    if (curveMinX == undefined) {
      console.log("undefined curveMinX: " + x1 + ", " + x2 + ", " + x3);
    }
    */
    
    if (curveMinX > boxMaxX
      || curveMaxX < boxMinX
      || curveMinY > boxMaxY
      || curveMaxY < boxMinY) {
      
      return 0;  
    }
    
    return 1;
  };

  $$.math.checkBezierInBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {

    function sampleInBox(t){
      var x = $$.math.qbezierAt(x1, x2, x3, t);
      var y = $$.math.qbezierAt(y1, y2, y3, t);

      return x1box <= x && x <= x2box
        && y1box <= y && y <= y2box
      ;
    }

    for( var t = 0; t <= 1; t += 0.25 ){
      if( !sampleInBox(t) ){
        return false;
      }
    }

    return true;
  };
  
  $$.math.checkStraightEdgeInBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {

    return x1box <= x1 && x1 <= x2box
      && x1box <= x2 && x2 <= x2box
      && y1box <= y1 && y1 <= y2box
      && y1box <= y2 && y2 <= y2box
    ;
  };

  $$.math.checkStraightEdgeCrossesBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, tolerance) {
    
   //console.log(arguments);
    
    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    // Check left + right bounds
    var aX = x2 - x1;
    var bX = x1;
    var yValue;
    
    // Top and bottom
    var aY = y2 - y1;
    var bY = y1;
    var xValue;
    
    if (Math.abs(aX) < 0.0001) {
      return (x1 >= boxMinX && x1 <= boxMaxX
        && Math.min(y1, y2) <= boxMinY
        && Math.max(y1, y2) >= boxMaxY);  
    }
    
    var tLeft = (boxMinX - bX) / aX;
    if (tLeft > 0 && tLeft <= 1) {
      yValue = aY * tLeft + bY;
      if (yValue >= boxMinY && yValue <= boxMaxY) {
        return true;
      } 
    }
    
    var tRight = (boxMaxX - bX) / aX;
    if (tRight > 0 && tRight <= 1) {
      yValue = aY * tRight + bY;
      if (yValue >= boxMinY && yValue <= boxMaxY) {
        return true;
      } 
    }
    
    var tTop = (boxMinY - bY) / aY;
    if (tTop > 0 && tTop <= 1) {
      xValue = aX * tTop + bX;
      if (xValue >= boxMinX && xValue <= boxMaxX) {
        return true;
      } 
    }
    
    var tBottom = (boxMaxY - bY) / aY;
    if (tBottom > 0 && tBottom <= 1) {
      xValue = aX * tBottom + bX;
      if (xValue >= boxMinX && xValue <= boxMaxX) {
        return true;
      } 
    }
    
    return false;
  };
  
  $$.math.checkBezierCrossesBox = function(
    x1box, y1box, x2box, y2box, x1, y1, x2, y2, x3, y3, tolerance) {
    
    var boxMinX = Math.min(x1box, x2box) - tolerance;
    var boxMinY = Math.min(y1box, y2box) - tolerance;
    var boxMaxX = Math.max(x1box, x2box) + tolerance;
    var boxMaxY = Math.max(y1box, y2box) + tolerance;
    
    if (x1 >= boxMinX && x1 <= boxMaxX && y1 >= boxMinY && y1 <= boxMaxY) {
      return true;
    } else if (x3 >= boxMinX && x3 <= boxMaxX && y3 >= boxMinY && y3 <= boxMaxY) {
      return true;
    }
    
    var aX = x1 - 2 * x2 + x3;
    var bX = -2 * x1 + 2 * x2;
    var cX = x1;

    var xIntervals = [];
    
    if (Math.abs(aX) < 0.0001) {
      var leftParam = (boxMinX - x1) / bX;
      var rightParam = (boxMaxX - x1) / bX;
      
      xIntervals.push(leftParam, rightParam);
    } else {
      // Find when x coordinate of the curve crosses the left side of the box
      var discriminantX1 = bX * bX - 4 * aX * (cX - boxMinX);
      var tX1, tX2;
      if (discriminantX1 > 0) {
        var sqrt = Math.sqrt(discriminantX1);
        tX1 = (-bX + sqrt) / (2 * aX);
        tX2 = (-bX - sqrt) / (2 * aX);
        
        xIntervals.push(tX1, tX2);
      }
      
      var discriminantX2 = bX * bX - 4 * aX * (cX - boxMaxX);
      var tX3, tX4;
      if (discriminantX2 > 0) {
        var sqrt = Math.sqrt(discriminantX2);
        tX3 = (-bX + sqrt) / (2 * aX);
        tX4 = (-bX - sqrt) / (2 * aX);
        
        xIntervals.push(tX3, tX4);
      }
    }
    
    xIntervals.sort(function(a, b) { return a - b; });
    
    var aY = y1 - 2 * y2 + y3;
    var bY = -2 * y1 + 2 * y2;
    var cY = y1;
    
    var yIntervals = [];
    
    if (Math.abs(aY) < 0.0001) {
      var topParam = (boxMinY - y1) / bY;
      var bottomParam = (boxMaxY - y1) / bY;
      
      yIntervals.push(topParam, bottomParam);
    } else {
      var discriminantY1 = bY * bY - 4 * aY * (cY - boxMinY);
      
      var tY1, tY2;
      if (discriminantY1 > 0) {
        var sqrt = Math.sqrt(discriminantY1);
        tY1 = (-bY + sqrt) / (2 * aY);
        tY2 = (-bY - sqrt) / (2 * aY);
        
        yIntervals.push(tY1, tY2);
      }
  
      var discriminantY2 = bY * bY - 4 * aY * (cY - boxMaxY);
      
      var tY3, tY4;
      if (discriminantY2 > 0) {
        var sqrt = Math.sqrt(discriminantY2);
        tY3 = (-bY + sqrt) / (2 * aY);
        tY4 = (-bY - sqrt) / (2 * aY);
        
        yIntervals.push(tY3, tY4);
      }
    }
        
    yIntervals.sort(function(a, b) { return a - b; });

    for (var index = 0; index < xIntervals.length; index += 2) {
      for (var yIndex = 1; yIndex < yIntervals.length; yIndex += 2) {
        
        // Check if there exists values for the Bezier curve
        // parameter between 0 and 1 where both the curve's
        // x and y coordinates are within the bounds specified by the box
        if (xIntervals[index] < yIntervals[yIndex]
          && yIntervals[yIndex] >= 0.0
          && xIntervals[index] <= 1.0
          && xIntervals[index + 1] > yIntervals[yIndex - 1]
          && yIntervals[yIndex - 1] <= 1.0
          && xIntervals[index + 1] >= 0.0) {
          
          return true;
        }
      }
    }
    
    return false;
  };
  
  $$.math.inLineVicinity = function(x, y, lx1, ly1, lx2, ly2, tolerance){
    var t = tolerance;

    var x1 = Math.min(lx1, lx2);
    var x2 = Math.max(lx1, lx2);
    var y1 = Math.min(ly1, ly2);
    var y2 = Math.max(ly1, ly2);

    return x1 - t <= x && x <= x2 + t
      && y1 - t <= y && y <= y2 + t;
  };

  $$.math.inBezierVicinity = function(
    x, y, x1, y1, x2, y2, x3, y3, toleranceSquared) {

    var bb = {
      x1: Math.min( x1, x3, x2 ),
      x2: Math.max( x1, x3, x2 ),
      y1: Math.min( y1, y3, y2 ),
      y2: Math.max( y1, y3, y2 )
    };

    // if outside the rough bounding box for the bezier, then it can't be a hit
    if( x < bb.x1 || x > bb.x2 || y < bb.y1 || y > bb.y2 ){
      // console.log('bezier out of rough bb')
      return false;
    } else {
      // console.log('do more expensive check');
      return true;
    }

  };
  
  $$.math.solveCubic = function(a, b, c, d, result) {
    
    // Solves a cubic function, returns root in form [r1, i1, r2, i2, r3, i3], where
    // r is the real component, i is the imaginary component

    // An implementation of the Cardano method from the year 1545
    // http://en.wikipedia.org/wiki/Cubic_function#The_nature_of_the_roots

    b /= a;
    c /= a;
    d /= a;
    
    var discriminant, q, r, dum1, s, t, term1, r13;

    q = (3.0 * c - (b * b)) / 9.0;
    r = -(27.0 * d) + b * (9.0 * c - 2.0 * (b * b));
    r /= 54.0;
    
    discriminant = q * q * q + r * r;
    result[1] = 0;
    term1 = (b / 3.0);
    
    if (discriminant > 0) {
      s = r + Math.sqrt(discriminant);
      s = ((s < 0) ? -Math.pow(-s, (1.0 / 3.0)) : Math.pow(s, (1.0 / 3.0)));
      t = r - Math.sqrt(discriminant);
      t = ((t < 0) ? -Math.pow(-t, (1.0 / 3.0)) : Math.pow(t, (1.0 / 3.0)));
      result[0] = -term1 + s + t;
      term1 += (s + t) / 2.0;
      result[4] = result[2] = -term1;
      term1 = Math.sqrt(3.0) * (-t + s) / 2;
      result[3] = term1;
      result[5] = -term1;
      return;
    }
    
    result[5] = result[3] = 0;
    
    if (discriminant === 0) {
      r13 = ((r < 0) ? -Math.pow(-r, (1.0 / 3.0)) : Math.pow(r, (1.0 / 3.0)));
      result[0] = -term1 + 2.0 * r13;
      result[4] = result[2] = -(r13 + term1);
      return;
    }
    
    q = -q;
    dum1 = q * q * q;
    dum1 = Math.acos(r / Math.sqrt(dum1));
    r13 = 2.0 * Math.sqrt(q);
    result[0] = -term1 + r13 * Math.cos(dum1 / 3.0);
    result[2] = -term1 + r13 * Math.cos((dum1 + 2.0 * Math.PI) / 3.0);
    result[4] = -term1 + r13 * Math.cos((dum1 + 4.0 * Math.PI) / 3.0);
    
    return;
  };

  $$.math.sqDistanceToQuadraticBezier = function(
    x, y, x1, y1, x2, y2, x3, y3) {
    
    // Find minimum distance by using the minimum of the distance 
    // function between the given point and the curve
    
    // This gives the coefficients of the resulting cubic equation
    // whose roots tell us where a possible minimum is
    // (Coefficients are divided by 4)
    
    var a = 1.0 * x1*x1 - 4*x1*x2 + 2*x1*x3 + 4*x2*x2 - 4*x2*x3 + x3*x3
      + y1*y1 - 4*y1*y2 + 2*y1*y3 + 4*y2*y2 - 4*y2*y3 + y3*y3;
    
    var b = 1.0 * 9*x1*x2 - 3*x1*x1 - 3*x1*x3 - 6*x2*x2 + 3*x2*x3
      + 9*y1*y2 - 3*y1*y1 - 3*y1*y3 - 6*y2*y2 + 3*y2*y3;
    
    var c = 1.0 * 3*x1*x1 - 6*x1*x2 + x1*x3 - x1*x + 2*x2*x2 + 2*x2*x - x3*x
      + 3*y1*y1 - 6*y1*y2 + y1*y3 - y1*y + 2*y2*y2 + 2*y2*y - y3*y;
      
    var d = 1.0 * x1*x2 - x1*x1 + x1*x - x2*x
      + y1*y2 - y1*y1 + y1*y - y2*y;
    
    // debug("coefficients: " + a / a + ", " + b / a + ", " + c / a + ", " + d / a);
    
    var roots = [];
    
    // Use the cubic solving algorithm
    this.solveCubic(a, b, c, d, roots);
    
    var zeroThreshold = 0.0000001;
    
    var params = [];
    
    for (var index = 0; index < 6; index += 2) {
      if (Math.abs(roots[index + 1]) < zeroThreshold
          && roots[index] >= 0
          && roots[index] <= 1.0) {
        params.push(roots[index]);
      }
    }
    
    params.push(1.0);
    params.push(0.0);
    
    var minDistanceSquared = -1;
    var closestParam;
    
    var curX, curY, distSquared;
    for (var i = 0; i < params.length; i++) {
      curX = Math.pow(1.0 - params[i], 2.0) * x1
        + 2.0 * (1 - params[i]) * params[i] * x2
        + params[i] * params[i] * x3;
        
      curY = Math.pow(1 - params[i], 2.0) * y1
        + 2 * (1.0 - params[i]) * params[i] * y2
        + params[i] * params[i] * y3;
        
      distSquared = Math.pow(curX - x, 2) + Math.pow(curY - y, 2);
      // debug('distance for param ' + params[i] + ": " + Math.sqrt(distSquared));
      if (minDistanceSquared >= 0) {
        if (distSquared < minDistanceSquared) {
          minDistanceSquared = distSquared;
          closestParam = params[i];
        }
      } else {
        minDistanceSquared = distSquared;
        closestParam = params[i];
      }
    }
    
    /*
    debugStats.clickX = x;
    debugStats.clickY = y;
    
    debugStats.closestX = Math.pow(1.0 - closestParam, 2.0) * x1
        + 2.0 * (1.0 - closestParam) * closestParam * x2
        + closestParam * closestParam * x3;
        
    debugStats.closestY = Math.pow(1.0 - closestParam, 2.0) * y1
        + 2.0 * (1.0 - closestParam) * closestParam * y2
        + closestParam * closestParam * y3;
    */
    
    // debug("given: " 
    //   + "( " + x + ", " + y + "), " 
    //   + "( " + x1 + ", " + y1 + "), " 
    //   + "( " + x2 + ", " + y2 + "), "
    //   + "( " + x3 + ", " + y3 + ")");
    
    
    // debug("roots: " + roots);
    // debug("params: " + params);
    // debug("closest param: " + closestParam);
    return minDistanceSquared;
  };
  
  $$.math.sqDistanceToFiniteLine = function(x, y, x1, y1, x2, y2) {
    var offset = [x - x1, y - y1];
    var line = [x2 - x1, y2 - y1];
    
    var lineSq = line[0] * line[0] + line[1] * line[1];
    var hypSq = offset[0] * offset[0] + offset[1] * offset[1];
    
    var dotProduct = offset[0] * line[0] + offset[1] * line[1];
    var adjSq = dotProduct * dotProduct / lineSq;
    
    if (dotProduct < 0) {
      return hypSq;
    }
    
    if (adjSq > lineSq) {
      return (x - x2) * (x - x2) + (y - y2) * (y - y2);
    }
    
    return hypSq - adjSq;
  };

  $$.math.pointInsidePolygon = function(
    x, y, basePoints, centerX, centerY, width, height, direction, padding) {

    //var direction = arguments[6];
    var transformedPoints = new Array(basePoints.length);

    // Gives negative angle
    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] 
      + direction[1] * direction[1])));
    
    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
        
    var cos = Math.cos(-angle);
    var sin = Math.sin(-angle);
    
//    console.log("base: " + basePoints);
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = 
        width / 2 * (basePoints[i * 2] * cos
          - basePoints[i * 2 + 1] * sin);
      
      transformedPoints[i * 2 + 1] = 
        height / 2 * (basePoints[i * 2 + 1] * cos 
          + basePoints[i * 2] * sin);

      transformedPoints[i * 2] += centerX;
      transformedPoints[i * 2 + 1] += centerY;
    }
    
    var points;
    
    if (padding > 0) {
      var expandedLineSet = this.expandPolygon(
        transformedPoints,
        -padding);
      
      points = this.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    
    var x1, y1, x2, y2;
    var y3;
    
    // Intersect with vertical line through (x, y)
    var up = 0;
    var down = 0;
    for (var i = 0; i < points.length / 2; i++) {
      
      x1 = points[i * 2];
      y1 = points[i * 2 + 1];
      
      if (i + 1 < points.length / 2) {
        x2 = points[(i + 1) * 2];
        y2 = points[(i + 1) * 2 + 1];
      } else {
        x2 = points[(i + 1 - points.length / 2) * 2];
        y2 = points[(i + 1 - points.length / 2) * 2 + 1];
      }
      
//*      console.log("line from (" + x1 + ", " + y1 + ") to (" + x2 + ", " + y2 + ")");

//&      console.log(x1, x, x2);

      if (x1 == x && x2 == x) {
        
      } else if ((x1 >= x && x >= x2)
        || (x1 <= x && x <= x2)) {
        
        y3 = (x - x1) / (x2 - x1) * (y2 - y1) + y1;
        
        if (y3 > y) {
          up++;
        }
        
        if (y3 < y) {
          down++;
        }
        
//*        console.log(y3, y);
        
      } else {
//*        console.log('22');
        continue;
      }
      
    }
    
//*    console.log("up: " + up + ", down: " + down);
    
    if (up % 2 === 0) {
      return false;
    } else {
      return true;
    }
  };

  $$.math.joinLines = function(lineSet) {
    
    var vertices = new Array(lineSet.length / 2);
    
    var currentLineStartX, currentLineStartY, currentLineEndX, currentLineEndY;
    var nextLineStartX, nextLineStartY, nextLineEndX, nextLineEndY;
    
    for (var i = 0; i < lineSet.length / 4; i++) {
      currentLineStartX = lineSet[i * 4];
      currentLineStartY = lineSet[i * 4 + 1];
      currentLineEndX = lineSet[i * 4 + 2];
      currentLineEndY = lineSet[i * 4 + 3];
      
      if (i < lineSet.length / 4 - 1) {
        nextLineStartX = lineSet[(i + 1) * 4];
        nextLineStartY = lineSet[(i + 1) * 4 + 1];
        nextLineEndX = lineSet[(i + 1) * 4 + 2];
        nextLineEndY = lineSet[(i + 1) * 4 + 3];
      } else {
        nextLineStartX = lineSet[0];
        nextLineStartY = lineSet[1];
        nextLineEndX = lineSet[2];
        nextLineEndY = lineSet[3];
      }
      
      var intersection = this.finiteLinesIntersect(
        currentLineStartX, currentLineStartY,
        currentLineEndX, currentLineEndY,
        nextLineStartX, nextLineStartY,
        nextLineEndX, nextLineEndY,
        true);
      
      vertices[i * 2] = intersection[0];
      vertices[i * 2 + 1] = intersection[1];
    }
    
    return vertices;
  };

  $$.math.expandPolygon = function(points, pad) {
    
    var expandedLineSet = new Array(points.length * 2);
    
    var currentPointX, currentPointY, nextPointX, nextPointY;
    
    for (var i = 0; i < points.length / 2; i++) {
      currentPointX = points[i * 2];
      currentPointY = points[i * 2 + 1];
      
      if (i < points.length / 2 - 1) {
        nextPointX = points[(i + 1) * 2];
        nextPointY = points[(i + 1) * 2 + 1];
      } else {
        nextPointX = points[0];
        nextPointY = points[1];
      }
      
      // Current line: [currentPointX, currentPointY] to [nextPointX, nextPointY]
      
      // Assume CCW polygon winding
      
      var offsetX = (nextPointY - currentPointY);
      var offsetY = -(nextPointX - currentPointX);
      
      // Normalize
      var offsetLength = Math.sqrt(offsetX * offsetX + offsetY * offsetY);
      var normalizedOffsetX = offsetX / offsetLength;
      var normalizedOffsetY = offsetY / offsetLength;
      
      expandedLineSet[i * 4] = currentPointX + normalizedOffsetX * pad;
      expandedLineSet[i * 4 + 1] = currentPointY + normalizedOffsetY * pad;
      expandedLineSet[i * 4 + 2] = nextPointX + normalizedOffsetX * pad;
      expandedLineSet[i * 4 + 3] = nextPointY + normalizedOffsetY * pad;
    }
    
    return expandedLineSet;
  };

  $$.math.intersectLineEllipse = function(
    x, y, centerX, centerY, ellipseWradius, ellipseHradius) {
    
    var dispX = centerX - x;
    var dispY = centerY - y;
    
    dispX /= ellipseWradius;
    dispY /= ellipseHradius;
    
    var len = Math.sqrt(dispX * dispX + dispY * dispY);
    
    var newLength = len - 1;
    
    if (newLength < 0) {
      return [];
    }
    
    var lenProportion = newLength / len;
    
    return [(centerX - x) * lenProportion + x, (centerY - y) * lenProportion + y];
  };
  
  $$.math.dotProduct = function(
    vec1, vec2) {
    
    if (vec1.length != 2 || vec2.length != 2) {
      throw 'dot product: arguments are not vectors';
    }
    
    return (vec1[0] * vec2[0] + vec1[1] * vec2[1]);
  };
  
  // Returns intersections of increasing distance from line's start point
  $$.math.intersectLineCircle = function(
    x1, y1, x2, y2, centerX, centerY, radius) {
    
    // Calculate d, direction vector of line
    var d = [x2 - x1, y2 - y1]; // Direction vector of line
    var c = [centerX, centerY]; // Center of circle
    var f = [x1 - centerX, y1 - centerY];
    
    var a = d[0] * d[0] + d[1] * d[1];
    var b = 2 * (f[0] * d[0] + f[1] * d[1]);
    var c = (f[0] * f[0] + f[1] * f[1]) - radius * radius ;
    
    var discriminant = b*b-4*a*c;
    
    if (discriminant < 0) {
      return [];
    }
    
    var t1 = (-b + Math.sqrt(discriminant)) / (2 * a);
    var t2 = (-b - Math.sqrt(discriminant)) / (2 * a);
    
    var tMin = Math.min(t1, t2);
    var tMax = Math.max(t1, t2);
    var inRangeParams = [];
    
    if (tMin >= 0 && tMin <= 1) {
      inRangeParams.push(tMin);
    }
    
    if (tMax >= 0 && tMax <= 1) {
      inRangeParams.push(tMax);
    }
    
    if (inRangeParams.length === 0) {
      return [];
    }
    
    var nearIntersectionX = inRangeParams[0] * d[0] + x1;
    var nearIntersectionY = inRangeParams[0] * d[1] + y1;
    
    if (inRangeParams.length > 1) {
    
      if (inRangeParams[0] == inRangeParams[1]) {
        return [nearIntersectionX, nearIntersectionY];
      } else {
        
        var farIntersectionX = inRangeParams[1] * d[0] + x1;
        var farIntersectionY = inRangeParams[1] * d[1] + y1;
      
        return [nearIntersectionX, nearIntersectionY, farIntersectionX, farIntersectionY];
      }
      
    } else {
      return [nearIntersectionX, nearIntersectionY];
    }
    
  };
  
  $$.math.findCircleNearPoint = function(centerX, centerY, 
    radius, farX, farY) {
    
    var displacementX = farX - centerX;
    var displacementY = farY - centerY;
    var distance = Math.sqrt(displacementX * displacementX 
      + displacementY * displacementY);
    
    var unitDisplacementX = displacementX / distance;
    var unitDisplacementY = displacementY / distance;
    
    return [centerX + unitDisplacementX * radius, 
      centerY + unitDisplacementY * radius];
  };
  
  $$.math.findMaxSqDistanceToOrigin = function(points) {
    var maxSqDistance = 0.000001;
    var sqDistance;
    
    for (var i = 0; i < points.length / 2; i++) {
      
      sqDistance = points[i * 2] * points[i * 2] 
        + points[i * 2 + 1] * points[i * 2 + 1];
      
      if (sqDistance > maxSqDistance) {
        maxSqDistance = sqDistance;
      }
    }
    
    return maxSqDistance;
  };
  
  $$.math.finiteLinesIntersect = function(
    x1, y1, x2, y2, x3, y3, x4, y4, infiniteLines) {
    
    var ua_t = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
    var ub_t = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);
    var u_b = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);

    if (u_b !== 0) {
      var ua = ua_t / u_b;
      var ub = ub_t / u_b;
      
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {  
        return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
        
      } else {
        if (!infiniteLines) {
          return [];
        } else {
          return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
        }
      }
    } else {
      if (ua_t === 0 || ub_t === 0) {

        // Parallel, coincident lines. Check if overlap

        // Check endpoint of second line
        if ([x1, x2, x4].sort()[1] === x4) {
          return [x4, y4];
        }
        
        // Check start point of second line
        if ([x1, x2, x3].sort()[1] === x3) {
          return [x3, y3];
        }
        
        // Endpoint of first line
        if ([x3, x4, x2].sort()[1] === x2) {
          return [x2, y2];
        }
        
        return [];
      } else {
      
        // Parallel, non-coincident
        return [];
      }
    }
  };
  
  // (boxMinX, boxMinY, boxMaxX, boxMaxY, padding,
  //      cornerRadius * 2, cornerRadius * 2, vBoxTopLeftX + padding, hBoxTopLeftY + padding)) {
  
  $$.math.boxIntersectEllipse = function(
    x1, y1, x2, y2, padding, width, height, centerX, centerY) {
    
    if (x2 < x1) {
      var oldX1 = x1;
      x1 = x2;
      x2 = oldX1;
    }
    
    if (y2 < y1) {
      var oldY1 = y1;
      y1 = y2;
      y2 = oldY1;
    }
    
    // 4 ortho extreme points
    var west = [centerX - width / 2 - padding, centerY];
    var east = [centerX + width / 2 + padding, centerY];
    var north = [centerX, centerY - height / 2 - padding];
    var south = [centerX, centerY + height / 2 + padding];
    
    // out of bounds: return false
    if (x2 < west[0]) {
      return false;
    }
    
    if (x1 > east[0]) {
      return false;
    }
    
    if (y1 > south[1]) {
      return false;
    }
    
    if (y2 < north[1]) {
      return false;
    }
    
    // 1 of 4 ortho extreme points in box: return true
    if (x1 <= east[0] && east[0] <= x2
        && y1 <= east[1] && east[1] <= y2) {
      return true;
    }
    
    if (x1 <= west[0] && west[0] <= x2
        && y1 <= west[1] && west[1] <= y2) {
      return true;
    }
    
    if (x1 <= north[0] && north[0] <= x2
        && y1 <= north[1] && north[1] <= y2) {
      return true;
    }
    
    if (x1 <= south[0] && south[0] <= x2
        && y1 <= south[1] && south[1] <= y2) {
      return true;
    }
    
    // box corner in ellipse: return true    
    x1 = (x1 - centerX) / (width / 2 + padding);
    x2 = (x2 - centerX) / (width / 2 + padding);
    
    y1 = (y1 - centerY) / (height / 2 + padding);
    y2 = (y2 - centerY) / (height / 2 + padding);
    
    if (x1 * x1 + y1 * y1 <= 1) {
      return true;
    }
    
    if (x2 * x2 + y1 * y1 <= 1) {
      return true;
    }
    
    if (x2 * x2 + y2 * y2 <= 1) {
      return true;
    }
    
    if (x1 * x1 + y2 * y2 <= 1) {
      return true;
    }
    
    return false;
  };
  
  $$.math.boxIntersectPolygon = function(
    x1, y1, x2, y2, basePoints, width, height, centerX, centerY, direction, padding) {
    
//    console.log(arguments);
    
    if (x2 < x1) {
      var oldX1 = x1;
      x1 = x2;
      x2 = oldX1;
    }
    
    if (y2 < y1) {
      var oldY1 = y1;
      y1 = y2;
      y2 = oldY1;
    }
    
    var transformedPoints = new Array(basePoints.length);
    
    // Gives negative of angle
    var angle = Math.asin(direction[1] / (Math.sqrt(direction[0] * direction[0] 
      + direction[1] * direction[1])));
    
    if (direction[0] < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = -angle - Math.PI / 2;
    }
    
    var cos = Math.cos(-angle);
    var sin = Math.sin(-angle);
    
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = 
        width / 2 * (basePoints[i * 2] * cos
          - basePoints[i * 2 + 1] * sin);
      
      transformedPoints[i * 2 + 1] = 
        height / 2 * (basePoints[i * 2 + 1] * cos 
          + basePoints[i * 2] * sin);
      
      transformedPoints[i * 2] += centerX;
      transformedPoints[i * 2 + 1] += centerY;
    }
    
    // Assume transformedPoints.length > 0, and check if intersection is possible
    var minTransformedX = transformedPoints[0];
    var maxTransformedX = transformedPoints[0];
    var minTransformedY = transformedPoints[1];
    var maxTransformedY = transformedPoints[1];
    
    for (var i = 1; i < transformedPoints.length / 2; i++) {
      if (transformedPoints[i * 2] > maxTransformedX) {
        maxTransformedX = transformedPoints[i * 2];
      }
      
      if (transformedPoints[i * 2] < minTransformedX) {
        minTransformedX = transformedPoints[i * 2];
      }
      
      if (transformedPoints[i * 2 + 1] > maxTransformedY) {
        maxTransformedY = transformedPoints[i * 2 + 1];
      }
      
      if (transformedPoints[i * 2 + 1] < minTransformedY) {
        minTransformedY = transformedPoints[i * 2 + 1];
      }
    }
    
    if (x2 < minTransformedX - padding) {
      return false;
    }
    
    if (x1 > maxTransformedX + padding) {
      return false;
    }
    
    if (y2 < minTransformedY - padding) {
      return false;
    }
    
    if (y1 > maxTransformedY + padding) {
      return false;
    }
    
    // Continue checking with padding-corrected points
    var points;
    
    if (padding > 0) {
      var expandedLineSet = $$.math.expandPolygon(
        transformedPoints,
        -padding);
      
      points = $$.math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    
    // Check if a point is in box
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      if (x1 <= transformedPoints[i * 2]
          && transformedPoints[i * 2] <= x2) {
        
        if (y1 <= transformedPoints[i * 2 + 1]
            && transformedPoints[i * 2 + 1] <= y2) {
          
          return true;
        }
      }
    }
    
    
    // Check for intersections with the selection box
    for (var i = 0; i < points.length / 2; i++) {
      
      var currentX = points[i * 2];
      var currentY = points[i * 2 + 1];
      var nextX;
      var nextY;
      
      if (i < points.length / 2 - 1) {
        nextX = points[(i + 1) * 2];
        nextY = points[(i + 1) * 2 + 1];
      } else {
        nextX = points[0];
        nextY = points[1];
      }
      
      // Intersection with top of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x2, y1, false).length > 0) {
        return true;
      }
      
      // Intersection with bottom of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y2, x2, y2, false).length > 0) {
        return true;
      }
      
      // Intersection with left side of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x1, y1, x1, y2, false).length > 0) {
        return true;
      }
      
      // Intersection with right side of selection box
      if ($$.math.finiteLinesIntersect(currentX, currentY, nextX, nextY, x2, y1, x2, y2, false).length > 0) {
        return true;
      }
    }

    /*
    // Check if box corner in the polygon
    if ($$.math.pointInsidePolygon(
      x1, y1, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    } else if ($$.math.pointInsidePolygon(
      x1, y2, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    } else if ($$.math.pointInsidePolygon(
      x2, y2, points, 0, 0, 1, 1, 0, direction)) {
       
      return true; 
    } else if ($$.math.pointInsidePolygon(
      x2, y1, points, 0, 0, 1, 1, 0, direction)) {
      
      return true;
    }
    */
    return false;
  };
  
  $$.math.polygonIntersectLine = function(
    x, y, basePoints, centerX, centerY, width, height, padding) {
    
    var intersections = [];
    var intersection;
    
    var transformedPoints = new Array(basePoints.length);
    
    for (var i = 0; i < transformedPoints.length / 2; i++) {
      transformedPoints[i * 2] = basePoints[i * 2] * width + centerX;
      transformedPoints[i * 2 + 1] = basePoints[i * 2 + 1] * height + centerY;
    }
    
    var points;
    
    if (padding > 0) {
      var expandedLineSet = $$.math.expandPolygon(
        transformedPoints,
        -padding);
      
      points = $$.math.joinLines(expandedLineSet);
    } else {
      points = transformedPoints;
    }
    // var points = transformedPoints;
    
    var currentX, currentY, nextX, nextY;
    
    for (var i = 0; i < points.length / 2; i++) {
    
      currentX = points[i * 2];
      currentY = points[i * 2 + 1];

      if (i < points.length / 2 - 1) {
        nextX = points[(i + 1) * 2]; 
        nextY = points[(i + 1) * 2 + 1];
      } else {
        nextX = points[0]; 
        nextY = points[1];
      }
      
      intersection = this.finiteLinesIntersect(
        x, y, centerX, centerY,
        currentX, currentY,
        nextX, nextY);
      
      if (intersection.length !== 0) {
        intersections.push(intersection[0], intersection[1]);
      }
    }
    
    return intersections;
  };
  
  $$.math.shortenIntersection = function(
    intersection, offset, amount) {
    
    var disp = [intersection[0] - offset[0], intersection[1] - offset[1]];
    
    var length = Math.sqrt(disp[0] * disp[0] + disp[1] * disp[1]);
    
    var lenRatio = (length - amount) / length;
    
    if (lenRatio < 0) {
      lenRatio = 0.00001;
    }

    return [offset[0] + lenRatio * disp[0], offset[1] + lenRatio * disp[1]];
  };

  $$.math.generateUnitNgonPointsFitToSquare = function(sides, rotationRadians) {
    var points = $$.math.generateUnitNgonPoints(sides, rotationRadians);
    points = $$.math.fitPolygonToSquare(points);

    return points;
  };

  $$.math.fitPolygonToSquare = function(points){
    var x, y;
    var sides = points.length/2;
    var minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

    for (var i = 0; i < sides; i++) {
      x = points[2 * i];
      y = points[2 * i + 1];

      minX = Math.min( minX, x );
      maxX = Math.max( maxX, x );
      minY = Math.min( minY, y );
      maxY = Math.max( maxY, y );
    }
    
    // stretch factors
    var sx = 2 / (maxX - minX);
    var sy = 2 / (maxY - minY);

    for (var i = 0; i < sides; i++){
      x = points[2 * i] = points[2 * i] * sx;
      y = points[2 * i + 1] = points[2 * i + 1] * sy;

      minX = Math.min( minX, x );
      maxX = Math.max( maxX, x );
      minY = Math.min( minY, y );
      maxY = Math.max( maxY, y );
    }

    if( minY < -1 ){
      for (var i = 0; i < sides; i++){
        y = points[2 * i + 1] = points[2 * i + 1] + (-1 -minY);
      }
    }
    
    return points;
  };

  $$.math.generateUnitNgonPoints = function(sides, rotationRadians) {
    
    var increment = 1.0 / sides * 2 * Math.PI;
    var startAngle = sides % 2 === 0 ? 
      Math.PI / 2.0 + increment / 2.0 : Math.PI / 2.0;
//    console.log(nodeShapes['square']);
    startAngle += rotationRadians;
    
    var points = new Array(sides * 2);

    var currentAngle, x, y;
    for (var i = 0; i < sides; i++) {
      currentAngle = i * increment + startAngle;
      
      x = points[2 * i] = Math.cos(currentAngle);// * (1 + i/2);
      y = points[2 * i + 1] = Math.sin(-currentAngle);//  * (1 + i/2);
    }
    
    return points;
  };

  $$.math.getRoundRectangleRadius = function(width, height) {
    
    // Set the default radius, unless half of width or height is smaller than default
    return Math.min(width / 4, height / 4, 8);
  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  // registered extensions to cytoscape, indexed by name
  var extensions = {};
  $$.extensions = extensions;
  
  // registered modules for extensions, indexed by name
  var modules = {};
  $$.modules = modules;
  
  function setExtension(type, name, registrant){
    var impl = {};
    impl[name] = registrant;
    
    switch( type ){
    case 'core':
    case 'collection':
      $$.fn[type]( impl );
    }
    
    // fill in missing layout functions in the prototype
    if( type === 'layout' ){
      var layoutProto = registrant.prototype;
      var optLayoutFns = [];

      for( var i = 0; i < optLayoutFns.length; i++ ){
        var fnName = optLayoutFns[i];

        layoutProto[fnName] = layoutProto[fnName] || function(){ return this; };
      }

      // either .start() or .run() is defined, so autogen the other
      if( layoutProto.start && !layoutProto.run ){
        layoutProto.run = function(){ this.start(); return this; };
      } else if( !layoutProto.start && layoutProto.run ){
        layoutProto.start = function(){ this.run(); return this; };
      }
      
      if( !layoutProto.stop ){
        layoutProto.stop = function(){
          var opts = this.options;
          
          if( opts && opts.animate ){
            opts.eles.stop();
          }
          
          return this;
        };
      }

      layoutProto.on = $$.define.on({ layout: true });
      layoutProto.one = $$.define.on({ layout: true, unbindSelfOnTrigger: true });
      layoutProto.once = $$.define.on({ layout: true, unbindAllBindersOnTrigger: true });
      layoutProto.off = $$.define.off({ layout: true });
      layoutProto.trigger = $$.define.trigger({ layout: true });

      $$.define.eventAliasesOn( layoutProto );
    }

    return $$.util.setMap({
      map: extensions,
      keys: [ type, name ],
      value: registrant
    });
  }
  
  function getExtension(type, name){
    return $$.util.getMap({
      map: extensions,
      keys: [ type, name ]
    });
  }
  
  function setModule(type, name, moduleType, moduleName, registrant){
    return $$.util.setMap({
      map: modules,
      keys: [ type, name, moduleType, moduleName ],
      value: registrant
    });
  }
  
  function getModule(type, name, moduleType, moduleName){
    return $$.util.getMap({
      map: modules,
      keys: [ type, name, moduleType, moduleName ]
    });
  }
  
  $$.extension = function(){
    // e.g. $$.extension('renderer', 'svg')
    if( arguments.length == 2 ){
      return getExtension.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', { ... })
    else if( arguments.length == 3 ){
      return setExtension.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse')
    else if( arguments.length == 4 ){
      return getModule.apply(this, arguments);
    }
    
    // e.g. $$.extension('renderer', 'svg', 'nodeShape', 'ellipse', { ... })
    else if( arguments.length == 5 ){
      return setModule.apply(this, arguments);
    }
    
    else {
      $$.util.error('Invalid extension access syntax');
    }
  
  };
  
})( cytoscape );

;(function($, $$){ 'use strict';
  
  if( !$ ){ return; } // no jquery => don't need this

  var cyReg = function( $ele ){
    var d = $ele[0]._cyreg = $ele[0]._cyreg || {};

    return d;
  };

  // allow calls on a jQuery selector by proxying calls to $.cytoscape
  // e.g. $("#foo").cytoscape(options) => $.cytoscape(options) on #foo
  $.fn.cytoscape = function(opts){
    var $this = $(this);

    // get object
    if( opts === 'get' ){
      return cyReg( $this ).cy;
    }
    
    // bind to ready
    else if( $$.is.fn(opts) ){

      var ready = opts;
      var cy = cyReg( $this ).cy;
      
      if( cy && cy.isReady() ){ // already ready so just trigger now
        cy.trigger('ready', [], ready);

      } else { // not yet ready, so add to readies list
        var data = cyReg( $this );
        var readies = data.readies = data.readies || [];

        readies.push( ready );
      } 
      
    }
    
    // proxy to create instance
    else if( $$.is.plainObject(opts) ){
      return $this.each(function(){
        var options = $.extend({}, opts, {
          container: $(this)[0]
        });
      
        cytoscape(options);
      });
    }
  };
  
  // allow access to the global cytoscape object under jquery for legacy reasons
  $.cytoscape = cytoscape;
  
  // use short alias (cy) if not already defined
  if( $.fn.cy == null && $.cy == null ){
    $.fn.cy = $.fn.cytoscape;
    $.cy = $.cytoscape;
  }
  
})(typeof jQuery !== 'undefined' ? jQuery : null , cytoscape);

;(function($$){ 'use strict';
  
  // shamelessly taken from jQuery
  // https://github.com/jquery/jquery/blob/master/src/event.js

  $$.Event = function( src, props ) {
    // Allow instantiation without the 'new' keyword
    if ( !(this instanceof $$.Event) ) {
      return new $$.Event( src, props );
    }

    // Event object
    if ( src && src.type ) {
      this.originalEvent = src;
      this.type = src.type;

      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = ( src.defaultPrevented ) ? returnTrue : returnFalse;

    // Event type
    } else {
      this.type = src;
    }

    // Put explicitly provided properties onto the event object
    if ( props ) {
      // $$.util.extend( this, props );

      // more efficient to manually copy fields we use
      this.type = props.type !== undefined ? props.type : this.type;
      this.cy = props.cy;
      this.cyTarget = props.cyTarget;
      this.cyPosition = props.cyPosition;
      this.cyRenderedPosition = props.cyRenderedPosition;
      this.namespace = props.namespace;
      this.layout = props.layout;
      this.data = props.data;
      this.message = props.message;
    }

    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || +new Date();
  };

  function returnFalse() {
    return false;
  }
  function returnTrue() {
    return true;
  }

  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  $$.Event.prototype = {
    preventDefault: function() {
      this.isDefaultPrevented = returnTrue;

      var e = this.originalEvent;
      if ( !e ) {
        return;
      }

      // if preventDefault exists run it on the original event
      if ( e.preventDefault ) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      this.isPropagationStopped = returnTrue;

      var e = this.originalEvent;
      if ( !e ) {
        return;
      }
      // if stopPropagation exists run it on the original event
      if ( e.stopPropagation ) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    },
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse
  };
  
  
})( cytoscape );

;(function($$){ 'use strict';

  // use this module to cherry pick functions into your prototype
  // (useful for functions shared between the core and collections, for example)

  // e.g.
  // $$.fn.collection({
  //   foo: $$.define.foo({ /* params... */ })
  // });

  $$.define = {

    // access data field
    data: function( params ){
      var defaults = { 
        field: 'data',
        bindingEvent: 'data',
        allowBinding: false,
        allowSetting: false,
        allowGetting: false,
        settingEvent: 'data',
        settingTriggersEvent: false,
        triggerFnName: 'trigger',
        immutableKeys: {}, // key => true if immutable
        updateStyle: false,
        onSet: function( self ){},
        canSet: function( self ){ return true; }
      };
      params = $$.util.extend({}, defaults, params);

      return function dataImpl( name, value ){
        var p = params;
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var single = selfIsArrayLike ? self[0] : self;

        // .data('foo', ...)
        if( $$.is.string(name) ){ // set or get property

          // .data('foo')
          if( p.allowGetting && value === undefined ){ // get

            var ret;
            if( single ){
              ret = single._private[ p.field ][ name ];
            }
            return ret;
          
          // .data('foo', 'bar')
          } else if( p.allowSetting && value !== undefined ) { // set
            var valid = !p.immutableKeys[name];
            if( valid ){
              for( var i = 0, l = all.length; i < l; i++ ){
                if( p.canSet( all[i] ) ){
                  all[i]._private[ p.field ][ name ] = value;
                }
              }

              // update mappers if asked
              if( p.updateStyle ){ self.updateStyle(); }

              // call onSet callback
              p.onSet( self );

              if( p.settingTriggersEvent ){
                self[ p.triggerFnName ]( p.settingEvent );
              }
            }
          }

        // .data({ 'foo': 'bar' })
        } else if( p.allowSetting && $$.is.plainObject(name) ){ // extend
          var obj = name;
          var k, v;

          for( k in obj ){
            v = obj[ k ];

            var valid = !p.immutableKeys[k];
            if( valid ){
              for( var i = 0, l = all.length; i < l; i++ ){
                if( p.canSet( all[i] ) ){
                  all[i]._private[ p.field ][ k ] = v;
                }
              }
            }
          }
          
          // update mappers if asked
          if( p.updateStyle ){ self.updateStyle(); }

          // call onSet callback
          p.onSet( self );

          if( p.settingTriggersEvent ){
            self[ p.triggerFnName ]( p.settingEvent );
          }
        
        // .data(function(){ ... })
        } else if( p.allowBinding && $$.is.fn(name) ){ // bind to event
          var fn = name;
          self.bind( p.bindingEvent, fn );
        
        // .data()
        } else if( p.allowGetting && name === undefined ){ // get whole object
          var ret;
          if( single ){
            ret = single._private[ p.field ];
          }
          return ret;
        }

        return self; // maintain chainability
      }; // function
    }, // data

    // remove data field
    removeData: function( params ){
      var defaults = { 
        field: 'data',
        event: 'data',
        triggerFnName: 'trigger',
        triggerEvent: false,
        immutableKeys: {} // key => true if immutable
      };
      params = $$.util.extend({}, defaults, params);

      return function removeDataImpl( names ){
        var p = params;
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        
        // .removeData('foo bar')
        if( $$.is.string(names) ){ // then get the list of keys, and delete them
          var keys = names.split(/\s+/);
          var l = keys.length;

          for( var i = 0; i < l; i++ ){ // delete each non-empty key
            var key = keys[i];
            if( $$.is.emptyString(key) ){ continue; }

            var valid = !p.immutableKeys[ key ]; // not valid if immutable
            if( valid ){
              for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
                all[ i_a ]._private[ p.field ][ key ] = undefined;
              }
            }
          }

          if( p.triggerEvent ){
            self[ p.triggerFnName ]( p.event );
          }

        // .removeData()
        } else if( names === undefined ){ // then delete all keys

          for( var i_a = 0, l_a = all.length; i_a < l_a; i_a++ ){
            var _privateFields = all[ i_a ]._private[ p.field ];
            
            for( var key in _privateFields ){
              var validKeyToDelete = !p.immutableKeys[ key ];

              if( validKeyToDelete ){
                _privateFields[ key ] = undefined;
              }
            }
          }

          if( p.triggerEvent ){
            self[ p.triggerFnName ]( p.event );
          }
        }

        return self; // maintain chaining
      }; // function
    }, // removeData

    // event function reusable stuff
    event: {
      regex: /(\w+)(\.\w+)?/, // regex for matching event strings (e.g. "click.namespace")
      optionalTypeRegex: /(\w+)?(\.\w+)?/,
      falseCallback: function(){ return false; }
    },

    // event binding
    on: function( params ){
      var defaults = {
        unbindSelfOnTrigger: false,
        unbindAllBindersOnTrigger: false
      };
      params = $$.util.extend({}, defaults, params);
      
      return function onImpl(events, selector, data, callback){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);
        var p = params;

        if( $$.is.plainObject(selector) ){ // selector is actually data
          callback = data;
          data = selector;
          selector = undefined;
        } else if( $$.is.fn(selector) || selector === false ){ // selector is actually callback
          callback = selector;
          data = undefined;
          selector = undefined;
        }

        if( $$.is.fn(data) || data === false ){ // data is actually callback
          callback = data;
          data = undefined;
        }

        // if there isn't a callback, we can't really do anything
        // (can't speak for mapped events arg version)
        if( !($$.is.fn(callback) || callback === false) && eventsIsString ){
          return self; // maintain chaining
        }

        if( eventsIsString ){ // then convert to map
          var map = {};
          map[ events ] = callback;
          events = map;
        }

        for( var evts in events ){
          callback = events[evts];
          if( callback === false ){
            callback = $$.define.event.falseCallback;
          }

          if( !$$.is.fn(callback) ){ continue; }

          evts = evts.split(/\s+/);
          for( var i = 0; i < evts.length; i++ ){
            var evt = evts[i];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.regex ); // type[.namespace]

            if( match ){
              var type = match[1];
              var namespace = match[2] ? match[2] : undefined;

              var listener = {
                callback: callback, // callback to run
                data: data, // extra data in eventObj.data
                delegated: selector ? true : false, // whether the evt is delegated
                selector: selector, // the selector to match for delegated events
                selObj: new $$.Selector(selector), // cached selector object to save rebuilding
                type: type, // the event type (e.g. 'click')
                namespace: namespace, // the event namespace (e.g. ".foo")
                unbindSelfOnTrigger: p.unbindSelfOnTrigger,
                unbindAllBindersOnTrigger: p.unbindAllBindersOnTrigger,
                binders: all // who bound together
              };

              for( var j = 0; j < all.length; j++ ){
                var _p = all[j]._private;

                _p.listeners = _p.listeners || [];
                _p.listeners.push( listener );
              }
            }
          } // for events array
        } // for events map
        
        return self; // maintain chaining
      }; // function
    }, // on

    eventAliasesOn: function( proto ){
      var p = proto;

      p.addListener = p.listen = p.bind = p.on;
      p.removeListener = p.unlisten = p.unbind = p.off;
      p.emit = p.trigger;

      // this is just a wrapper alias of .on()
      p.pon = p.promiseOn = function( events, selector ){
        var self = this;
        var args = Array.prototype.slice.call( arguments, 0 );

        return new $$.Promise(function( resolve, reject ){
          var callback = function( e ){
            self.off.apply( self, offArgs );

            resolve( e );
          };

          var onArgs = args.concat([ callback ]);
          var offArgs = onArgs.concat([]);

          self.on.apply( self, onArgs );
        });
      };
    },

    off: function offImpl( params ){
      var defaults = {
      };
      params = $$.util.extend({}, defaults, params);
      
      return function(events, selector, callback){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);

        if( arguments.length === 0 ){ // then unbind all

          for( var i = 0; i < all.length; i++ ){
            all[i]._private.listeners = [];
          }

          return self; // maintain chaining
        }

        if( $$.is.fn(selector) || selector === false ){ // selector is actually callback
          callback = selector;
          selector = undefined;
        }

        if( eventsIsString ){ // then convert to map
          var map = {};
          map[ events ] = callback;
          events = map;
        }

        for( var evts in events ){
          callback = events[evts];

          if( callback === false ){
            callback = $$.define.event.falseCallback;
          }

          evts = evts.split(/\s+/);
          for( var h = 0; h < evts.length; h++ ){
            var evt = evts[h];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.optionalTypeRegex ); // [type][.namespace]
            if( match ){
              var type = match[1] ? match[1] : undefined;
              var namespace = match[2] ? match[2] : undefined;

              for( var i = 0; i < all.length; i++ ){ //
                var listeners = all[i]._private.listeners = all[i]._private.listeners || [];

                for( var j = 0; j < listeners.length; j++ ){
                  var listener = listeners[j];
                  var nsMatches = !namespace || namespace === listener.namespace;
                  var typeMatches = !type || listener.type === type;
                  var cbMatches = !callback || callback === listener.callback;
                  var listenerMatches = nsMatches && typeMatches && cbMatches;

                  // delete listener if it matches
                  if( listenerMatches ){
                    listeners.splice(j, 1);
                    j--;
                  }
                } // for listeners
              } // for all
            } // if match
          } // for events array

        } // for events map
        
        return self; // maintain chaining
      }; // function
    }, // off

    trigger: function( params ){
      var defaults = {};
      params = $$.util.extend({}, defaults, params);
      
      return function triggerImpl(events, extraParams, fnToTrigger){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var eventsIsString = $$.is.string(events);
        var eventsIsObject = $$.is.plainObject(events);
        var eventsIsEvent = $$.is.event(events);
        var cy = this._private.cy || ( $$.is.core(this) ? this : null );
        var hasCompounds = cy ? cy.hasCompoundNodes() : false;

        if( eventsIsString ){ // then make a plain event object for each event name
          var evts = events.split(/\s+/);
          events = [];

          for( var i = 0; i < evts.length; i++ ){
            var evt = evts[i];
            if( $$.is.emptyString(evt) ){ continue; }

            var match = evt.match( $$.define.event.regex ); // type[.namespace]
            var type = match[1];
            var namespace = match[2] ? match[2] : undefined;

            events.push( {
              type: type,
              namespace: namespace
            } );
          }
        } else if( eventsIsObject ){ // put in length 1 array
          var eventArgObj = events;

          events = [ eventArgObj ];
        }

        if( extraParams ){
          if( !$$.is.array(extraParams) ){ // make sure extra params are in an array if specified
            extraParams = [ extraParams ];
          }
        } else { // otherwise, we've got nothing
          extraParams = [];
        }

        for( var i = 0; i < events.length; i++ ){ // trigger each event in order
          var evtObj = events[i];
          
          for( var j = 0; j < all.length; j++ ){ // for each
            var triggerer = all[j];
            var listeners = triggerer._private.listeners = triggerer._private.listeners || [];
            var triggererIsElement = $$.is.element(triggerer);
            var bubbleUp = triggererIsElement || params.layout;

            // create the event for this element from the event object
            var evt;

            if( eventsIsEvent ){ // then just get the object
              evt = evtObj;
              
              evt.cyTarget = evt.cyTarget || triggerer;
              evt.cy = evt.cy || cy;

            } else { // then we have to make one
              evt = new $$.Event( evtObj, {
                cyTarget: triggerer,
                cy: cy,
                namespace: evtObj.namespace
              } );
            }

            // if a layout was specified, then put it in the typed event
            if( evtObj.layout ){
              evt.layout = evtObj.layout;
            }

            // if triggered by layout, put in event
            if( params.layout ){
              evt.layout = triggerer;
            }

            // create a rendered position based on the passed position
            if( evt.cyPosition ){
              var pos = evt.cyPosition;
              var zoom = cy.zoom();
              var pan = cy.pan();

              evt.cyRenderedPosition = {
                x: pos.x * zoom + pan.x,
                y: pos.y * zoom + pan.y
              };
            }

            if( fnToTrigger ){ // then override the listeners list with just the one we specified
              listeners = [{
                namespace: evt.namespace,
                type: evt.type,
                callback: fnToTrigger
              }];
            }

            for( var k = 0; k < listeners.length; k++ ){ // check each listener
              var lis = listeners[k];
              var nsMatches = !lis.namespace || lis.namespace === evt.namespace;
              var typeMatches = lis.type === evt.type;
              var targetMatches = lis.delegated ? ( triggerer !== evt.cyTarget && $$.is.element(evt.cyTarget) && lis.selObj.matches(evt.cyTarget) ) : (true); // we're not going to validate the hierarchy; that's too expensive
              var listenerMatches = nsMatches && typeMatches && targetMatches;

              if( listenerMatches ){ // then trigger it
                var args = [ evt ];
                args = args.concat( extraParams ); // add extra params to args list

                if( lis.data ){ // add on data plugged into binding
                  evt.data = lis.data;
                } else { // or clear it in case the event obj is reused
                  evt.data = undefined;
                }

                if( lis.unbindSelfOnTrigger || lis.unbindAllBindersOnTrigger ){ // then remove listener
                  listeners.splice(k, 1);
                  k--;
                }

                if( lis.unbindAllBindersOnTrigger ){ // then delete the listener for all binders
                  var binders = lis.binders;
                  for( var l = 0; l < binders.length; l++ ){
                    var binder = binders[l];
                    if( !binder || binder === triggerer ){ continue; } // already handled triggerer or we can't handle it

                    var binderListeners = binder._private.listeners;
                    for( var m = 0; m < binderListeners.length; m++ ){
                      var binderListener = binderListeners[m];

                      if( binderListener === lis ){ // delete listener from list
                        binderListeners.splice(m, 1);
                        m--;
                      }
                    }
                  }
                }

                // run the callback
                var context = lis.delegated ? evt.cyTarget : triggerer;
                var ret = lis.callback.apply( context, args );

                if( ret === false || evt.isPropagationStopped() ){
                  // then don't bubble
                  bubbleUp = false;

                  if( ret === false ){
                    // returning false is a shorthand for stopping propagation and preventing the def. action
                    evt.stopPropagation();
                    evt.preventDefault();
                  }
                }
              } // if listener matches
            } // for each listener

            // bubble up event for elements
            if( bubbleUp ){
              var parent = hasCompounds ? triggerer._private.parent : null;
              var hasParent = parent != null && parent.length !== 0;

              if( hasParent ){ // then bubble up to parent
                parent = parent[0];
                parent.trigger(evt);
              } else { // otherwise, bubble up to the core
                cy.trigger(evt);
              }
            }

          } // for each of all
        } // for each event
        
        return self; // maintain chaining
      }; // function
    }, // trigger


    animated: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function animatedImpl(){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return false; }

        var ele = all[0];

        if( ele ){
          return ele._private.animation.current.length > 0;
        }
      };
    }, // animated

    clearQueue: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function clearQueueImpl(){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
          ele._private.animation.queue = [];
        }

        return this;
      };
    }, // clearQueue

    delay: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function delayImpl( time, complete ){
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        this.animate({
          delay: time
        }, {
          duration: time,
          complete: complete
        });

        return this;
      };
    }, // delay

    animate: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function animateImpl( properties, params ){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;
        var isCore = !selfIsArrayLike;
        var isEles = !isCore;

        if( !cy.styleEnabled() ){ return this; }

        var callTime = +new Date();
        var style = cy.style();
        var q;
        
        if( params === undefined ){
          params = {};
        }

        if( params.duration === undefined ){
          params.duration = 400;
        }
        
        switch( params.duration ){
        case 'slow':
          params.duration = 600;
          break;
        case 'fast':
          params.duration = 200;
          break;
        }
        
        var propertiesEmpty = true;
        if( properties ){ for( var i in properties ){
          propertiesEmpty = false;
          break;
        } }

        if( propertiesEmpty ){
          return this; // nothing to animate
        }

        if( properties.css && isEles ){
          properties.css = style.getValueStyle( properties.css, { array: true } );
        }

        if( properties.renderedPosition && isEles ){
          var rpos = properties.renderedPosition;
          var pan = cy.pan();
          var zoom = cy.zoom();

          properties.position = {
            x: ( rpos.x - pan.x ) /zoom,
            y: ( rpos.y - pan.y ) /zoom
          };
        }

        // override pan w/ panBy if set
        if( properties.panBy && isCore ){
          var panBy = properties.panBy;
          var cyPan = cy.pan();

          properties.pan = {
            x: cyPan.x + panBy.x,
            y: cyPan.y + panBy.y
          };
        }

        // override pan w/ center if set
        var center = properties.center || properties.centre;
        if( center && isCore ){
          var centerPan = cy.getCenterPan( center.eles, properties.zoom );

          if( centerPan ){
            properties.pan = centerPan;
          }
        }

        // override pan & zoom w/ fit if set
        if( properties.fit && isCore ){
          var fit = properties.fit;
          var fitVp = cy.getFitViewport( fit.eles || fit.boundingBox, fit.padding );

          if( fitVp ){
            properties.pan = fitVp.pan; //{ x: fitVp.pan.x, y: fitVp.pan.y };
            properties.zoom = fitVp.zoom;
          }
        }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
         
          if( ele.animated() && (params.queue === undefined || params.queue) ){
            q = ele._private.animation.queue;
          } else {
            q = ele._private.animation.current;
          }

          q.push({
            properties: properties,
            duration: params.duration,
            params: params,
            callTime: callTime
          });
        }

        if( isEles ){
          cy.addToAnimationPool( this );
        }

        return this; // chaining
      };
    }, // animate

    stop: function( fnParams ){
      var defaults = {};
      fnParams = $$.util.extend({}, defaults, fnParams);

      return function stopImpl( clearQueue, jumpToEnd ){
        var self = this;
        var selfIsArrayLike = self.length !== undefined;
        var all = selfIsArrayLike ? self : [self]; // put in array if not array-like
        var cy = this._private.cy || this;

        if( !cy.styleEnabled() ){ return this; }

        for( var i = 0; i < all.length; i++ ){
          var ele = all[i];
          var anis = ele._private.animation.current;

          for( var j = 0; j < anis.length; j++ ){
            var animation = anis[j];    
            if( jumpToEnd ){
              // next iteration of the animation loop, the animation
              // will go straight to the end and be removed
              animation.duration = 0; 
            }
          }
          
          // clear the queue of future animations
          if( clearQueue ){
            ele._private.animation.queue = [];
          }

          if( !jumpToEnd ){
            ele._private.animation.current = [];
          }
        }
        
        // we have to notify (the animation loop doesn't do it for us on `stop`)
        cy.notify({
          collection: this,
          type: 'draw'
        });
        
        return this;
      };
    } // stop

  }; // define

  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.selector = function(map, options){
    for( var name in map ){
      var fn = map[name];
      $$.Selector.prototype[ name ] = fn;
    }
  };

  $$.Selector = function(onlyThisGroup, selector){
    
    if( !(this instanceof $$.Selector) ){
      return new $$.Selector(onlyThisGroup, selector);
    }
  
    if( selector === undefined && onlyThisGroup !== undefined ){
      selector = onlyThisGroup;
      onlyThisGroup = undefined;
    }
    
    var self = this;
    
    self._private = {
      selectorText: null,
      invalid: true
    };
    
    if( !selector || ( $$.is.string(selector) && selector.match(/^\s*$/) ) ){
      
      if( onlyThisGroup == null ){
        // ignore
        self.length = 0;
      } else {
        self[0] = newQuery();
        self[0].group = onlyThisGroup;
        self.length = 1;
      }
              
    } else if( $$.is.element( selector ) ){
      var collection = new $$.Collection(self.cy(), [ selector ]);
      
      self[0] = newQuery();
      self[0].collection = collection;
      self.length = 1;
      
    } else if( $$.is.collection( selector ) ){
      self[0] = newQuery();
      self[0].collection = selector;
      self.length = 1;
      
    } else if( $$.is.fn( selector ) ) {
      self[0] = newQuery();
      self[0].filter = selector;
      self.length = 1;
      
    } else if( $$.is.string( selector ) ){

      // the current subject in the query
      var currentSubject = null;
      
      // storage for parsed queries
      var newQuery = function(){
        return {
          classes: [], 
          colonSelectors: [],
          data: [],
          group: null,
          ids: [],
          meta: [],

          // fake selectors
          collection: null, // a collection to match against
          filter: null, // filter function

          // these are defined in the upward direction rather than down (e.g. child)
          // because we need to go up in Selector.filter()
          parent: null, // parent query obj
          ancestor: null, // ancestor query obj
          subject: null, // defines subject in compound query (subject query obj; points to self if subject)

          // use these only when subject has been defined
          child: null,
          descendant: null
        };
      };

      // tokens in the query language
      var tokens = {
        metaChar: '[\\!\\"\\#\\$\\%\\&\\\'\\(\\)\\*\\+\\,\\.\\/\\:\\;\\<\\=\\>\\?\\@\\[\\]\\^\\`\\{\\|\\}\\~]', // chars we need to escape in var names, etc
        comparatorOp: '=|\\!=|>|>=|<|<=|\\$=|\\^=|\\*=', // binary comparison op (used in data selectors)
        boolOp: '\\?|\\!|\\^', // boolean (unary) operators (used in data selectors)
        string: '"(?:\\\\"|[^"])+"' + '|' + "'(?:\\\\'|[^'])+'", // string literals (used in data selectors) -- doublequotes | singlequotes
        number: $$.util.regex.number, // number literal (used in data selectors) --- e.g. 0.1234, 1234, 12e123
        meta: 'degree|indegree|outdegree', // allowed metadata fields (i.e. allowed functions to use from $$.Collection)
        separator: '\\s*,\\s*', // queries are separated by commas, e.g. edge[foo = 'bar'], node.someClass
        descendant: '\\s+',
        child: '\\s+>\\s+',
        subject: '\\$'
      };
      tokens.variable = '(?:[\\w-]|(?:\\\\'+ tokens.metaChar +'))+'; // a variable name
      tokens.value = tokens.string + '|' + tokens.number; // a value literal, either a string or number
      tokens.className = tokens.variable; // a class name (follows variable conventions)
      tokens.id = tokens.variable; // an element id (follows variable conventions)

      // when a token like a variable has escaped meta characters, we need to clean the backslashes out
      // so that values get compared properly in Selector.filter()
      var cleanMetaChars = function(str){
        return str.replace(new RegExp('\\\\(' + tokens.metaChar + ')', 'g'), function(match, $1, offset, original){
          return $1;
        });
      };
      
      // add @ variants to comparatorOp
      var ops = tokens.comparatorOp.split('|');
      for( var i = 0; i < ops.length; i++ ){
        var op = ops[i];
        tokens.comparatorOp += '|@' + op;
      }

      // add ! variants to comparatorOp
      var ops = tokens.comparatorOp.split('|');
      for( var i = 0; i < ops.length; i++ ){
        var op = ops[i];

        if( op.indexOf('!') >= 0 ){ continue; } // skip ops that explicitly contain !
        if( op === '=' ){ continue; } // skip = b/c != is explicitly defined

        tokens.comparatorOp += '|\\!' + op;
      }

      // NOTE: add new expression syntax here to have it recognised by the parser;
      // - a query contains all adjacent (i.e. no separator in between) expressions;
      // - the current query is stored in self[i] --- you can use the reference to `this` in the populate function;
      // - you need to check the query objects in Selector.filter() for it actually filter properly, but that's pretty straight forward
      // - when you add something here, also add to Selector.toString()
      var exprs = {
        group: {
          query: true,
          regex: '(node|edge|\\*)',
          populate: function( group ){
            this.group = group == "*" ? group : group + 's';
          }
        },
        
        state: {
          query: true,
          // NB: if one colon selector is a substring of another from its start, place the longer one first
          // e.g. :foobar|:foo
          regex: '(:selected|:unselected|:locked|:unlocked|:visible|:hidden|:transparent|:grabbed|:free|:removed|:inside|:grabbable|:ungrabbable|:animated|:unanimated|:selectable|:unselectable|:orphan|:nonorphan|:parent|:child|:loop|:simple|:active|:inactive|:touch|:backgrounding|:nonbackgrounding)',
          populate: function( state ){
            this.colonSelectors.push( state );
          }
        },
        
        id: {
          query: true,
          regex: '\\#('+ tokens.id +')',
          populate: function( id ){
            this.ids.push( cleanMetaChars(id) );
          }
        },
        
        className: {
          query: true,
          regex: '\\.('+ tokens.className +')',
          populate: function( className ){
            this.classes.push( cleanMetaChars(className) );
          }
        },
        
        dataExists: {
          query: true,
          regex: '\\[\\s*('+ tokens.variable +')\\s*\\]',
          populate: function( variable ){
            this.data.push({
              field: cleanMetaChars(variable)
            });
          }
        },
        
        dataCompare: {
          query: true,
          regex: '\\[\\s*('+ tokens.variable +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.value +')\\s*\\]',
          populate: function( variable, comparatorOp, value ){ 
            var valueIsString = new RegExp('^' + tokens.string + '$').exec(value) != null;

            if( valueIsString ){
              value = value.substring(1, value.length - 1);
            } else {
              value = parseFloat(value);
            }

            this.data.push({
              field: cleanMetaChars(variable),
              operator: comparatorOp,
              value: value
            });
          }
        },
        
        dataBool: {
          query: true,
          regex: '\\[\\s*('+ tokens.boolOp +')\\s*('+ tokens.variable +')\\s*\\]',
          populate: function( boolOp, variable ){
            this.data.push({
              field: cleanMetaChars(variable),
              operator: boolOp
            });
          }
        },
        
        metaCompare: {
          query: true,
          regex: '\\[\\[\\s*('+ tokens.meta +')\\s*('+ tokens.comparatorOp +')\\s*('+ tokens.number +')\\s*\\]\\]',
          populate: function( meta, comparatorOp, number ){
            this.meta.push({
              field: cleanMetaChars(meta),
              operator: comparatorOp,
              value: parseFloat(number)
            });
          }
        },

        nextQuery: {
          separator: true,
          regex: tokens.separator,
          populate: function(){
            // go on to next query
            self[++i] = newQuery();
            currentSubject = null;
          }
        },

        child: {
          separator: true,
          regex: tokens.child,
          populate: function(){
            // this query is the parent of the following query
            var childQuery = newQuery();
            childQuery.parent = this;
            childQuery.subject = currentSubject;

            // we're now populating the child query with expressions that follow
            self[i] = childQuery;
          }
        },

        descendant: {
          separator: true,
          regex: tokens.descendant,
          populate: function(){
            // this query is the ancestor of the following query
            var descendantQuery = newQuery();
            descendantQuery.ancestor = this;
            descendantQuery.subject = currentSubject;

            // we're now populating the descendant query with expressions that follow
            self[i] = descendantQuery;
          }
        },

        subject: {
          modifier: true,
          regex: tokens.subject,
          populate: function(){
            if( currentSubject != null && this.subject != this ){
              $$.util.error('Redefinition of subject in selector `' + selector + '`');
              return false;
            }

            currentSubject = this;
            this.subject = this;
          }

        }
      };

      var j = 0;
      for( var name in exprs ){
        exprs[j] = exprs[name];
        exprs[j].name = name;

        j++;
      }
      exprs.length = j;

      self._private.selectorText = selector;
      var remaining = selector;
      var i = 0;
      
      // of all the expressions, find the first match in the remaining text
      var consumeExpr = function( expectation ){
        var expr;
        var match;
        var name;
        
        for( var j = 0; j < exprs.length; j++ ){
          var e = exprs[j];
          var n = e.name;

          // ignore this expression if it doesn't meet the expectation function
          if( $$.is.fn( expectation ) && !expectation(n, e) ){ continue; }

          var m = remaining.match(new RegExp( '^' + e.regex ));
          
          if( m != null ){
            match = m;
            expr = e;
            name = n;
            
            var consumed = m[0];
            remaining = remaining.substring( consumed.length );                
            
            break; // we've consumed one expr, so we can return now
          }
        }
        
        return {
          expr: expr,
          match: match,
          name: name
        };
      };
      
      // consume all leading whitespace
      var consumeWhitespace = function(){
        var match = remaining.match(/^\s+/);
        
        if( match ){
          var consumed = match[0];
          remaining = remaining.substring( consumed.length );
        }
      };
      
      self[0] = newQuery(); // get started

      consumeWhitespace(); // get rid of leading whitespace
      for(;;){        
        var check = consumeExpr();
        
        if( check.expr == null ){
          $$.util.error('The selector `'+ selector +'`is invalid');
          return;
        } else {
          var args = [];
          for(var j = 1; j < check.match.length; j++){
            args.push( check.match[j] );
          }
          
          // let the token populate the selector object (i.e. in self[i])
          var ret = check.expr.populate.apply( self[i], args );

          if( ret === false ){ return; } // exit if population failed
        }
        
        // we're done when there's nothing left to parse
        if( remaining.match(/^\s*$/) ){
          break;
        }
      }
      
      self.length = i + 1;

      // adjust references for subject
      for(j = 0; j < self.length; j++){
        var query = self[j];

        if( query.subject != null ){
          // go up the tree until we reach the subject
          for(;;){
            if( query.subject == query ){ break; } // done if subject is self

            if( query.parent != null ){ // swap parent/child reference
              var parent = query.parent;
              var child = query;

              child.parent = null;
              parent.child = child;

              query = parent; // go up the tree
            } else if( query.ancestor != null ){ // swap ancestor/descendant
              var ancestor = query.ancestor;
              var descendant = query;

              descendant.ancestor = null;
              ancestor.descendant = descendant;

              query = ancestor; // go up the tree
            } else {
              $$.util.error('When adjusting references for the selector `'+ query +'`, neither parent nor ancestor was found');
              break;
            }
          } // for

          self[j] = query.subject; // subject should be the root query
        } // if
      } // for

      // make sure for each query that the subject group matches the implicit group if any
      if( onlyThisGroup != null ){
        for(var j = 0; j < self.length; j++){
          if( self[j].group != null && self[j].group != onlyThisGroup ){
            $$.util.error('Group `'+ self[j].group +'` conflicts with implicit group `'+ onlyThisGroup +'` in selector `'+ selector +'`');
            return;
          }

          self[j].group = onlyThisGroup; // set to implicit group
        }
      }
      
    } else {
      $$.util.error('A selector must be created from a string; found ' + selector);
      return;
    }

    self._private.invalid = false;
    
  };

  $$.selfn = $$.Selector.prototype;
  
  $$.selfn.size = function(){
    return this.length;
  };
  
  $$.selfn.eq = function(i){
    return this[i];
  };
  
  // get elements from the core and then filter them
  $$.selfn.find = function(){
    // TODO impl if we decide to use a DB for storing elements
  };
  
  var queryMatches = function(query, element){
    // check group
    if( query.group != null && query.group != '*' && query.group != element._private.group ){
      return false;
    }

    var cy = element.cy();
    
    // check colon selectors
    var allColonSelectorsMatch = true;
    for(var k = 0; k < query.colonSelectors.length; k++){
      var sel = query.colonSelectors[k];
      
      switch(sel){
      case ':selected':
        allColonSelectorsMatch = element.selected();
        break;
      case ':unselected':
        allColonSelectorsMatch = !element.selected();
        break;
      case ':selectable':
        allColonSelectorsMatch = element.selectable();
        break;
      case ':unselectable':
        allColonSelectorsMatch = !element.selectable();
        break;
      case ':locked':
        allColonSelectorsMatch = element.locked();
        break;
      case ':unlocked':
        allColonSelectorsMatch = !element.locked();
        break;
      case ':visible':
        allColonSelectorsMatch = element.visible();
        break;
      case ':hidden':
        allColonSelectorsMatch = !element.visible();
        break;
      case ':transparent':
        allColonSelectorsMatch = element.transparent();
        break;
      case ':grabbed':
        allColonSelectorsMatch = element.grabbed();
        break;
      case ':free':
        allColonSelectorsMatch = !element.grabbed();
        break;
      case ':removed':
        allColonSelectorsMatch = element.removed();
        break;
      case ':inside':
        allColonSelectorsMatch = !element.removed();
        break;
      case ':grabbable':
        allColonSelectorsMatch = element.grabbable();
        break;
      case ':ungrabbable':
        allColonSelectorsMatch = !element.grabbable();
        break;
      case ':animated':
        allColonSelectorsMatch = element.animated();
        break;
      case ':unanimated':
        allColonSelectorsMatch = !element.animated();
        break;
      case ':parent':
        allColonSelectorsMatch = element.isNode() && element.children().nonempty();
        break;
      case ':child':
      case ':nonorphan':
        allColonSelectorsMatch = element.isNode() && element.parent().nonempty();
        break;
      case ':orphan':
        allColonSelectorsMatch = element.isNode() && element.parent().empty();
        break;
      case ':loop':
        allColonSelectorsMatch = element.isEdge() && element.data('source') === element.data('target');
        break;
      case ':simple':
        allColonSelectorsMatch = element.isEdge() && element.data('source') !== element.data('target');
        break;
      case ':active':
        allColonSelectorsMatch = element.active();
        break;
      case ':inactive':
        allColonSelectorsMatch = !element.active();
        break;
      case ':touch':
        allColonSelectorsMatch = $$.is.touch();
        break;
      case ':backgrounding':
        allColonSelectorsMatch = element.backgrounding();
        break;
      case ':nonbackgrounding':
        allColonSelectorsMatch = !element.backgrounding();
        break;
      }
      
      if( !allColonSelectorsMatch ) break;
    }
    if( !allColonSelectorsMatch ) return false;
    
    // check id
    var allIdsMatch = true;
    for(var k = 0; k < query.ids.length; k++){
      var id = query.ids[k];
      var actualId = element._private.data.id;
      
      allIdsMatch = allIdsMatch && (id == actualId);
      
      if( !allIdsMatch ) break;
    }
    if( !allIdsMatch ) return false;
    
    // check classes
    var allClassesMatch = true;
    for(var k = 0; k < query.classes.length; k++){
      var cls = query.classes[k];
      
      allClassesMatch = allClassesMatch && element.hasClass(cls);
      
      if( !allClassesMatch ) break;
    }
    if( !allClassesMatch ) return false;
    
    // generic checking for data/metadata
    var operandsMatch = function(params){
      var allDataMatches = true;
      for(var k = 0; k < query[params.name].length; k++){
        var data = query[params.name][k];
        var operator = data.operator;
        var value = data.value;
        var field = data.field;
        var matches;
        
        if( operator != null && value != null ){
          
          var fieldVal = params.fieldValue(field);
          var fieldStr = !$$.is.string(fieldVal) && !$$.is.number(fieldVal) ? '' : '' + fieldVal;
          var valStr = '' + value;
          
          var caseInsensitive = false;
          if( operator.indexOf('@') >= 0 ){
            fieldStr = fieldStr.toLowerCase();
            valStr = valStr.toLowerCase();
            
            operator = operator.replace('@', '');
            caseInsensitive = true;
          }

          var notExpr = false;
          var handledNotExpr = false;
          if( operator.indexOf('!') >= 0 ){
            operator = operator.replace('!', '');
            notExpr = true;
          }
          
          // if we're doing a case insensitive comparison, then we're using a STRING comparison
          // even if we're comparing numbers
          if( caseInsensitive ){
            value = valStr.toLowerCase();
            fieldVal = fieldStr.toLowerCase();
          }

          switch(operator){
          case '*=':
            matches = fieldStr.search(valStr) >= 0;
            break;
          case '$=':
            matches = new RegExp(valStr + '$').exec(fieldStr) != null;
            break;
          case '^=':
            matches = new RegExp('^' + valStr).exec(fieldStr) != null;
            break;
          case '=':
            matches = fieldVal === value;
            break;
          case '!=':
            matches = fieldVal !== value;
            break;
          case '>':
            matches = !notExpr ? fieldVal > value : fieldVal <= value;
            handledNotExpr = true;
            break;
          case '>=':
            matches = !notExpr ? fieldVal >= value : fieldVal < value;
            handledNotExpr = true;
            break;
          case '<':
            matches = !notExpr ? fieldVal < value : fieldVal >= value;
            handledNotExpr = true;
            break;
          case '<=':
            matches = !notExpr ? fieldVal <= value : fieldVal > value;
            handledNotExpr = true;
            break;
          default:
            matches = false;
            break;
            
          }
        } else if( operator != null ){
          switch(operator){
          case '?':
            matches = params.fieldTruthy(field);
            break;
          case '!':
            matches = !params.fieldTruthy(field);
            break;
          case '^':
            matches = params.fieldUndefined(field);
            break;
          }
        } else {   
          matches = !params.fieldUndefined(field);
        }

        if( notExpr && !handledNotExpr ){
          matches = !matches;
          handledNotExpr = true;
        }
        
        if( !matches ){
          allDataMatches = false;
          break;
        }
      } // for
      
      return allDataMatches;
    }; // operandsMatch
    
    // check data matches
    var allDataMatches = operandsMatch({
      name: 'data',
      fieldValue: function(field){
        return element._private.data[field];
      },
      fieldRef: function(field){
        return 'element._private.data.' + field;
      },
      fieldUndefined: function(field){
        return element._private.data[field] === undefined;
      },
      fieldTruthy: function(field){
        if( element._private.data[field] ){
          return true;
        }
        return false;
      }
    });
    
    if( !allDataMatches ){
      return false;
    }
    
    // check metadata matches
    var allMetaMatches = operandsMatch({
      name: 'meta',
      fieldValue: function(field){
        return element[field]();
      },
      fieldRef: function(field){
        return 'element.' + field + '()';
      },
      fieldUndefined: function(field){
        return element[field]() == null;
      },
      fieldTruthy: function(field){
        if( element[field]() ){
          return true;
        }
        return false;
      }
    });
    
    if( !allMetaMatches ){
      return false;
    }
    
    // check collection
    if( query.collection != null ){
      var matchesAny = query.collection._private.ids[ element.id() ] != null;
      
      if( !matchesAny ){
        return false;
      }
    }
    
    // check filter function
    if( query.filter != null && element.collection().filter( query.filter ).size() === 0 ){
      return false;
    }
    

    // check parent/child relations
    var confirmRelations = function( query, elements ){
      if( query != null ){
        var matches = false;

        if( !cy.hasCompoundNodes() ){
          return false;
        }

        elements = elements(); // make elements functional so we save cycles if query == null

        // query must match for at least one element (may be recursive)
        for(var i = 0; i < elements.length; i++){
          if( queryMatches( query, elements[i] ) ){
            matches = true;
            break;
          }
        }

        return matches;
      } else {
        return true;
      }
    };

    if (! confirmRelations(query.parent, function(){
      return element.parent();
    }) ){ return false; }

    if (! confirmRelations(query.ancestor, function(){
      return element.parents();
    }) ){ return false; }

    if (! confirmRelations(query.child, function(){
      return element.children();
    }) ){ return false; }

    if (! confirmRelations(query.descendant, function(){
      return element.descendants();
    }) ){ return false; }

    // we've reached the end, so we've matched everything for this query
    return true;
  }; // queryMatches

  // filter an existing collection
  $$.selfn.filter = function(collection){
    var self = this;
    var cy = collection.cy();
    
    // don't bother trying if it's invalid
    if( self._private.invalid ){
      return new $$.Collection( cy );
    }
  
    var selectorFunction = function(i, element){
      for(var j = 0; j < self.length; j++){
        var query = self[j];
        
        if( queryMatches(query, element) ){
          return true;
        }
      }
      
      return false;
    };
    
    if( self._private.selectorText == null ){
      selectorFunction = function(){ return true; };
    }
    
    var filteredCollection = collection.filter( selectorFunction );
    
    return filteredCollection;
  }; // filter

  // does selector match a single element?
  $$.selfn.matches = function(ele){
    var self = this;
    
    // don't bother trying if it's invalid
    if( self._private.invalid ){
      return false;
    }
  
    for(var j = 0; j < self.length; j++){
      var query = self[j];
      
      if( queryMatches(query, ele) ){
        return true;
      }
    }
    
    return false;
  }; // filter
  
  // ith query to string
  $$.selfn.toString = $$.selfn.selector = function(){
    
    var str = '';
    
    var clean = function(obj, isValue){
      if( $$.is.string(obj) ){
        return isValue ? '"' + obj + '"' : obj;
      } 
      return '';
    };
    
    var queryToString = function(query){
      var str = '';

      if( query.subject === query ){
        str += '$';
      }

      var group = clean(query.group);
      str += group.substring(0, group.length - 1);
      
      for(var j = 0; j < query.data.length; j++){
        var data = query.data[j];
        
        if( data.value ){
          str += '[' + data.field + clean(data.operator) + clean(data.value, true) + ']';
        } else {
          str += '[' + clean(data.operator) + data.field + ']';
        }
      }

      for(var j = 0; j < query.meta.length; j++){
        var meta = query.meta[j];
        str += '[[' + meta.field + clean(meta.operator) + clean(meta.value, true) + ']]';
      }
      
      for(var j = 0; j < query.colonSelectors.length; j++){
        var sel = query.colonSelectors[i];
        str += sel;
      }
      
      for(var j = 0; j < query.ids.length; j++){
        var sel = '#' + query.ids[i];
        str += sel;
      }
      
      for(var j = 0; j < query.classes.length; j++){
        var sel = '.' + query.classes[i];
        str += sel;
      }

      if( query.parent != null ){
        str = queryToString( query.parent ) + ' > ' + str; 
      }

      if( query.ancestor != null ){
        str = queryToString( query.ancestor ) + ' ' + str; 
      }

      if( query.child != null ){
        str += ' > ' + queryToString( query.child ); 
      }

      if( query.descendant != null ){
        str += ' ' + queryToString( query.descendant ); 
      }

      return str;
    };

    for(var i = 0; i < this.length; i++){
      var query = this[i];
      
      str += queryToString( query );
      
      if( this.length > 1 && i < this.length - 1 ){
        str += ', ';
      }
    }
    
    return str;
  };
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.Style = function( cy ){

    if( !(this instanceof $$.Style) ){
      return new $$.Style(cy);
    }

    if( !$$.is.core(cy) ){
      $$.util.error('A style must have a core reference');
      return;
    }

    this._private = {
      cy: cy,
      coreStyle: {},
      newStyle: true
    };

    this.length = 0;

    this.addDefaultStylesheet();
  };

  // nice-to-have aliases
  $$.style = $$.Style;
  $$.styfn = $$.Style.prototype;

  // define functions in the Style prototype
  $$.fn.style = function( fnMap, options ){
    for( var fnName in fnMap ){
      var fn = fnMap[ fnName ];
      $$.Style.prototype = fn;
    }
  };

  (function(){
    var number = $$.util.regex.number;
    var rgba = $$.util.regex.rgbaNoBackRefs;
    var hsla = $$.util.regex.hslaNoBackRefs;
    var hex3 = $$.util.regex.hex3;
    var hex6 = $$.util.regex.hex6;
    var data = function( prefix ){ return '^' + prefix + '\\s*\\(\\s*([\\w\\.]+)\\s*\\)$'; };
    var mapData = function( prefix ){ return '^' + prefix + '\\s*\\(([\\w\\.]+)\\s*\\,\\s*(' + number + ')\\s*\\,\\s*(' + number + ')\\s*,\\s*(' + number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\s*\\,\\s*(' + number + '|\\w+|' + rgba + '|' + hsla + '|' + hex3 + '|' + hex6 + ')\\)$'; };

    // each visual style property has a type and needs to be validated according to it
    $$.style.types = {
      time: { number: true, min: 0, units: 's|ms', implicitUnits: 'ms' },
      percent: { number: true, min: 0, max: 100, units: '%' },
      zeroOneNumber: { number: true, min: 0, max: 1, unitless: true },
      nOneOneNumber: { number: true, min: -1, max: 1, unitless: true },
      nonNegativeInt: { number: true, min: 0, integer: true, unitless: true },
      position: { enums: ['parent', 'origin'] },
      autoSize: { number: true, min: 0, enums: ['auto'] },
      number: { number: true },
      size: { number: true, min: 0 },
      bgSize: { number: true, min: 0, allowPercent: true },
      bgWH: { number: true, min: 0, allowPercent: true, enums: ['auto'] },
      bgPos: { number: true, allowPercent: true },
      bgRepeat: { enums: ['repeat', 'repeat-x', 'repeat-y', 'no-repeat'] },
      bgFit: { enums: ['none', 'contain', 'cover'] },
      bgClip: { enums: ['none', 'node'] },
      color: { color: true },
      lineStyle: { enums: ['solid', 'dotted', 'dashed'] },
      borderStyle: { enums: ['solid', 'dotted', 'dashed', 'double'] },
      curveStyle: { enums: ['bezier', 'unbundled-bezier', 'haystack'] },
      fontFamily: { regex: '^([\\w- \\"]+(?:\\s*,\\s*[\\w- \\"]+)*)$' },
      fontVariant: { enums: ['small-caps', 'normal'] },
      fontStyle: { enums: ['italic', 'normal', 'oblique'] },
      fontWeight: { enums: ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '800', '900', 100, 200, 300, 400, 500, 600, 700, 800, 900] },
      textDecoration: { enums: ['none', 'underline', 'overline', 'line-through'] },
      textTransform: { enums: ['none', 'uppercase', 'lowercase'] },
      textWrap: { enums: ['none', 'wrap'] },
      textBackgroundShape: { enums: ['rectangle', 'roundrectangle']},
      nodeShape: { enums: ['rectangle', 'roundrectangle', 'ellipse', 'triangle', 'square', 'pentagon', 'hexagon', 'heptagon', 'octagon', 'star', 'diamond', 'vee', 'rhomboid'] },
      compoundIncludeLabels: { enums: ['include', 'exclude'] },
      arrowShape: { enums: ['tee', 'triangle', 'triangle-tee', 'triangle-backcurve', 'half-triangle-overshot', 'square', 'circle', 'diamond', 'none'] },
      arrowFill: { enums: ['filled', 'hollow'] },
      display: { enums: ['element', 'none'] },
      visibility: { enums: ['hidden', 'visible'] },
      valign: { enums: ['top', 'center', 'bottom'] },
      halign: { enums: ['left', 'center', 'right'] },
      text: { string: true },
      data: { mapping: true, regex: data('data') },
      layoutData: { mapping: true, regex: data('layoutData') },
      scratch: { mapping: true, regex: data('scratch') },
      mapData: { mapping: true, regex: mapData('mapData') },
      mapLayoutData: { mapping: true, regex: mapData('mapLayoutData') },
      mapScratch: { mapping: true, regex: mapData('mapScratch') },
      fn: { mapping: true, fn: true },
      url: { regex: '^url\\s*\\(\\s*([^\\s]+)\\s*\\s*\\)|none|(.+)$' },
      propList: { propList: true },
      angle: { number: true, units: 'deg|rad' },
      textRotation: { enums: ['none', 'autorotate'] }
    };

    // define visual style properties
    var t = $$.style.types;
    var props = $$.style.properties = [
      // labels
      { name: 'text-valign', type: t.valign },
      { name: 'text-halign', type: t.halign },
      { name: 'color', type: t.color },
      { name: 'content', type: t.text },
      { name: 'text-outline-color', type: t.color },
      { name: 'text-outline-width', type: t.size },
      { name: 'text-outline-opacity', type: t.zeroOneNumber },
      { name: 'text-opacity', type: t.zeroOneNumber },
      { name: 'text-background-color', type: t.color },
      { name: 'text-background-opacity', type: t.zeroOneNumber },
      { name: 'text-border-opacity', type: t.zeroOneNumber },
      { name: 'text-border-color', type: t.color },
      { name: 'text-border-width', type: t.size },
      { name: 'text-border-style', type: t.borderStyle },
      { name: 'text-background-shape', type: t.textBackgroundShape},
      // { name: 'text-decoration', type: t.textDecoration }, // not supported in canvas
      { name: 'text-transform', type: t.textTransform },
      { name: 'text-wrap', type: t.textWrap },
      { name: 'text-max-width', type: t.size },

      // { name: 'text-rotation', type: t.angle }, // TODO disabled b/c rotation breaks bounding boxes
      { name: 'font-family', type: t.fontFamily },
      { name: 'font-style', type: t.fontStyle },
      // { name: 'font-variant', type: t.fontVariant }, // not useful
      { name: 'font-weight', type: t.fontWeight },
      { name: 'font-size', type: t.size },
      { name: 'min-zoomed-font-size', type: t.size },
      { name: 'edge-text-rotation', type: t.textRotation },

      // visibility
      { name: 'display', type: t.display },
      { name: 'visibility', type: t.visibility },
      { name: 'opacity', type: t.zeroOneNumber },
      { name: 'z-index', type: t.nonNegativeInt },

      // overlays
      { name: 'overlay-padding', type: t.size },
      { name: 'overlay-color', type: t.color },
      { name: 'overlay-opacity', type: t.zeroOneNumber },

      // shadows
      { name: 'shadow-blur', type: t.size },
      { name: 'shadow-color', type: t.color },
      { name: 'shadow-opacity', type: t.zeroOneNumber },
      { name: 'shadow-offset-x', type: t.number },
      { name: 'shadow-offset-y', type: t.number },

      // label shadows
      { name: 'text-shadow-blur', type: t.size },
      { name: 'text-shadow-color', type: t.color },
      { name: 'text-shadow-opacity', type: t.zeroOneNumber },
      { name: 'text-shadow-offset-x', type: t.number },
      { name: 'text-shadow-offset-y', type: t.number },

      // transition anis
      { name: 'transition-property', type: t.propList },
      { name: 'transition-duration', type: t.time },
      { name: 'transition-delay', type: t.time },

      // node body
      { name: 'height', type: t.autoSize },
      { name: 'width', type: t.autoSize },
      { name: 'shape', type: t.nodeShape },
      { name: 'background-color', type: t.color },
      { name: 'background-opacity', type: t.zeroOneNumber },
      { name: 'background-blacken', type: t.nOneOneNumber },

      // node border
      { name: 'border-color', type: t.color },
      { name: 'border-opacity', type: t.zeroOneNumber },
      { name: 'border-width', type: t.size },
      { name: 'border-style', type: t.borderStyle },

      // node background images
      { name: 'background-image', type: t.url },
      { name: 'background-image-opacity', type: t.zeroOneNumber },
      { name: 'background-position-x', type: t.bgPos },
      { name: 'background-position-y', type: t.bgPos },
      { name: 'background-repeat', type: t.bgRepeat },
      { name: 'background-fit', type: t.bgFit },
      { name: 'background-clip', type: t.bgClip },
      { name: 'background-width', type: t.bgWH },
      { name: 'background-height', type: t.bgWH },

      // compound props
      { name: 'padding-left', type: t.size },
      { name: 'padding-right', type: t.size },
      { name: 'padding-top', type: t.size },
      { name: 'padding-bottom', type: t.size },
      { name: 'position', type: t.position },
      { name: 'compound-sizing-wrt-labels', type: t.compoundIncludeLabels },

      // edge line
      { name: 'line-style', type: t.lineStyle },
      { name: 'line-color', type: t.color },
      { name: 'control-point-step-size', type: t.size },
      { name: 'control-point-distance', type: t.number },
      { name: 'control-point-weight', type: t.zeroOneNumber },
      { name: 'curve-style', type: t.curveStyle },
      { name: 'haystack-radius', type: t.zeroOneNumber },

      // edge arrows
      { name: 'source-arrow-shape', type: t.arrowShape },
      { name: 'target-arrow-shape', type: t.arrowShape },
      { name: 'mid-source-arrow-shape', type: t.arrowShape },
      { name: 'mid-target-arrow-shape', type: t.arrowShape },
      { name: 'source-arrow-color', type: t.color },
      { name: 'target-arrow-color', type: t.color },
      { name: 'mid-source-arrow-color', type: t.color },
      { name: 'mid-target-arrow-color', type: t.color },
      { name: 'source-arrow-fill', type: t.arrowFill },
      { name: 'target-arrow-fill', type: t.arrowFill },
      { name: 'mid-source-arrow-fill', type: t.arrowFill },
      { name: 'mid-target-arrow-fill', type: t.arrowFill },

      // these are just for the core
      { name: 'selection-box-color', type: t.color },
      { name: 'selection-box-opacity', type: t.zeroOneNumber },
      { name: 'selection-box-border-color', type: t.color },
      { name: 'selection-box-border-width', type: t.size },
      { name: 'active-bg-color', type: t.color },
      { name: 'active-bg-opacity', type: t.zeroOneNumber },
      { name: 'active-bg-size', type: t.size },
      { name: 'outside-texture-bg-color', type: t.color },
      { name: 'outside-texture-bg-opacity', type: t.zeroOneNumber }
    ];

    // pie backgrounds for nodes
    $$.style.pieBackgroundN = 16; // because the pie properties are numbered, give access to a constant N (for renderer use)
    props.push({ name: 'pie-size', type: t.bgSize });
    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){
      props.push({ name: 'pie-'+i+'-background-color', type: t.color });
      props.push({ name: 'pie-'+i+'-background-size', type: t.percent });
      props.push({ name: 'pie-'+i+'-background-opacity', type: t.zeroOneNumber });
    }

    // allow access of properties by name ( e.g. $$.style.properties.height )
    for( var i = 0; i < props.length; i++ ){
      var prop = props[i];

      props[ prop.name ] = prop; // allow lookup by name
    }
  })();

  // adds the default stylesheet to the current style
  $$.styfn.addDefaultStylesheet = function(){
    // to be nice, we build font related style properties from the core container
    // so that cytoscape matches the style of its container by default
    //
    // unfortunately, this doesn't seem work consistently and can grab the default stylesheet values
    // instead of the developer's values so let's just make it explicit for the dev for now
    //
    // delaying the read of these val's is not an opt'n: that would delay init'l load time
    var fontFamily = 'Helvetica' || this.containerPropertyAsString('font-family') || 'sans-serif';
    var fontStyle = 'normal' || this.containerPropertyAsString('font-style') || 'normal';
    // var fontVariant = 'normal' || this.containerPropertyAsString('font-variant') || 'normal';
    var fontWeight = 'normal' || this.containerPropertyAsString('font-weight') || 'normal';
    var color = '#000' || this.containerPropertyAsString('color') || '#000';
    var textTransform = 'none' || this.containerPropertyAsString('text-transform') || 'none';
    var fontSize = 16 || this.containerPropertyAsString('font-size') || 16;
    var textMaxWidth = 9999 || this.containerPropertyAsString('text-max-width') || 9999;

    // fill the style with the default stylesheet
    this
      .selector('node, edge') // common properties
        .css({
          'text-valign': 'top',
          'text-halign': 'center',
          'color': color,
          'text-outline-color': '#000',
          'text-outline-width': 0,
          'text-outline-opacity': 1,
          'text-opacity': 1,
          'text-decoration': 'none',
          'text-transform': textTransform,
          'text-wrap': 'none',
          'text-max-width': textMaxWidth,
          'text-background-color': '#000',
          'text-background-opacity': 0,
          'text-border-opacity': 0,
          'text-border-width': 0,
          'text-border-style': 'solid',
          'text-border-color':'#000',
          'text-background-shape':'rectangle',
          'font-family': fontFamily,
          'font-style': fontStyle,
          // 'font-variant': fontVariant,
          'font-weight': fontWeight,
          'font-size': fontSize,
          'min-zoomed-font-size': 0,
          'edge-text-rotation': 'none',
          'visibility': 'visible',
          'display': 'element',
          'opacity': 1,
          'z-index': 0,
          'content': '',
          'overlay-opacity': 0,
          'overlay-color': '#000',
          'overlay-padding': 10,
          'shadow-opacity': 0,
          'shadow-color': '#000',
          'shadow-blur': 10,
          'shadow-offset-x': 0,
          'shadow-offset-y': 0,
          'text-shadow-opacity': 0,
          'text-shadow-color': '#000',
          'text-shadow-blur': 5,
          'text-shadow-offset-x': 0,
          'text-shadow-offset-y': 0,
          'transition-property': 'none',
          'transition-duration': 0,
          'transition-delay': 0,

          // node props
          'background-blacken': 0,
          'background-color': '#888',
          'background-opacity': 1,
          'background-image': 'none',
          'background-image-opacity': 1,
          'background-position-x': '50%',
          'background-position-y': '50%',
          'background-repeat': 'no-repeat',
          'background-fit': 'none',
          'background-clip': 'node',
          'background-width': 'auto',
          'background-height': 'auto',
          'border-color': '#000',
          'border-opacity': 1,
          'border-width': 0,
          'border-style': 'solid',
          'height': 30,
          'width': 30,
          'shape': 'ellipse',

          // compound props
          'padding-top': 0,
          'padding-bottom': 0,
          'padding-left': 0,
          'padding-right': 0,
          'position': 'origin',
          'compound-sizing-wrt-labels': 'include',


          // node pie bg
          'pie-size': '100%',
          'pie-1-background-color': 'black',
          'pie-2-background-color': 'black',
          'pie-3-background-color': 'black',
          'pie-4-background-color': 'black',
          'pie-5-background-color': 'black',
          'pie-6-background-color': 'black',
          'pie-7-background-color': 'black',
          'pie-8-background-color': 'black',
          'pie-9-background-color': 'black',
          'pie-10-background-color': 'black',
          'pie-11-background-color': 'black',
          'pie-12-background-color': 'black',
          'pie-13-background-color': 'black',
          'pie-14-background-color': 'black',
          'pie-15-background-color': 'black',
          'pie-16-background-color': 'black',
          'pie-1-background-size': '0%',
          'pie-2-background-size': '0%',
          'pie-3-background-size': '0%',
          'pie-4-background-size': '0%',
          'pie-5-background-size': '0%',
          'pie-6-background-size': '0%',
          'pie-7-background-size': '0%',
          'pie-8-background-size': '0%',
          'pie-9-background-size': '0%',
          'pie-10-background-size': '0%',
          'pie-11-background-size': '0%',
          'pie-12-background-size': '0%',
          'pie-13-background-size': '0%',
          'pie-14-background-size': '0%',
          'pie-15-background-size': '0%',
          'pie-16-background-size': '0%',
          'pie-1-background-opacity': 1,
          'pie-2-background-opacity': 1,
          'pie-3-background-opacity': 1,
          'pie-4-background-opacity': 1,
          'pie-5-background-opacity': 1,
          'pie-6-background-opacity': 1,
          'pie-7-background-opacity': 1,
          'pie-8-background-opacity': 1,
          'pie-9-background-opacity': 1,
          'pie-10-background-opacity': 1,
          'pie-11-background-opacity': 1,
          'pie-12-background-opacity': 1,
          'pie-13-background-opacity': 1,
          'pie-14-background-opacity': 1,
          'pie-15-background-opacity': 1,
          'pie-16-background-opacity': 1,

          // edge props
          'source-arrow-shape': 'none',
          'mid-source-arrow-shape': 'none',
          'target-arrow-shape': 'none',
          'mid-target-arrow-shape': 'none',
          'source-arrow-color': '#ddd',
          'mid-source-arrow-color': '#ddd',
          'target-arrow-color': '#ddd',
          'mid-target-arrow-color': '#ddd',
          'source-arrow-fill': 'filled',
          'mid-source-arrow-fill': 'filled',
          'target-arrow-fill': 'filled',
          'mid-target-arrow-fill': 'filled',
          'line-style': 'solid',
          'line-color': '#ddd',
          'control-point-step-size': 40,
          'control-point-weight': 0.5,
          'curve-style': 'bezier',
          'haystack-radius': 0.8
        })
      .selector('$node > node') // compound (parent) node properties
        .css({
          'width': 'auto',
          'height': 'auto',
          'shape': 'rectangle',
          'background-opacity': 0.5,
          'padding-top': 10,
          'padding-right': 10,
          'padding-left': 10,
          'padding-bottom': 10
        })
      .selector('edge') // just edge properties
        .css({
          'width': 1
        })
      .selector(':active')
        .css({
          'overlay-color': 'black',
          'overlay-padding': 10,
          'overlay-opacity': 0.25
        })
      .selector('core') // just core properties
        .css({
          'selection-box-color': '#ddd',
          'selection-box-opacity': 0.65,
          'selection-box-border-color': '#aaa',
          'selection-box-border-width': 1,
          'active-bg-color': 'black',
          'active-bg-opacity': 0.15,
          'active-bg-size': 30,
          'outside-texture-bg-color': '#000',
          'outside-texture-bg-opacity': 0.125
        })
    ;

    this.defaultLength = this.length;
  };

  // remove all contexts
  $$.styfn.clear = function(){
    for( var i = 0; i < this.length; i++ ){
      this[i] = undefined;
    }
    this.length = 0;
    this._private.newStyle = true;

    return this; // chaining
  };

  $$.styfn.resetToDefault = function(){
    this.clear();
    this.addDefaultStylesheet();

    return this;
  };

  // builds a style object for the 'core' selector
  $$.styfn.core = function(){
    return this._private.coreStyle;
  };

  // parse a property; return null on invalid; return parsed property otherwise
  // fields :
  // - name : the name of the property
  // - value : the parsed, native-typed value of the property
  // - strValue : a string value that represents the property value in valid css
  // - bypass : true iff the property is a bypass property
  $$.styfn.parse = function( name, value, propIsBypass, propIsFlat ){

    name = $$.util.camel2dash( name ); // make sure the property name is in dash form (e.g. 'property-name' not 'propertyName')
    var property = $$.style.properties[ name ];
    var passedValue = value;
    var types = $$.style.types;

    if( !property ){ return null; } // return null on property of unknown name
    if( value === undefined || value === null ){ return null; } // can't assign null

    var valueIsString = $$.is.string(value);
    if( valueIsString ){ // trim the value to make parsing easier
      value = $$.util.trim( value );
    }

    var type = property.type;
    if( !type ){ return null; } // no type, no luck

    // check if bypass is null or empty string (i.e. indication to delete bypass property)
    if( propIsBypass && (value === '' || value === null) ){
      return {
        name: name,
        value: value,
        bypass: true,
        deleteBypass: true
      };
    }

    var hasPie = name.match(/pie-(\d+)-background-size/);

    // check if value is a function used as a mapper
    if( $$.is.fn(value) ){
      return {
        name: name,
        value: value,
        strValue: 'fn',
        mapped: types.fn,
        bypass: propIsBypass,
        hasPie: hasPie
      };
    }

    // check if value is mapped
    var data, mapData, layoutData, mapLayoutData, scratch, mapScratch;
    if( !valueIsString || propIsFlat ){
      // then don't bother to do the expensive regex checks

    } else if(
      ( data = new RegExp( types.data.regex ).exec( value ) ) ||
      ( layoutData = new RegExp( types.layoutData.regex ).exec( value ) ) ||
      ( scratch = new RegExp( types.scratch.regex ).exec( value ) )
    ){
      if( propIsBypass ){ return false; } // mappers not allowed in bypass

      var mapped;
      if( data ){
        mapped = types.data;
      } else if( layoutData ){
        mapped = types.layoutData;
      } else {
        mapped = types.scratch;
      }

      data = data || layoutData || scratch;

      return {
        name: name,
        value: data,
        strValue: '' + value,
        mapped: mapped,
        field: data[1],
        bypass: propIsBypass,
        hasPie: hasPie
      };

    } else if(
      ( mapData = new RegExp( types.mapData.regex ).exec( value ) ) ||
      ( mapLayoutData = new RegExp( types.mapLayoutData.regex ).exec( value ) ) ||
      ( mapScratch = new RegExp( types.mapScratch.regex ).exec( value ) )
    ){
      if( propIsBypass ){ return false; } // mappers not allowed in bypass

      var mapped;
      if( mapData ){
        mapped = types.mapData;
      } else if( mapLayoutData ){
        mapped = types.mapLayoutData;
      } else {
        mapped = types.mapScratch;
      }

      mapData = mapData || mapLayoutData || mapScratch;

      // we can map only if the type is a colour or a number
      if( !(type.color || type.number) ){ return false; }

      var valueMin = this.parse( name, mapData[4]); // parse to validate
      if( !valueMin || valueMin.mapped ){ return false; } // can't be invalid or mapped

      var valueMax = this.parse( name, mapData[5]); // parse to validate
      if( !valueMax || valueMax.mapped ){ return false; } // can't be invalid or mapped

      // check if valueMin and valueMax are the same
      if( valueMin.value === valueMax.value ){
        return false; // can't make much of a mapper without a range

      } else if( type.color ){
        var c1 = valueMin.value;
        var c2 = valueMax.value;

        var same = c1[0] === c2[0] // red
          && c1[1] === c2[1] // green
          && c1[2] === c2[2] // blue
          && ( // optional alpha
            c1[3] === c2[3] // same alpha outright
            || (
              (c1[3] == null || c1[3] === 1) // full opacity for colour 1?
              &&
              (c2[3] == null || c2[3] === 1) // full opacity for colour 2?
            )
          )
        ;

        if( same ){ return false; } // can't make a mapper without a range
      }

      return {
        name: name,
        value: mapData,
        strValue: '' + value,
        mapped: mapped,
        field: mapData[1],
        fieldMin: parseFloat( mapData[2] ), // min & max are numeric
        fieldMax: parseFloat( mapData[3] ),
        valueMin: valueMin.value,
        valueMax: valueMax.value,
        bypass: propIsBypass,
        hasPie: hasPie
      };
    }

    // check the type and return the appropriate object
    if( type.number ){
      var units;
      var implicitUnits = 'px'; // not set => px

      if( type.units ){ // use specified units if set
        units = type.units;
      }

      if( type.implicitUnits ){
        implicitUnits = type.implicitUnits;
      }

      if( !type.unitless ){
        if( valueIsString ){
          var unitsRegex = 'px|em' + (type.allowPercent ? '|\\%' : '');
          if( units ){ unitsRegex = units; } // only allow explicit units if so set
          var match = value.match( '^(' + $$.util.regex.number + ')(' + unitsRegex + ')?' + '$' );

          if( match ){
            value = match[1];
            units = match[2] || implicitUnits;
          }

        } else if( !units || type.implicitUnits ) {
          units = implicitUnits; // implicitly px if unspecified
        }
      }

      value = parseFloat( value );

      // if not a number and enums not allowed, then the value is invalid
      if( isNaN(value) && type.enums === undefined ){
        return null;
      }

      // check if this number type also accepts special keywords in place of numbers
      // (i.e. `left`, `auto`, etc)
      if( isNaN(value) && type.enums !== undefined ){
        value = passedValue;

        for( var i = 0; i < type.enums.length; i++ ){
          var en = type.enums[i];

          if( en === value ){
            return {
              name: name,
              value: value,
              strValue: '' + value,
              bypass: propIsBypass
            };
          }
        }

        return null; // failed on enum after failing on number
      }

      // check if value must be an integer
      if( type.integer && !$$.is.integer(value) ){
        return null;
      }

      // check value is within range
      if( (type.min !== undefined && value < type.min)
      || (type.max !== undefined && value > type.max)
      ){
        return null;
      }

      var ret = {
        name: name,
        value: value,
        strValue: '' + value + (units ? units : ''),
        units: units,
        bypass: propIsBypass,
        hasPie: hasPie && value != null && value !== 0 && value !== ''
      };

      // normalise value in pixels
      if( type.unitless || (units !== 'px' && units !== 'em') ){
        // then pxValue does not apply
      } else {
        ret.pxValue = ( units === 'px' || !units ? (value) : (this.getEmSizeInPixels() * value) );
      }

      // normalise value in ms
      if( units === 'ms' || units === 's' ){
        ret.msValue = units === 'ms' ? value : 1000 * value;
      }

      return ret;

    } else if( type.propList ) {

      var props = [];
      var propsStr = '' + value;

      if( propsStr === 'none' ){
        // leave empty

      } else { // go over each prop

        var propsSplit = propsStr.split(',');
        for( var i = 0; i < propsSplit.length; i++ ){
          var propName = $$.util.trim( propsSplit[i] );

          if( $$.style.properties[propName] ){
            props.push( propName );
          }
        }

        if( props.length === 0 ){ return null; }

      }

      return {
        name: name,
        value: props,
        strValue: props.length === 0 ? 'none' : props.join(', '),
        bypass: propIsBypass
      };

    } else if( type.color ){
      var tuple = $$.util.color2tuple( value );

      if( !tuple ){ return null; }

      return {
        name: name,
        value: tuple,
        strValue: '' + value,
        bypass: propIsBypass
      };

    } else if( type.enums ){
      for( var i = 0; i < type.enums.length; i++ ){
        var en = type.enums[i];

        if( en === value ){
          return {
            name: name,
            value: value,
            strValue: '' + value,
            bypass: propIsBypass
          };
        }
      }

      return null;

    } else if( type.regex ){
      var regex = new RegExp( type.regex ); // make a regex from the type
      var m = regex.exec( value );

      if( m ){ // regex matches
        return {
          name: name,
          value: m,
          strValue: '' + value,
          bypass: propIsBypass
        };
      } else { // regex doesn't match
        return null; // didn't match the regex so the value is bogus
      }

    } else if( type.string ){
      // just return
      return {
        name: name,
        value: value,
        strValue: '' + value,
        bypass: propIsBypass
      };

    } else {
      return null; // not a type we can handle
    }

  };

  // create a new context from the specified selector string and switch to that context
  $$.styfn.selector = function( selectorStr ){
    // 'core' is a special case and does not need a selector
    var selector = selectorStr === 'core' ? null : new $$.Selector( selectorStr );

    var i = this.length++; // new context means new index
    this[i] = {
      selector: selector,
      properties: [],
      mappedProperties: [],
      index: i
    };

    return this; // chaining
  };

  // add one or many css rules to the current context
  $$.styfn.css = function(){
    var args = arguments;

    switch( args.length ){
    case 1:
      var map = args[0];

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var mapVal = map[ prop.name ];

        if( mapVal === undefined ){
          mapVal = map[ $$.util.dash2camel(prop.name) ];
        }

        if( mapVal !== undefined ){
          this.cssRule( prop.name, mapVal );
        }
      }

      break;

    case 2:
      this.cssRule( args[0], args[1] );
      break;

    default:
      break; // do nothing if args are invalid
    }

    return this; // chaining
  };
  $$.styfn.style = $$.styfn.css;

  // add a single css rule to the current context
  $$.styfn.cssRule = function( name, value ){
    // name-value pair
    var property = this.parse( name, value );

    // add property to current context if valid
    if( property ){
      var i = this.length - 1;
      this[i].properties.push( property );
      this[i].properties[ property.name ] = property; // allow access by name as well

      if( property.hasPie ){
        this._private.hasPie = true;
      }

      if( property.mapped ){
        this[i].mappedProperties.push( property );
      }

      // add to core style if necessary
      var currentSelectorIsCore = !this[i].selector;
      if( currentSelectorIsCore ){
        this._private.coreStyle[ property.name ] = property;
      }
    }

    return this; // chaining
  };

})( cytoscape );

;(function($$){ 'use strict';

  // (potentially expensive calculation)
  // apply the style to the element based on
  // - its bypass
  // - what selectors match it
  $$.styfn.apply = function( eles ){
    var self = this;

    if( self._private.newStyle ){ // clear style caches
      this._private.contextStyles = {};
      this._private.propDiffs = {};
    }

    for( var ie = 0; ie < eles.length; ie++ ){
      var ele = eles[ie];
      var cxtMeta = self.getContextMeta( ele );
      var cxtStyle = self.getContextStyle( cxtMeta );
      var app = self.applyContextStyle( cxtMeta, cxtStyle, ele );

      self.updateTransitions( ele, app.diffProps );
      self.updateStyleHints( ele );

    } // for elements

    self._private.newStyle = false;
  };

  $$.styfn.getPropertiesDiff = function( oldCxtKey, newCxtKey ){
    var self = this;
    var cache = self._private.propDiffs = self._private.propDiffs || {};
    var dualCxtKey = oldCxtKey + '-' + newCxtKey;
    var cachedVal = cache[dualCxtKey];

    if( cachedVal ){
      return cachedVal;
    }

    var diffProps = [];
    var addedProp = {};

    for( var i = 0; i < self.length; i++ ){
      var cxt = self[i];
      var oldHasCxt = oldCxtKey[i] === 't';
      var newHasCxt = newCxtKey[i] === 't';
      var cxtHasDiffed = oldHasCxt !== newHasCxt;
      var cxtHasMappedProps = cxt.mappedProperties.length > 0;

      if( cxtHasDiffed || cxtHasMappedProps ){
        var props;

        if( cxtHasDiffed && cxtHasMappedProps ){
          props = cxt.properties; // suffices b/c mappedProperties is a subset of properties
        } else if( cxtHasDiffed ){
          props = cxt.properties; // need to check them all
        } else if( cxtHasMappedProps ){
          props = cxt.mappedProperties; // only need to check mapped
        }

        for( var j = 0; j < props.length; j++ ){
          var prop = props[j];
          var name = prop.name;

          // if a later context overrides this property, then the fact that this context has switched/diffed doesn't matter
          // (semi expensive check since it makes this function O(n^2) on context length, but worth it since overall result
          // is cached)
          var laterCxtOverrides = false;
          for( var k = i + 1; k < self.length; k++ ){
            var laterCxt = self[k];
            var hasLaterCxt = newCxtKey[k] === 't';

            if( !hasLaterCxt ){ continue; } // can't override unless the context is active

            laterCxtOverrides = laterCxt.properties[ prop.name ] != null;

            if( laterCxtOverrides ){ break; } // exit early as long as one later context overrides
          }

          if( !addedProp[name] && !laterCxtOverrides ){
            addedProp[name] = true;
            diffProps.push( name );
          }
        } // for props
      } // if

    } // for contexts

    cache[ dualCxtKey ] = diffProps;
    return diffProps;
  };

  $$.styfn.getContextMeta = function( ele ){
    var self = this;
    var cxtKey = '';
    var diffProps;
    var prevKey = ele._private.styleCxtKey || '';

    if( self._private.newStyle ){
      prevKey = ''; // since we need to apply all style if a fresh stylesheet
    }

    // get the cxt key
    for( var i = 0; i < self.length; i++ ){
      var context = self[i];
      var contextSelectorMatches = context.selector && context.selector.matches( ele ); // NB: context.selector may be null for 'core'

      if( contextSelectorMatches ){
        cxtKey += 't';
      } else {
        cxtKey += 'f';
      }
    } // for context

    diffProps = self.getPropertiesDiff( prevKey, cxtKey );

    ele._private.styleCxtKey = cxtKey;

    return {
      key: cxtKey,
      diffPropNames: diffProps
    };
  };

  // gets a computed ele style object based on matched contexts
  $$.styfn.getContextStyle = function( cxtMeta ){
    var cxtKey = cxtMeta.key;
    var self = this;
    var cxtStyles = this._private.contextStyles = this._private.contextStyles || {};

    // if already computed style, returned cached copy
    if( cxtStyles[cxtKey] ){ return cxtStyles[cxtKey]; }

    var style = {
      _private: {
        key: cxtKey
      }
    };

    for( var i = 0; i < self.length; i++ ){
      var cxt = self[i];
      var hasCxt = cxtKey[i] === 't';

      if( !hasCxt ){ continue; }

      for( var j = 0; j < cxt.properties.length; j++ ){
        var prop = cxt.properties[j];
        var styProp = style[ prop.name ] = prop;

        styProp.context = cxt;
      }
    }

    cxtStyles[cxtKey] = style;
    return style;
  };

  $$.styfn.applyContextStyle = function( cxtMeta, cxtStyle, ele ){
    var self = this;
    var diffProps = cxtMeta.diffPropNames;
    var retDiffProps = {};

    for( var i = 0; i < diffProps.length; i++ ){
      var diffPropName = diffProps[i];
      var cxtProp = cxtStyle[ diffPropName ];
      var eleProp = ele._private.style[ diffPropName ];

      // save cycles when the context prop doesn't need to be applied
      if( !cxtProp || eleProp === cxtProp ){ continue; }

      var retDiffProp = retDiffProps[ diffPropName ] = {
        prev: eleProp
      };

      self.applyParsedProperty( ele, cxtProp );

      retDiffProp.next = ele._private.style[ diffPropName ];

      if( retDiffProp.next && retDiffProp.next.bypass ){
        retDiffProp.next = retDiffProp.next.bypassed;
      }
    }

    return {
      diffProps: retDiffProps
    };
  };

  $$.styfn.updateStyleHints = function(ele){
    var _p = ele._private;
    var self = this;
    var style = _p.style;

    // set whether has pie or not; for greater efficiency
    var hasPie = false;
    if( _p.group === 'nodes' && self._private.hasPie ){
      for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N
        var size = _p.style['pie-' + i + '-background-size'].value;

        if( size > 0 ){
          hasPie = true;
          break;
        }
      }
    }

    _p.hasPie = hasPie;

    var transform = style['text-transform'].strValue;
    var content = style['content'].strValue;
    var fStyle = style['font-style'].strValue;
    var size = style['font-size'].pxValue + 'px';
    var family = style['font-family'].strValue;
    // var variant = style['font-variant'].strValue;
    var weight = style['font-weight'].strValue;
    var valign = style['text-valign'].strValue;
    var halign = style['text-valign'].strValue;
    var oWidth = style['text-outline-width'].pxValue;
    var wrap = style['text-wrap'].strValue;
    var wrapW = style['text-max-width'].pxValue;
    _p.labelKey = fStyle +'$'+ size +'$'+ family +'$'+ weight +'$'+ content +'$'+ transform +'$'+ valign +'$'+ halign +'$'+ oWidth + '$' + wrap + '$' + wrapW;
    _p.fontKey = fStyle +'$'+ weight +'$'+ size +'$'+ family;

    var width = style['width'].pxValue;
    var height = style['height'].pxValue;
    var borderW = style['border-width'].pxValue;
    _p.boundingBoxKey = width +'$'+ height +'$'+ borderW;

    if( ele._private.group === 'edges' ){
      var cpss = style['control-point-step-size'].pxValue;
      var cpd = style['control-point-distance'] ? style['control-point-distance'].pxValue : undefined;
      var cpw = style['control-point-weight'].value;
      var curve = style['curve-style'].strValue;

      _p.boundingBoxKey += '$'+ cpss +'$'+ cpd +'$'+ cpw +'$'+ curve;
    }

    _p.styleKey = Date.now(); // probably safe to use applied time and much faster
    // for( var i = 0; i < $$.style.properties.length; i++ ){
    //   var prop = $$.style.properties[i];
    //   var eleProp = _p.style[ prop.name ];
    //   var val = eleProp && eleProp.strValue ? eleProp.strValue : 'undefined';

    //   _p.styleKey += '$' + val;
    // }
  };

  // apply a property to the style (for internal use)
  // returns whether application was successful
  //
  // now, this function flattens the property, and here's how:
  //
  // for parsedProp:{ bypass: true, deleteBypass: true }
  // no property is generated, instead the bypass property in the
  // element's style is replaced by what's pointed to by the `bypassed`
  // field in the bypass property (i.e. restoring the property the
  // bypass was overriding)
  //
  // for parsedProp:{ mapped: truthy }
  // the generated flattenedProp:{ mapping: prop }
  //
  // for parsedProp:{ bypass: true }
  // the generated flattenedProp:{ bypassed: parsedProp }
  $$.styfn.applyParsedProperty = function( ele, parsedProp ){
    var prop = parsedProp;
    var style = ele._private.style;
    var fieldVal, flatProp;
    var types = $$.style.types;
    var type = $$.style.properties[ prop.name ].type;
    var propIsBypass = prop.bypass;
    var origProp = style[ prop.name ];
    var origPropIsBypass = origProp && origProp.bypass;
    var _p = ele._private;

    // can't apply auto to width or height unless it's a parent node
    if( (parsedProp.name === 'height' || parsedProp.name === 'width') && ele.isNode() ){
      if( parsedProp.value === 'auto' && !ele.isParent() ){
        return false;
      } else if( parsedProp.value !== 'auto' && ele.isParent() ){
        prop = parsedProp = this.parse( parsedProp.name, 'auto', propIsBypass );
      }
    }

    // check if we need to delete the current bypass
    if( propIsBypass && prop.deleteBypass ){ // then this property is just here to indicate we need to delete
      var currentProp = style[ prop.name ];

      // can only delete if the current prop is a bypass and it points to the property it was overriding
      if( !currentProp ){
        return true; // property is already not defined
      } else if( currentProp.bypass && currentProp.bypassed ){ // then replace the bypass property with the original

        // because the bypassed property was already applied (and therefore parsed), we can just replace it (no reapplying necessary)
        style[ prop.name ] = currentProp.bypassed;
        return true;

      } else {
        return false; // we're unsuccessful deleting the bypass
      }
    }

    var printMappingErr = function(){
      $$.util.error('Do not assign mappings to elements without corresponding data (e.g. ele `'+ ele.id() +'` for property `'+ prop.name +'` with data field `'+ prop.field +'`); try a `['+ prop.field +']` selector to limit scope to elements with `'+ prop.field +'` defined');
    };

    // put the property in the style objects
    switch( prop.mapped ){ // flatten the property if mapped
    case types.mapData:
    case types.mapLayoutData:
    case types.mapScratch:

      var isLayout = prop.mapped === types.mapLayoutData;
      var isScratch = prop.mapped === types.mapScratch;

      // flatten the field (e.g. data.foo.bar)
      var fields = prop.field.split(".");
      var fieldVal;

      if( isScratch || isLayout ){
        fieldVal = _p.scratch;
      } else {
        fieldVal = _p.data;
      }

      for( var i = 0; i < fields.length && fieldVal; i++ ){
        var field = fields[i];
        fieldVal = fieldVal[ field ];
      }

      var percent;
      if( !$$.is.number(fieldVal) ){ // then keep the mapping but assume 0% for now
        percent = 0;
      } else {
        percent = (fieldVal - prop.fieldMin) / (prop.fieldMax - prop.fieldMin);
      }

      // make sure to bound percent value
      if( percent < 0 ){
        percent = 0;
      } else if( percent > 1 ){
        percent = 1;
      }

      if( type.color ){
        var r1 = prop.valueMin[0];
        var r2 = prop.valueMax[0];
        var g1 = prop.valueMin[1];
        var g2 = prop.valueMax[1];
        var b1 = prop.valueMin[2];
        var b2 = prop.valueMax[2];
        var a1 = prop.valueMin[3] == null ? 1 : prop.valueMin[3];
        var a2 = prop.valueMax[3] == null ? 1 : prop.valueMax[3];

        var clr = [
          Math.round( r1 + (r2 - r1)*percent ),
          Math.round( g1 + (g2 - g1)*percent ),
          Math.round( b1 + (b2 - b1)*percent ),
          Math.round( a1 + (a2 - a1)*percent )
        ];

        flatProp = { // colours are simple, so just create the flat property instead of expensive string parsing
          bypass: prop.bypass, // we're a bypass if the mapping property is a bypass
          name: prop.name,
          value: clr,
          strValue: 'rgb(' + clr[0] + ', ' + clr[1] + ', ' + clr[2] + ')'
        };

      } else if( type.number ){
        var calcValue = prop.valueMin + (prop.valueMax - prop.valueMin) * percent;
        flatProp = this.parse( prop.name, calcValue, prop.bypass, true );

      } else {
        return false; // can only map to colours and numbers
      }

      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
        flatProp = this.parse( prop.name, origProp.strValue, prop.bypass, true );
      }

      if( !flatProp ){ printMappingErr(); }
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want

      break;

    // direct mapping
    case types.data:
    case types.layoutData:
    case types.scratch:
      var isLayout = prop.mapped === types.layoutData;
      var isScratch = prop.mapped === types.scratch;

      // flatten the field (e.g. data.foo.bar)
      var fields = prop.field.split(".");
      var fieldVal;

      if( isScratch || isLayout ){
        fieldVal = _p.scratch;
      } else {
        fieldVal = _p.data;
      }

      if( fieldVal ){ for( var i = 0; i < fields.length; i++ ){
        var field = fields[i];
        fieldVal = fieldVal[ field ];
      } }

      flatProp = this.parse( prop.name, fieldVal, prop.bypass, true );

      if( !flatProp ){ // if we can't flatten the property, then use the origProp so we still keep the mapping itself
        var flatPropVal = origProp ? origProp.strValue : '';

        flatProp = this.parse( prop.name, flatPropVal, prop.bypass, true );
      }

      if( !flatProp ){ printMappingErr(); }
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want

      break;

    case types.fn:
      var fn = prop.value;
      var fnRetVal = fn( ele );

      flatProp = this.parse( prop.name, fnRetVal, prop.bypass, true );
      flatProp.mapping = prop; // keep a reference to the mapping
      prop = flatProp; // the flattened (mapped) property is the one we want

      break;

    case undefined:
      break; // just set the property

    default:
      return false; // not a valid mapping
    }

    // if the property is a bypass property, then link the resultant property to the original one
    if( propIsBypass ){
      if( origPropIsBypass ){ // then this bypass overrides the existing one
        prop.bypassed = origProp.bypassed; // steal bypassed prop from old bypass
      } else { // then link the orig prop to the new bypass
        prop.bypassed = origProp;
      }

      style[ prop.name ] = prop; // and set

    } else { // prop is not bypass
      if( origPropIsBypass ){ // then keep the orig prop (since it's a bypass) and link to the new prop
        origProp.bypassed = prop;
      } else { // then just replace the old prop with the new one
        style[ prop.name ] = prop;
      }
    }

    return true;
  };

  // updates the visual style for all elements (useful for manual style modification after init)
  $$.styfn.update = function(){
    var cy = this._private.cy;
    var eles = cy.elements();

    eles.updateStyle();
  };

  // just update the functional properties (i.e. mappings) in the elements'
  // styles (less expensive than recalculation)
  $$.styfn.updateMappers = function( eles ){
    for( var i = 0; i < eles.length; i++ ){ // for each ele
      var ele = eles[i];
      var style = ele._private.style;

      for( var j = 0; j < $$.style.properties.length; j++ ){ // for each prop
        var prop = $$.style.properties[j];
        var propInStyle = style[ prop.name ];

        if( propInStyle && propInStyle.mapping ){
          var mapping = propInStyle.mapping;
          this.applyParsedProperty( ele, mapping ); // reapply the mapping property
        }
      }

      this.updateStyleHints( ele );
    }
  };

  // diffProps : { name => { prev, next } }
  $$.styfn.updateTransitions = function( ele, diffProps, isBypass ){
    var self = this;
    var style = ele._private.style;

    var props = style['transition-property'].value;
    var duration = style['transition-duration'].msValue;
    var delay = style['transition-delay'].msValue;
    var css = {};

    if( props.length > 0 && duration > 0 ){

      // build up the style to animate towards
      var anyPrev = false;
      for( var i = 0; i < props.length; i++ ){
        var prop = props[i];
        var styProp = style[ prop ];
        var diffProp = diffProps[ prop ];

        if( !diffProp ){ continue; }

        var prevProp = diffProp.prev;
        var fromProp = prevProp;
        var toProp = diffProp.next != null ? diffProp.next : styProp;
        var diff = false;

        if( !fromProp ){ continue; }

        // consider px values
        if( $$.is.number( fromProp.pxValue ) && $$.is.number( toProp.pxValue ) ){
          diff = fromProp.pxValue !== toProp.pxValue;

        // consider numerical values
        } else if( $$.is.number( fromProp.value ) && $$.is.number( toProp.value ) ){
          diff = fromProp.value !== toProp.value;

        // consider colour values
        } else if( $$.is.array( fromProp.value ) && $$.is.array( toProp.value ) ){
          diff = fromProp.value[0] !== toProp.value[0]
            || fromProp.value[1] !== toProp.value[1]
            || fromProp.value[2] !== toProp.value[2]
          ;
        }

        // the previous value is good for an animation only if it's different
        if( diff ){
          css[ prop ] = toProp.strValue; // to val
          this.applyBypass(ele, prop, fromProp.strValue); // from val
          anyPrev = true;
        }

      } // end if props allow ani

      // can't transition if there's nothing previous to transition from
      if( !anyPrev ){ return; }

      ele._private.transitioning = true;

      ele.stop();

      if( delay > 0 ){
        ele.delay( delay );
      }

      ele.animate({
        css: css
      }, {
        duration: duration,
        queue: false,
        complete: function(){
          if( !isBypass ){
            self.removeBypasses( ele, props );
          }

          ele._private.transitioning = false;
        }
      });

    } else if( ele._private.transitioning ){
      ele.stop();

      this.removeBypasses( ele, props );

      ele._private.transitioning = false;
    }
  };

})( cytoscape );

;(function($$){ 'use strict';

  // bypasses are applied to an existing style on an element, and just tacked on temporarily
  // returns true iff application was successful for at least 1 specified property
  $$.styfn.applyBypass = function( eles, name, value, updateTransitions ){
    var props = [];
    var isBypass = true;
    
    // put all the properties (can specify one or many) in an array after parsing them
    if( name === "*" || name === "**" ){ // apply to all property names

      if( value !== undefined ){
        for( var i = 0; i < $$.style.properties.length; i++ ){
          var prop = $$.style.properties[i];
          var name = prop.name;

          var parsedProp = this.parse(name, value, true);
          
          if( parsedProp ){
            props.push( parsedProp );
          }
        }
      }

    } else if( $$.is.string(name) ){ // then parse the single property
      var parsedProp = this.parse(name, value, true);

      if( parsedProp ){
        props.push( parsedProp );
      }
    } else if( $$.is.plainObject(name) ){ // then parse each property
      var specifiedProps = name;
      updateTransitions = value;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var name = prop.name;
        var value = specifiedProps[ name ];

        if( value === undefined ){ // try camel case name too
          value = specifiedProps[ $$.util.dash2camel(name) ];
        }

        if( value !== undefined ){
          var parsedProp = this.parse(name, value, true);
          
          if( parsedProp ){
            props.push( parsedProp );
          }
        }
      }
    } else { // can't do anything without well defined properties
      return false;
    }

    // we've failed if there are no valid properties
    if( props.length === 0 ){ return false; }

    // now, apply the bypass properties on the elements
    var ret = false; // return true if at least one succesful bypass applied
    for( var i = 0; i < eles.length; i++ ){ // for each ele
      var ele = eles[i];
      var style = ele._private.style;
      var diffProps = {};
      var diffProp;

      for( var j = 0; j < props.length; j++ ){ // for each prop
        var prop = props[j];

        if( updateTransitions ){
          var prevProp = style[ prop.name ];
          diffProp = diffProps[ prop.name ] = { prev: prevProp };
        }

        ret = this.applyParsedProperty( ele, prop ) || ret;

        if( updateTransitions ){
          diffProp.next = style[ prop.name ];
        }

      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles

    return ret;
  };

  // only useful in specific cases like animation
  $$.styfn.overrideBypass = function( eles, name, value ){
    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var prop = ele._private.style[ $$.util.camel2dash(name) ];

      if( !prop.bypass ){ // need a bypass if one doesn't exist
        this.applyBypass( ele, name, value );
        continue;
      }

      prop.value = value;
      prop.pxValue = value;
    }
  };

  $$.styfn.removeAllBypasses = function( eles, updateTransitions ){
    var isBypass = true;

    for( var j = 0; j < eles.length; j++ ){
      var ele = eles[j];
      var diffProps = {};
      var style = ele._private.style;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var name = prop.name;
        var value = ''; // empty => remove bypass
        var parsedProp = this.parse(name, value, true);
        var prevProp = style[ prop.name ];
        var diffProp = diffProps[ prop.name ] = { prev: prevProp };

        this.applyParsedProperty(ele, parsedProp);

        diffProp.next = style[ prop.name ];
      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles
  };

  $$.styfn.removeBypasses = function( eles, props, updateTransitions ){
    var isBypass = true;

    for( var j = 0; j < eles.length; j++ ){
      var ele = eles[j];
      var diffProps = {};
      var style = ele._private.style;

      for( var i = 0; i < props.length; i++ ){
        var name = props[i];
        var prop = $$.style.properties[ name ];
        var value = ''; // empty => remove bypass
        var parsedProp = this.parse(name, value, true);
        var prevProp = style[ prop.name ];
        var diffProp = diffProps[ prop.name ] = { prev: prevProp };

        this.applyParsedProperty(ele, parsedProp);

        diffProp.next = style[ prop.name ];
      } // for props

      if( updateTransitions ){
        this.updateTransitions( ele, diffProps, isBypass );
      }
    } // for eles
  };

})( cytoscape );
;(function($$, window){ 'use strict';

  // gets what an em size corresponds to in pixels relative to a dom element
  $$.styfn.getEmSizeInPixels = function(){
    var cy = this._private.cy;
    var domElement = cy.container();

    if( window && domElement && window.getComputedStyle ){
      var pxAsStr = window.getComputedStyle(domElement).getPropertyValue('font-size');
      var px = parseFloat( pxAsStr );
      return px;
    } else {
      return 1; // in case we're running outside of the browser
    }
  };

  // gets css property from the core container
  $$.styfn.containerCss = function( propName ){
    var cy = this._private.cy;
    var domElement = cy.container();

    if( window && domElement && window.getComputedStyle ){
      return window.getComputedStyle(domElement).getPropertyValue( propName );
    }
  };

  $$.styfn.containerProperty = function( propName ){
    var propStr = this.containerCss( propName );
    var prop = this.parse( propName, propStr );
    return prop;
  };

  $$.styfn.containerPropertyAsString = function( propName ){
    var prop = this.containerProperty( propName );

    if( prop ){
      return prop.strValue;
    }
  };

})( cytoscape, typeof window === 'undefined' ? null : window );
;(function($$){ 'use strict';

  // gets the rendered style for an element
  $$.styfn.getRenderedStyle = function( ele ){
    var ele = ele[0]; // insure it's an element

    if( ele ){
      var rstyle = {};
      var style = ele._private.style;
      var cy = this._private.cy;
      var zoom = cy.zoom();

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ];

        if( styleProp ){
          var val = styleProp.unitless ? styleProp.strValue : (styleProp.pxValue * zoom) + 'px';
          rstyle[ prop.name ] = val;
          rstyle[ $$.util.dash2camel(prop.name) ] = val;
        }
      }

      return rstyle;
    }
  };

  // gets the raw style for an element
  $$.styfn.getRawStyle = function( ele ){
    var ele = ele[0]; // insure it's an element

    if( ele ){
      var rstyle = {};
      var style = ele._private.style;

      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ];

        if( styleProp ){
          rstyle[ prop.name ] = styleProp.strValue;
          rstyle[ $$.util.dash2camel(prop.name) ] = styleProp.strValue;
        }
      }

      return rstyle;
    }
  };

  // gets the value style for an element (useful for things like animations)
  $$.styfn.getValueStyle = function( ele, opts ){
    opts = opts || {};

    var rstyle = opts.array ? [] : {}; 
    var style;

    if( $$.is.element(ele) ){
      style = ele._private.style;    
    } else {
      style = ele; // just passed the style itself
    }

    if( style ){
      for( var i = 0; i < $$.style.properties.length; i++ ){
        var prop = $$.style.properties[i];
        var styleProp = style[ prop.name ] || style[ $$.util.dash2camel(prop.name) ];

        if( styleProp !== undefined && !$$.is.plainObject( styleProp ) ){ // then make a prop of it
          styleProp = this.parse(prop.name, styleProp);
        }

        if( styleProp ){
          if( opts.array ){
            rstyle.push( styleProp );
          } else {
            rstyle[ prop.name ] = styleProp;
            rstyle[ $$.util.dash2camel(prop.name) ] = styleProp;
          }
        }
      }
    }

    return rstyle;
  };

})( cytoscape );
;(function($$){ 'use strict';

  $$.style.applyFromJson = function( style, json ){
    for( var i = 0; i < json.length; i++ ){
      var context = json[i];
      var selector = context.selector;
      var props = context.style || context.css;

      style.selector( selector ); // apply selector

      for( var name in props ){
        var value = props[name];

        style.css( name, value ); // apply property
      }
    }

    return style;
  };

  // static function
  $$.style.fromJson = function( cy, json ){
    var style = new $$.Style(cy);

    $$.style.applyFromJson( style, json );

    return style;
  };

  // accessible cy.style() function
  $$.styfn.fromJson = function( json ){
    var style = this;

    style.resetToDefault();

    $$.style.applyFromJson( style, json );

    return style;
  };

  // get json from cy.style() api
  $$.styfn.json = function(){
    var json = [];

    for( var i = this.defaultLength; i < this.length; i++ ){
      var cxt = this[i];
      var selector = cxt.selector;
      var props = cxt.properties;
      var css = {};

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];
        css[ prop.name ] = prop.strValue;
      }

      json.push({
        selector: !selector ? 'core' : selector.toString(),
        style: css
      });
    }

    return json;
  };

})( cytoscape );
;(function($$){ 'use strict';

  $$.style.applyFromString = function( style, string ){
    var remaining = '' + string;
    var selAndBlockStr;
    var blockRem;
    var propAndValStr;

    // remove comments from the style string
    remaining = remaining.replace(/[/][*](\s|.)+?[*][/]/g, '');

    function removeSelAndBlockFromRemaining(){
      // remove the parsed selector and block from the remaining text to parse
      if( remaining.length > selAndBlockStr.length ){
        remaining = remaining.substr( selAndBlockStr.length );
      } else {
        remaining = '';
      }
    }

    function removePropAndValFromRem(){
      // remove the parsed property and value from the remaining block text to parse
      if( blockRem.length > propAndValStr.length ){
        blockRem = blockRem.substr( propAndValStr.length );
      } else {
        blockRem = '';
      }
    }

    while(true){
      var nothingLeftToParse = remaining.match(/^\s*$/);
      if( nothingLeftToParse ){ break; }

      var selAndBlock = remaining.match(/^\s*((?:.|\s)+?)\s*\{((?:.|\s)+?)\}/);

      if( !selAndBlock ){
        $$.util.error('Halting stylesheet parsing: String stylesheet contains more to parse but no selector and block found in: ' + remaining);
        break;
      }

      selAndBlockStr = selAndBlock[0];

      // parse the selector
      var selectorStr = selAndBlock[1];
      if( selectorStr !== 'core' ){
        var selector = new $$.Selector( selectorStr );
        if( selector._private.invalid ){
          $$.util.error('Skipping parsing of block: Invalid selector found in string stylesheet: ' + selectorStr);

          // skip this selector and block
          removeSelAndBlockFromRemaining();
          continue; 
        }
      }

      // parse the block of properties and values
      var blockStr = selAndBlock[2];
      var invalidBlock = false;
      blockRem = blockStr;
      var props = [];

      while(true){
        var nothingLeftToParse = blockRem.match(/^\s*$/);
        if( nothingLeftToParse ){ break; }

        var propAndVal = blockRem.match(/^\s*(.+?)\s*:\s*(.+?)\s*;/);

        if( !propAndVal ){
          $$.util.error('Skipping parsing of block: Invalid formatting of style property and value definitions found in:' + blockStr);
          invalidBlock = true;
          break;
        }

        propAndValStr = propAndVal[0];
        var propStr = propAndVal[1];
        var valStr = propAndVal[2];

        var prop = $$.style.properties[ propStr ];
        if( !prop ){
          $$.util.error('Skipping property: Invalid property name in: ' + propAndValStr);

          // skip this property in the block
          removePropAndValFromRem();
          continue;
        }

        var parsedProp = style.parse( propStr, valStr );

        if( !parsedProp ){
          $$.util.error('Skipping property: Invalid property definition in: ' + propAndValStr);

          // skip this property in the block
          removePropAndValFromRem();
          continue;
        }

        props.push({
          name: propStr,
          val: valStr
        });
        removePropAndValFromRem();
      }

      if( invalidBlock ){
        removeSelAndBlockFromRemaining();
        break;
      }

      // put the parsed block in the style
      style.selector( selectorStr );
      for( var i = 0; i < props.length; i++ ){
        var prop = props[i];
        style.css( prop.name, prop.val );
      }

      removeSelAndBlockFromRemaining();
    }

    return style;
  };

  $$.style.fromString = function( cy, string ){
    var style = new $$.Style(cy);
    
    $$.style.applyFromString( style, string );

    return style;
  };

  $$.styfn.fromString = function( string ){
    var style = this;

    style.resetToDefault();

    $$.style.applyFromString( style, string );

    return style;
  };

})( cytoscape );

;(function($$){ 'use strict';

  // a dummy stylesheet object that doesn't need a reference to the core
  // (useful for init)
  $$.stylesheet = $$.Stylesheet = function(){
    if( !(this instanceof $$.Stylesheet) ){
      return new $$.Stylesheet();
    }

    this.length = 0;
  };

  $$.sheetfn = $$.Stylesheet.prototype;

  // just store the selector to be parsed later
  $$.sheetfn.selector = function( selector ){
    var i = this.length++;

    this[i] = {
      selector: selector,
      properties: []
    };

    return this; // chaining
  };

  // just store the property to be parsed later
  $$.sheetfn.css = function( name, value ){
    var i = this.length - 1;

    if( $$.is.string(name) ){
      this[i].properties.push({
        name: name,
        value: value
      });
    } else if( $$.is.plainObject(name) ){
      var map = name;

      for( var j = 0; j < $$.style.properties.length; j++ ){
        var prop = $$.style.properties[j];
        var mapVal = map[ prop.name ];

        if( mapVal === undefined ){ // also try camel case name
          mapVal = map[ $$.util.dash2camel(prop.name) ];
        }

        if( mapVal !== undefined ){
          var name = prop.name;
          var value = mapVal;

          this[i].properties.push({
            name: name,
            value: value
          });
        }
      }
    }

    return this; // chaining
  };

  $$.sheetfn.style = $$.sheetfn.css;

  // generate a real style object from the dummy stylesheet
  $$.sheetfn.generateStyle = function( cy ){
    var style = new $$.Style(cy);

    for( var i = 0; i < this.length; i++ ){
      var context = this[i];
      var selector = context.selector;
      var props = context.properties;

      style.selector(selector); // apply selector

      for( var j = 0; j < props.length; j++ ){
        var prop = props[j];

        style.css( prop.name, prop.value ); // apply property
      }
    }

    return style;
  };

})( cytoscape );
// cross-env thread/worker
// NB : uses (heavyweight) processes on nodejs so best not to create too many threads

;(function($$, window){ 'use strict';

  $$.Thread = function( fn ){
    if( !(this instanceof $$.Thread) ){
      return new $$.Thread( fn );
    }

    this._private = {
      requires: [],
      files: [],
      queue: null,
      pass: []
    };

    if( fn ){
      this.run( fn );
    }

  };

  $$.thread = $$.Thread;
  $$.thdfn = $$.Thread.prototype; // short alias

  $$.fn.thread = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Thread.prototype[ name ] = fn;
    }
  };

  var stringifyFieldVal = function( val ){
    var valStr = $$.is.fn( val ) ? val.toString() : 'JSON.parse("' + JSON.stringify(val) + '")';

    return valStr;
  };

  // allows for requires with prototypes and subobjs etc
  var fnAsRequire = function( fn ){
    var req;
    var fnName;

    if( $$.is.object(fn) && fn.fn ){ // manual fn
      req = fnAs( fn.fn, fn.name );
      fnName = fn.name;
      fn = fn.fn;
    } else if( $$.is.fn(fn) ){ // auto fn
      req = fn.toString();
      fnName = fn.name;
    } else if( $$.is.string(fn) ){ // stringified fn
      req = fn;
    } else if( $$.is.object(fn) ){ // plain object
      if( fn.proto ){
        req = '';
      } else {
        req = fn.name + ' = {};';
      }

      fnName = fn.name;
      fn = fn.obj;
    }

    req += '\n';

    var protoreq = function( val, subname ){
      if( val.prototype ){
        var protoNonempty = false;
        for( var prop in val.prototype ){ protoNonempty = true; break; }

        if( protoNonempty ){
          req += fnAsRequire( {
            name: subname,
            obj: val,
            proto: true
          }, val );
        }
      }
    };

    // pull in prototype
    if( fn.prototype && fnName != null ){

      for( var name in fn.prototype ){
        var protoStr = '';

        var val = fn.prototype[ name ];
        var valStr = stringifyFieldVal( val );
        var subname = fnName + '.prototype.' + name;

        protoStr += subname + ' = ' + valStr + ';\n';

        if( protoStr ){
          req += protoStr;
        }

        protoreq( val, subname ); // subobject with prototype
      }
  
    }

    // pull in properties for obj/fns
    if( !$$.is.string(fn) ){ for( var name in fn ){
      var propsStr = '';

      if( fn.hasOwnProperty(name) ){
        var val = fn[ name ];
        var valStr = stringifyFieldVal( val );
        var subname = fnName + '["' + name + '"]';

        propsStr += subname + ' = ' + valStr + ';\n';
      }

      if( propsStr ){
        req += propsStr;
      }

      protoreq( val, subname ); // subobject with prototype
    } }

    return req;
  };
  
  var isPathStr = function( str ){
    return $$.is.string(str) && str.match(/\.js$/);
  };

  $$.fn.thread({

    require: function( fn, as ){
      if( isPathStr(fn) ){
        this._private.files.push( fn );
        
        return this;
      }
        
      if( as ){
        if( $$.is.fn(fn) ){
          // disabled b/c doesn't work with forced names on functions w/ prototypes
          //fn = fnAs( fn, as );

          as = as || fn.name;

          fn = { name: as, fn: fn };
        } else {
          fn = { name: as, obj: fn };
        }
      }

      this._private.requires.push( fn );

      return this; // chaining
    },

    pass: function( data ){
      this._private.pass.push( data );

      return this; // chaining
    },

    run: function( fn, pass ){ // fn used like main()
      var self = this;
      var _p = this._private;
      pass = pass || _p.pass.shift();

      if( _p.stopped ){
        $$.util.error('Attempted to run a stopped thread!  Start a new thread or do not stop the existing thread and reuse it.');
        return;
      }

      if( _p.running ){
        return _p.queue = _p.queue.then(function(){ // inductive step
          return self.run( fn, pass );
        });
      }
      
      var useWW = window != null;
      var useNode = typeof module !== 'undefined';

      self.trigger('run');

      var runP = new $$.Promise(function( resolve, reject ){

        _p.running = true;

        var threadTechAlreadyExists = _p.ran;

        var fnImplStr = $$.is.string( fn ) ? fn : fn.toString();

        // worker code to exec
        var fnStr = '\n' + ( _p.requires.map(function( r ){
          return fnAsRequire( r );
        }) ).concat( _p.files.map(function( f ){
          if( useWW ){
            var wwifyFile = function( file ){
              if( file.match(/^\.\//) || file.match(/^\.\./) ){
                return window.location.origin + window.location.pathname + file;
              } else if( file.match(/^\//) ){
                return window.location.origin + '/' + file;
              }
              return file;
            };
            
            return 'importScripts("' + wwifyFile(f) + '");';
          } else if( useNode ) {
            return 'eval( require("fs").readFileSync("' + f + '", { encoding: "utf8" }) );';
          }
        }) ).concat([
          '( function(){',
            'var ret = (' + fnImplStr + ')(' + JSON.stringify(pass) + ');',
            'if( ret !== undefined ){ resolve(ret); }', // assume if ran fn returns defined value (incl. null), that we want to resolve to it
          '} )()\n'
        ]).join('\n');

        // because we've now consumed the requires, empty the list so we don't dupe on next run()
        _p.requires = [];
        _p.files = [];

        if( useWW ){
          var fnBlob, fnUrl;

          // add normalised thread api functions
          if( !threadTechAlreadyExists ){
            var fnPre = fnStr + '';

            fnStr = [
              'function broadcast(m){ return message(m); };', // alias
              'function message(m){ postMessage(m); };',
              'function listen(fn){',
              '  self.addEventListener("message", function(m){ ',
              '    if( typeof m === "object" && (m.data.$$eval || m.data === "$$start") ){',
              '    } else { ',
              '      fn( m.data );',
              '    }',
              '  });',
              '};', 
              'self.addEventListener("message", function(m){  if( m.data.$$eval ){ eval( m.data.$$eval ); }  });',
              'function resolve(v){ postMessage({ $$resolve: v }); };', 
              'function reject(v){ postMessage({ $$reject: v }); };'
            ].join('\n');
          
            fnStr += fnPre;

            fnBlob = new Blob([ fnStr ], {
              type: 'application/javascript'
            });
            fnUrl = window.URL.createObjectURL( fnBlob );
          }
          // create webworker and let it exec the serialised code
          var ww = _p.webworker = _p.webworker || new Worker( fnUrl );

          if( threadTechAlreadyExists ){ // then just exec new run() code
            ww.postMessage({
              $$eval: fnStr
            });
          }

          // worker messages => events
          var cb;
          ww.addEventListener('message', cb = function( m ){
            var isObject = $$.is.object(m) && $$.is.object( m.data );
            
            if( isObject && ('$$resolve' in m.data) ){
              ww.removeEventListener('message', cb); // done listening b/c resolve()

              resolve( m.data.$$resolve );
            } else if( isObject && ('$$reject' in m.data) ){
              ww.removeEventListener('message', cb); // done listening b/c reject()

              reject( m.data.$$reject );
            } else {
              self.trigger( new $$.Event(m, { type: 'message', message: m.data }) );
            }
          }, false);

          if( !threadTechAlreadyExists ){
            ww.postMessage('$$start'); // start up the worker
          }

        } else if( useNode ){
          // create a new process
          var path = require('path');
          var child_process = require('child_process');
          var child = _p.child = _p.child || child_process.fork( path.join(__dirname, 'thread-node-fork') );

          // child process messages => events
          var cb;
          child.on('message', cb = function( m ){
            if( $$.is.object(m) && ('$$resolve' in m) ){
              child.removeListener('message', cb); // done listening b/c resolve()

              resolve( m.$$resolve );
            } else if( $$.is.object(m) && ('$$reject' in m) ){
              child.removeListener('message', cb); // done listening b/c reject()

              reject( m.$$reject );
            } else {
              self.trigger( new $$.Event({}, { type: 'message', message: m }) );
            }
          });

          // ask the child process to eval the worker code
          child.send({
            $$eval: fnStr
          });
        } else {
          $$.error('Tried to create thread but no underlying tech found!');
          // TODO fallback on main JS thread?
        }

      }).then(function( v ){
        _p.running = false;
        _p.ran = true;

        self.trigger('ran');

        return v;
      });

      if( _p.queue == null ){
        _p.queue = runP; // i.e. first step of inductive promise chain (for queue)
      }

      return runP;
    },

    // send the thread a message
    message: function( m ){
      var _p = this._private;

      if( _p.webworker ){
        _p.webworker.postMessage( m );
      }

      if( _p.child ){
        _p.child.send( m );
      } 

      return this; // chaining
    },

    stop: function(){
      var _p = this._private;

      if( _p.webworker ){
        _p.webworker.terminate();
      }

      if( _p.child ){
        _p.child.kill();
      } 

      _p.stopped = true;

      return this.trigger('stop'); // chaining
    },

    stopped: function(){
      return this._private.stopped;
    }

  });

  var fnAs = function( fn, name ){
    var fnStr = fn.toString();
    fnStr = fnStr.replace(/function.*\(/, 'function ' + name + '(');

    return fnStr;
  };

  var defineFnal = function( opts ){
    opts = opts || {};

    return function fnalImpl( fn, arg1 ){
      var fnStr = fnAs( fn, '_$_$_' + opts.name );

      this.require( fnStr );

      return this.run( [ 
        'function( data ){',
        '  var origResolve = resolve;',
        '  var res = [];',
        '  ',
        '  resolve = function( val ){',
        '    res.push( val );',
        '  };',
        '  ',
        '  var ret = data.' + opts.name + '( _$_$_' + opts.name + ( arguments.length > 1 ? ', ' + JSON.stringify(arg1) : '' ) + ' );',
        '  ',
        '  resolve = origResolve;',
        '  resolve( res.length > 0 ? res : ret );',
        '}'
      ].join('\n') );
    };
  };

  $$.fn.thread({
    reduce: defineFnal({ name: 'reduce' }),

    reduceRight: defineFnal({ name: 'reduceRight' }),

    map: defineFnal({ name: 'map' })
  });

  // aliases
  var fn = $$.thdfn;
  fn.promise = fn.run;
  fn.terminate = fn.halt = fn.stop;
  fn.include = fn.require;

  // higher level alias (in case you like the worker metaphor)
  $$.worker = $$.Worker = $$.Thread;

  // pull in event apis
  $$.fn.thread({
    on: $$.define.on(),
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    off: $$.define.off(), 
    trigger: $$.define.trigger()
  });

  $$.define.eventAliasesOn( $$.thdfn );
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';

  $$.Fabric = function( N ){
    if( !(this instanceof $$.Fabric) ){
      return new $$.Fabric( N );
    }

    this._private = {
      pass: []
    };

    var defN = 4;

    if( $$.is.number(N) ){
      // then use the specified number of threads
    } if( typeof navigator !== 'undefined' && navigator.hardwareConcurrency != null ){
      N = navigator.hardwareConcurrency;
    } else if( typeof module !== 'undefined' ){
      N = require('os').cpus().length;
    } else { // TODO could use an estimation here but would the additional expense be worth it?
      N = defN;
    }

    for( var i = 0; i < N; i++ ){
      this[i] = $$.Thread();
    }

    this.length = N;
  };

  $$.fabric = $$.Fabric;
  $$.fabfn = $$.Fabric.prototype; // short alias

  $$.fn.fabric = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Fabric.prototype[ name ] = fn;
    }
  };

  $$.fn.fabric({

    // require fn in all threads
    require: function( fn, as ){
      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];

        thread.require( fn, as );
      }

      return this;
    },

    // get a random thread
    random: function(){
      var i = Math.round( (this.length - 1) * Math.random() );
      var thread = this[i];

      return thread;
    },

    // run on random thread
    run: function( fn ){
      var pass = this._private.pass.shift();

      return this.random().pass( pass ).run( fn );
    },

    // sends a random thread a message
    message: function( m ){
      return this.random().message( m );
    },

    // send all threads a message
    broadcast: function( m ){
      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];

        thread.message( m );
      }

      return this; // chaining
    },

    // stop all threads
    stop: function(){
      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];

        thread.stop();
      }

      return this; // chaining
    },

    // pass data to be used with .spread() etc.
    pass: function( data ){
      var pass = this._private.pass;

      if( $$.is.array(data) ){
        pass.push( data );
      } else {
        $$.util.error('Only arrays or collections may be used with fabric.pass()');
      }

      return this; // chaining
    },

    spreadSize: function(){
      var subsize =  Math.ceil( this._private.pass[0].length / this.length );

      subsize = Math.max( 1, subsize ); // don't pass less than one ele to each thread

      return subsize;
    },

    // split the data into slices to spread the data equally among threads
    spread: function( fn ){
      var self = this;
      var _p = self._private;
      var subsize = self.spreadSize(); // number of pass eles to handle in each thread
      var pass = _p.pass.shift().concat([]); // keep a copy
      var runPs = [];

      for( var i = 0; i < this.length; i++ ){
        var thread = this[i];
        var slice = pass.splice( 0, subsize );

        var runP = thread.pass( slice ).run( fn );

        runPs.push( runP );

        var doneEarly = pass.length === 0;
        if( doneEarly ){ break; }
      }

      return $$.Promise.all( runPs ).then(function( thens ){
        var postpass = [];
        var p = 0;

        // fill postpass with the total result joined from all threads
        for( var i = 0; i < thens.length; i++ ){
          var then = thens[i]; // array result from thread i

          for( var j = 0; j < then.length; j++ ){
            var t = then[j]; // array element

            postpass[ p++ ] = t;
          }
        }

        return postpass;
      });
    },

    // parallel version of array.map()
    map: function( fn ){
      var self = this;

      self.require( fn, '_$_$_fabmap' );

      return self.spread(function( split ){
        var mapped = [];
        var origResolve = resolve;

        resolve = function( val ){
          mapped.push( val );
        };

        for( var i = 0; i < split.length; i++ ){
          var oldLen = mapped.length;
          var ret = _$_$_fabmap( split[i] );
          var nothingInsdByResolve = oldLen === mapped.length;

          if( nothingInsdByResolve ){
            mapped.push( ret );
          }
        }

        resolve = origResolve;

        return mapped;
      });

    },

    // parallel version of array.filter()
    filter: function( fn ){
      var _p = this._private;
      var pass = _p.pass[0];

      return this.map( fn ).then(function( include ){
        var ret = [];

        for( var i = 0; i < pass.length; i++ ){
          var datum = pass[i];
          var incDatum = include[i];

          if( incDatum ){
            ret.push( datum );
          }
        }

        return ret;
      });
    },

    // sorts the passed array using a divide and conquer strategy
    sort: function( cmp ){
      var self = this;
      var P = this._private.pass[0].length;
      var subsize = this.spreadSize();

      cmp = cmp || function( a, b ){ // default comparison function
        if( a < b ){
          return -1;
        } else if( a > b ){
          return 1;
        }

        return 0;
      };

      self.require( cmp, '_$_$_cmp' );

      return self.spread(function( split ){ // sort each split normally
        var sortedSplit = split.sort( _$_$_cmp );
        resolve( sortedSplit );

      }).then(function( joined ){
        // do all the merging in the main thread to minimise data transfer

        // TODO could do merging in separate threads but would incur add'l cost of data transfer
        // for each level of the merge

        var merge = function( i, j, max ){
          // don't overflow array
          j = Math.min( j, P );
          max = Math.min( max, P );

          // left and right sides of merge
          var l = i;
          var r = j;

          var sorted = [];

          for( var k = l; k < max; k++ ){

            var eleI = joined[i];
            var eleJ = joined[j];

            if( i < r && ( j >= max || cmp(eleI, eleJ) <= 0 ) ){
              sorted.push( eleI );
              i++;
            } else {
              sorted.push( eleJ );
              j++;
            }

          }

          // in the array proper, put the sorted values
          for( var k = 0; k < sorted.length; k++ ){ // kth sorted item
            var index = l + k;

            joined[ index ] = sorted[k];
          }
        };

        for( var splitL = subsize; splitL < P; splitL *= 2 ){ // merge until array is "split" as 1

          for( var i = 0; i < P; i += 2*splitL ){
            merge( i, i + splitL, i + 2*splitL );
          }

        }

        return joined;
      });
    }


  });

  var defineRandomPasser = function( opts ){
    opts = opts || {};

    return function( fn, arg1 ){
      var pass = this._private.pass.shift();

      return this.random().pass( pass )[ opts.threadFn ]( fn, arg1 );
    };
  };

  $$.fn.fabric({
    randomMap: defineRandomPasser({ threadFn: 'map' }),

    reduce: defineRandomPasser({ threadFn: 'reduce' }),

    reduceRight: defineRandomPasser({ threadFn: 'reduceRight' })
  });

  // aliases
  var fn = $$.fabfn;
  fn.promise = fn.run;
  fn.terminate = fn.halt = fn.stop;
  fn.include = fn.require;

  // pull in event apis
  $$.fn.fabric({
    on: $$.define.on(),
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    off: $$.define.off(),
    trigger: $$.define.trigger()
  });

  $$.define.eventAliasesOn( $$.fabfn );

})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';

  var defaults = {
  };
  
  var origDefaults = $$.util.copy( defaults );

  $$.defaults = function( opts ){
    defaults = $$.util.extend({}, origDefaults, opts);
  };

  $$.fn.core = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Core.prototype[ name ] = fn;
    }
  };
  
  $$.Core = function( opts ){
    if( !(this instanceof $$.Core) ){
      return new $$.Core(opts);
    }
    var cy = this;

    opts = $$.util.extend({}, defaults, opts);

    var container = opts.container;
    var reg = container ? container._cyreg : null; // e.g. already registered some info (e.g. readies) via jquery
    reg = reg || {};

    if( reg && reg.cy ){ 
      if( container ){
        while( container.firstChild ){ // clean the container
          container.removeChild( container.firstChild );
        }
      }
      
      reg.cy.notify({ type: 'destroy' }); // destroy the renderer

      reg = {}; // old instance => replace reg completely
    }

    var readies = reg.readies = reg.readies || [];
    
    if( container ){ container._cyreg = reg; } // make sure container assoc'd reg points to this cy
    reg.cy = cy;

    var head = window !== undefined && container !== undefined && !opts.headless;
    var options = opts;
    options.layout = $$.util.extend( { name: head ? 'grid' : 'null' }, options.layout );
    options.renderer = $$.util.extend( { name: head ? 'canvas' : 'null' }, options.renderer );
    
    var defVal = function( def, val, altVal ){
      if( val !== undefined ){
        return val;
      } else if( altVal !== undefined ){
        return altVal;
      } else {
        return def;
      }
    };

    var _p = this._private = {
      container: options.container, // html dom ele container
      ready: false, // whether ready has been triggered
      initrender: false, // has initrender has been triggered
      options: options, // cached options
      elements: [], // array of elements
      id2index: {}, // element id => index in elements array
      listeners: [], // list of listeners
      onRenders: [], // rendering listeners
      aniEles: $$.Collection(this), // elements being animated
      scratch: {}, // scratch object for core
      layout: null,
      renderer: null,
      notificationsEnabled: true, // whether notifications are sent to the renderer
      minZoom: 1e-50,
      maxZoom: 1e50,
      zoomingEnabled: defVal(true, options.zoomingEnabled),
      userZoomingEnabled: defVal(true, options.userZoomingEnabled),
      panningEnabled: defVal(true, options.panningEnabled),
      userPanningEnabled: defVal(true, options.userPanningEnabled),
      boxSelectionEnabled: defVal(false, options.boxSelectionEnabled),
      autolock: defVal(false, options.autolock, options.autolockNodes),
      autoungrabify: defVal(false, options.autoungrabify, options.autoungrabifyNodes),
      autounselectify: defVal(false, options.autounselectify),
      styleEnabled: options.styleEnabled === undefined ? head : options.styleEnabled,
      zoom: $$.is.number(options.zoom) ? options.zoom : 1,
      pan: {
        x: $$.is.plainObject(options.pan) && $$.is.number(options.pan.x) ? options.pan.x : 0,
        y: $$.is.plainObject(options.pan) && $$.is.number(options.pan.y) ? options.pan.y : 0
      },
      animation: { // object for currently-running animations
        current: [],
        queue: []
      },
      hasCompoundNodes: false,
      deferredExecQueue: []
    };

    // set selection type
    var selType = options.selectionType;
    if( selType === undefined || (selType !== 'additive' && selType !== 'single') ){
      // then set default

      _p.selectionType = 'single';
    } else {
      _p.selectionType = selType;
    }

    // init zoom bounds
    if( $$.is.number(options.minZoom) && $$.is.number(options.maxZoom) && options.minZoom < options.maxZoom ){
      _p.minZoom = options.minZoom;
      _p.maxZoom = options.maxZoom;
    } else if( $$.is.number(options.minZoom) && options.maxZoom === undefined ){
      _p.minZoom = options.minZoom;
    } else if( $$.is.number(options.maxZoom) && options.minZoom === undefined ){
      _p.maxZoom = options.maxZoom;
    }

    var loadExtData = function( next ){
      var anyIsPromise = false;

      for( var i = 0; i < extData.length; i++ ){
        var datum = extData[i];

        if( $$.is.promise(datum) ){
          anyIsPromise = true;
          break;
        }
      }

      if( anyIsPromise ){
        return $$.Promise.all( extData ).then( next ); // load all data asynchronously, then exec rest of init
      } else {
        next( extData ); // exec synchronously for convenience
      }
    };

    var extData = [ options.style, options.elements ];
    loadExtData(function( thens ){
      var initStyle = thens[0];
      var initEles = thens[1];
   
      // init style
      if( _p.styleEnabled ){
        cy.setStyle( initStyle );
      }

      // create the renderer
      cy.initRenderer( $$.util.extend({
        hideEdgesOnViewport: options.hideEdgesOnViewport,
        hideLabelsOnViewport: options.hideLabelsOnViewport,
        textureOnViewport: options.textureOnViewport,
        wheelSensitivity: $$.is.number(options.wheelSensitivity) && options.wheelSensitivity > 0 ? options.wheelSensitivity : 1,
        motionBlur: options.motionBlur === undefined ? true : options.motionBlur, // on by default
        motionBlurOpacity: options.motionBlurOpacity === undefined ? 0.05 : options.motionBlurOpacity,
        pixelRatio: $$.is.number(options.pixelRatio) && options.pixelRatio > 0 ? options.pixelRatio : (options.pixelRatio === 'auto' ? undefined : 1),
        desktopTapThreshold: options.desktopTapThreshold === undefined ? 4 : options.desktopTapThreshold,
        touchTapThreshold: options.touchTapThreshold === undefined ? 8 : options.touchTapThreshold
      }, options.renderer) );

      // trigger the passed function for the `initrender` event
      if( options.initrender ){
        cy.on('initrender', options.initrender);
        cy.on('initrender', function(){
          cy._private.initrender = true;
        });
      }

      // initial load
      cy.load(initEles, function(){ // onready
        cy.startAnimationLoop();
        cy._private.ready = true;

        // if a ready callback is specified as an option, the bind it
        if( $$.is.fn( options.ready ) ){
          cy.on('ready', options.ready);
        }

        // bind all the ready handlers registered before creating this instance
        for( var i = 0; i < readies.length; i++ ){
          var fn = readies[i];
          cy.on('ready', fn);
        }
        if( reg ){ reg.readies = []; } // clear b/c we've bound them all and don't want to keep it around in case a new core uses the same div etc
        
        cy.trigger('ready');
      }, options.done);

    });
  };

  $$.corefn = $$.Core.prototype; // short alias
  

  $$.fn.core({
    isReady: function(){
      return this._private.ready;
    },

    ready: function( fn ){
      if( this.isReady() ){
        this.trigger('ready', [], fn); // just calls fn as though triggered via ready event
      } else {
        this.on('ready', fn);
      }
    },

    initrender: function(){
      return this._private.initrender;
    },

    destroy: function(){
      this.notify({ type: 'destroy' }); // destroy the renderer

      var domEle = this.container();
      var parEle = domEle.parentNode;
      if( parEle ){
        parEle.removeChild( domEle );
      }

      return this;
    },

    getElementById: function( id ){
      var index = this._private.id2index[ id ];
      if( index !== undefined ){
        return this._private.elements[ index ];
      }

      // worst case, return an empty collection
      return new $$.Collection( this );
    },

    selectionType: function(){
      return this._private.selectionType;
    },

    hasCompoundNodes: function(){
      return this._private.hasCompoundNodes;
    },

    styleEnabled: function(){
      return this._private.styleEnabled;
    },

    addToPool: function( eles ){
      var elements = this._private.elements;
      var id2index = this._private.id2index;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        var id = ele._private.data.id;
        var index = id2index[ id ];
        var alreadyInPool = index !== undefined;

        if( !alreadyInPool ){
          index = elements.length;
          elements.push( ele );
          id2index[ id ] = index;
          ele._private.index = index;
        }
      }

      return this; // chaining
    },

    removeFromPool: function( eles ){
      var elements = this._private.elements;
      var id2index = this._private.id2index;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];

        var id = ele._private.data.id;
        var index = id2index[ id ];
        var inPool = index !== undefined;

        if( inPool ){
          this._private.id2index[ id ] = undefined;
          elements.splice(index, 1);

          // adjust the index of all elements past this index
          for( var j = index; j < elements.length; j++ ){
            var jid = elements[j]._private.data.id;
            id2index[ jid ]--;
            elements[j]._private.index--;
          }
        }
      }
    },

    container: function(){
      return this._private.container;
    },

    options: function(){
      return $$.util.copy( this._private.options );
    },
    
    json: function(params){
      var json = {};
      var cy = this;
      
      json.elements = {};
      cy.elements().each(function(i, ele){
        var group = ele.group();
        
        if( !json.elements[group] ){
          json.elements[group] = [];
        }
        
        json.elements[group].push( ele.json() );
      });

      if( this._private.styleEnabled ){
        json.style = cy.style().json();
      }

      json.zoomingEnabled = cy._private.zoomingEnabled;
      json.userZoomingEnabled = cy._private.userZoomingEnabled;
      json.zoom = cy._private.zoom;
      json.minZoom = cy._private.minZoom;
      json.maxZoom = cy._private.maxZoom;
      json.panningEnabled = cy._private.panningEnabled;
      json.userPanningEnabled = cy._private.userPanningEnabled;
      json.pan = cy._private.pan;
      json.boxSelectionEnabled = cy._private.boxSelectionEnabled;
      json.layout = cy._private.options.layout;
      json.renderer = cy._private.options.renderer;
      json.hideEdgesOnViewport = cy._private.options.hideEdgesOnViewport;
      json.hideLabelsOnViewport = cy._private.options.hideLabelsOnViewport;
      json.textureOnViewport = cy._private.options.textureOnViewport;
      json.wheelSensitivity = cy._private.options.wheelSensitivity;
      json.motionBlur = cy._private.options.motionBlur;
      
      return json;
    },

    // defer execution until not busy and guarantee relative execution order of deferred functions
    defer: function( fn ){
      var cy = this;
      var _p = cy._private;
      var q = _p.deferredExecQueue;

      q.push( fn );

      if( !_p.deferredTimeout ){
        _p.deferredTimeout = setTimeout(function(){
          while( q.length > 0 ){
            ( q.shift() )();
          }

          _p.deferredTimeout = null;
        }, 0);
      }
    }
    
  });  
  
})( cytoscape, typeof window === 'undefined' ? null : window );

(function($$, window){ 'use strict';

  function ready(f) {
    var fn = ( document && (document.readyState === 'interactive' || document.readyState === 'complete') )  ? f : ready;

    setTimeout(fn, 9, f);
  }

  $$.fn.core({
    add: function(opts){
      
      var elements;
      var cy = this;
      
      // add the elements
      if( $$.is.elementOrCollection(opts) ){
        var eles = opts;

        if( eles._private.cy === cy ){ // same instance => just restore
          elements = eles.restore();

        } else { // otherwise, copy from json
          var jsons = [];

          for( var i = 0; i < eles.length; i++ ){
            var ele = eles[i];
            jsons.push( ele.json() );
          }

          elements = new $$.Collection( cy, jsons );
        }
      }
      
      // specify an array of options
      else if( $$.is.array(opts) ){
        var jsons = opts;

        elements = new $$.Collection(cy, jsons);
      }
      
      // specify via opts.nodes and opts.edges
      else if( $$.is.plainObject(opts) && ($$.is.array(opts.nodes) || $$.is.array(opts.edges)) ){
        var elesByGroup = opts;
        var jsons = [];

        var grs = ['nodes', 'edges'];
        for( var i = 0, il = grs.length; i < il; i++ ){
          var group = grs[i];
          var elesArray = elesByGroup[group];

          if( $$.is.array(elesArray) ){

            for( var j = 0, jl = elesArray.length; j < jl; j++ ){
              var json = elesArray[j];
              json.group = group;

              jsons.push( json );
            }
          } 
        }

        elements = new $$.Collection(cy, jsons);
      }
      
      // specify options for one element
      else {
        var json = opts;
        elements = (new $$.Element( cy, json )).collection();
      }
      
      return elements;
    },
    
    remove: function(collection){
      if( $$.is.elementOrCollection(collection) ){
        collection = collection;
      } else if( $$.is.string(collection) ){
        var selector = collection;
        collection = this.$( selector );
      }
      
      return collection.remove();
    },
    
    load: function(elements, onload, ondone){
      var cy = this;
      
      cy.notifications(false);

      // remove old elements
      var oldEles = cy.elements();
      if( oldEles.length > 0 ){
        oldEles.remove();
      }
      
      if( elements != null ){
        if( $$.is.plainObject(elements) || $$.is.array(elements) ){
          cy.add( elements );
        } 
      }
      
      function callback(){        
        cy.one('layoutready', function(e){
          cy.notifications(true);
          cy.trigger(e); // we missed this event by turning notifications off, so pass it on

          cy.notify({
            type: 'load',
            collection: cy.elements()
          });

          cy.one('load', onload);
          cy.trigger('load');
        }).one('layoutstop', function(){
          cy.one('done', ondone);
          cy.trigger('done');
        });
        
        var layoutOpts = $$.util.extend({}, cy._private.options.layout);
        layoutOpts.eles = cy.$();

        cy.layout( layoutOpts );

      }

      if( window ){
        ready( callback );
      } else {
        callback();
      }

      return this;
    }
  });
  
})( cytoscape, typeof window === 'undefined' ? null : window );

;(function($$, window){ 'use strict';
  
  $$.fn.core({
    
    // pull in animation functions
    animated: $$.define.animated(),
    clearQueue: $$.define.clearQueue(),
    delay: $$.define.delay(),
    animate: $$.define.animate(),
    stop: $$.define.stop(),

    addToAnimationPool: function( eles ){
      var cy = this;

      if( !cy.styleEnabled() ){ return; } // save cycles when no style used
      
      cy._private.aniEles.merge( eles );
    },

    startAnimationLoop: function(){
      var cy = this;

      if( !cy.styleEnabled() ){ return; } // save cycles when no style used

      // don't execute the animation loop in headless environments
      if( !window ){
        return;
      }
      
      function globalAnimationStep(){
        $$.util.requestAnimationFrame(function(now){
          handleElements(now);
          globalAnimationStep();
        });
      }
      
      globalAnimationStep(); // first call
      
      function handleElements(now){
        now = +new Date();

        var eles = cy._private.aniEles;
        var doneEles = [];

        function handleElement( ele, isCore ){
          var current = ele._private.animation.current;
          var queue = ele._private.animation.queue;
          var ranAnis = false;
          
          // if nothing currently animating, get something from the queue
          if( current.length === 0 ){
            var next = queue.length > 0 ? queue.shift() : null;
            
            if( next ){
              next.callTime = now; // was queued, so update call time
              current.push( next );
            }
          }
          
          // step and remove if done
          var completes = [];
          for(var i = current.length - 1; i >= 0; i--){
            var ani = current[i];

            // start if need be
            if( !ani.started ){ startAnimation( ele, ani ); }
            
            step( ele, ani, now, isCore );

            if( ani.done ){
              completes.push( ani );
              
              // remove current[i]
              current.splice(i, 1);
            }

            ranAnis = true;
          }
          
          // call complete callbacks
          for( var i = 0; i < completes.length; i++ ){
            var ani = completes[i];
            var complete = ani.params.complete;

            if( $$.is.fn(complete) ){
              complete.apply( ele, [ now ] );
            }
          }

          if( !isCore && current.length === 0 && queue.length === 0 ){
            doneEles.push( ele );
          }

          return ranAnis;
        } // handleElements

        // handle all eles
        for( var e = 0; e < eles.length; e++ ){
          var ele = eles[e];
          
          handleElement( ele );
        } // each element

        var ranCoreAni = handleElement( cy, true );
        
        // notify renderer
        if( eles.length > 0 || ranCoreAni ){
          var toNotify;

          if( eles.length > 0 ){
            var updatedEles = eles.updateCompoundBounds();
            toNotify = updatedEles.length > 0 ? eles.add( updatedEles ) : eles;
          }

          cy.notify({
            type: 'draw',
            collection: toNotify
          });
        }

        // remove elements from list of currently animating if its queues are empty
        eles.unmerge( doneEles );

      } // handleElements
      
      function startAnimation( self, ani ){
        var isCore = $$.is.core( self );
        var isEles = !isCore;
        var ele = self;
        var style = cy._private.style;

        if( isEles ){
          var pos = ele._private.position;
          var startPosition = {
            x: pos.x,
            y: pos.y
          };
          var startStyle = style.getValueStyle( ele );
        }

        if( isCore ){
          var pan = cy._private.pan;
          var startPan = {
            x: pan.x,
            y: pan.y
          };

          var startZoom = cy._private.zoom;
        }

        ani.started = true;
        ani.startTime = Date.now();
        ani.startPosition = startPosition;
        ani.startStyle = startStyle;
        ani.startPan = startPan;
        ani.startZoom = startZoom;
      }

      function step( self, animation, now, isCore ){
        var style = cy._private.style;
        var properties = animation.properties;
        var params = animation.params;
        var startTime = animation.startTime;
        var percent;
        var isEles = !isCore;
        
        if( animation.duration === 0 ){
          percent = 1;
        } else {
          percent = Math.min(1, (now - startTime)/animation.duration);
        }

        if( percent < 0 ){
          percent = 0;
        } else if( percent > 1 ){
          percent = 1;
        }
        
        if( properties.delay == null ){ // then update

          var startPos = animation.startPosition;
          var endPos = properties.position;
          var pos = self._private.position;
          if( endPos && isEles ){
            if( valid( startPos.x, endPos.x ) ){
              pos.x = ease( startPos.x, endPos.x, percent );
            }

            if( valid( startPos.y, endPos.y ) ){
              pos.y = ease( startPos.y, endPos.y, percent );
            }
          }

          var startPan = animation.startPan;
          var endPan = properties.pan;
          var pan = self._private.pan;
          var animatingPan = endPan != null && isCore;
          if( animatingPan ){
            if( valid( startPan.x, endPan.x ) ){
              pan.x = ease( startPan.x, endPan.x, percent );
            }

            if( valid( startPan.y, endPan.y ) ){
              pan.y = ease( startPan.y, endPan.y, percent );
            }

            self.trigger('pan');
          }

          var startZoom = animation.startZoom;
          var endZoom = properties.zoom;
          var animatingZoom = endZoom != null && isCore;
          if( animatingZoom ){
            if( valid( startZoom, endZoom ) ){
              self._private.zoom = ease( startZoom, endZoom, percent );
            }

            self.trigger('zoom');
          }

          if( animatingPan || animatingZoom ){
            self.trigger('viewport');
          }

          var props = properties.style || properties.css;
          if( props && isEles ){

            for( var i = 0; i < props.length; i++ ){
              var name = props[i].name;
              var prop = props[i];
              var end = prop;

              var start = animation.startStyle[ name ];
              var easedVal = ease( start, end, percent );
              
              style.overrideBypass( self, name, easedVal );
            } // for props
            
          } // if 

        }
        
        if( $$.is.fn(params.step) ){
          params.step.apply( self, [ now ] );
        }
        
        if( percent >= 1 ){
          animation.done = true;
        }
        
        return percent;
      }
      
      function valid(start, end){
        if( start == null || end == null ){
          return false;
        }
        
        if( $$.is.number(start) && $$.is.number(end) ){
          return true;
        } else if( (start) && (end) ){
          return true;
        }
        
        return false;
      }
      
      function ease(startProp, endProp, percent){
        if( percent < 0 ){
          percent = 0;
        } else if( percent > 1 ){
          percent = 1;
        }

        var start, end;

        if( startProp.pxValue != null || startProp.value != null ){
          start = startProp.pxValue != null ? startProp.pxValue : startProp.value;
        } else {
          start = startProp;
        }

        if( endProp.pxValue != null || endProp.value != null ){
          end = endProp.pxValue != null ? endProp.pxValue : endProp.value;
        } else {
          end = endProp;
        }

        if( $$.is.number(start) && $$.is.number(end) ){
          return start + (end - start) * percent;

        } else if( $$.is.number(start[0]) && $$.is.number(end[0]) ){ // then assume a colour
          var c1 = start;
          var c2 = end;

          var ch = function(ch1, ch2){
            var diff = ch2 - ch1;
            var min = ch1;
            return Math.round( percent * diff + min );
          };
          
          var r = ch( c1[0], c2[0] );
          var g = ch( c1[1], c2[1] );
          var b = ch( c1[2], c2[2] );
          
          return [r, g, b];
        }
        
        return undefined;
      }
      
    }
    
  });
  
})( cytoscape, typeof window === 'undefined' ? null : window );


  
    
;(function($$){ 'use strict';
  
  $$.fn.core({
    data: $$.define.data({
      field: 'data',
      bindingEvent: 'data',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'data',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true
    }),

    removeData: $$.define.removeData({
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: true
    }),

    scratch: $$.define.data({
      field: 'scratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeScratch: $$.define.removeData({
      field: 'scratch',
      triggerEvent: false
    })
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.core({
    on: $$.define.on(), // .on( events [, selector] [, data], handler)
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    once: $$.define.on({ unbindAllBindersOnTrigger: true }),
    off: $$.define.off(), // .off( events [, selector] [, handler] )
    trigger: $$.define.trigger() // .trigger( events [, extraParams] )
  });

  $$.define.eventAliasesOn( $$.corefn );

})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    png: function( options ){
      var renderer = this._private.renderer;
      options = options || {};

      return renderer.png( options );      
    },
    
    jpg: function( options ){
      var renderer = this._private.renderer;
      options = options || {};
      
      options.bg = options.bg || '#fff';

      return renderer.jpg( options );      
    }
    
  });
  
  $$.corefn.jpeg = $$.corefn.jpg;
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    layout: function( params ){
      var layout;

      // always use a new layout w/ init opts; slightly different backwards compatibility
      // but fixes layout reuse issues like dagre #819 
      if( params == null ){ 
        params = $$.util.extend({}, this._private.options.layout);
        params.eles = this.$();
      }

      layout = this.initLayout( params );
      layout.run();

      return this; // chaining
    },

    makeLayout: function( params ){
      return this.initLayout( params );
    },
    
    initLayout: function( options ){
      if( options == null ){
        $$.util.error('Layout options must be specified to make a layout');
        return;
      }
      
      if( options.name == null ){
        $$.util.error('A `name` must be specified to make a layout');
        return;
      }
      
      var name = options.name;
      var LayoutProto = $$.extension('layout', name);
      
      if( LayoutProto == null ){
        $$.util.error('Can not apply layout: No such layout `' + name + '` found; did you include its JS file?');
        return;
      }

      options.eles = options.eles != null ? options.eles : this.$();

      if( $$.is.string( options.eles ) ){
        options.eles = this.$( options.eles );
      }
      
      var layout = new LayoutProto( $$.util.extend({}, options, {
        cy: this
      }) );

      // make sure layout has _private for use w/ std apis like .on()
      if( !$$.is.plainObject(layout._private) ){
        layout._private = {};
      }

      layout._private.cy = this;
      layout._private.listeners = [];
      
      return layout;
    }
    
  });

  $$.corefn.createLayout = $$.corefn.makeLayout;
  
})( cytoscape );
(function($$){ 'use strict';
  
  $$.fn.core({
    notify: function( params ){
      if( this._private.batchingNotify ){
        var bEles = this._private.batchNotifyEles;
        var bTypes = this._private.batchNotifyTypes;

        if( params.collection ){ for( var i = 0; i < params.collection.length; i++ ){
          var ele = params.collection[i];

          if( !bEles.ids[ ele._private.id ] ){
            bEles.push( ele );
          }
        } }

        if( !bTypes.ids[ params.type ] ){
          bTypes.push( params.type );
        }

        return; // notifications are disabled during batching
      }

      if( !this._private.notificationsEnabled ){ return; } // exit on disabled

      var renderer = this.renderer();
      
      renderer.notify(params);
    },
    
    notifications: function( bool ){
      var p = this._private;
      
      if( bool === undefined ){
        return p.notificationsEnabled;
      } else {
        p.notificationsEnabled = bool ? true : false;
      }
    },
    
    noNotifications: function( callback ){
      this.notifications(false);
      callback();
      this.notifications(true);
    },

    startBatch: function(){
      var _p = this._private;

      _p.batchingStyle = _p.batchingNotify = true;
      _p.batchStyleEles = [];
      _p.batchNotifyEles = [];
      _p.batchNotifyTypes = [];

      _p.batchStyleEles.ids = {};
      _p.batchNotifyEles.ids = {};
      _p.batchNotifyTypes.ids = {};

      return this;
    },

    endBatch: function(){
      var _p = this._private;

      // update style for dirty eles
      _p.batchingStyle = false;
      new $$.Collection(this, _p.batchStyleEles).updateStyle();

      // notify the renderer of queued eles and event types
      _p.batchingNotify = false;
      this.notify({
        type: _p.batchNotifyTypes,
        collection: _p.batchNotifyEles
      });

      return this;
    },

    batch: function( callback ){
      this.startBatch();
      callback();
      this.endBatch();

      return this;
    },

    // for backwards compatibility
    batchData: function( map ){
      var cy = this;

      return this.batch(function(){
        for( var id in map ){
          var data = map[id];
          var ele = cy.getElementById( id );
          
          ele.data( data );
        }
      });
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    renderTo: function( context, zoom, pan, pxRatio ){
      var r = this._private.renderer;

      r.renderTo( context, zoom, pan, pxRatio );
      return this;
    },

    renderer: function(){
      return this._private.renderer;
    },

    forceRender: function(){
      this.notify({
        type: 'draw'
      });

      return this;
    },

    resize: function(){
      this.notify({
        type: 'resize'
      });

      this.trigger('resize');

      return this;
    },
    
    initRenderer: function( options ){
      var cy = this;

      var RendererProto = $$.extension('renderer', options.name);
      if( RendererProto == null ){
        $$.util.error('Can not initialise: No such renderer `%s` found; did you include its JS file?', options.name);
        return;
      }
      
      this._private.renderer = new RendererProto(
        $$.util.extend({}, options, {
          cy: cy,
          style: cy._private.style
        })
      );
       
    },

    triggerOnRender: function(){
      var cbs = this._private.onRenders;

      for( var i = 0; i < cbs.length; i++ ){
        var cb = cbs[i];

        cb();
      }

      return this;
    },

    onRender: function( cb ){
      this._private.onRenders.push( cb );

      return this;
    },

    offRender: function( fn ){
      var cbs = this._private.onRenders;

      if( fn == null ){ // unbind all
        this._private.onRenders = [];
        return this;
      }

      for( var i = 0; i < cbs.length; i++ ){ // unbind specified
        var cb = cbs[i];

        if( fn === cb ){
          cbs.splice( i, 1 );
          break;
        }
      }

      return this;
    }
    
  });  
  
})( cytoscape );
;(function($$){ 'use strict';
  
  $$.fn.core({

    // get a collection
    // - empty collection on no args
    // - collection of elements in the graph on selector arg
    // - guarantee a returned collection when elements or collection specified
    collection: function( eles ){

      if( $$.is.string( eles ) ){
        return this.$( eles );

      } else if( $$.is.elementOrCollection( eles ) ){
        return eles.collection();

      } else if( $$.is.array( eles ) ){
        return new $$.Collection( this, eles );
      }

      return new $$.Collection( this );
    },
    
    nodes: function( selector ){
      var nodes = this.$(function(){
        return this.isNode();
      });

      if( selector ){
        return nodes.filter( selector );
      } 

      return nodes;
    },
    
    edges: function( selector ){
      var edges = this.$(function(){
        return this.isEdge();
      });

      if( selector ){
        return edges.filter( selector );
      }

      return edges;
    },
      
    // search the graph like jQuery
    $: function( selector ){
      var eles = new $$.Collection( this, this._private.elements );

      if( selector ){
        return eles.filter( selector );
      }

      return eles;
    }
    
  });  

  // aliases
  $$.corefn.elements = $$.corefn.filter = $$.corefn.$;  
  
})( cytoscape );

;(function($$){ 'use strict';
  
  $$.fn.core({
    
    style: function( newStyle ){
      if( newStyle ){
        var s = this.setStyle( newStyle );

        s.update();
      }

      return this._private.style;
    },

    setStyle: function( style ){
      var _p = this._private;

      if( $$.is.stylesheet(style) ){
        _p.style = style.generateStyle(this);
      
      } else if( $$.is.array(style) ) {
        _p.style = $$.style.fromJson(this, style);
      
      } else if( $$.is.string(style) ){
        _p.style = $$.style.fromString(this, style);
      
      } else {
        _p.style = new $$.Style( this );
      }

      return _p.style;
    }
  });
  
})( cytoscape );


;(function($$){ 'use strict';
  
  $$.fn.core({

    autolock: function(bool){
      if( bool !== undefined ){
        this._private.autolock = bool ? true : false;
      } else {
        return this._private.autolock;
      }
      
      return this; // chaining
    },

    autoungrabify: function(bool){
      if( bool !== undefined ){
        this._private.autoungrabify = bool ? true : false;
      } else {
        return this._private.autoungrabify;
      }
      
      return this; // chaining
    },

    autounselectify: function(bool){
      if( bool !== undefined ){
        this._private.autounselectify = bool ? true : false;
      } else {
        return this._private.autounselectify;
      }
      
      return this; // chaining
    },

    panningEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.panningEnabled = bool ? true : false;
      } else {
        return this._private.panningEnabled;
      }
      
      return this; // chaining
    },

    userPanningEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.userPanningEnabled = bool ? true : false;
      } else {
        return this._private.userPanningEnabled;
      }
      
      return this; // chaining
    },
    
    zoomingEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.zoomingEnabled = bool ? true : false;
      } else {
        return this._private.zoomingEnabled;
      }
      
      return this; // chaining
    },

    userZoomingEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.userZoomingEnabled = bool ? true : false;
      } else {
        return this._private.userZoomingEnabled;
      }
      
      return this; // chaining
    },

    boxSelectionEnabled: function( bool ){
      if( bool !== undefined ){
        this._private.boxSelectionEnabled = bool ? true : false;
      } else {
        return this._private.boxSelectionEnabled;
      }
      
      return this; // chaining
    },
    
    pan: function(){
      var args = arguments;
      var pan = this._private.pan;
      var dim, val, dims, x, y;

      switch( args.length ){
      case 0: // .pan()
        return pan;

      case 1: 

        if( $$.is.string( args[0] ) ){ // .pan('x')
          dim = args[0];
          return pan[ dim ];

        } else if( $$.is.plainObject( args[0] ) ) { // .pan({ x: 0, y: 100 })
          if( !this._private.panningEnabled ){
            return this;
          }

          dims = args[0];
          x = dims.x;
          y = dims.y;

          if( $$.is.number(x) ){
            pan.x = x;
          }

          if( $$.is.number(y) ){
            pan.y = y;
          }

          this.trigger('pan viewport');
        }
        break;

      case 2: // .pan('x', 100)
        if( !this._private.panningEnabled ){
          return this;
        }

        dim = args[0];
        val = args[1];

        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){
          pan[dim] = val;
        }

        this.trigger('pan viewport');
        break;

      default:
        break; // invalid
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },
    
    panBy: function(params){
      var args = arguments;
      var pan = this._private.pan;
      var dim, val, dims, x, y;

      if( !this._private.panningEnabled ){
        return this;
      }

      switch( args.length ){
      case 1: 

        if( $$.is.plainObject( args[0] ) ) { // .panBy({ x: 0, y: 100 })
          dims = args[0];
          x = dims.x;
          y = dims.y;

          if( $$.is.number(x) ){
            pan.x += x;
          }

          if( $$.is.number(y) ){
            pan.y += y;
          }

          this.trigger('pan viewport');
        }
        break;

      case 2: // .panBy('x', 100)
        dim = args[0];
        val = args[1];

        if( (dim === 'x' || dim === 'y') && $$.is.number(val) ){
          pan[dim] += val;
        }

        this.trigger('pan viewport');
        break;

      default:
        break; // invalid
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },
    
    fit: function( elements, padding ){
      var viewportState = this.getFitViewport( elements, padding );

      if( viewportState ){
        var _p = this._private;
        _p.zoom = viewportState.zoom;
        _p.pan = viewportState.pan;

        this.trigger('pan zoom viewport');

        this.notify({ // notify the renderer that the viewport changed
          type: 'viewport'
        });
      }

      return this; // chaining
    },

    getFitViewport: function( elements, padding ){
      if( $$.is.number(elements) && padding === undefined ){ // elements is optional
        padding = elements;
        elements = undefined;
      }

      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
        return;
      }

      var bb;

      if( $$.is.string(elements) ){
        var sel = elements;
        elements = this.$( sel );

      } else if( $$.is.boundingBox(elements) ){ // assume bb
        var bbe = elements;
        bb = {
          x1: bbe.x1,
          y1: bbe.y1,
          x2: bbe.x2,
          y2: bbe.y2
        };

        bb.w = bb.x2 - bb.x1;
        bb.h = bb.y2 - bb.y1;

      } else if( !$$.is.elementOrCollection(elements) ){
        elements = this.elements();
      }

      bb = bb || elements.boundingBox();

      var w = this.width();
      var h = this.height();
      var zoom;
      padding = $$.is.number(padding) ? padding : 0;

      if( !isNaN(w) && !isNaN(h) && w > 0 && h > 0 && !isNaN(bb.w) && !isNaN(bb.h) &&  bb.w > 0 && bb.h > 0 ){
        zoom = Math.min( (w - 2*padding)/bb.w, (h - 2*padding)/bb.h );

        // crop zoom
        zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
        zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

        var pan = { // now pan to middle
          x: (w - zoom*( bb.x1 + bb.x2 ))/2,
          y: (h - zoom*( bb.y1 + bb.y2 ))/2
        };

        return {
          zoom: zoom, 
          pan: pan
        };
      }

      return;
    },
    
    minZoom: function( zoom ){
      if( zoom === undefined ){
        return this._private.minZoom;
      } else if( $$.is.number(zoom) ){
        this._private.minZoom = zoom;
      }

      return this;
    },

    maxZoom: function( zoom ){
      if( zoom === undefined ){
        return this._private.maxZoom;
      } else if( $$.is.number(zoom) ){
        this._private.maxZoom = zoom;
      }

      return this;
    },

    zoom: function( params ){
      var pos; // in rendered px
      var zoom;

      if( params === undefined ){ // then get the zoom
        return this._private.zoom;

      } else if( $$.is.number(params) ){ // then set the zoom
        zoom = params;

      } else if( $$.is.plainObject(params) ){ // then zoom about a point
        zoom = params.level;

        if( params.position ){
          var p = params.position;
          var pan = this._private.pan;
          var z = this._private.zoom;

          pos = { // convert to rendered px
            x: p.x * z + pan.x,
            y: p.y * z + pan.y
          };
        } else if( params.renderedPosition ){
          pos = params.renderedPosition;
        }

        if( pos && !this._private.panningEnabled ){
          return this; // panning disabled
        }
      }

      if( !this._private.zoomingEnabled ){
        return this; // zooming disabled
      }

      if( !$$.is.number(zoom) || ( pos && (!$$.is.number(pos.x) || !$$.is.number(pos.y)) ) ){
        return this; // can't zoom with invalid params
      }

      // crop zoom
      zoom = zoom > this._private.maxZoom ? this._private.maxZoom : zoom;
      zoom = zoom < this._private.minZoom ? this._private.minZoom : zoom;

      if( pos ){ // set zoom about position
        var pan1 = this._private.pan;
        var zoom1 = this._private.zoom;
        var zoom2 = zoom;
        
        var pan2 = {
          x: -zoom2/zoom1 * (pos.x - pan1.x) + pos.x,
          y: -zoom2/zoom1 * (pos.y - pan1.y) + pos.y
        };

        this._private.zoom = zoom;
        this._private.pan = pan2;

        var posChanged = pan1.x !== pan2.x || pan1.y !== pan2.y;
        this.trigger(' zoom ' + (posChanged ? ' pan ' : '') + ' viewport ' );
      
      } else { // just set the zoom
        this._private.zoom = zoom;
        this.trigger('zoom viewport');
      }

      this.notify({ // notify the renderer that the viewport changed
        type: 'viewport'
      });

      return this; // chaining
    },

    viewport: function( opts ){ 
      var _p = this._private;
      var zoomDefd = true;
      var panDefd = true;
      var events = []; // to trigger
      var zoomFailed = false;
      var panFailed = false;

      if( !opts ){ return this; }
      if( !$$.is.number(opts.zoom) ){ zoomDefd = false; }
      if( !$$.is.plainObject(opts.pan) ){ panDefd = false; }
      if( !zoomDefd && !panDefd ){ return this; }

      if( zoomDefd ){
        var z = opts.zoom;

        if( z < _p.minZoom || z > _p.maxZoom || !_p.zoomingEnabled ){
          zoomFailed = true;

        } else {
          _p.zoom = z;

          events.push('zoom');
        }
      }

      if( panDefd && (!zoomFailed || !opts.cancelOnFailedZoom) && _p.panningEnabled ){
        var p = opts.pan;

        if( $$.is.number(p.x) ){
          _p.pan.x = p.x;
          panFailed = false;
        }

        if( $$.is.number(p.y) ){
          _p.pan.y = p.y;
          panFailed = false;
        }

        if( !panFailed ){
          events.push('pan');
        }
      }

      if( events.length > 0 ){
        events.push('viewport');
        this.trigger( events.join(' ') );

        this.notify({
          type: 'viewport'
        });
      }

      return this; // chaining
    },
    
    center: function( elements ){
      var pan = this.getCenterPan( elements );

      if( pan ){
        this._private.pan = pan;

        this.trigger('pan viewport');

        this.notify({ // notify the renderer that the viewport changed
          type: 'viewport'
        });
      }

      return this; // chaining
    },

    getCenterPan: function( elements, zoom ){
      if( !this._private.panningEnabled ){
        return;
      }

      if( $$.is.string(elements) ){
        var selector = elements;
        elements = this.elements( selector );
      } else if( !$$.is.elementOrCollection(elements) ){
        elements = this.elements();
      }

      var bb = elements.boundingBox();
      var w = this.width();
      var h = this.height();
      zoom = zoom === undefined ? this._private.zoom : zoom;

      var pan = { // middle
        x: (w - zoom*( bb.x1 + bb.x2 ))/2,
        y: (h - zoom*( bb.y1 + bb.y2 ))/2
      };
      
      return pan;
    },
    
    reset: function(){
      if( !this._private.panningEnabled || !this._private.zoomingEnabled ){
        return this;
      }

      this.viewport({
        pan: { x: 0, y: 0 },
        zoom: 1
      });
      
      return this; // chaining
    },

    width: function(){
      var container = this._private.container;

      if( container ){
        return container.clientWidth;
      }

      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
    },

    height: function(){
      var container = this._private.container;

      if( container ){
        return container.clientHeight;
      }

      return 1; // fallback if no container (not 0 b/c can be used for dividing etc)
    },

    extent: function(){
      var pan = this._private.pan;
      var zoom = this._private.zoom;
      var rb = this.renderedExtent();

      var b = {
        x1: ( rb.x1 - pan.x )/zoom,
        x2: ( rb.x2 - pan.x )/zoom,
        y1: ( rb.y1 - pan.y )/zoom,
        y2: ( rb.y2 - pan.y )/zoom,
      };

      b.w = b.x2 - b.x1;
      b.h = b.y2 - b.y1;

      return b;
    },

    renderedExtent: function(){
      var width = this.width();
      var height = this.height();

      return {
        x1: 0,
        y1: 0,
        x2: width,
        y2: height,
        w: width,
        h: height
      };
    }
  });

  // aliases
  $$.corefn.centre = $$.corefn.center;

  // backwards compatibility
  $$.corefn.autolockNodes = $$.corefn.autolock;
  $$.corefn.autoungrabifyNodes = $$.corefn.autoungrabify;

})( cytoscape );

;(function($$){ 'use strict';
  
  // Use this interface to define functions for collections/elements.
  // This interface is good, because it forces you to think in terms
  // of the collections case (more than 1 element), so we don't need
  // notification blocking nonsense everywhere.
  //
  // Other collection-*.js files depend on this being defined first.
  // It's a trade off: It simplifies the code for Collection and 
  // Element integration so much that it's worth it to create the
  // JS dependency.
  //
  // Having this integration guarantees that we can call any
  // collection function on an element and vice versa.

  // e.g. $$.fn.collection({ someFunc: function(){ /* ... */ } })
  $$.fn.collection = $$.fn.eles = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];

      $$.Collection.prototype[ name ] = fn;
    }
  };
  
  // factory for generating edge ids when no id is specified for a new element
  var idFactory = {
    prefix: {
      nodes: 'n',
      edges: 'e'
    },
    id: {
      nodes: 0,
      edges: 0
    },
    generate: function(cy, element, tryThisId){
      var json = $$.is.element( element ) ? element._private : element;
      var group = json.group;
      var id = tryThisId != null ? tryThisId : this.prefix[group] + this.id[group];
      
      if( cy.getElementById(id).empty() ){
        this.id[group]++; // we've used the current id, so move it up
      } else { // otherwise keep trying successive unused ids
        while( !cy.getElementById(id).empty() ){
          id = this.prefix[group] + ( ++this.id[group] );
        }
      }
      
      return id;
    }
  };
  
  // Element
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // represents a node or an edge
  $$.Element = function(cy, params, restore){
    if( !(this instanceof $$.Element) ){
      return new $$.Element(cy, params, restore);
    }

    var self = this;
    restore = (restore === undefined || restore ? true : false);
    
    if( cy === undefined || params === undefined || !$$.is.core(cy) ){
      $$.util.error('An element must have a core reference and parameters set');
      return;
    }
    
    // validate group
    if( params.group !== 'nodes' && params.group !== 'edges' ){
      $$.util.error('An element must be of type `nodes` or `edges`; you specified `' + params.group + '`');
      return;
    }
    
    // make the element array-like, just like a collection
    this.length = 1;
    this[0] = this;
    
    // NOTE: when something is added here, add also to ele.json()
    this._private = {
      cy: cy,
      single: true, // indicates this is an element
      data: params.data || {}, // data object
      position: params.position || {}, // (x, y) position pair
      autoWidth: undefined, // width and height of nodes calculated by the renderer when set to special 'auto' value
      autoHeight: undefined, 
      listeners: [], // array of bound listeners
      group: params.group, // string; 'nodes' or 'edges'
      style: {}, // properties as set by the style
      rstyle: {}, // properties for style sent from the renderer to the core
      styleCxts: [], // applied style contexts from the styler
      removed: true, // whether it's inside the vis; true if removed (set true here since we call restore)
      selected: params.selected ? true : false, // whether it's selected
      selectable: params.selectable === undefined ? true : ( params.selectable ? true : false ), // whether it's selectable
      locked: params.locked ? true : false, // whether the element is locked (cannot be moved)
      grabbed: false, // whether the element is grabbed by the mouse; renderer sets this privately
      grabbable: params.grabbable === undefined ? true : ( params.grabbable ? true : false ), // whether the element can be grabbed
      active: false, // whether the element is active from user interaction
      classes: {}, // map ( className => true )
      animation: { // object for currently-running animations
        current: [],
        queue: []
      },
      rscratch: {}, // object in which the renderer can store information
      scratch: params.scratch || {}, // scratch objects
      edges: [], // array of connected edges
      children: [] // array of children
    };
    
    // renderedPosition overrides if specified
    if( params.renderedPosition ){
      var rpos = params.renderedPosition;
      var pan = cy.pan();
      var zoom = cy.zoom();

      this._private.position = {
        x: (rpos.x - pan.x)/zoom,
        y: (rpos.y - pan.y)/zoom
      };
    }
    
    if( $$.is.string(params.classes) ){
      var classes = params.classes.split(/\s+/);
      for( var i = 0, l = classes.length; i < l; i++ ){
        var cls = classes[i];
        if( !cls || cls === '' ){ continue; }

        self._private.classes[cls] = true;
      }
    }

    if( params.css ){
      cy.style().applyBypass( this, params.css );
    }
    
    if( restore === undefined || restore ){
      this.restore();
    }
    
  };

  
  // Collection
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // represents a set of nodes, edges, or both together
  $$.Collection = function(cy, elements, options){
    if( !(this instanceof $$.Collection) ){
      return new $$.Collection(cy, elements);
    }

    if( cy === undefined || !$$.is.core(cy) ){
      $$.util.error('A collection must have a reference to the core');
      return;
    }
    
    var ids = {};
    var indexes = {};
    var createdElements = false;
    
    if( !elements ){
      elements = [];
    } else if( elements.length > 0 && $$.is.plainObject( elements[0] ) && !$$.is.element( elements[0] ) ){
      createdElements = true;

      // make elements from json and restore all at once later
      var eles = [];
      var elesIds = {};

      for( var i = 0, l = elements.length; i < l; i++ ){
        var json = elements[i];

        if( json.data == null ){
          json.data = {};
        }
        
        var data = json.data;

        // make sure newly created elements have valid ids
        if( data.id == null ){
          data.id = idFactory.generate( cy, json );
        } else if( cy.getElementById( data.id ).length !== 0 || elesIds[ data.id ] ){
          continue; // can't create element if prior id already exists
        }

        var ele = new $$.Element( cy, json, false );
        eles.push( ele );
        elesIds[ data.id ] = true;
      }

      elements = eles;
    }
    
    this.length = 0;

    for( var i = 0, l = elements.length; i < l; i++ ){
      var element = elements[i];
      if( !element ){  continue; }
      
      var id = element._private.data.id;
      
      if( !options || (options.unique && !ids[ id ] ) ){
        ids[ id ] = element;
        indexes[ id ] = this.length;

        this[ this.length ] = element;
        this.length++;
      }
    }
    
    this._private = {
      cy: cy,
      ids: ids,
      indexes: indexes
    };

    // restore the elements if we created them from json
    if( createdElements ){
      this.restore();
    }
  };
  
  
  // Functions
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  // keep the prototypes in sync (an element has the same functions as a collection)
  // and use $$.elefn and $$.elesfn as shorthands to the prototypes
  $$.elefn = $$.elesfn = $$.Element.prototype = $$.Collection.prototype;

  $$.elesfn.cy = function(){
    return this._private.cy;
  };
  
  $$.elesfn.element = function(){
    return this[0];
  };
  
  $$.elesfn.collection = function(){
    if( $$.is.collection(this) ){
      return this;
    } else { // an element
      return new $$.Collection( this._private.cy, [this] );
    }
  };

  $$.elesfn.unique = function(){
    return new $$.Collection( this._private.cy, this, { unique: true } );
  };

  $$.elesfn.getElementById = function( id ){
    var cy = this._private.cy;
    var ele = this._private.ids[ id ];

    return ele ? ele : $$.Collection(cy); // get ele or empty collection
  };

  $$.elesfn.json = function(){
    var ele = this.element();
    if( ele == null ){ return undefined; }

    var p = ele._private;
    
    var json = $$.util.copy({
      data: p.data,
      position: p.position,
      group: p.group,
      bypass: p.bypass,
      removed: p.removed,
      selected: p.selected,
      selectable: p.selectable,
      locked: p.locked,
      grabbed: p.grabbed,
      grabbable: p.grabbable,
      classes: ''
    });
    
    var classes = [];
    for( var cls in p.classes ){
      if( p.classes[cls] ){
        classes.push(cls);
      }
    }
    
    for( var i = 0; i < classes.length; i++ ){
      var cls = classes[i];
      json.classes += cls + ( i < classes.length - 1 ? ' ' : '' );
    }
    
    return json;
  };

  $$.elesfn.jsons = function(){
    var jsons = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var json = ele.json();

      jsons.push( json );
    }

    return jsons;
  };

  $$.elesfn.clone = function(){
    var cy = this.cy();
    var elesArr = [];

    for( var i = 0; i < this.length; i++ ){
      var ele = this[i];
      var json = ele.json();
      var clone = new $$.Element(cy, json, false); // NB no restore

      elesArr.push( clone );
    }

    return new $$.Collection( cy, elesArr );
  };
  $$.elesfn.copy = $$.elesfn.clone;

  $$.elesfn.restore = function( notifyRenderer ){
    var self = this;
    var restored = [];
    var cy = self.cy();
    
    if( notifyRenderer === undefined ){
      notifyRenderer = true;
    }

    // create arrays of nodes and edges, since we need to
    // restore the nodes first
    var elements = [];
    var nodes = [], edges = [];
    var numNodes = 0;
    var numEdges = 0;
    for( var i = 0, l = self.length; i < l; i++ ){
      var ele = self[i];
      
      // keep nodes first in the array and edges after
      if( ele.isNode() ){ // put to front of array if node
        nodes.push( ele );
        numNodes++;
      } else { // put to end of array if edge
        edges.push( ele );
        numEdges++;
      }
    }

    elements = nodes.concat( edges );

    // now, restore each element
    for( var i = 0, l = elements.length; i < l; i++ ){
      var ele = elements[i];

      if( !ele.removed() ){
        // don't need to do anything
        continue;
      }
      
      var _private = ele._private;
      var data = _private.data;
      
      // set id and validate
      if( data.id === undefined ){
        data.id = idFactory.generate( cy, ele );
      } else if( $$.is.emptyString(data.id) || !$$.is.string(data.id) ){
        $$.util.error('Can not create element with invalid string ID `' + data.id + '`');
        
        // can't create element if it has empty string as id or non-string id
        continue;
      } else if( cy.getElementById( data.id ).length !== 0 ){
        $$.util.error('Can not create second element with ID `' + data.id + '`');
        
        // can't create element if one already has that id
        continue;
      }

      var id = data.id; // id is finalised, now let's keep a ref
      
      if( ele.isEdge() ){ // extra checks for edges
        
        var edge = ele;
        var fields = ['source', 'target'];
        var fieldsLength = fields.length;
        var badSourceOrTarget = false;
        for(var j = 0; j < fieldsLength; j++){
          
          var field = fields[j];
          var val = data[field];
          
          if( val == null || val === '' ){
            // can't create if source or target is not defined properly
            $$.util.error('Can not create edge `' + id + '` with unspecified ' + field);
            badSourceOrTarget = true;
          } else if( cy.getElementById(val).empty() ){ 
            // can't create edge if one of its nodes doesn't exist
            $$.util.error('Can not create edge `' + id + '` with nonexistant ' + field + ' `' + val + '`');
            badSourceOrTarget = true;
          }
        }

        if( badSourceOrTarget ){ continue; } // can't create this
        
        var src = cy.getElementById( data.source );
        var tgt = cy.getElementById( data.target );

        src._private.edges.push( edge );
        tgt._private.edges.push( edge );

        edge._private.source = src;
        edge._private.target = tgt;

      } // if is edge
       
      // create mock ids map for element so it can be used like collections
      _private.ids = {};
      _private.ids[ id ] = ele;

      _private.removed = false;
      cy.addToPool( ele );
      
      restored.push( ele );
    } // for each element

    // do compound node sanity checks
    for( var i = 0; i < numNodes; i++ ){ // each node 
      var node = elements[i];
      var data = node._private.data;

      var parentId = node._private.data.parent;
      var specifiedParent = parentId != null;

      if( specifiedParent ){
        var parent = cy.getElementById( parentId );

        if( parent.empty() ){
          // non-existant parent; just remove it
          data.parent = undefined;
        } else {
          var selfAsParent = false;
          var ancestor = parent;
          while( !ancestor.empty() ){
            if( node.same(ancestor) ){
              // mark self as parent and remove from data
              selfAsParent = true;
              data.parent = undefined; // remove parent reference

              // exit or we loop forever
              break;
            }

            ancestor = ancestor.parent();
          }

          if( !selfAsParent ){
            // connect with children
            parent[0]._private.children.push( node );
            node._private.parent = parent[0];

            // let the core know we have a compound graph
            cy._private.hasCompoundNodes = true;
          }
        } // else
      } // if specified parent
    } // for each node
    
    restored = new $$.Collection( cy, restored );
    if( restored.length > 0 ){

      var toUpdateStyle = restored.add( restored.connectedNodes() ).add( restored.parent() );
      toUpdateStyle.updateStyle( notifyRenderer );

      if( notifyRenderer ){
        restored.rtrigger('add');
      } else {
        restored.trigger('add');
      }
    }
    
    return self; // chainability
  };
  
  $$.elesfn.removed = function(){
    var ele = this[0];
    return ele && ele._private.removed;
  };

  $$.elesfn.inside = function(){
    var ele = this[0];
    return ele && !ele._private.removed;
  };

  $$.elesfn.remove = function( notifyRenderer ){
    var self = this;
    var removed = [];
    var elesToRemove = [];
    var elesToRemoveIds = {};
    var cy = self._private.cy;
    
    if( notifyRenderer === undefined ){
      notifyRenderer = true;
    }
    
    // add connected edges
    function addConnectedEdges(node){
      var edges = node._private.edges; 
      for( var i = 0; i < edges.length; i++ ){
        add( edges[i] );
      }
    }
    

    // add descendant nodes
    function addChildren(node){
      var children = node._private.children;
      
      for( var i = 0; i < children.length; i++ ){
        add( children[i] );
      }
    }

    function add( ele ){
      var alreadyAdded =  elesToRemoveIds[ ele.id() ];
      if( alreadyAdded ){
        return;
      } else {
        elesToRemoveIds[ ele.id() ] = true;
      }

      if( ele.isNode() ){
        elesToRemove.push( ele ); // nodes are removed last

        addConnectedEdges( ele );
        addChildren( ele );
      } else {
        elesToRemove.unshift( ele ); // edges are removed first
      }
    }

    // make the list of elements to remove
    // (may be removing more than specified due to connected edges etc)

    for( var i = 0, l = self.length; i < l; i++ ){
      var ele = self[i];

      add( ele );
    }
    
    function removeEdgeRef(node, edge){
      var connectedEdges = node._private.edges;
      for( var j = 0; j < connectedEdges.length; j++ ){
        var connectedEdge = connectedEdges[j];
        
        if( edge === connectedEdge ){
          connectedEdges.splice( j, 1 );
          break;
        }
      }
    }

    function removeChildRef(parent, ele){
      ele = ele[0];
      parent = parent[0];
      var children = parent._private.children;

      for( var j = 0; j < children.length; j++ ){
        if( children[j][0] === ele[0] ){
          children.splice(j, 1);
          break;
        }
      }
    }

    for( var i = 0; i < elesToRemove.length; i++ ){
      var ele = elesToRemove[i];

      // mark as removed
      ele._private.removed = true;

      // remove from core pool
      cy.removeFromPool( ele );

      // add to list of removed elements
      removed.push( ele );

      if( ele.isEdge() ){ // remove references to this edge in its connected nodes
        var src = ele.source()[0];
        var tgt = ele.target()[0];

        removeEdgeRef( src, ele );
        removeEdgeRef( tgt, ele );

      } else { // remove reference to parent 
        var parent = ele.parent();

        if( parent.length !== 0 ){
          removeChildRef(parent, ele);
        }
      }
    }

    // check to see if we have a compound graph or not
    var elesStillInside = cy._private.elements;
    cy._private.hasCompoundNodes = false;
    for( var i = 0; i < elesStillInside.length; i++ ){
      var ele = elesStillInside[i];

      if( ele.isParent() ){
        cy._private.hasCompoundNodes = true;
        break;
      }
    }

    var removedElements = new $$.Collection( this.cy(), removed );
    if( removedElements.size() > 0 ){
      // must manually notify since trigger won't do this automatically once removed
      
      if( notifyRenderer ){
        this.cy().notify({
          type: 'remove',
          collection: removedElements
        });
      }
      
      removedElements.trigger('remove');
    }

    // check for empty remaining parent nodes
    var checkedParentId = {};
    for( var i = 0; i < elesToRemove.length; i++ ){
      var ele = elesToRemove[i];
      var isNode = ele._private.group === 'nodes';
      var parentId = ele._private.data.parent;

      if( isNode && parentId !== undefined && !checkedParentId[ parentId ] ){
        checkedParentId[ parentId ] = true;
        var parent = cy.getElementById( parentId );

        if( parent && parent.length !== 0 && !parent._private.removed && parent.children().length === 0 ){
          parent.updateStyle();
        }
      }
    }

    return this;
  };

  $$.elesfn.move = function( struct ){
    var cy = this._private.cy;

    if( struct.source !== undefined || struct.target !== undefined ){
      var srcId = struct.source;
      var tgtId = struct.target;
      var srcExists = cy.getElementById( srcId ).length > 0;
      var tgtExists = cy.getElementById( tgtId ).length > 0;

      if( srcExists || tgtExists ){
        var jsons = this.jsons();

        this.remove();

        for( var i = 0; i < jsons.length; i++ ){
          var json = jsons[i];

          if( json.group === 'edges' ){
            if( srcExists ){ json.data.source = srcId; }
            if( tgtExists ){ json.data.target = tgtId; }
          }
        }

        return cy.add( jsons );
      }
 
    } else if( struct.parent !== undefined ){ // move node to new parent
      var parentId = struct.parent;
      var parentExists = parentId === null || cy.getElementById( parentId ).length > 0;
    
      if( parentExists ){
        var jsons = this.jsons();
        var descs = this.descendants();
        var descsEtc = descs.merge( descs.add(this).connectedEdges() );

        this.remove(); // NB: also removes descendants and their connected edges

        for( var i = 0; i < this.length; i++ ){
          var json = jsons[i];

          if( json.group === 'nodes' ){
            json.data.parent = parentId === null ? undefined : parentId;
          }
        }
      }

      return cy.add( jsons ).merge( descsEtc.restore() );
    }

    return this; // if nothing done
  };
  
})( cytoscape );


;(function($$){ 'use strict';

  // search, spanning trees, etc
  $$.fn.eles({

    // std functional ele first callback style
    stdBreadthFirstSearch: function( options ){
      options = $$.util.extend( {}, options, {
        std: true
      } );

      return this.breadthFirstSearch( options );
    },

    // do a breadth first search from the nodes in the collection
    // from pseudocode on wikipedia
    breadthFirstSearch: function( roots, fn, directed ){
      var options;
      var std;
      var thisArg;
      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){
        options = roots;
        roots = options.roots;
        fn = options.visit;
        directed = options.directed;
        std = options.std;
        thisArg = options.thisArg;
      }

      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;
      fn = $$.is.fn(fn) ? fn : function(){};
      
      var cy = this._private.cy;
      var v = $$.is.string(roots) ? this.filter(roots) : roots;
      var Q = [];
      var connectedNodes = [];
      var connectedBy = {};
      var id2depth = {};
      var V = {};
      var j = 0;
      var found;
      var nodes = this.nodes();
      var edges = this.edges();

      // enqueue v
      for( var i = 0; i < v.length; i++ ){
        if( v[i].isNode() ){
          Q.unshift( v[i] );
          V[ v[i].id() ] = true; 

          connectedNodes.push( v[i] );
          id2depth[ v[i].id() ] = 0;
        }
      }

      while( Q.length !== 0 ){
        var v = Q.shift();
        var depth = id2depth[ v.id() ];
        var prevEdge = connectedBy[ v.id() ];
        var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
        var ret;

        if( std ){
          ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
        } else {
          ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
        }

        if( ret === true ){
          found = v;
          break;
        }

        if( ret === false ){
          break;
        }

        var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
        for( var i = 0; i < vwEdges.length; i++ ){
          var e = vwEdges[i];
          var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

          if( w.length !== 0 && !V[ w.id() ] ){
            w = w[0];

            Q.push( w );
            V[ w.id() ] = true;

            id2depth[ w.id() ] = id2depth[ v.id() ] + 1;

            connectedNodes.push( w );
            connectedBy[ w.id() ] = e;
          }
        }
        
      }

      var connectedEles = [];

      for( var i = 0; i < connectedNodes.length; i++ ){
        var node = connectedNodes[i];
        var edge = connectedBy[ node.id() ];

        if( edge ){
          connectedEles.push( edge );
        }

        connectedEles.push( node );
      }

      return {
        path: new $$.Collection( cy, connectedEles, { unique: true } ),
        found: new $$.Collection( cy, found, { unique: true } )
      };
    },

    // std functional ele first callback style
    stdDepthFirstSearch: function( options ){
      options = $$.util.extend( {}, options, {
        std: true
      } );

      return this.depthFirstSearch( options );
    },

    // do a depth first search on the nodes in the collection
    // from pseudocode on wikipedia (iterative impl)
    depthFirstSearch: function( roots, fn, directed ){
      var options;
      var std;
      var thisArg;
      if( $$.is.plainObject(roots) && !$$.is.elementOrCollection(roots) ){
        options = roots;
        roots = options.roots;
        fn = options.visit;
        directed = options.directed;
        std = options.std;
        thisArg = options.thisArg;
      }
      
      directed = arguments.length === 2 && !$$.is.fn(fn) ? fn : directed;
      fn = $$.is.fn(fn) ? fn : function(){};
      var cy = this._private.cy;
      var v = $$.is.string(roots) ? this.filter(roots) : roots;
      var S = [];
      var connectedNodes = [];
      var connectedBy = {};
      var id2depth = {};
      var discovered = {};
      var j = 0;
      var found;
      var edges = this.edges();
      var nodes = this.nodes();

      // push v
      for( var i = 0; i < v.length; i++ ){
        if( v[i].isNode() ){
          S.push( v[i] );

          connectedNodes.push( v[i] );
          id2depth[ v[i].id() ] = 0;
        }
      }

      while( S.length !== 0 ){
        var v = S.pop();

        if( !discovered[ v.id() ] ){
          discovered[ v.id() ] = true;

          var depth = id2depth[ v.id() ];
          var prevEdge = connectedBy[ v.id() ];
          var prevNode = prevEdge == null ? undefined : prevEdge.connectedNodes().not( v )[0];
          var ret;

          if( std ){
            ret = fn.call(thisArg, v, prevEdge, prevNode, j++, depth);
          } else {
            ret = fn.call(v, j++, depth, v, prevEdge, prevNode);
          }

          if( ret === true ){
            found = v;
            break;
          }

          if( ret === false ){
            break;
          }

          var vwEdges = v.connectedEdges(directed ? function(){ return this.data('source') === v.id(); } : undefined).intersect( edges );
          
          for( var i = 0; i < vwEdges.length; i++ ){
            var e = vwEdges[i];
            var w = e.connectedNodes(function(){ return this.id() !== v.id(); }).intersect( nodes );

            if( w.length !== 0 && !discovered[ w.id() ] ){
              w = w[0];

              S.push( w );

              id2depth[ w.id() ] = id2depth[ v.id() ] + 1;

              connectedNodes.push( w );
              connectedBy[ w.id() ] = e;
            }
          }
        }
      }

      var connectedEles = [];

      for( var i = 0; i < connectedNodes.length; i++ ){
        var node = connectedNodes[i];
        var edge = connectedBy[ node.id() ];

        if( edge ){
          connectedEles.push( edge );
        }

        connectedEles.push( node );
      }

      return {
        path: new $$.Collection( cy, connectedEles, { unique: true } ),
        found: new $$.Collection( cy, found, { unique: true } )
      };
    },

    // kruskal's algorithm (finds min spanning tree, assuming undirected graph)
    // implemented from pseudocode from wikipedia
    kruskal: function( weightFn ){
      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

      function findSet(ele){
        for( var i = 0; i < forest.length; i++ ){
          var eles = forest[i];

          if( eles.anySame(ele) ){
            return {
              eles: eles,
              index: i
            };
          }
        }
      }

      var A = new $$.Collection(this._private.cy, []);
      var forest = [];
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        forest.push( nodes[i].collection() );
      }

      var edges = this.edges();
      var S = edges.toArray().sort(function(a, b){
        var weightA = weightFn.call(a, a);
        var weightB = weightFn.call(b, b);

        return weightA - weightB;
      });

      for(var i = 0; i < S.length; i++){
        var edge = S[i];
        var u = edge.source()[0];
        var v = edge.target()[0];
        var setU = findSet(u);
        var setV = findSet(v);

        if( setU.index !== setV.index ){
          A = A.add( edge );

          // combine forests for u and v
          forest[ setU.index ] = setU.eles.add( setV.eles );
          forest.splice( setV.index, 1 );
        }
      }

      return nodes.add( A );

    },

    dijkstra: function( root, weightFn, directed ){
      var options;
      if( $$.is.plainObject(root) && !$$.is.elementOrCollection(root) ){
        options = root;
        root = options.root;
        weightFn = options.weight;
        directed = options.directed;
      }

      var cy = this._private.cy;
      weightFn = $$.is.fn(weightFn) ? weightFn : function(){ return 1; }; // if not specified, assume each edge has equal weight (1)

      var source = $$.is.string(root) ? this.filter(root)[0] : root[0];
      var dist = {};
      var prev = {};
      var knownDist = {};

      var edges = this.edges().filter(function(){ return !this.isLoop(); });
      var nodes = this.nodes();
      var Q = [];

      for( var i = 0; i < nodes.length; i++ ){
        dist[ nodes[i].id() ] = nodes[i].same( source ) ? 0 : Infinity;
        Q.push( nodes[i] );
      }

      var valueFn = function(node) {
        return dist[ node.id() ];
      };
      
      Q = new $$.Collection(cy, Q);
    
      var heap = $$.Minheap(cy, Q, valueFn);
    
      var distBetween = function(u, v){
        var uvs = ( directed ? u.edgesTo(v) : u.edgesWith(v) ).intersect(edges);
        var smallestDistance = Infinity;
        var smallestEdge;

        for( var i = 0; i < uvs.length; i++ ){
          var edge = uvs[i];
          var weight = weightFn.apply( edge, [edge] );

          if( weight < smallestDistance || !smallestEdge ){
            smallestDistance = weight;
            smallestEdge = edge;
          }
        }

        return {
          edge: smallestEdge,
          dist: smallestDistance
        };
      };

      while(heap.size() > 0){
        var smallestEl = heap.pop(),
        smalletsDist = smallestEl.value,
        uid = smallestEl.id,
        u = cy.getElementById(uid);
    
        knownDist[uid] = smalletsDist;
      
        if( smalletsDist === Math.Infinite ){
          break;
        }

        var neighbors = u.neighborhood().intersect(nodes);
        for( var i = 0; i < neighbors.length; i++ ){
          var v = neighbors[i];
          var vid = v.id();
          var vDist = distBetween(u, v);

          var alt = smalletsDist + vDist.dist;

          if( alt < heap.getValueById(vid) ){
            heap.edit(vid, alt);
            prev[ vid ] = {
              node: u,
              edge: vDist.edge
            };
          }
        } // for 
      } // while

      return {
        distanceTo: function(node){
          var target = $$.is.string(node) ? nodes.filter(node)[0] : node[0];

          return knownDist[ target.id() ];
        },

        pathTo: function(node){
          var target = $$.is.string(node) ? nodes.filter(node)[0] : node[0];
          var S = [];
          var u = target;

          if( target.length > 0 ){
            S.unshift( target );

            while( prev[ u.id() ] ){
              var p = prev[ u.id() ];

              S.unshift( p.edge );
              S.unshift( p.node );

              u = p.node;
            }
          }

          return new $$.Collection( cy, S );
        }
      };
    }  
  });

  // nice, short mathemathical alias
  $$.elesfn.bfs = $$.elesfn.breadthFirstSearch;
  $$.elesfn.dfs = $$.elesfn.depthFirstSearch;
  $$.elesfn.stdBfs = $$.elesfn.stdBreadthFirstSearch;
  $$.elesfn.stdDfs = $$.elesfn.stdDepthFirstSearch;
  
})( cytoscape );

;(function($$) { 
  'use strict';

  // Additional graph analysis algorithms
  $$.fn.eles({

    // Implemented from pseudocode from wikipedia

    // options => options object
    //   root // starting node (either element or selector string)
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   heuristic: function( node ){} // specifies heuristic value for `node`/`this`
    //   directed // default false
    //   goal // target node (either element or selector string). Mandatory.

    // retObj => returned object by function
    //   found : true/false // whether a path from root to goal has been found
    //   distance // Distance for the shortest path from root to goal
    //   path // Array of ids of nodes in shortest path
    aStar: function(options) {
      options = options || {};

      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Reconstructs the path from Start to End, acumulating the result in pathAcum
      var reconstructPath = function(start, end, cameFromMap, pathAcum) {
        // Base case
        if (start == end) {
          pathAcum.push( cy.getElementById(end) );
          return pathAcum;
        }
        
        if (end in cameFromMap) {
          // We know which node is before the last one
          var previous = cameFromMap[end];
          var previousEdge = cameFromEdge[end];

          pathAcum.push( cy.getElementById(end) );
          pathAcum.push( cy.getElementById(previousEdge) );


          return reconstructPath(start, 
                       previous, 
                       cameFromMap, 
                       pathAcum);
        }

        // We should not reach here!
        return undefined;       
      };

      // Returns the index of the element in openSet which has minimum fScore
      var findMin = function(openSet, fScore) {
        if (openSet.length === 0) {
          // Should never be the case
          return undefined;
        }
        var minPos = 0;
        var tempScore = fScore[openSet[0]];
        for (var i = 1; i < openSet.length; i++) {
          var s = fScore[openSet[i]];
          if (s < tempScore) {
            tempScore = s;
            minPos = i;
          }
        }
        return minPos;
      };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting aStar..."); 
      var cy = this._private.cy;

      // root - mandatory!
      if (options != null && options.root != null) {        
        var source = $$.is.string(options.root) ? 
          // use it as a selector, e.g. "#rootID
          this.filter(options.root)[0] : 
          options.root[0];
        // logDebug("Source node: %s", source.id()); 
      } else {
        return undefined;
      }
      
      // goal - mandatory!
      if (options.goal != null) {       
        var target = $$.is.string(options.goal) ? 
          // use it as a selector, e.g. "#goalID
          this.filter(options.goal)[0] : 
          options.goal[0];
        // logDebug("Target node: %s", target.id()); 
      } else {
        return undefined;
      }

      // Heuristic function - optional
      if (options.heuristic != null && $$.is.fn(options.heuristic)) {       
        var heuristic = options.heuristic;
      } else {
        var heuristic = function(){ return 0; }; // use constant if unspecified
        // $$.util.error("Missing required parameter (heuristic)! Aborting.");
        // return;
      }

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var closedSet = [];
      var openSet = [source.id()];
      var cameFrom = {};
      var cameFromEdge = {};
      var gScore = {};
      var fScore = {};

      gScore[source.id()] = 0;
      fScore[source.id()] = heuristic(source);
      
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();

      // Counter
      var steps = 0;

      // Main loop 
      while (openSet.length > 0) {
        var minPos = findMin(openSet, fScore);
        var cMin = cy.getElementById( openSet[minPos] );
        steps++;

        // logDebug("\nStep: %s", steps);
        // logDebug("Processing node: %s, fScore = %s", cMin.id(), fScore[cMin.id()]);
        
        // If we've found our goal, then we are done
        if (cMin.id() == target.id()) {
          // logDebug("Found goal node!");
          var rPath = reconstructPath(source.id(), target.id(), cameFrom, []);
          rPath.reverse();
          // logDebug("Path: %s", rPath);
          return {
            found : true,
            distance : gScore[cMin.id()],
            path : new $$.Collection(cy, rPath),
            steps : steps
          };          
        }
        
        // Add cMin to processed nodes
        closedSet.push(cMin.id());
        // Remove cMin from boundary nodes
        openSet.splice(minPos, 1);
        // logDebug("Added node to closedSet, removed from openSet.");
        // logDebug("Processing neighbors...");

        // Update scores for neighbors of cMin
        // Take into account if graph is directed or not
        var vwEdges = cMin.connectedEdges();
        if( directed ){ vwEdges = vwEdges.stdFilter(function(ele){ return ele.data('source') === cMin.id(); }); }
        vwEdges = vwEdges.intersect(edges);  
        
        for (var i = 0; i < vwEdges.length; i++) {
          var e = vwEdges[i];
          var w = e.connectedNodes().stdFilter(function(n){ return n.id() !== cMin.id(); }).intersect(nodes);

          // logDebug("   processing neighbor: %s", w.id());
          // if node is in closedSet, ignore it
          if (closedSet.indexOf(w.id()) != -1) {
            // logDebug("   already in closedSet, ignoring it.");
            continue;
          }
          
          // New tentative score for node w
          var tempScore = gScore[cMin.id()] + weightFn.apply(e, [e]);
          // logDebug("   tentative gScore: %d", tempScore);

          // Update gScore for node w if:
          //   w not present in openSet
          // OR
          //   tentative gScore is less than previous value

          // w not in openSet
          if (openSet.indexOf(w.id()) == -1) {
            gScore[w.id()] = tempScore;
            fScore[w.id()] = tempScore + heuristic(w);
            openSet.push(w.id()); // Add node to openSet
            cameFrom[w.id()] = cMin.id();
            cameFromEdge[w.id()] = e.id();
            // logDebug("   not in openSet, adding it. ");
            // logDebug("   fScore(%s) = %s", w.id(), tempScore);
            continue;
          }
          // w already in openSet, but with greater gScore
          if (tempScore < gScore[w.id()]) {
            gScore[w.id()] = tempScore;
            fScore[w.id()] = tempScore + heuristic(w);
            cameFrom[w.id()] = cMin.id();
            // logDebug("   better score, replacing gScore. ");
            // logDebug("   fScore(%s) = %s", w.id(), tempScore);
          }

        } // End of neighbors update

      } // End of main loop

      // If we've reached here, then we've not reached our goal
      // logDebug("Reached end of computation without finding our goal");
      return {
        found : false,
        distance : undefined,
        path : undefined,
        steps : steps
      };
    }, // aStar()


    // Implemented from pseudocode from wikipedia
    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   pathTo : function(fromId, toId) // Returns the shortest path from node with ID "fromID" to node with ID "toId", as an array of node IDs
    //   distanceTo: function(fromId, toId) // Returns the distance of the shortest path from node with ID "fromID" to node with ID "toId"
    floydWarshall: function(options) {
      options = options || {};

      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting floydWarshall..."); 

      var cy = this._private.cy;

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;

      // mapping: node id -> position in nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }     

      // Initialize distance matrix
      var dist = [];
      for (var i = 0; i < numNodes; i++) {
        var newRow = new Array(numNodes);
        for (var j = 0; j < numNodes; j++) {
          if (i == j) {
            newRow[j] = 0;
          } else {
            newRow[j] = Infinity;
          }
        }
        dist.push(newRow);
      }           

      // Initialize matrix used for path reconstruction
      // Initialize distance matrix
      var next = [];
      var edgeNext = [];

      var initMatrix = function(next){
        for (var i = 0; i < numNodes; i++) {
          var newRow = new Array(numNodes);
          for (var j = 0; j < numNodes; j++) {
            newRow[j] = undefined;
          }
          next.push(newRow);
        }
      };

      initMatrix(next);
      initMatrix(edgeNext);
      
      // Process edges
      for (var i = 0; i < edges.length ; i++) {     
        var sourceIndex = id2position[edges[i].source().id()];
        var targetIndex = id2position[edges[i].target().id()];    
        var weight = weightFn.apply(edges[i], [edges[i]]);
        
        // Check if already process another edge between same 2 nodes
        if (dist[sourceIndex][targetIndex] > weight) {
          dist[sourceIndex][targetIndex] = weight;
          next[sourceIndex][targetIndex] = targetIndex;
          edgeNext[sourceIndex][targetIndex] = edges[i];
        }
      }

      // If undirected graph, process 'reversed' edges
      if (!directed) {
        for (var i = 0; i < edges.length ; i++) {     
          var sourceIndex = id2position[edges[i].target().id()];    
          var targetIndex = id2position[edges[i].source().id()];
          var weight = weightFn.apply(edges[i], [edges[i]]);
          
          // Check if already process another edge between same 2 nodes
          if (dist[sourceIndex][targetIndex] > weight) {
            dist[sourceIndex][targetIndex] = weight;
            next[sourceIndex][targetIndex] = targetIndex;
            edgeNext[sourceIndex][targetIndex] = edges[i];
          }
        }
      }

      // Main loop
      for (var k = 0; k < numNodes; k++) {
        for (var i = 0; i < numNodes; i++) {
          for (var j = 0; j < numNodes; j++) {            
            if (dist[i][k] + dist[k][j] < dist[i][j]) {
              dist[i][j] = dist[i][k] + dist[k][j];
              next[i][j] = next[i][k];
            }
          }
        }
      }

      // Build result object       
      var position2id = [];
      for (var i = 0; i < numNodes; i++) {
        position2id.push(nodes[i].id());
      }

      var res = {
        distance: function(from, to) {
          if ($$.is.string(from)) {
            // from is a selector string
            var fromId = (cy.filter(from)[0]).id();
          } else {
            // from is a node
            var fromId = from.id();
          }

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }

          return dist[id2position[fromId]][id2position[toId]];
        },

        path: function(from, to) {
          var reconstructPathAux = function(from, to, next, position2id, edgeNext) {
            if (from === to) {
              return cy.getElementById( position2id[from] );
            }
            if (next[from][to] === undefined) {
              return undefined;
            }

            var path = [ cy.getElementById(position2id[from]) ];
            var prev = from;
            while (from !== to) {
              prev = from;
              from = next[from][to];

              var edge = edgeNext[prev][from];
              path.push( edge );

              path.push( cy.getElementById(position2id[from]) );
            }
            return path;
          };

          if ($$.is.string(from)) {
            // from is a selector string
            var fromId = (cy.filter(from)[0]).id();
          } else {
            // from is a node
            var fromId = from.id();
          }

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }
          
          var pathArr = reconstructPathAux(id2position[fromId], 
                        id2position[toId], 
                        next,
                        position2id,
                        edgeNext);

          return new $$.Collection( cy, pathArr );
        },
      };

      return res;

    }, // floydWarshall


    // Implemented from pseudocode from wikipedia
    // options => options object
    //   root: starting node (either element or selector string)
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   pathTo : function(toId) // Returns the shortest path from root node to node with ID "toId", as an array of node IDs
    //   distanceTo: function(toId) // Returns the distance of the shortest path from root node to node with ID "toId"
    //   hasNegativeWeightCycle: true/false (if true, pathTo and distanceTo will be undefined)
    bellmanFord: function(options) {
      options = options || {};

      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting bellmanFord..."); 

      // Weight function - optional
      if (options.weight != null && $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;};
      }

      // directed - optional
      if (options.directed != null) {       
        var directed = options.directed;
      } else {
        var directed = false;
      }

      // root - mandatory!
      if (options.root != null) {       
        if ($$.is.string(options.root)) {
          // use it as a selector, e.g. "#rootID
          var source = this.filter(options.root)[0];
        } else {
          var source = options.root[0];
        }
        // logDebug("Source node: %s", source.id()); 
      } else {
        $$.util.error("options.root required");
        return undefined;
      }

      var cy = this._private.cy;
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;

      // mapping: node id -> position in nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }     

      // Initializations
      var cost = [];
      var predecessor = [];
      var predEdge = [];
      
      for (var i = 0; i < numNodes; i++) {
        if (nodes[i].id() === source.id()) {
          cost[i] = 0;
        } else {
          cost[i] = Infinity;
        } 
        predecessor[i] = undefined;
      }
      
      // Edges relaxation      
      var flag = false;
      for (var i = 1; i < numNodes; i++) {
        flag = false;
        for (var e = 0; e < edges.length; e++) {
          var sourceIndex = id2position[edges[e].source().id()];
          var targetIndex = id2position[edges[e].target().id()];    
          var weight = weightFn.apply(edges[e], [edges[e]]);
          
          var temp = cost[sourceIndex] + weight;
          if (temp < cost[targetIndex]) {
            cost[targetIndex] = temp;
            predecessor[targetIndex] = sourceIndex;
            predEdge[targetIndex] = edges[e];
            flag = true;
          }

          // If undirected graph, we need to take into account the 'reverse' edge
          if (!directed) {
            var temp = cost[targetIndex] + weight;
            if (temp < cost[sourceIndex]) {
              cost[sourceIndex] = temp;
              predecessor[sourceIndex] = targetIndex;
              predEdge[sourceIndex] = edges[e];
              flag = true;
            }
          }
        }

        if (!flag) {
          break;
        }
      }      
            
      if (flag) {
        // Check for negative weight cycles
        for (var e = 0; e < edges.length; e++) {
          var sourceIndex = id2position[edges[e].source().id()];
          var targetIndex = id2position[edges[e].target().id()];    
          var weight = weightFn.apply(edges[e], [edges[e]]);
          
          if (cost[sourceIndex] + weight < cost[targetIndex]) {
            $$.util.error("Error: graph contains a negative weigth cycle!"); 
            return { pathTo: undefined,
                 distanceTo: undefined,
                 hasNegativeWeightCycle: true};
          }
        }     
      }

      // Build result object       
      var position2id = [];
      for (var i = 0; i < numNodes; i++) {
        position2id.push(nodes[i].id());
      }
      
      
      var res = {       
        distanceTo : function(to) {
          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }

          return cost[id2position[toId]];
        }, 

        pathTo : function(to) {

          var reconstructPathAux = function(predecessor, fromPos, toPos, position2id, acumPath, predEdge) {
            for(;;){
              // Add toId to path
              acumPath.push( cy.getElementById(position2id[toPos]) );
              acumPath.push( predEdge[toPos] );

              if (fromPos === toPos) {
                // reached starting node
                return acumPath;
              }

              // If no path exists, discart acumulated path and return undefined
              var predPos = predecessor[toPos];
              if (typeof predPos === "undefined") {
                return undefined;
              }

              toPos = predPos;
            }

          };

          if ($$.is.string(to)) {
            // to is a selector string
            var toId = (cy.filter(to)[0]).id();
          } else {
            // to is a node
            var toId = to.id();
          }
          var path = [];

          // This returns a reversed path 
          var res =  reconstructPathAux(predecessor, 
                        id2position[source.id()],
                        id2position[toId], 
                        position2id, 
                        path,
                        predEdge);

          // Get it in the correct order and return it
          if (res != null) {
            res.reverse();
          }

          return new $$.Collection(cy, res);                       
        }, 

        hasNegativeWeightCycle: false
      };

      return res;

    }, // bellmanFord


    // Computes the minimum cut of an undirected graph
    // Returns the correct answer with high probability
    // options => options object
    // 
    // retObj => returned object by function
    //   cut : list of IDs of edges in the cut,
    //   partition1: list of IDs of nodes in one partition
    //   partition2: list of IDs of nodes in the other partition
    kargerStein: function(options) {
      options = options || {};
      
      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Function which colapses 2 (meta) nodes into one
      // Updates the remaining edge lists
      // Receives as a paramater the edge which causes the collapse
      var colapse = function(edgeIndex, nodeMap, remainingEdges) {
        var edgeInfo = remainingEdges[edgeIndex];
        var sourceIn = edgeInfo[1];
        var targetIn = edgeInfo[2];
        var partition1 = nodeMap[sourceIn];
        var partition2 = nodeMap[targetIn];

        // Delete all edges between partition1 and partition2
        var newEdges = remainingEdges.filter(function(edge) {
          if (nodeMap[edge[1]] === partition1 && nodeMap[edge[2]] === partition2) {
            return false;
          }
          if (nodeMap[edge[1]] === partition2 && nodeMap[edge[2]] === partition1) {
            return false;
          }
          return true;
        });
        
        // All edges pointing to partition2 should now point to partition1
        for (var i = 0; i < newEdges.length; i++) {
          var edge = newEdges[i];
          if (edge[1] === partition2) { // Check source
            newEdges[i] = edge.slice(0);
            newEdges[i][1] = partition1;
          } else if (edge[2] === partition2) { // Check target
            newEdges[i] = edge.slice(0);
            newEdges[i][2] = partition1;
          }
        } 
        
        // Move all nodes from partition2 to partition1
        for (var i = 0; i < nodeMap.length; i++) {
          if (nodeMap[i] === partition2) {
            nodeMap[i] = partition1;
          }
        }
        
        return newEdges;
      };


      // Contracts a graph until we reach a certain number of meta nodes
      var contractUntil = function(metaNodeMap, 
                     remainingEdges,
                     size, 
                     sizeLimit) {
        // Stop condition
        if (size <= sizeLimit) {
          return remainingEdges;
        }
        
        // Choose an edge randomly
        var edgeIndex = Math.floor((Math.random() * remainingEdges.length));

        // Colapse graph based on edge
        var newEdges = colapse(edgeIndex, metaNodeMap, remainingEdges);
        
        return contractUntil(metaNodeMap, 
                   newEdges, 
                   size - 1, 
                   sizeLimit);        
      };


      // Parse options
      // debug - optional
      // if (options != null && options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting kargerStein..."); 

      var cy = this._private.cy;
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;
      var numEdges = edges.length;
      var numIter = Math.ceil(Math.pow(Math.log(numNodes) / Math.LN2, 2));
      var stopSize = Math.floor(numNodes / Math.sqrt(2));

      if (numNodes < 2) {
        $$.util.error("At least 2 nodes are required for KargerSteing algorithm!"); 
        return undefined;
      }

      // Create numerical identifiers for each node
      // mapping: node id -> position in nodes array
      // for reverse mapping, simply use nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }

      // Now store edge destination as indexes
      // Format for each edge (edge index, source node index, target node index)
      var edgeIndexes = [];
      for (var i = 0; i < numEdges; i++) {
        var e = edges[i];
        edgeIndexes.push([i, id2position[e.source().id()], id2position[e.target().id()]]);
      }

      // We will store the best cut found here
      var minCutSize = Infinity;
      var minCut;     

      // Initial meta node partition
      var originalMetaNode = [];
      for (var i = 0; i < numNodes; i++) {
        originalMetaNode.push(i);
      }

      // Main loop
      for (var iter = 0; iter <= numIter; iter++) {
        // Create new meta node partition
        var metaNodeMap = originalMetaNode.slice(0);

        // Contract until stop point (stopSize nodes)
        var edgesState = contractUntil(metaNodeMap, edgeIndexes, numNodes, stopSize);
        
        // Create a copy of the colapsed nodes state
        var metaNodeMap2 = metaNodeMap.slice(0);

        // Run 2 iterations starting in the stop state
        var res1 = contractUntil(metaNodeMap, edgesState, stopSize, 2);
        var res2 = contractUntil(metaNodeMap2, edgesState, stopSize, 2);

        // Is any of the 2 results the best cut so far?
        if (res1.length <= res2.length && res1.length < minCutSize) {
          minCutSize = res1.length;
          minCut = [res1, metaNodeMap];
        } else if (res2.length <= res1.length && res2.length < minCutSize) {
          minCutSize = res2.length;
          minCut = [res2, metaNodeMap2];
        }
      } // end of main loop

      
      // Construct result
      var resEdges = (minCut[0]).map(function(e){ return edges[e[0]]; });
      var partition1 = [];
      var partition2 = [];

      // traverse metaNodeMap for best cut
      var witnessNodePartition = minCut[1][0];
      for (var i = 0; i < minCut[1].length; i++) { 
        var partitionId = minCut[1][i]; 
        if (partitionId === witnessNodePartition) {
          partition1.push(nodes[i]);
        } else {
          partition2.push(nodes[i]);
        }       
      }
      
      var ret = {
        cut: new $$.Collection(cy, resEdges),
        partition1: new $$.Collection(cy, partition1),
        partition2: new $$.Collection(cy, partition2)
      };
      
      return ret;
    },


    // 
    // options => options object
    //   dampingFactor: optional
    //   precision: optional
    //   iterations : optional
    // retObj => returned object by function
    //  rank : function that returns the pageRank of a given node (object or selector string)
    pageRank: function(options) {
      options = options || {};
      
      var normalizeVector = function(vector) {
        var length = vector.length;

        // First, get sum of all elements
        var total = 0; 
        for (var i = 0; i < length; i++) {
          total += vector[i];
        }

        // Now, divide each by the sum of all elements
        for (var i = 0; i < length; i++) {
          vector[i] = vector[i] / total;
        }
      };
      
      // var logDebug = function() {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };
      
      // Parse options
      // debug - optional
      // if (options != null && 
      //   options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }
      // logDebug("Starting pageRank..."); 

      // dampingFactor - optional
      if (options != null && 
        options.dampingfactor != null) {
        var dampingFactor = options.dampingFactor;
      } else {
        var dampingFactor = 0.8; // Default damping factor
      }

      // desired precision - optional
      if (options != null && 
        options.precision != null) {
        var epsilon = options.precision;
      } else {
        var epsilon = 0.000001; // Default precision
      }

      // Max number of iterations - optional
      if (options != null && 
        options.iterations != null) {
        var numIter = options.iterations;
      } else {
        var numIter = 200; // Default number of iterations
      }

      // Weight function - optional
      if (options != null && 
        options.weight != null && 
        $$.is.fn(options.weight)) {       
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function(e) {return 1;}; 
      }

      var cy = this._private.cy;
      var edges = this.edges().stdFilter(function(e){ return !e.isLoop(); });
      var nodes = this.nodes();
      var numNodes = nodes.length;
      var numEdges = edges.length;

      // Create numerical identifiers for each node
      // mapping: node id -> position in nodes array
      // for reverse mapping, simply use nodes array
      var id2position = {};
      for (var i = 0; i < numNodes; i++) {
        id2position[nodes[i].id()] = i;
      }

      // Construct transposed adjacency matrix
      // First lets have a zeroed matrix of the right size
      // We'll also keep track of the sum of each column
      var matrix = [];
      var columnSum = [];
      var additionalProb = (1 - dampingFactor) / numNodes;

      // Create null matric
      for (var i = 0; i < numNodes; i++) { 
        var newRow = [];
        for (var j = 0; j < numNodes; j++) {
          newRow.push(0.0);
        }
        matrix.push(newRow);
        columnSum.push(0.0);
      }

      // Now, process edges
      for (var i = 0; i < numEdges; i++) {
        var edge = edges[i];
        var s = id2position[edge.source().id()];
        var t = id2position[edge.target().id()];
        var w = weightFn.apply(edge, [edge]);
        
        // Update matrix
        matrix[t][s] += w;

        // Update column sum
        columnSum[s] += w; 
      }

      // Add additional probability based on damping factor
      // Also, take into account columns that have sum = 0
      var p = 1.0 / numNodes + additionalProb; // Shorthand
      // Traverse matrix, column by column
      for (var j = 0; j < numNodes; j++) { 
        if (columnSum[j] === 0) {
          // No 'links' out from node jth, assume equal probability for each possible node
          for (var i = 0; i < numNodes; i++) {
            matrix[i][j] = p;
          }
        } else {
          // Node jth has outgoing link, compute normalized probabilities
          for (var i = 0; i < numNodes; i++) {
            matrix[i][j] = matrix[i][j] / columnSum[j] + additionalProb;
          }         
        }
      }

      // Compute dominant eigenvector using power method
      var eigenvector = [];
      var nullVector = [];
      var previous;

      // Start with a vector of all 1's
      // Also, initialize a null vector which will be used as shorthand
      for (var i = 0; i < numNodes; i++) {
        eigenvector.push(1.0);
        nullVector.push(0.0);
      }
            
      for (var iter = 0; iter < numIter; iter++) {
        // New array with all 0's
        var temp = nullVector.slice(0);
        
        // Multiply matrix with previous result
        for (var i = 0; i < numNodes; i++) {
          for (var j = 0; j < numNodes; j++) {        
            temp[i] += matrix[i][j] * eigenvector[j];
          }
        }

        normalizeVector(temp);
        previous = eigenvector;
        eigenvector = temp;

        var diff = 0;
        // Compute difference (squared module) of both vectors
        for (var i = 0; i < numNodes; i++) {
          diff += Math.pow(previous[i] - eigenvector[i], 2);
        }
        
        // If difference is less than the desired threshold, stop iterating
        if (diff < epsilon) {
          // logDebug("Stoped at iteration %s", iter);
          break;
        }
      }
            
      // logDebug("Result:\n" + eigenvector);

      // Construct result
      var res = {
        rank : function(node) {
          if ($$.is.string(node)) {
            // is a selector string
            var nodeId = (cy.filter(node)[0]).id();
          } else {
            // is a node object
            var nodeId = node.id();
          }
          return eigenvector[id2position[nodeId]];
        }
      };


      return res;
    }, // pageRank


    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    // if directed
    //   indegree : function(node) // Returns the normalized indegree of the given node
    //   outdegree: function(node) // Returns the normalized outdegree of the given node
    // if undirected
    //   degree : function(node) // Returns the normalized degree of the given node
    degreeCentralityNormalized: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // directed - optional
      if (options.directed != null) {
        var directed = options.directed;
      } else {
        var directed = false;
      }

      // logDebug("Starting degree centrality...");
      var nodes = this.nodes();
      var numNodes = nodes.length;

      if (!directed) {
        var degrees = {};
        var maxDegree = 0;

        for (var i = 0; i < numNodes; i++) {
          var node = nodes[i];
          // add current node to the current options object and call degreeCentrality 
          var currDegree = this.degreeCentrality($$.util.extend({}, options, {root: node}));
          if (maxDegree < currDegree.degree)
            maxDegree = currDegree.degree;

          degrees[node.id()] = currDegree.degree;
        }

        return {
          degree: function (node) {
            if ($$.is.string(node)) {
              // from is a selector string
              var node = (cy.filter(node)[0]).id();
            } else {
              // from is a node
              var node = node.id();
            }

            return degrees[node] / maxDegree;
          }
        };
      } else {
        var indegrees = {};
        var outdegrees = {};
        var maxIndegree = 0;
        var maxOutdegree = 0;

        for (var i = 0; i < numNodes; i++) {
          var node = nodes[i];
          // add current node to the current options object and call degreeCentrality 
          var currDegree = this.degreeCentrality($$.util.extend({}, options, {root: node}));

          if (maxIndegree < currDegree.indegree)
            maxIndegree = currDegree.indegree;

          if (maxOutdegree < currDegree.outdegree)
            maxOutdegree = currDegree.outdegree;

          indegrees[node.id()] = currDegree.indegree;
          outdegrees[node.id()] = currDegree.outdegree;
        }

        return {
          indegree: function (node) {
            if ($$.is.string(node)) {
              // from is a selector string
              var node = (cy.filter(node)[0]).id();
            } else {
              // from is a node
              var node = node.id();
            }

            return indegrees[node] / maxIndegree;
          },
          outdegree: function (node) {
            if ($$.is.string(node)) {
              // from is a selector string
              var node = (cy.filter(node)[0]).id();
            } else {
              // from is a node
              var node = node.id();
            }

            return outdegrees[node] / maxOutdegree;
          }

        };
      }

    }, // degreeCentralityNormalized

    // Implemented from the algorithm in Opsahl's paper "Node centrality in weighted networks: Generalizing degree and shortest paths" check the heading 2 "Degree"
    // options => options object
    //   node : focal node
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   alpha : alpha value for the algorithm (Benchmark values of alpha: 0 -> disregards the weights focuses on number of edges
    //                                                                     1 -> disregards the number of edges focuses on total amount of weight 
    //   directed // default false
    // retObj => returned object by function
    // if directed
    //   indegree : indegree of the given node
    //   outdegree: outdegree of the given node
    // if undirected
    //   degree : degree of the given node
    degreeCentrality: function (options) {
      options = options || {};

      var callingEles = this;

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting degree centrality...");

      // root - mandatory!
      if (options != null && options.root != null) {
        var root = $$.is.string(options.root) ? this.filter(options.root)[0] : options.root[0];
        // logDebug("Source node: %s", root.id());
      } else {
        return undefined;
      }

      // weight - optional
      if (options.weight != null && $$.is.fn(options.weight)) {
        var weightFn = options.weight;
      } else {
        // If not specified, assume each edge has equal weight (1)
        var weightFn = function (e) {
          return 1;
        };
      }

      // directed - optional
      if (options.directed != null) {
        var directed = options.directed;
      } else {
        var directed = false;
      }

      // alpha - optional
      if (options.alpha != null && $$.is.number(options.alpha)) {
        var alpha = options.alpha;
      } else {
        alpha = 0;
      }


      if (!directed) {
        var connEdges = root.connectedEdges().intersection( callingEles );
        var k = connEdges.length;
        var s = 0;

        // Now, sum edge weights
        for (var i = 0; i < connEdges.length; i++) {
          var edge = connEdges[i];
          s += weightFn.apply(edge, [edge]);
        }

        return {
          degree: Math.pow(k, 1 - alpha) * Math.pow(s, alpha)
        };
      } else {
        var incoming = root.connectedEdges('edge[target = "' + root.id() + '"]').intersection( callingEles );
        var outgoing = root.connectedEdges('edge[source = "' + root.id() + '"]').intersection( callingEles );
        var k_in = incoming.length;
        var k_out = outgoing.length;
        var s_in = 0;
        var s_out = 0;

        // Now, sum incoming edge weights
        for (var i = 0; i < incoming.length; i++) {
          var edge = incoming[i];
          s_in += weightFn.apply(edge, [edge]);
        }

        // Now, sum outgoing edge weights
        for (var i = 0; i < outgoing.length; i++) {
          var edge = outgoing[i];
          s_out += weightFn.apply(edge, [edge]);
        }

        return {
          indegree: Math.pow(k_in, 1 - alpha) * Math.pow(s_in, alpha),
          outdegree: Math.pow(k_out, 1 - alpha) * Math.pow(s_out, alpha)
        };
      }
    }, // degreeCentrality

    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    //   harmonic // use harmonic mean instead of arithmetic mean
    // retObj => returned object by function
    //   closeness : function(node) // Returns the normalized closeness of the given node
    closenessCentralityNormalized: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting closeness centrality...");

      var harmonic = options.harmonic;
      if( harmonic === undefined ){
        harmonic = true;
      }
 
      var closenesses = {};
      var maxCloseness = 0;
      var nodes = this.nodes();
      var fw = this.floydWarshall({ weight: options.weight, directed: options.directed });

      // Compute closeness for every node and find the maximum closeness
      for(var i = 0; i < nodes.length; i++){
        var currCloseness = 0;
        for (var j = 0; j < nodes.length; j++) {
          if (i != j) {
            var d = fw.distance(nodes[i], nodes[j]);
            
            if( harmonic ){
              currCloseness += 1 / d;
            } else {
              currCloseness += d;
            }
          }
        }
        
        if( !harmonic ){
          currCloseness = 1 / currCloseness;
        }

        if (maxCloseness < currCloseness){
          maxCloseness = currCloseness;
        }

        closenesses[nodes[i].id()] = currCloseness;
      }

      return {
        closeness: function (node) {
          if ($$.is.string(node)) {
            // from is a selector string
            var node = (cy.filter(node)[0]).id();
          } else {
            // from is a node
            var node = node.id();
          }

          return closenesses[node] / maxCloseness;
        }
      };
    },
    // Implemented from pseudocode from wikipedia
    // options => options object
    //   root : focal node
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // closeness => returned value by the function. Closeness value of the given node.
    closenessCentrality: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting closeness centrality...");

      // root - mandatory!
      if (options.root != null) {
        if ($$.is.string(options.root)) {
          // use it as a selector, e.g. "#rootID
          var root = this.filter(options.root)[0];
        } else {
          var root = options.root[0];
        }
        // logDebug("Source node: %s", root.id());
      } else {
        $$.util.error("options.root required");
        return undefined;
      }

      // weight - optional
      if (options.weight != null && $$.is.fn(options.weight)) {
        var weight = options.weight;
      } else {
        var weight = function(){return 1;};
      }

      // directed - optional
      if (options.directed != null && $$.is.bool(options.directed)) {
        var directed = options.directed;
      } else {
        var directed = false;
      }
      
      var harmonic = options.harmonic;
      if( harmonic === undefined ){
        harmonic = true;
      }

      // we need distance from this node to every other node
      var dijkstra = this.dijkstra({
        root: root,
        weight: weight,
        directed: directed
      });
      var totalDistance = 0;

      var nodes = this.nodes();
      for (var i = 0; i < nodes.length; i++){
        if (nodes[i].id() != root.id()){
          var d = dijkstra.distanceTo(nodes[i]);
          
          if( harmonic ){
            totalDistance += 1 / d; 
          } else {
            totalDistance += d;
          }
        }
      }

      return harmonic ? totalDistance : 1 / totalDistance;
    }, // closenessCentrality

    // Implemented from the algorithm in the paper "On Variants of Shortest-Path Betweenness Centrality and their Generic Computation" by Ulrik Brandes
    // options => options object
    //   weight: function( edge ){} // specifies weight to use for `edge`/`this`. If not present, it will be asumed a weight of 1 for all edges
    //   directed // default false
    // retObj => returned object by function
    //   betweenness : function(node) // Returns the betweenness centrality of the given node
    //   betweennessNormalized : function(node) // Returns the normalized betweenness centrality of the given node
    betweennessCentrality: function (options) {
      options = options || {};

      // var logDebug = function () {
      //   if (debug) {
      //     console.log.apply(console, arguments);
      //   }
      // };

      // Parse options
      // debug - optional
      // if (options.debug != null) {
      //   var debug = options.debug;
      // } else {
      //   var debug = false;
      // }

      // logDebug("Starting betweenness centrality...");

      // Weight - optional
      if (options.weight != null && $$.is.fn(options.weight)) {
        var weightFn = options.weight;
        var weighted = true;
      } else {
        var weighted = false;
      }

      // Directed - default false
      if (options.directed != null && $$.is.bool(options.directed)) {
        var directed = options.directed;
      } else {
        var directed = false;
      }

      var priorityInsert = function (queue, ele) {
        queue.unshift(ele);
        for (var i = 0; d[queue[i]] < d[queue[i + 1]] && i < queue.length - 1; i++) {
          var tmp = queue[i];
          queue[i] = queue[i + 1];
          queue[i + 1] = tmp;
        }
      };

      var cy = this._private.cy;

      // starting
      var V = this.nodes();
      var A = {};
      var C = {};

      // A contains the neighborhoods of every node
      for (var i = 0; i < V.length; i++) {
        if (directed) {
          A[V[i].id()] = V[i].outgoers("node"); // get outgoers of every node
        } else {
          A[V[i].id()] = V[i].openNeighborhood("node"); // get neighbors of every node          
        }
      }

      // C contains the betweenness values
      for (var i = 0; i < V.length; i++) {
        C[V[i].id()] = 0;
      }

      for (var s = 0; s < V.length; s++) {
        var S = []; // stack
        var P = {};
        var g = {};
        var d = {};
        var Q = []; // queue

        // init dictionaries
        for (var i = 0; i < V.length; i++) {
          P[V[i].id()] = [];
          g[V[i].id()] = 0;
          d[V[i].id()] = Number.POSITIVE_INFINITY;
        }

        g[V[s].id()] = 1; // sigma
        d[V[s].id()] = 0; // distance to s

        Q.unshift(V[s].id());

        while (Q.length > 0) {
          var v = Q.pop();
          S.push(v);
          if (weighted) {
            A[v].forEach(function (w) {
              if (cy.$('#' + v).edgesTo(w).length > 0) {
                var edge = cy.$('#' + v).edgesTo(w)[0];
              } else {
                var edge = w.edgesTo('#' + v)[0];
              }
              
              var edgeWeight = weightFn.apply(edge, [edge]);

              if (d[w.id()] > d[v] + edgeWeight) {
                d[w.id()] = d[v] + edgeWeight;
                if (Q.indexOf(w.id()) < 0) { //if w is not in Q
                  priorityInsert(Q, w.id());
                } else { // update position if w is in Q
                  Q.splice(Q.indexOf(w.id()), 1);
                  priorityInsert(Q, w.id());
                }
                g[w.id()] = 0;
                P[w.id()] = [];
              }
              if (d[w.id()] == d[v] + edgeWeight) {
                g[w.id()] = g[w.id()] + g[v];
                P[w.id()].push(v);
              }
            });
          } else {
            A[v].forEach(function (w) {
              if (d[w.id()] == Number.POSITIVE_INFINITY) {
                Q.unshift(w.id());
                d[w.id()] = d[v] + 1;
              }
              if (d[w.id()] == d[v] + 1) {
                g[w.id()] = g[w.id()] + g[v];
                P[w.id()].push(v);
              }
            });
          }
        }

        var e = {};
        for (var i = 0; i < V.length; i++) {
          e[V[i].id()] = 0;
        }

        while (S.length > 0) {
          var w = S.pop();
          P[w].forEach(function (v) {
            e[v] = e[v] + (g[v] / g[w]) * (1 + e[w]);
            if (w != V[s].id())
              C[w] = C[w] + e[w];
          });
        }
      }

      var max = 0;
      for (var key in C) {
        if (max < C[key])
          max = C[key];
      }

      var ret = {
        betweenness: function (node) {
          if ($$.is.string(node)) {
            var node = (cy.filter(node)[0]).id();
          } else {
            var node = node.id();
          }

          return C[node];
        },

        betweennessNormalized: function (node) {
          if ($$.is.string(node)) {
            var node = (cy.filter(node)[0]).id();
          } else {
            var node = node.id();
          }

          return C[node] / max;
        }
      };

      // alias
      ret.betweennessNormalised = ret.betweennessNormalized;

      return ret;
    } // betweennessCentrality
  }); // $$.fn.eles

  // nice, short mathemathical alias
  $$.elesfn.dc = $$.elesfn.degreeCentrality;
  $$.elesfn.dcn = $$.elesfn.degreeCentralityNormalised = $$.elesfn.degreeCentralityNormalized;
  $$.elesfn.cc = $$.elesfn.closenessCentrality;
  $$.elesfn.ccn = $$.elesfn.closenessCentralityNormalised = $$.elesfn.closenessCentralityNormalized;
  $$.elesfn.bc = $$.elesfn.betweennessCentrality;
}) (cytoscape);

;(function( $$ ){ 'use strict';

  $$.fn.eles({
    animated: $$.define.animated(),
    clearQueue: $$.define.clearQueue(),
    delay: $$.define.delay(),
    animate: $$.define.animate(),
    stop: $$.define.stop()
  });
  
})( cytoscape );  

;(function( $$ ){ 'use strict';
  
  $$.fn.eles({
    addClass: function(classes){
      classes = classes.split(/\s+/);
      var self = this;
      var changed = [];
      
      for( var i = 0; i < classes.length; i++ ){
        var cls = classes[i];
        if( $$.is.emptyString(cls) ){ continue; }
        
        for( var j = 0; j < self.length; j++ ){
          var ele = self[j];
          var hasClass = ele._private.classes[cls];
          ele._private.classes[cls] = true;

          if( !hasClass ){ // if didn't already have, add to list of changed
            changed.push( ele );
          }
        }
      }
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(this._private.cy, changed)
          .updateStyle()
          .trigger('class')
        ;
      }

      return self;
    },

    hasClass: function(className){
      var ele = this[0];
      return ( ele != null && ele._private.classes[className] ) ? true : false;
    },

    toggleClass: function(classesStr, toggle){
      var classes = classesStr.split(/\s+/);
      var self = this;
      var changed = []; // eles who had classes changed
      
      for( var i = 0, il = self.length; i < il; i++ ){
        var ele = self[i];

        for( var j = 0; j < classes.length; j++ ){
          var cls = classes[j];

          if( $$.is.emptyString(cls) ){ continue; }
          
          var hasClass = ele._private.classes[cls];
          var shouldAdd = toggle || (toggle === undefined && !hasClass);

          if( shouldAdd ){
            ele._private.classes[cls] = true;

            if( !hasClass ){ changed.push(ele); }
          } else { // then remove
            ele._private.classes[cls] = false;

            if( hasClass ){ changed.push(ele); }
          }

        } // for j classes
      } // for i eles
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(this._private.cy, changed)
          .updateStyle()
          .trigger('class')
        ;
      }

      return self;
    },

    removeClass: function(classes){
      classes = classes.split(/\s+/);
      var self = this;
      var changed = [];

      for( var i = 0; i < self.length; i++ ){
        var ele = self[i];

        for( var j = 0; j < classes.length; j++ ){
          var cls = classes[j];
          if( !cls || cls === '' ){ continue; }

          var hasClass = ele._private.classes[cls];
          ele._private.classes[cls] = undefined;

          if( hasClass ){ // then we changed its set of classes
            changed.push( ele );
          }
        }
      }
      
      // trigger update style on those eles that had class changes
      if( changed.length > 0 ){
        new $$.Collection(self._private.cy, changed).updateStyle();
      }

      self.trigger('class');
      return self;
    },

    flashClass: function(classes, duration){
      var self = this;

      if( duration == null ){
        duration = 250;
      } else if( duration === 0 ){
        return self; // nothing to do really
      }

      self.addClass( classes );
      setTimeout(function(){
        self.removeClass( classes );
      }, duration);

      return self;
    }
  });
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({
    allAre: function( selector ){
      return this.filter(selector).length === this.length;
    },

    is: function( selector ){
      return this.filter(selector).length > 0;
    },

    some: function( fn, thisArg ){
      for( var i = 0; i < this.length; i++ ){
        var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );

        if( ret ){
          return true;
        }
      }

      return false;
    },

    every: function( fn, thisArg ){
      for( var i = 0; i < this.length; i++ ){
        var ret = !thisArg ? fn( this[i], i, this ) : fn.apply( thisArg, [ this[i], i, this ] );

        if( !ret ){
          return false;
        }
      }

      return true;
    },

    same: function( collection ){
      collection = this.cy().collection( collection );

      // cheap extra check
      if( this.length !== collection.length ){
        return false;
      }

      return this.intersect( collection ).length === this.length;
    },

    anySame: function( collection ){
      collection = this.cy().collection( collection );

      return this.intersect( collection ).length > 0;
    },

    allAreNeighbors: function( collection ){
      collection = this.cy().collection( collection );

      return this.neighborhood().intersect( collection ).length === collection.length;
    }
  });

  $$.elesfn.allAreNeighbours = $$.elesfn.allAreNeighbors;
  
})( cytoscape );

;(function($$){ 'use strict';

  // Compound functions
  /////////////////////

  $$.fn.eles({
    parent: function( selector ){
      var parents = [];
      var cy = this._private.cy;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var parent = cy.getElementById( ele._private.data.parent );

        if( parent.size() > 0 ){
          parents.push( parent );
        }
      }
      
      return new $$.Collection( cy, parents, { unique: true } ).filter( selector );
    },

    parents: function( selector ){
      var parents = [];

      var eles = this.parent();
      while( eles.nonempty() ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];
          parents.push( ele );
        }

        eles = eles.parent();
      }

      return new $$.Collection( this.cy(), parents, { unique: true } ).filter( selector );
    },

    commonAncestors: function( selector ){
      var ancestors;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var parents = ele.parents();
        
        ancestors = ancestors || parents;

        ancestors = ancestors.intersect( parents ); // current list must be common with current ele parents set
      }

      return ancestors.filter( selector );
    },

    orphans: function( selector ){
      return this.stdFilter(function( ele ){
        return ele.isNode() && ele.parent().empty();
      }).filter( selector );
    },

    nonorphans: function( selector ){
      return this.stdFilter(function( ele ){
        return ele.isNode() && ele.parent().nonempty();
      }).filter( selector );
    },

    children: function( selector ){
      var children = [];

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        children = children.concat( ele._private.children );
      }

      return new $$.Collection( this.cy(), children, { unique: true } ).filter( selector );
    },

    siblings: function( selector ){
      return this.parent().children().not( this ).filter( selector );
    },

    isParent: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.children.length !== 0;
      }
    },

    isChild: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.data.parent !== undefined && ele.parent().length !== 0;
      }
    },

    descendants: function( selector ){
      var elements = [];

      function add( eles ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          elements.push( ele );

          if( ele.children().nonempty() ){
            add( ele.children() );
          }
        }
      }

      add( this.children() );

      return new $$.Collection( this.cy(), elements, { unique: true } ).filter( selector );
    }
  });

  // aliases
  $$.elesfn.ancestors = $$.elesfn.parents;
  
})( cytoscape );
;(function($$){ 'use strict';

  var borderWidthMultiplier = 2 * 0.5;
  var borderWidthAdjustment = 0;

  $$.fn.eles({

    data: $$.define.data({
      field: 'data',
      bindingEvent: 'data',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'data',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true,
      immutableKeys: {
        'id': true,
        'source': true,
        'target': true,
        'parent': true
      },
      updateStyle: true
    }),

    removeData: $$.define.removeData({
      field: 'data',
      event: 'data',
      triggerFnName: 'trigger',
      triggerEvent: true,
      immutableKeys: {
        'id': true,
        'source': true,
        'target': true,
        'parent': true
      },
      updateStyle: true
    }),

    scratch: $$.define.data({
      field: 'scratch',
      bindingEvent: 'scratch',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'scratch',
      settingTriggersEvent: true,
      triggerFnName: 'trigger',
      allowGetting: true,
      updateStyle: true
    }),

    removeScratch: $$.define.removeData({
      field: 'scratch',
      event: 'scratch',
      triggerFnName: 'trigger',
      triggerEvent: true,
      updateStyle: true
    }),

    rscratch: $$.define.data({
      field: 'rscratch',
      allowBinding: false,
      allowSetting: true,
      settingTriggersEvent: false,
      allowGetting: true
    }),

    removeRscratch: $$.define.removeData({
      field: 'rscratch',
      triggerEvent: false
    }),

    id: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.data.id;
      }
    },

    position: $$.define.data({
      field: 'position',
      bindingEvent: 'position',
      allowBinding: true,
      allowSetting: true,
      settingEvent: 'position',
      settingTriggersEvent: true,
      triggerFnName: 'rtrigger',
      allowGetting: true,
      validKeys: ['x', 'y'],
      onSet: function( eles ){
        var updatedEles = eles.updateCompoundBounds();
        updatedEles.rtrigger('position');
      },
      canSet: function( ele ){
        return !ele.locked();
      }
    }),

    // position but no notification to renderer
    silentPosition: $$.define.data({
      field: 'position',
      bindingEvent: 'position',
      allowBinding: false,
      allowSetting: true,
      settingEvent: 'position',
      settingTriggersEvent: false,
      triggerFnName: 'trigger',
      allowGetting: true,
      validKeys: ['x', 'y'],
      onSet: function( eles ){
        eles.updateCompoundBounds();
      },
      canSet: function( ele ){
        return !ele.locked();
      }
    }),

    positions: function( pos, silent ){
      if( $$.is.plainObject(pos) ){
        this.position(pos);

      } else if( $$.is.fn(pos) ){
        var fn = pos;

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          var pos = fn.apply(ele, [i, ele]);

          if( pos && !ele.locked() ){
            var elePos = ele._private.position;
            elePos.x = pos.x;
            elePos.y = pos.y;
          }
        }

        var updatedEles = this.updateCompoundBounds();
        var toTrigger = updatedEles.length > 0 ? this.add( updatedEles ) : this;

        if( silent ){
          toTrigger.trigger('position');
        } else {
          toTrigger.rtrigger('position');
        }
      }

      return this; // chaining
    },

    silentPositions: function( pos ){
      return this.positions( pos, true );
    },

    updateCompoundBounds: function(){
      var cy = this.cy();

      if( !cy.styleEnabled() || !cy.hasCompoundNodes() ){ return cy.collection(); } // save cycles for non compound graphs or when style disabled

      var updated = [];

      function update( parent ){
        var children = parent.children();
        var style = parent._private.style;
        var includeLabels = style['compound-sizing-wrt-labels'].value === 'include';
        var bb = children.boundingBox({ includeLabels: includeLabels, includeEdges: true });
        var padding = {
          top: style['padding-top'].pxValue,
          bottom: style['padding-bottom'].pxValue,
          left: style['padding-left'].pxValue,
          right: style['padding-right'].pxValue
        };
        var pos = parent._private.position;
        var didUpdate = false;

        if( style['width'].value === 'auto' ){
          parent._private.autoWidth = bb.w + padding.left + padding.right;
          pos.x = (bb.x1 + bb.x2 - padding.left + padding.right)/2;
          didUpdate = true;
        }

        if( style['height'].value === 'auto' ){
          parent._private.autoHeight = bb.h + padding.top + padding.bottom;
          pos.y = (bb.y1 + bb.y2 - padding.top + padding.bottom)/2;
          didUpdate = true;
        }

        if( didUpdate ){
          updated.push( parent );
        }
      }

      // go up, level by level
      var eles = this.parent();
      while( eles.nonempty() ){

        // update each parent node in this level
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          update( ele );
        }

        // next level
        eles = eles.parent();
      }

      // return changed
      return new $$.Collection( cy, updated );
    },

    // get/set the rendered (i.e. on screen) positon of the element
    renderedPosition: function( dim, val ){
      var ele = this[0];
      var cy = this.cy();
      var zoom = cy.zoom();
      var pan = cy.pan();
      var rpos = $$.is.plainObject( dim ) ? dim : undefined;
      var setting = rpos !== undefined || ( val !== undefined && $$.is.string(dim) );

      if( ele && ele.isNode() ){ // must have an element and must be a node to return position
        if( setting ){
          for( var i = 0; i < this.length; i++ ){
            var ele = this[i];

            if( val !== undefined ){ // set one dimension
              ele._private.position[dim] = ( val - pan[dim] )/zoom;
            } else if( rpos !== undefined ){ // set whole position
              ele._private.position = {
                x: ( rpos.x - pan.x ) /zoom,
                y: ( rpos.y - pan.y ) /zoom
              };
            }
          }

          this.rtrigger('position');
        } else { // getting
          var pos = ele._private.position;
          rpos = {
            x: pos.x * zoom + pan.x,
            y: pos.y * zoom + pan.y
          };

          if( dim === undefined ){ // then return the whole rendered position
            return rpos;
          } else { // then return the specified dimension
            return rpos[ dim ];
          }
        }
      } else if( !setting ){
        return undefined; // for empty collection case
      }

      return this; // chaining
    },

    // get/set the position relative to the parent
    relativePosition: function( dim, val ){
      var ele = this[0];
      var cy = this.cy();
      var ppos = $$.is.plainObject( dim ) ? dim : undefined;
      var setting = ppos !== undefined || ( val !== undefined && $$.is.string(dim) );
      var hasCompoundNodes = cy.hasCompoundNodes();

      if( ele && ele.isNode() ){ // must have an element and must be a node to return position
        if( setting ){
          for( var i = 0; i < this.length; i++ ){
            var ele = this[i];
            var parent = hasCompoundNodes ? ele.parent() : null;
            var hasParent = parent && parent.length > 0;
            var relativeToParent = hasParent;

            if( hasParent ){
              parent = parent[0];
            }

            var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

            if( val !== undefined ){ // set one dimension
              ele._private.position[dim] = val + origin[dim];
            } else if( ppos !== undefined ){ // set whole position
              ele._private.position = {
                x: ppos.x + origin.x,
                y: ppos.y + origin.y,
              };
            }
          }

          this.rtrigger('position');

        } else { // getting
          var pos = ele._private.position;
          var parent = hasCompoundNodes ? ele.parent() : null;
          var hasParent = parent && parent.length > 0;
          var relativeToParent = hasParent;

          if( hasParent ){
            parent = parent[0];
          }

          var origin = relativeToParent ? parent._private.position : { x: 0, y: 0 };

          ppos = {
            x: pos.x - origin.x,
            y: pos.y - origin.y
          };

          if( dim === undefined ){ // then return the whole rendered position
            return ppos;
          } else { // then return the specified dimension
            return ppos[ dim ];
          }
        }
      } else if( !setting ){
        return undefined; // for empty collection case
      }

      return this; // chaining
    },

    // convenience function to get a numerical value for the width of the node/edge
    width: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele ){
        if( styleEnabled ){
          var w = ele._private.style.width;
          return w.strValue === 'auto' ? ele._private.autoWidth : w.pxValue;
        } else {
          return 1;
        }
      }
    },

    outerWidth: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele ){
        if( styleEnabled ){
          var style = ele._private.style;
          var width = style.width.strValue === 'auto' ? ele._private.autoWidth : style.width.pxValue;
          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;

          return width + border;
        } else {
          return 1;
        }
      }
    },

    renderedWidth: function(){
      var ele = this[0];

      if( ele ){
        var width = ele.width();
        return width * this.cy().zoom();
      }
    },

    renderedOuterWidth: function(){
      var ele = this[0];

      if( ele ){
        var owidth = ele.outerWidth();
        return owidth * this.cy().zoom();
      }
    },

    // convenience function to get a numerical value for the height of the node
    height: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele && ele._private.group === 'nodes' ){
        if( styleEnabled ){
          var h = ele._private.style.height;
          return h.strValue === 'auto' ? ele._private.autoHeight : h.pxValue;
        } else {
          return 1;
        }
      }
    },

    outerHeight: function(){
      var ele = this[0];
      var cy = ele._private.cy;
      var styleEnabled = cy._private.styleEnabled;

      if( ele && ele._private.group === 'nodes' ){
        if( styleEnabled ){
          var style = ele._private.style;
          var height = style.height.strValue === 'auto' ? ele._private.autoHeight : style.height.pxValue;
          var border = style['border-width'] ? style['border-width'].pxValue * borderWidthMultiplier + borderWidthAdjustment : 0;
        } else {
          return 1;
        }

        return height + border;
      }
    },

    renderedHeight: function(){
      var ele = this[0];

      if( ele && ele._private.group === 'nodes' ){
        var height = ele.height();
        return height * this.cy().zoom();
      }
    },

    renderedOuterHeight: function(){
      var ele = this[0];

      if( ele && ele._private.group === 'nodes' ){
        var oheight = ele.outerHeight();
        return oheight * this.cy().zoom();
      }
    },

    renderedBoundingBox: function( options ){
      var bb = this.boundingBox( options );
      var cy = this.cy();
      var zoom = cy.zoom();
      var pan = cy.pan();

      var x1 = bb.x1 * zoom + pan.x;
      var x2 = bb.x2 * zoom + pan.x;
      var y1 = bb.y1 * zoom + pan.y;
      var y2 = bb.y2 * zoom + pan.y;

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
      };
    },

    // get the bounding box of the elements (in raw model position)
    boundingBox: function( options ){
      var eles = this;
      var cy = eles._private.cy;
      var cy_p = cy._private;
      var styleEnabled = cy_p.styleEnabled;

      options = options || {};

      var includeNodes = options.includeNodes === undefined ? true : options.includeNodes;
      var includeEdges = options.includeEdges === undefined ? true : options.includeEdges;
      var includeLabels = options.includeLabels === undefined ? true : options.includeLabels;

      // recalculate projections etc
      if( styleEnabled ){
        cy_p.renderer.recalculateRenderedStyle( this );
      }

      var x1 = Infinity;
      var x2 = -Infinity;
      var y1 = Infinity;
      var y2 = -Infinity;

      // find bounds of elements
      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var _p = ele._private;
        var style = _p.style;
        var display = styleEnabled ? _p.style['display'].value : 'element';
        var isNode = _p.group === 'nodes';
        var ex1, ex2, ey1, ey2, x, y;
        var includedEle = false;

        if( display === 'none' ){ continue; } // then ele doesn't take up space

        if( isNode && includeNodes ){
          includedEle = true;

          var pos = _p.position;
          x = pos.x;
          y = pos.y;
          var w = ele.outerWidth();
          var halfW = w/2;
          var h = ele.outerHeight();
          var halfH = h/2;

          // handle node dimensions
          /////////////////////////

          ex1 = x - halfW;
          ex2 = x + halfW;
          ey1 = y - halfH;
          ey2 = y + halfH;

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;

        } else if( ele.isEdge() && includeEdges ){
          includedEle = true;

          var n1 = _p.source;
          var n1_p = n1._private;
          var n1pos = n1_p.position;
          
          var n2 = _p.target;
          var n2_p = n2._private;
          var n2pos = n2_p.position;
          

          // handle edge dimensions (rough box estimate)
          //////////////////////////////////////////////

          var rstyle = _p.rstyle || {};

          ex1 = n1pos.x;
          ex2 = n2pos.x;
          ey1 = n1pos.y;
          ey2 = n2pos.y;
          
          if( ex1 > ex2 ){
            var temp = ex1;
            ex1 = ex2;
            ex2 = temp;
          }

          if( ey1 > ey2 ){
            var temp = ey1;
            ey1 = ey2;
            ey2 = temp;
          }

          x1 = ex1 < x1 ? ex1 : x1;
          x2 = ex2 > x2 ? ex2 : x2;
          y1 = ey1 < y1 ? ey1 : y1;
          y2 = ey2 > y2 ? ey2 : y2;

          // handle points along edge (sanity check)
          //////////////////////////////////////////

          if( styleEnabled ){
            var bpts = rstyle.bezierPts || [];

            var w = style['width'].pxValue;
            var wHalf = w/2;

            for( var j = 0; j < bpts.length; j++ ){
              var bpt = bpts[j];

              ex1 = bpt.x - wHalf;
              ex2 = bpt.x + wHalf;
              ey1 = bpt.y - wHalf;
              ey2 = bpt.y + wHalf;

              x1 = ex1 < x1 ? ex1 : x1;
              x2 = ex2 > x2 ? ex2 : x2;
              y1 = ey1 < y1 ? ey1 : y1;
              y2 = ey2 > y2 ? ey2 : y2;
            }
          }
          
          // precise haystacks (sanity check)
          ///////////////////////////////////
          
          if( styleEnabled && style['curve-style'].strValue === 'haystack' ){
            var hpts = _p.rscratch.haystackPts;
            
            ex1 = hpts[0];
            ey1 = hpts[1];
            ex2 = hpts[2];
            ey2 = hpts[3];

            if( ex1 > ex2 ){
              var temp = ex1;
              ex1 = ex2;
              ex2 = temp;
            }

            if( ey1 > ey2 ){
              var temp = ey1;
              ey1 = ey2;
              ey2 = temp;
            }

            x1 = ex1 < x1 ? ex1 : x1;
            x2 = ex2 > x2 ? ex2 : x2;
            y1 = ey1 < y1 ? ey1 : y1;
            y2 = ey2 > y2 ? ey2 : y2;  
          }

        } // edges
            

        // handle label dimensions
        //////////////////////////

        if( styleEnabled ){

          var style = ele._private.style;
          var rstyle = ele._private.rstyle;
          var label = style['content'].strValue;
          var fontSize = style['font-size'];
          var halign = style['text-halign'];
          var valign = style['text-valign'];
          var labelWidth = rstyle.labelWidth;
          var labelHeight = rstyle.labelHeight;
          var labelX = rstyle.labelX;
          var labelY = rstyle.labelY;

          if( includedEle && includeLabels && label && fontSize && labelHeight != null && labelWidth != null && labelX != null && labelY != null && halign && valign ){
            var lh = labelHeight;
            var lw = labelWidth;
            var lx1, lx2, ly1, ly2;

            if( ele.isEdge() ){
              lx1 = labelX - lw/2;
              lx2 = labelX + lw/2;
              ly1 = labelY - lh/2;
              ly2 = labelY + lh/2;
            } else {
              switch( halign.value ){
                case 'left':
                  lx1 = labelX - lw;
                  lx2 = labelX;
                  break;

                case 'center':
                  lx1 = labelX - lw/2;
                  lx2 = labelX + lw/2;
                  break;

                case 'right':
                  lx1 = labelX;
                  lx2 = labelX + lw;
                  break;
              }

              switch( valign.value ){
                case 'top':
                  ly1 = labelY - lh;
                  ly2 = labelY;
                  break;

                case 'center':
                  ly1 = labelY - lh/2;
                  ly2 = labelY + lh/2;
                  break;

                case 'bottom':
                  ly1 = labelY;
                  ly2 = labelY + lh;
                  break;
              }
            }

            x1 = lx1 < x1 ? lx1 : x1;
            x2 = lx2 > x2 ? lx2 : x2;
            y1 = ly1 < y1 ? ly1 : y1;
            y2 = ly2 > y2 ? ly2 : y2;
          }
        } // style enabled
      } // for

      return {
        x1: x1,
        x2: x2,
        y1: y1,
        y2: y2,
        w: x2 - x1,
        h: y2 - y1
      };
    }
  });

  // aliases
  var fn = $$.elesfn;
  fn.attr = fn.data;
  fn.removeAttr = fn.removeData;
  fn.modelPosition = fn.point = fn.position;
  fn.modelPositions = fn.points = fn.positions;
  fn.renderedPoint = fn.renderedPosition;
  fn.relativePoint = fn.relativePosition;
  fn.boundingbox = fn.boundingBox;
  fn.renderedBoundingbox = fn.renderedBoundingBox;

})( cytoscape );

;(function( $$ ){ 'use strict';
  
  // Regular degree functions (works on single element)
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  function defineDegreeFunction(callback){
    return function( includeLoops ){
      var self = this;

      if( includeLoops === undefined ){
        includeLoops = true;
      }
      
      if( self.length === 0 ){ return; }

      if( self.isNode() && !self.removed() ){
        var degree = 0;
        var node = self[0];
        var connectedEdges = node._private.edges;

        for( var i = 0; i < connectedEdges.length; i++ ){
          var edge = connectedEdges[i];

          if( !includeLoops && edge.isLoop() ){
            continue;
          }

          degree += callback( node, edge );
        }
        
        return degree;
      } else {
        return;
      }
    };
  }
  
  $$.fn.eles({
    degree: defineDegreeFunction(function(node, edge){
      if( edge.source().same( edge.target() ) ){
        return 2;
      } else {
        return 1;
      }
    }),

    indegree: defineDegreeFunction(function(node, edge){
      if( edge.target().same(node) ){
        return 1;
      } else {
        return 0;
      }
    }),

    outdegree: defineDegreeFunction(function(node, edge){
      if( edge.source().same(node) ){
        return 1;
      } else {
        return 0;
      }
    })
  });
  
  
  // Collection degree stats
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  function defineDegreeBoundsFunction(degreeFn, callback){
    return function( includeLoops ){
      var ret;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        var ele = nodes[i];
        var degree = ele[degreeFn]( includeLoops );
        if( degree !== undefined && (ret === undefined || callback(degree, ret)) ){
          ret = degree;
        }
      }
      
      return ret;
    };
  }
  
  $$.fn.eles({
    minDegree: defineDegreeBoundsFunction('degree', function(degree, min){
      return degree < min;
    }),

    maxDegree: defineDegreeBoundsFunction('degree', function(degree, max){
      return degree > max;
    }),

    minIndegree: defineDegreeBoundsFunction('indegree', function(degree, min){
      return degree < min;
    }),

    maxIndegree: defineDegreeBoundsFunction('indegree', function(degree, max){
      return degree > max;
    }),

    minOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, min){
      return degree < min;
    }),

    maxOutdegree: defineDegreeBoundsFunction('outdegree', function(degree, max){
      return degree > max;
    })
  });
  
  $$.fn.eles({
    totalDegree: function( includeLoops ){
      var total = 0;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){
        total += nodes[i].degree( includeLoops );
      }

      return total;
    }
  });
  
})( cytoscape );

  
;(function($$){ 'use strict';
  
  // Functions for binding & triggering events
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({
    on: $$.define.on(), // .on( events [, selector] [, data], handler)
    one: $$.define.on({ unbindSelfOnTrigger: true }),
    once: $$.define.on({ unbindAllBindersOnTrigger: true }),
    off: $$.define.off(), // .off( events [, selector] [, handler] )
    trigger: $$.define.trigger(), // .trigger( events [, extraParams] )

    rtrigger: function(event, extraParams){ // for internal use only
      if( this.length === 0 ){ return; } // empty collections don't need to notify anything

      // notify renderer
      this.cy().notify({
        type: event,
        collection: this
      });
      
      this.trigger(event, extraParams);
      return this;
    }
  });

  // aliases:
  $$.define.eventAliasesOn( $$.elesfn );
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({
    nodes: function( selector ){
      return this.filter(function(i, element){
        return element.isNode();
      }).filter(selector);
    },

    edges: function( selector ){
      return this.filter(function(i, element){
        return element.isEdge();
      }).filter(selector);
    },

    filter: function( filter ){
      var cy = this._private.cy;
      
      if( $$.is.fn(filter) ){
        var elements = [];

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( filter.apply(ele, [i, ele]) ){
            elements.push(ele);
          }
        }
        
        return new $$.Collection(cy, elements);
      
      } else if( $$.is.string(filter) || $$.is.elementOrCollection(filter) ){
        return new $$.Selector(filter).filter(this);
      
      } else if( filter === undefined ){
        return this;
      }

      return new $$.Collection( cy ); // if not handled by above, give 'em an empty collection
    },

    not: function( toRemove ){
      var cy = this._private.cy;

      if( !toRemove ){
        return this;
      } else {
      
        if( $$.is.string( toRemove ) ){
          toRemove = this.filter( toRemove );
        }
        
        var elements = [];
        
        for( var i = 0; i < this.length; i++ ){
          var element = this[i];

          var remove = toRemove._private.ids[ element.id() ];
          if( !remove ){
            elements.push( element );
          }
        }
        
        return new $$.Collection( cy, elements );
      }
      
    },

    absoluteComplement: function(){
      var cy = this._private.cy;

      return cy.elements().not( this );
    },

    intersect: function( other ){
      var cy = this._private.cy;
      
      // if a selector is specified, then filter by it instead
      if( $$.is.string(other) ){
        var selector = other;
        return this.filter( selector );
      }
      
      var elements = [];
      var col1 = this;
      var col2 = other;
      var col1Smaller = this.length < other.length;
      // var ids1 = col1Smaller ? col1._private.ids : col2._private.ids;
      var ids2 = col1Smaller ? col2._private.ids : col1._private.ids;
      var col = col1Smaller ? col1 : col2;
      
      for( var i = 0; i < col.length; i++ ){
        var id = col[i]._private.data.id;
        var ele = ids2[ id ];

        if( ele ){
          elements.push( ele );
        }
      }
      
      return new $$.Collection( cy, elements );
    },

    xor: function( other ){
      var cy = this._private.cy;

      if( $$.is.string(other) ){
        other = cy.$( other );
      }

      var elements = [];
      var col1 = this;
      var col2 = other;
      
      var add = function( col, other ){

        for( var i = 0; i < col.length; i++ ){
          var ele = col[i];
          var id = ele._private.data.id;
          var inOther = other._private.ids[ id ];
          
          if( !inOther ){
            elements.push( ele );
          }
        }

      };

      add( col1, col2 );
      add( col2, col1 );

      return new $$.Collection( cy, elements );
    },  

    diff: function( other ){
      var cy = this._private.cy;

      if( $$.is.string(other) ){
        other = cy.$( other );
      }

      var left = [];
      var right = [];
      var both = [];
      var col1 = this;
      var col2 = other;

      var add = function( col, other, retEles ){

        for( var i = 0; i < col.length; i++ ){
          var ele = col[i];
          var id = ele._private.data.id;
          var inOther = other._private.ids[ id ];
          
          if( inOther ){
            both.push( ele );
          } else {
            retEles.push( ele );
          }
        }

      };

      add( col1, col2, left );
      add( col2, col1, right );

      return {
        left: new $$.Collection( cy, left, { unique: true } ),
        right: new $$.Collection( cy, right, { unique: true } ),
        both: new $$.Collection( cy, both, { unique: true } )
      };
    },

    add: function( toAdd ){
      var cy = this._private.cy;    
      
      if( !toAdd ){
        return this;
      }
      
      if( $$.is.string(toAdd) ){
        var selector = toAdd;
        toAdd = cy.elements(selector);
      }
      
      var elements = [];

      for( var i = 0; i < this.length; i++ ){
        elements.push( this[i] );
      }

      for( var i = 0; i < toAdd.length; i++ ){

        var add = !this._private.ids[ toAdd[i].id() ];
        if( add ){
          elements.push( toAdd[i] );
        }
      }
      
      return new $$.Collection(cy, elements);
    },

    // in place merge on calling collection
    merge: function( toAdd ){
      var _p = this._private;
      var cy = _p.cy;    
      
      if( !toAdd ){
        return this;
      }
      
      if( $$.is.string(toAdd) ){
        var selector = toAdd;
        toAdd = cy.elements(selector);
      }

      for( var i = 0; i < toAdd.length; i++ ){
        var toAddEle = toAdd[i];
        var id = toAddEle.id();
        var add = !_p.ids[ id ];

        if( add ){
          var index = this.length++;

          this[ index ] = toAddEle;
          _p.ids[ id ] = toAddEle;
          _p.indexes[ id ] = index;
        }
      }
      
      return this; // chaining
    },

    // remove single ele in place in calling collection
    unmergeOne: function( ele ){
      ele = ele[0];

      var _p = this._private;
      var id = ele.id();
      var i = _p.indexes[ id ];

      if( i == null ){
        return this; // no need to remove
      }

      // remove ele
      this[i] = undefined;
      _p.ids[ id ] = undefined;
      _p.indexes[ id ] = undefined;

      var unmergedLastEle = i === this.length - 1;

      // replace empty spot with last ele in collection
      if( this.length > 1 && !unmergedLastEle ){
        var lastEleI = this.length - 1;
        var lastEle = this[ lastEleI ];

        this[ lastEleI ] = undefined;
        this[i] = lastEle;
        _p.indexes[ lastEle.id() ] = i;
      }

      // the collection is now 1 ele smaller
      this.length--;

      return this;
    },

    // remove eles in place on calling collection
    unmerge: function( toRemove ){
      var cy = this._private.cy;    
      
      if( !toRemove ){
        return this;
      }

      if( $$.is.string(toRemove) ){
        var selector = toRemove;
        toRemove = cy.elements(selector);
      }

      for( var i = 0; i < toRemove.length; i++ ){
        this.unmergeOne( toRemove[i] );
      }
      
      return this; // chaining
    },

    map: function( mapFn, thisArg ){
      var arr = [];
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var ret = thisArg ? mapFn.apply( thisArg, [ele, i, eles] ) : mapFn( ele, i, eles );

        arr.push( ret );
      }

      return arr;
    },

    stdFilter: function( fn, thisArg ){
      var filterEles = [];
      var eles = this;
      var cy = this._private.cy;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var include = thisArg ? fn.apply( thisArg, [ele, i, eles] ) : fn( ele, i, eles );

        if( include ){
          filterEles.push( ele );
        }
      }

      return new $$.Collection( cy, filterEles );
    },

    max: function( valFn, thisArg ){
      var max = -Infinity;
      var maxEle;
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

        if( val > max ){
          max = val;
          maxEle = ele;
        }
      }

      return {
        value: max,
        ele: maxEle
      };
    },

    min: function( valFn, thisArg ){
      var min = Infinity;
      var minEle;
      var eles = this;

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var val = thisArg ? valFn.apply( thisArg, [ ele, i, eles ] ) : valFn( ele, i, eles );

        if( val < min ){
          min = val;
          minEle = ele;
        }
      }

      return {
        value: min,
        ele: minEle
      };
    }
  });

  // aliases
  var fn = $$.elesfn;
  fn['u'] = fn['|'] = fn['+'] = fn.union = fn.or = fn.add;
  fn['\\'] = fn['!'] = fn['-'] = fn.difference = fn.relativeComplement = fn.not;
  fn['n'] = fn['&'] = fn['.'] = fn.and = fn.intersection = fn.intersect;
  fn['^'] = fn['(+)'] = fn['(-)'] = fn.symmetricDifference = fn.symdiff = fn.xor;
  fn.fnFilter = fn.filterFn = fn.stdFilter;
  fn.complement = fn.abscomp = fn.absoluteComplement;
  
})( cytoscape );
;(function($$){ 'use strict';

  $$.fn.eles({
    isNode: function(){
      return this.group() === 'nodes';
    },

    isEdge: function(){
      return this.group() === 'edges';
    },

    isLoop: function(){
      return this.isEdge() && this.source().id() === this.target().id();
    },

    isSimple: function(){
      return this.isEdge() && this.source().id() !== this.target().id();
    },

    group: function(){
      var ele = this[0];

      if( ele ){
        return ele._private.group;
      }
    }
  });

  
})( cytoscape );

;(function($$){ 'use strict';
  
  // Functions for iterating over collections
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({
    each: function(fn){
      if( $$.is.fn(fn) ){
        for(var i = 0; i < this.length; i++){
          var ele = this[i];
          var ret = fn.apply( ele, [ i, ele ] );

          if( ret === false ){ break; } // exit each early on return false
        }
      }
      return this;
    },

    forEach: function(fn, thisArg){
      if( $$.is.fn(fn) ){

        for(var i = 0; i < this.length; i++){
          var ele = this[i];
          var ret = thisArg ? fn.apply( thisArg, [ ele, i, this ] ) : fn( ele, i, this );

          if( ret === false ){ break; } // exit each early on return false
        }
      }

      return this;
    },

    toArray: function(){
      var array = [];
      
      for(var i = 0; i < this.length; i++){
        array.push( this[i] );
      }
      
      return array;
    },

    slice: function(start, end){
      var array = [];
      var thisSize = this.length;
      
      if( end == null ){
        end = thisSize;
      }

      if( start == null ){
        start = 0;
      }
      
      if( start < 0 ){
        start = thisSize + start;
      }

      if( end < 0 ){
        end = thisSize + end;
      }
      
      for(var i = start; i >= 0 && i < end && i < thisSize; i++){
        array.push( this[i] );
      }
      
      return new $$.Collection(this.cy(), array);
    },

    size: function(){
      return this.length;
    },

    eq: function(i){
      return this[i] || new $$.Collection( this.cy() );
    },

    first: function(){
      return this[0] || new $$.Collection( this.cy() );
    },

    last: function(){
      return this[ this.length - 1 ] || new $$.Collection( this.cy() );
    },

    empty: function(){
      return this.length === 0;
    },

    nonempty: function(){
      return !this.empty();
    },

    sort: function( sortFn ){
      if( !$$.is.fn( sortFn ) ){
        return this;
      }

      var cy = this.cy();      
      var sorted = this.toArray().sort( sortFn );

      return new $$.Collection(cy, sorted);
    },

    sortByZIndex: function(){
      return this.sort( $$.Collection.zIndexSort );
    },

    zDepth: function(){
      var ele = this[0];
      if( !ele ){ return undefined; }

      // var cy = ele.cy();
      var _p = ele._private;
      var group = _p.group;

      if( group === 'nodes' ){
        var depth = _p.data.parent ? ele.parents().size() : 0;
        
        if( !ele.isParent() ){
          return Number.MAX_VALUE; // childless nodes always on top
        }
        
        return depth;
      } else {
        var src = _p.source;
        var tgt = _p.target;
        var srcDepth = src.zDepth();
        var tgtDepth = tgt.zDepth();

        return Math.max( srcDepth, tgtDepth, 0 ); // depth of deepest parent
      }
    }
  });

  $$.Collection.zIndexSort = function(a, b){
    var cy = a.cy();
    var a_p = a._private;
    var b_p = b._private;
    var zDiff = a_p.style['z-index'].value - b_p.style['z-index'].value;
    var depthA = 0;
    var depthB = 0;
    var hasCompoundNodes = cy.hasCompoundNodes();
    var aIsNode = a_p.group === 'nodes';
    var aIsEdge = a_p.group === 'edges';
    var bIsNode = b_p.group === 'nodes';
    var bIsEdge = b_p.group === 'edges';

    // no need to calculate element depth if there is no compound node
    if( hasCompoundNodes ){
      depthA = a.zDepth();
      depthB = b.zDepth();
    }

    var depthDiff = depthA - depthB;
    var sameDepth = depthDiff === 0;

    if( sameDepth ){
      
      if( aIsNode && bIsEdge ){      
        return 1; // 'a' is a node, it should be drawn later       
      
      } else if( aIsEdge && bIsNode ){
        return -1; // 'a' is an edge, it should be drawn first

      } else { // both nodes or both edges        
        if( zDiff === 0 ){ // same z-index => compare indices in the core (order added to graph w/ last on top)
          return a_p.index - b_p.index;
        } else {
          return zDiff;
        }
      }
    
    // elements on different level
    } else {      
      return depthDiff; // deeper element should be drawn later
    }

  };
  
})( cytoscape );

;(function($$){ 'use strict';
  
  // Functions for layouts on nodes
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  $$.fn.eles({

    // using standard layout options, apply position function (w/ or w/o animation)
    layoutPositions: function( layout, options, fn ){
      var nodes = this.nodes();
      var cy = this.cy();

      layout.trigger({ type: 'layoutstart', layout: layout });

      if( options.animate ){
        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var lastNode = i === nodes.length - 1;

          var newPos = fn.call( node, i, node );
          var pos = node.position();

          if( !$$.is.number(pos.x) || !$$.is.number(pos.y) ){
            node.silentPosition({ x: 0, y: 0 });
          }

          node.animate({
            position: newPos
          }, {
            duration: options.animationDuration,
            step: !lastNode ? undefined : function(){
              if( options.fit ){
                cy.fit( options.eles, options.padding );
              } 
            },
            complete: !lastNode ? undefined : function(){
              if( options.zoom != null ){
                cy.zoom( options.zoom );
              }

              if( options.pan ){
                cy.pan( options.pan );
              } 

              if( options.fit ){
                cy.fit( options.eles, options.padding );
              } 
              
              layout.one('layoutstop', options.stop);
              layout.trigger({ type: 'layoutstop', layout: layout });
            }
          });
        }

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
      } else {
        nodes.positions( fn );

        if( options.fit ){
          cy.fit( options.eles, options.padding );
        }

        if( options.zoom != null ){
          cy.zoom( options.zoom );
        }

        if( options.pan ){
          cy.pan( options.pan );
        } 

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
        
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      }

      return this; // chaining
    },

    layout: function( options ){
      var cy = this.cy();

      cy.layout( $$.util.extend({}, options, {
        eles: this
      }) );

      return this;
    },

    makeLayout: function( options ){
      var cy = this.cy();

      return cy.makeLayout( $$.util.extend({}, options, {
        eles: this
      }) );
    }

  });

  // aliases:
  $$.elesfn.createLayout = $$.elesfn.makeLayout;
  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({

    // fully updates (recalculates) the style for the elements
    updateStyle: function( notifyRenderer ){
      var cy = this._private.cy;

      if( !cy.styleEnabled() ){ return this; }

      if( cy._private.batchingStyle ){
        var bEles = cy._private.batchStyleEles;

        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];

          if( !bEles.ids[ ele._private.id ] ){
            bEles.push( ele );
          }
        }

        return this; // chaining and exit early when batching
      }

      var style = cy.style();
      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

      style.apply( this );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

      if( notifyRenderer ){
        toNotify.rtrigger('style'); // let renderer know we changed style
      } else {
        toNotify.trigger('style'); // just fire the event
      }
      return this; // chaining
    },

    // just update the mappers in the elements' styles; cheaper than eles.updateStyle()
    updateMappers: function( notifyRenderer ){
      var cy = this._private.cy;
      var style = cy.style();
      notifyRenderer = notifyRenderer || notifyRenderer === undefined ? true : false;

      if( !cy.styleEnabled() ){ return this; }

      style.updateMappers( this );

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;

      if( notifyRenderer ){
        toNotify.rtrigger('style'); // let renderer know we changed style
      } else {
        toNotify.trigger('style'); // just fire the event
      }
      return this; // chaining
    },

    // get the specified css property as a rendered value (i.e. on-screen value)
    // or get the whole rendered style if no property specified (NB doesn't allow setting)
    renderedCss: function( property ){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return this; }

      var ele = this[0];

      if( ele ){
        var renstyle = ele.cy().style().getRenderedStyle( ele );

        if( property === undefined ){
          return renstyle;
        } else {
          return renstyle[ property ];
        }
      }
    },

    // read the calculated css style of the element or override the style (via a bypass)
    css: function( name, value ){
      var cy = this.cy();
      
      if( !cy.styleEnabled() ){ return this; }

      var updateTransitions = false;
      var style = cy.style();

      if( $$.is.plainObject(name) ){ // then extend the bypass
        var props = name;
        style.applyBypass( this, props, updateTransitions );

        var updatedCompounds = this.updateCompoundBounds();
        var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
        toNotify.rtrigger('style'); // let the renderer know we've updated style

      } else if( $$.is.string(name) ){
  
        if( value === undefined ){ // then get the property from the style
          var ele = this[0];

          if( ele ){
            return ele._private.style[ name ].strValue;
          } else { // empty collection => can't get any value
            return;
          }

        } else { // then set the bypass with the property value
          style.applyBypass( this, name, value, updateTransitions );

          var updatedCompounds = this.updateCompoundBounds();
          var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
          toNotify.rtrigger('style'); // let the renderer know we've updated style
        }

      } else if( name === undefined ){
        var ele = this[0];

        if( ele ){
          return style.getRawStyle( ele );
        } else { // empty collection => can't get any value
          return;
        }
      }

      return this; // chaining
    },

    removeCss: function( names ){
      var cy = this.cy();
      
      if( !cy.styleEnabled() ){ return this; }

      var updateTransitions = false;
      var style = cy.style();
      var eles = this;

      if( names === undefined ){
        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          style.removeAllBypasses( ele, updateTransitions );
        }
      } else {
        names = names.split(/\s+/);

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          style.removeBypasses( ele, names, updateTransitions );
        }
      }

      var updatedCompounds = this.updateCompoundBounds();
      var toNotify = updatedCompounds.length > 0 ? this.add( updatedCompounds ) : this;
      toNotify.rtrigger('style'); // let the renderer know we've updated style

      return this; // chaining
    },

    show: function(){
      this.css('display', 'element');
      return this; // chaining
    },

    hide: function(){
      this.css('display', 'none');
      return this; // chaining
    },

    visible: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return true; }

      var ele = this[0];
      var hasCompoundNodes = cy.hasCompoundNodes();

      if( ele ){
        var style = ele._private.style;

        if(
          style['visibility'].value !== 'visible'
          || style['display'].value !== 'element'
        ){
          return false;
        }
        
        if( ele._private.group === 'nodes' ){
          if( !hasCompoundNodes ){ return true; }

          var parents = ele._private.data.parent ? ele.parents() : null;

          if( parents ){
            for( var i = 0; i < parents.length; i++ ){
              var parent = parents[i];
              var pStyle = parent._private.style;
              var pVis = pStyle['visibility'].value;
              var pDis = pStyle['display'].value;

              if( pVis !== 'visible' || pDis !== 'element' ){
                return false;
              }
            }
          }

          return true;
        } else {
          var src = ele._private.source;
          var tgt = ele._private.target;

          return src.visible() && tgt.visible();
        }

      }
    },

    hidden: function(){
      var ele = this[0];

      if( ele ){
        return !ele.visible();
      }
    },

    effectiveOpacity: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return 1; }

      var hasCompoundNodes = cy.hasCompoundNodes();
      var ele = this[0];

      if( ele ){
        var _p = ele._private;
        var parentOpacity = _p.style.opacity.value;

        if( !hasCompoundNodes ){ return parentOpacity; }

        var parents = !_p.data.parent ? null : ele.parents();
        
        if( parents ){
          for( var i = 0; i < parents.length; i++ ){
            var parent = parents[i];
            var opacity = parent._private.style.opacity.value;

            parentOpacity = opacity * parentOpacity;
          }
        }

        return parentOpacity;
      }
    },

    transparent: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return false; }

      var ele = this[0];
      var hasCompoundNodes = ele.cy().hasCompoundNodes();

      if( ele ){
        if( !hasCompoundNodes ){
          return ele._private.style.opacity.value === 0;
        } else {
          return ele.effectiveOpacity() === 0;
        }
      }
    },

    isFullAutoParent: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return false; }

      var ele = this[0];

      if( ele ){
        var autoW = ele._private.style['width'].value === 'auto';
        var autoH = ele._private.style['height'].value === 'auto';

        return ele.isParent() && autoW && autoH;
      }
    },

    backgrounding: function(){
      var cy = this.cy();
      if( !cy.styleEnabled() ){ return false; }

      var ele = this[0];

      return ele._private.backgrounding ? true : false;
    }

  });


  $$.elesfn.bypass = $$.elesfn.style = $$.elesfn.css;
  $$.elesfn.renderedStyle = $$.elesfn.renderedCss;
  $$.elesfn.removeBypass = $$.elesfn.removeStyle = $$.elesfn.removeCss;
  
})( cytoscape );
;(function($$){ 'use strict';
  
  // Collection functions that toggle a boolean value
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  
  
  function defineSwitchFunction(params){
    return function(){
      var args = arguments;
      var changedEles = [];
      
      // e.g. cy.nodes().select( data, handler )
      if( args.length === 2 ){
        var data = args[0];
        var handler = args[1];
        this.bind( params.event, data, handler );
      } 
      
      // e.g. cy.nodes().select( handler )
      else if( args.length === 1 ){
        var handler = args[0];
        this.bind( params.event, handler );
      }
      
      // e.g. cy.nodes().select()
      else if( args.length === 0 ){
        for( var i = 0; i < this.length; i++ ){
          var ele = this[i];
          var able = !params.ableField || ele._private[params.ableField];
          var changed = ele._private[params.field] != params.value;

          if( params.overrideAble ){
            var overrideAble = params.overrideAble(ele);

            if( overrideAble !== undefined ){
              able = overrideAble;

              if( !overrideAble ){ return this; } // to save cycles assume not able for all on override
            }
          }

          if( able ){
            ele._private[params.field] = params.value;

            if( changed ){
              changedEles.push( ele );
            }
          }
        }

        var changedColl = $$.Collection( this.cy(), changedEles );
        changedColl.updateStyle(); // change of state => possible change of style
        changedColl.trigger( params.event );
      }

      return this;
    };
  }
  
  function defineSwitchSet( params ){
    $$.elesfn[ params.field ] = function(){
      var ele = this[0];

      if( ele ){
        if( params.overrideField ){
          var val = params.overrideField(ele);

          if( val !== undefined ){
            return val;
          }
        }

        return ele._private[ params.field ];
      }
    };
    
    $$.elesfn[ params.on ] = defineSwitchFunction({
      event: params.on,
      field: params.field,
      ableField: params.ableField,
      overrideAble: params.overrideAble,
      value: true
    });

    $$.elesfn[ params.off ] = defineSwitchFunction({
      event: params.off,
      field: params.field,
      ableField: params.ableField,
      overrideAble: params.overrideAble,
      value: false
    });
  }
  
  defineSwitchSet({
    field: 'locked',
    overrideField: function(ele){
      return ele.cy().autolock() ? true : undefined;
    },
    on: 'lock',
    off: 'unlock'
  });
  
  defineSwitchSet({
    field: 'grabbable',
    overrideField: function(ele){
      return ele.cy().autoungrabify() ? false : undefined;
    },
    on: 'grabify',
    off: 'ungrabify'
  });
  
  defineSwitchSet({
    field: 'selected',
    ableField: 'selectable',
    overrideAble: function(ele){
      return ele.cy().autounselectify() ? false : undefined;
    },
    on: 'select',
    off: 'unselect'
  });
  
  defineSwitchSet({
    field: 'selectable',
    overrideField: function(ele){
      return ele.cy().autounselectify() ? false : undefined;
    },
    on: 'selectify',
    off: 'unselectify'
  });

  $$.elesfn.deselect = $$.elesfn.unselect;
  
  $$.elesfn.grabbed = function(){
    var ele = this[0];
    if( ele ){
      return ele._private.grabbed;
    }
  };

  defineSwitchSet({
    field: 'active',
    on: 'activate',
    off: 'unactivate'
  });

  $$.elesfn.inactive = function(){
    var ele = this[0];
    if( ele ){
      return !ele._private.active;
    }
  };
  
})( cytoscape );

;(function($$){ 'use strict';

  // DAG functions
  //////////////////////////

  $$.fn.eles({
    // get the root nodes in the DAG
    roots: function( selector ){
      var eles = this;
      var roots = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        if( !ele.isNode() ){
          continue;
        }

        var hasEdgesPointingIn = ele.connectedEdges(function(){
          return this.data('target') === ele.id() && this.data('source') !== ele.id();
        }).length > 0;

        if( !hasEdgesPointingIn ){
          roots.push( ele );
        }
      }

      return new $$.Collection( this._private.cy, roots, { unique: true } ).filter( selector );
    },

    // get the leaf nodes in the DAG
    leaves: function( selector ){
      var eles = this;
      var leaves = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        if( !ele.isNode() ){
          continue;
        }

        var hasEdgesPointingOut = ele.connectedEdges(function(){
          return this.data('source') === ele.id() && this.data('target') !== ele.id();
        }).length > 0;

        if( !hasEdgesPointingOut ){
          leaves.push( ele );
        }
      }

      return new $$.Collection( this._private.cy, leaves, { unique: true } ).filter( selector );
    },

    // normally called children in graph theory
    // these nodes =edges=> outgoing nodes
    outgoers: function( selector ){
      var eles = this;
      var oEles = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var eleId = ele.id();

        if( !ele.isNode() ){ continue; }

        var edges = ele._private.edges;
        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];
          var srcId = edge._private.data.source;
          var tgtId = edge._private.data.target;

          if( srcId === eleId && tgtId !== eleId ){
            oEles.push( edge );
            oEles.push( edge.target()[0] );
          }
        }
      }

      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );
    },

    // aka DAG descendants
    successors: function( selector ){
      var eles = this;
      var sEles = [];
      var sElesIds = {};

      for(;;){
        var outgoers = eles.outgoers();

        if( outgoers.length === 0 ){ break; } // done if no outgoers left

        var newOutgoers = false;
        for( var i = 0; i < outgoers.length; i++ ){
          var outgoer = outgoers[i];
          var outgoerId = outgoer.id();

          if( !sElesIds[ outgoerId ] ){
            sElesIds[ outgoerId ] = true;
            sEles.push( outgoer );
            newOutgoers = true;
          }
        }

        if( !newOutgoers ){ break; } // done if touched all outgoers already

        eles = outgoers;
      }

      return new $$.Collection( this._private.cy, sEles, { unique: true } ).filter( selector );
    },

    // normally called parents in graph theory
    // these nodes <=edges= incoming nodes
    incomers: function( selector ){
      var eles = this;
      var oEles = [];

      for( var i = 0; i < eles.length; i++ ){
        var ele = eles[i];
        var eleId = ele.id();

        if( !ele.isNode() ){ continue; }

        var edges = ele._private.edges;
        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];
          var srcId = edge._private.data.source;
          var tgtId = edge._private.data.target;

          if( tgtId === eleId && srcId !== eleId ){
            oEles.push( edge );
            oEles.push( edge.source()[0] );
          }
        }
      }

      return new $$.Collection( this._private.cy, oEles, { unique: true } ).filter( selector );
    },

    // aka DAG ancestors
    predecessors: function( selector ){
      var eles = this;
      var pEles = [];
      var pElesIds = {};

      for(;;){
        var incomers = eles.incomers();

        if( incomers.length === 0 ){ break; } // done if no incomers left

        var newIncomers = false;
        for( var i = 0; i < incomers.length; i++ ){
          var incomer = incomers[i];
          var incomerId = incomer.id();

          if( !pElesIds[ incomerId ] ){
            pElesIds[ incomerId ] = true;
            pEles.push( incomer );
            newIncomers = true;
          }
        }

        if( !newIncomers ){ break; } // done if touched all incomers already

        eles = incomers;
      }

      return new $$.Collection( this._private.cy, pEles, { unique: true } ).filter( selector );
    }
  });


  // Neighbourhood functions
  //////////////////////////

  $$.fn.eles({
    neighborhood: function(selector){
      var elements = [];
      var cy = this._private.cy;
      var nodes = this.nodes();

      for( var i = 0; i < nodes.length; i++ ){ // for all nodes
        var node = nodes[i];
        var connectedEdges = node.connectedEdges();

        // for each connected edge, add the edge and the other node
        for( var j = 0; j < connectedEdges.length; j++ ){
          var edge = connectedEdges[j];
          var otherNode = edge.connectedNodes().not(node);

          // need check in case of loop
          if( otherNode.length > 0 ){
            elements.push( otherNode[0] ); // add node 1 hop away
          }
          
          // add connected edge
          elements.push( edge[0] );
        }

      }
      
      return ( new $$.Collection( cy, elements, { unique: true } ) ).filter( selector );
    },

    closedNeighborhood: function(selector){
      return this.neighborhood().add( this ).filter( selector );
    },

    openNeighborhood: function(selector){
      return this.neighborhood( selector );
    }
  });  

  // aliases
  $$.elesfn.neighbourhood = $$.elesfn.neighborhood;
  $$.elesfn.closedNeighbourhood = $$.elesfn.closedNeighborhood;
  $$.elesfn.openNeighbourhood = $$.elesfn.openNeighborhood;


  // Edge functions
  /////////////////

  $$.fn.eles({
    source: function( selector ){
      var ele = this[0];
      var src;

      if( ele ){
        src = ele._private.source;
      }

      return src && selector ? src.filter( selector ) : src;
    },

    target: function( selector ){
      var ele = this[0];
      var tgt;

      if( ele ){
        tgt = ele._private.target;
      }

      return tgt && selector ? tgt.filter( selector ) : tgt;
    },

    sources: defineSourceFunction({
      attr: 'source'
    }),

    targets: defineSourceFunction({
      attr: 'target'
    })
  });
  
  function defineSourceFunction( params ){
    return function( selector ){
      var sources = [];
      var cy = this._private.cy;

      for( var i = 0; i < this.length; i++ ){
        var ele = this[i];
        var src = ele._private[ params.attr ];

        if( src ){
          sources.push( src );
        }
      }
      
      return new $$.Collection( cy, sources, { unique: true } ).filter( selector );
    };
  }

  $$.fn.eles({
    edgesWith: defineEdgesWithFunction(),

    edgesTo: defineEdgesWithFunction({
      thisIs: 'source'
    })
  });
  
  function defineEdgesWithFunction( params ){
    
    return function(otherNodes){
      var elements = [];
      var cy = this._private.cy;
      var p = params || {};

      // get elements if a selector is specified
      if( $$.is.string(otherNodes) ){
        otherNodes = cy.$( otherNodes );
      }
      
      var thisIds = this._private.ids;
      var otherIds = otherNodes._private.ids;
      
      for( var h = 0; h < otherNodes.length; h++ ){
        var edges = otherNodes[h]._private.edges;
        
        for( var i = 0; i < edges.length; i++ ){
          var edge = edges[i];
          var foundId;
          var edgeData = edge._private.data;
          var thisToOther = thisIds[ edgeData.source ] && otherIds[ edgeData.target ];
          var otherToThis = otherIds[ edgeData.source ] && thisIds[ edgeData.target ];
          var edgeConnectsThisAndOther = thisToOther || otherToThis;

          if( !edgeConnectsThisAndOther ){ continue; }

          if( p.thisIs ){
            if( p.thisIs === 'source' && !thisToOther ){ continue; }
            
            if( p.thisIs === 'target' && !otherToThis ){ continue; }
          }
          
          elements.push( edge );
        }
      }
      
      return new $$.Collection( cy, elements, { unique: true } );
    };
  }
  
  $$.fn.eles({
    connectedEdges: function( selector ){
      var retEles = [];
      var cy = this._private.cy;
      
      var eles = this;
      for( var i = 0; i < eles.length; i++ ){
        var node = eles[i];
        if( !node.isNode() ){ continue; }

        var edges = node._private.edges;

        for( var j = 0; j < edges.length; j++ ){
          var edge = edges[j];          
          retEles.push( edge );
        }
      }
      
      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );
    },

    connectedNodes: function( selector ){
      var retEles = [];
      var cy = this._private.cy;

      var eles = this;
      for( var i = 0; i < eles.length; i++ ){
        var edge = eles[i];
        if( !edge.isEdge() ){ continue; }

        retEles.push( edge.source()[0] );
        retEles.push( edge.target()[0] );
      }

      return new $$.Collection( cy, retEles, { unique: true } ).filter( selector );
    },

    parallelEdges: defineParallelEdgesFunction(),

    codirectedEdges: defineParallelEdgesFunction({
      codirected: true
    })
  });
  
  function defineParallelEdgesFunction(params){
    var defaults = {
      codirected: false
    };
    params = $$.util.extend({}, defaults, params);
    
    return function( selector ){
      var cy = this._private.cy;
      var elements = [];
      var edges = this.edges();
      var p = params;

      // look at all the edges in the collection
      for( var i = 0; i < edges.length; i++ ){
        var edge1 = edges[i];
        var src1 = edge1.source()[0];
        var srcid1 = src1.id();
        var tgt1 = edge1.target()[0];
        var tgtid1 = tgt1.id();
        var srcEdges1 = src1._private.edges;

        // look at edges connected to the src node of this edge
        for( var j = 0; j < srcEdges1.length; j++ ){
          var edge2 = srcEdges1[j];
          var edge2data = edge2._private.data;
          var tgtid2 = edge2data.target;
          var srcid2 = edge2data.source;

          var codirected = tgtid2 === tgtid1 && srcid2 === srcid1;
          var oppdirected = srcid1 === tgtid2 && tgtid1 === srcid2;
          
          if( (p.codirected && codirected) || (!p.codirected && (codirected || oppdirected)) ){
            elements.push( edge2 );
          }
        }
      }
      
      return new $$.Collection( cy, elements, { unique: true } ).filter( selector );
    };
  
  }

  
})( cytoscape );

;(function($$){ 'use strict';

  $$.fn.eles({

    fit: function(){},
    center: function(){}

  });
  
})( cytoscape );
;(function ($$) {
  "use strict";

  /*  Min and Max heap predefaults */
  
  $$.Minheap = function (cy, eles, valueFn) {
    return new $$.Heap(cy, eles, $$.Heap.minHeapComparator, valueFn);
  };

  $$.Maxheap = function (cy, eles, valueFn) {
    return new $$.Heap(cy, eles, $$.Heap.maxHeapComparator, valueFn);
  };
  
  $$.Heap = function (cy, eles, comparator, valueFn) {
    if (typeof comparator === "undefined" || typeof eles === "undefined") {
      return;
    }
    
    if (typeof valueFn === "undefined") {
      valueFn = $$.Heap.idFn;
    }

    var sourceHeap = [],
      pointers = {},
      elements = [],
      i = 0,
      id,
      heap,
      elesLen;

    eles = this.getArgumentAsCollection(eles, cy);
    elesLen = eles.length;

    for (i = 0; i < elesLen; i += 1) {
      sourceHeap.push(valueFn.call(cy, eles[i], i, eles));

      id = eles[i].id();
      
      if (pointers.hasOwnProperty(id)) {
        throw "ERROR: Multiple items with the same id found: " + id;
      }
      
      pointers[id] = i;
      elements.push(id);
    }

    this._private = {
      cy: cy,
      heap: sourceHeap,
      pointers: pointers,
      elements: elements,
      comparator: comparator,
      extractor: valueFn,
      length: elesLen
    };

    for (i = Math.floor(elesLen / 2); i >= 0; i -= 1) {
      heap = this.heapify(i);
    }

    return heap;
  };

  /* static methods */
  $$.Heap.idFn = function (node) {
    return node.id();
  };

  $$.Heap.minHeapComparator = function (a, b) {
    return a >= b;
  };

  $$.Heap.maxHeapComparator = function (a, b) {
    return a <= b;
  };

  $$.fn.heap = function( fnMap, options ){
    for( var name in fnMap ){
      var fn = fnMap[name];
      $$.Heap.prototype[ name ] = fn;
    }
  };

  $$.heapfn = $$.Heap.prototype; // short alias

  /* object methods */
  $$.heapfn.size = function () {
    return this._private.length;
  };

  $$.heapfn.getArgumentAsCollection = function (eles, cy) {
    var result;
    if(typeof cy === "undefined") {
      cy = this._private.cy;
    }

    if ($$.is.elementOrCollection(eles)) {
      result = eles;

    } else {
      var resultArray = [],
        sourceEles = [].concat.apply([], [eles]);

      for (var i = 0; i < sourceEles.length; i++) {
        var id = sourceEles[i],
          ele = cy.getElementById(id);

        if(ele.length > 0) {
          resultArray.push(ele);
        }
      }

      result = new $$.Collection(cy, resultArray);
    }

    return result;
  };

  $$.heapfn.isHeap = function () {
    var array = this._private.heap,
      arrlen = array.length,
      i,
      left,
      right,
      lCheck,
      rCheck,
      comparator = this._private.comparator;

    for (i = 0; i < arrlen; i += 1) {
      left = 2 * i + 1;
      right = left + 1;
      lCheck = left < arrlen ? comparator(array[left], array[i]) : true;
      rCheck = right < arrlen ? comparator(array[right], array[i]) : true;

      if (!lCheck || !rCheck) {
        return false;
      }
    }

    return true;
  };

  $$.heapfn.heapSwap = function (i, j) {
    var heap = this._private.heap,
      pointers = this._private.pointers,
      elements = this._private.elements,
      swapValue = heap[i],
      swapElems = elements[i],
      idI = elements[i],
      idJ = elements[j];

    heap[i] = heap[j];
    elements[i] = elements[j];

    pointers[idI] = j;
    pointers[idJ] = i;

    heap[j] = swapValue;
    elements[j] = swapElems;
  };

  $$.heapfn.heapify = function (i, rootToLeaf) {
    var treeLen = 0,
      condHeap = false,
      array,
      current,
      left,
      right,
      best,
      comparator,
      parent;
    
    if (typeof rootToLeaf === "undefined") {
      rootToLeaf = true;
    }

    array = this._private.heap;
    treeLen = array.length;
    comparator = this._private.comparator;
    current = i;

    while (!condHeap) {

      if (rootToLeaf) {
        left = 2 * current + 1;
        right = left + 1;
        best = current;
        
        if (left < treeLen && !comparator(array[left], array[best])) {
          best = left;
        }
        
        if (right < treeLen && !comparator(array[right], array[best])) {
          best = right;
        }
        
        condHeap = best === current;
        
        if (!condHeap) {
          this.heapSwap(best, current);
          current = best;
        }

      } else {
        parent = Math.floor((current - 1) / 2);
        best = current;
        condHeap = parent < 0 || comparator(array[best], array[parent]);

        if (!condHeap) {
          this.heapSwap(best, parent);
          current = parent;
        }
      }

    } // while
  };

  /* collectionOrElement */
  $$.heapfn.insert = function (eles) {
    var elements = this.getArgumentAsCollection(eles),
      elsize = elements.length,
      element,
      elindex,
      elvalue,
      elid,
      i;

    for (i = 0; i < elsize; i += 1) {
      element = elements[i];
      elindex = this._private.heap.length;
      elvalue = this._private.extractor(element);
      elid = element.id();

      if (this._private.pointers.hasOwnProperty(elid)) {
        throw "ERROR: Multiple items with the same id found: " + elid;
      }

      this._private.heap.push(elvalue);
      this._private.elements.push(elid);
      this._private.pointers[elid] = elindex;
      this.heapify(elindex, false);
    }

    this._private.length = this._private.heap.length;
  };

  $$.heapfn.getValueById = function (elementId) {
    if (this._private.pointers.hasOwnProperty(elementId)) {
      var elementIndex = this._private.pointers[elementId];

      return this._private.heap[elementIndex];
    }
  };
  
  $$.heapfn.contains = function (eles) {
    var elements = this.getArgumentAsCollection(eles);

    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id();

      if(!this._private.pointers.hasOwnProperty(elementId)) {
        return false;
      }
    }

    return true;
  };
  
  $$.heapfn.top = function () {
    if (this._private.length > 0) {

      return {
        value: this._private.heap[0],
        id: this._private.elements[0]
      };

    }
  };

  $$.heapfn.pop = function () {
    if (this._private.length > 0) {
      var top = this.top(),
        lastIndex = this._private.length - 1,
        removeCandidate,
        removeValue,
        remId;

      this.heapSwap(0, lastIndex);

      removeCandidate = this._private.elements[lastIndex];
      removeValue = this._private.heap[lastIndex];
      remId = removeCandidate;

      this._private.heap.pop();
      this._private.elements.pop();
      this._private.length = this._private.heap.length;
      this._private.pointers[remId] = undefined;

      this.heapify(0);
      return top;
    }
  };

  $$.heapfn.findDirectionHeapify = function (index) {
    var parent = Math.floor((index - 1) / 2),
      array = this._private.heap,
      condHeap = parent < 0 || this._private.comparator(array[index], array[parent]);

    this.heapify(index, condHeap);
  };

  /* edit is a new value or function */
  // only values in heap are updated. elements themselves are not!
  $$.heapfn.edit = function (eles, edit) {
    var elements = this.getArgumentAsCollection(eles);
    
    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id(),
        elementIndex = this._private.pointers[elementId],
        elementValue = this._private.heap[elementIndex];
      
      if ($$.is.number(edit)) {
        this._private.heap[elementIndex] = edit;
        
      } else if ($$.is.fn(edit)) {
        this._private.heap[elementIndex] = edit.call(this._private.cy, elementValue, elementIndex);
      }

      this.findDirectionHeapify(elementIndex);
    }
  };

  $$.heapfn.remove = function (eles) {
    var elements = this.getArgumentAsCollection(eles);
    
    for (var i = 0; i < elements.length; i += 1) {
      var elementId = elements[i].id(),
        elementIndex = this._private.pointers[elementId],
        lastIndex = this._private.length - 1,
        removeCandidate,
        removeValue,
        remId;

      if (elementIndex !== lastIndex) {
        this.heapSwap(elementIndex, lastIndex);
      }

      removeCandidate = this._private.elements[lastIndex];
      removeValue = this._private.heap[lastIndex];
      remId = removeCandidate;

      this._private.heap.pop();
      this._private.elements.pop();
      this._private.length = this._private.heap.length;
      this._private.pointers[remId] = undefined;

      this.findDirectionHeapify(elementIndex);
    }

    return removeValue;
  };

})(cytoscape);
/*
  The canvas renderer was written by Yue Dong.

  Modifications tracked on Github.
*/

(function($$) { 'use strict';

  CanvasRenderer.CANVAS_LAYERS = 3;
  //
  CanvasRenderer.SELECT_BOX = 0;
  CanvasRenderer.DRAG = 1;
  CanvasRenderer.NODE = 2;

  CanvasRenderer.BUFFER_COUNT = 3;
  //
  CanvasRenderer.TEXTURE_BUFFER = 0;
  CanvasRenderer.MOTIONBLUR_BUFFER_NODE = 1;
  CanvasRenderer.MOTIONBLUR_BUFFER_DRAG = 2;

  function CanvasRenderer(options) {  

    this.options = options;

    this.data = {
        
      select: [undefined, undefined, undefined, undefined, 0], // Coordinates for selection box, plus enabled flag 
      renderer: this, cy: options.cy, container: options.cy.container(),
      
      canvases: new Array(CanvasRenderer.CANVAS_LAYERS),
      contexts: new Array(CanvasRenderer.CANVAS_LAYERS),
      canvasNeedsRedraw: new Array(CanvasRenderer.CANVAS_LAYERS),
      
      bufferCanvases: new Array(CanvasRenderer.BUFFER_COUNT),
      bufferContexts: new Array(CanvasRenderer.CANVAS_LAYERS)

    };
    
    //--Pointer-related data
    this.hoverData = {down: null, last: null, 
        downTime: null, triggerMode: null, 
        dragging: false, 
        initialPan: [null, null], capture: false};
    
    this.timeoutData = {panTimeout: null};
    
    this.dragData = {possibleDragElements: []};
    
    this.touchData = {start: null, capture: false,
        // These 3 fields related to tap, taphold events
        startPosition: [null, null, null, null, null, null],
        singleTouchStartTime: null,
        singleTouchMoved: true,
        
        
        now: [null, null, null, null, null, null], 
        earlier: [null, null, null, null, null, null] };
    //--
    
    //--Wheel-related data 
    this.zoomData = {freeToZoom: false, lastPointerX: null};
    //--
    
    this.redraws = 0;
    this.showFps = options.showFps;

    this.bindings = [];
    
    this.data.canvasContainer = document.createElement('div');
    var containerStyle = this.data.canvasContainer.style;
    containerStyle.position = 'absolute';
    containerStyle.zIndex = '0';
    containerStyle.overflow = 'hidden';

    this.data.container.appendChild( this.data.canvasContainer );

    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {
      this.data.canvases[i] = document.createElement('canvas');
      this.data.contexts[i] = this.data.canvases[i].getContext('2d');
      this.data.canvases[i].style.position = 'absolute';
      this.data.canvases[i].setAttribute('data-id', 'layer' + i);
      this.data.canvases[i].style.zIndex = String(CanvasRenderer.CANVAS_LAYERS - i);
      this.data.canvasContainer.appendChild(this.data.canvases[i]);
      
      this.data.canvasNeedsRedraw[i] = false;
    }
    this.data.topCanvas = this.data.canvases[0];

    this.data.canvases[CanvasRenderer.NODE].setAttribute('data-id', 'layer' + CanvasRenderer.NODE + '-node');
    this.data.canvases[CanvasRenderer.SELECT_BOX].setAttribute('data-id', 'layer' + CanvasRenderer.SELECT_BOX + '-selectbox');
    this.data.canvases[CanvasRenderer.DRAG].setAttribute('data-id', 'layer' + CanvasRenderer.DRAG + '-drag');
    
    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {
      this.data.bufferCanvases[i] = document.createElement('canvas');
      this.data.bufferContexts[i] = this.data.bufferCanvases[i].getContext('2d');
      this.data.bufferCanvases[i].style.position = 'absolute';
      this.data.bufferCanvases[i].setAttribute('data-id', 'buffer' + i);
      this.data.bufferCanvases[i].style.zIndex = String(-i - 1);
      this.data.bufferCanvases[i].style.visibility = 'hidden';
      //this.data.canvasContainer.appendChild(this.data.bufferCanvases[i]);
    }

    this.hideEdgesOnViewport = options.hideEdgesOnViewport;
    this.hideLabelsOnViewport = options.hideLabelsOnViewport;
    this.textureOnViewport = options.textureOnViewport;
    this.wheelSensitivity = options.wheelSensitivity;
    this.motionBlurEnabled = options.motionBlur; // on by default
    this.forcedPixelRatio = options.pixelRatio;
    this.motionBlur = true; // for initial kick off
    this.motionBlurOpacity = options.motionBlurOpacity;
    this.motionBlurTransparency = 1 - this.motionBlurOpacity;
    this.motionBlurPxRatio = 1;
    this.mbPxRBlurry = 1; //0.8;
    this.minMbLowQualFrames = 4;
    this.fullQualityMb = false;
    this.clearedForMotionBlur = [];
    this.desktopTapThreshold = options.desktopTapThreshold;
    this.desktopTapThreshold2 = options.desktopTapThreshold * options.desktopTapThreshold;
    this.touchTapThreshold = options.touchTapThreshold;
    this.touchTapThreshold2 = options.touchTapThreshold * options.touchTapThreshold;
    this.tapholdDuration = 500;

    this.load();
  }

  CanvasRenderer.panOrBoxSelectDelay = 400;

  // whether to use Path2D caching for drawing
  var pathsImpld = typeof Path2D !== 'undefined';
  CanvasRenderer.usePaths = function(){
    return pathsImpld;
  };

  CanvasRenderer.prototype.notify = function(params) {
    var types;

    if( $$.is.array( params.type ) ){
      types = params.type;

    } else {
      types = [ params.type ];
    }

    for( var i = 0; i < types.length; i++ ){
      var type = types[i];

      switch( type ){
        case 'destroy':
          this.destroy();
          return;

        case 'add':
        case 'remove':
        case 'load':
          this.updateNodesCache();
          this.updateEdgesCache();
          break;

        case 'viewport':
          this.data.canvasNeedsRedraw[CanvasRenderer.SELECT_BOX] = true;
          break;

        case 'style':
          this.updateCachedZSortedEles();
          break;
      }

      if( type === 'load' || type === 'resize' ){
        this.invalidateContainerClientCoordsCache();
        this.matchCanvasSize(this.data.container);
      }
    } // for
    
    this.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
    this.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;

    this.redraw();
  };

  CanvasRenderer.prototype.destroy = function(){
    this.destroyed = true;

    for( var i = 0; i < this.bindings.length; i++ ){
      var binding = this.bindings[i];
      var b = binding;

      b.target.removeEventListener(b.event, b.handler, b.useCapture);
    }

    if( this.removeObserver ){
      this.removeObserver.disconnect();
    }

    if( this.labelCalcDiv ){
      document.body.removeChild(this.labelCalcDiv);
    }
  };

  

  // copy the math functions into the renderer prototype
  // unfortunately these functions are used interspersed t/o the code
  // and this makes sure things work just in case a ref was missed in refactoring
  // TODO remove this eventually
  for( var fnName in $$.math ){
    CanvasRenderer.prototype[ fnName ] = $$.math[ fnName ];
  }
  
  
  $$('renderer', 'canvas', CanvasRenderer);
  
})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var rendFunc = CanvasRenderer.prototype;
  var arrowShapes = CanvasRenderer.arrowShapes = {};

  CanvasRenderer.arrowShapeHeight = 0.3;

  // Contract for arrow shapes:
  // 0, 0 is arrow tip
  // (0, 1) is direction towards node
  // (1, 0) is right
  //
  // functional api:
  // collide: check x, y in shape
  // roughCollide: called before collide, no false negatives
  // draw: draw
  // spacing: dist(arrowTip, nodeBoundary)
  // gap: dist(edgeTip, nodeBoundary), edgeTip may != arrowTip

  var bbCollide = function(x, y, centerX, centerY, width, height, direction, padding){
    var x1 = centerX - width/2;
    var x2 = centerX + width/2;
    var y1 = centerY - height/2;
    var y2 = centerY + height/2;

    return (x1 <= x && x <= x2) && (y1 <= y && y <= y2);
  };

  var transform = function(x, y, size, angle, translation){
    angle = -angle; // b/c of notation used in arrow draw fn

    var xRotated = x * Math.cos(angle) - y * Math.sin(angle);
    var yRotated = x * Math.sin(angle) + y * Math.cos(angle);
    
    var xScaled = xRotated * size;
    var yScaled = yRotated * size;

    var xTranslated = xScaled + translation.x;
    var yTranslated = yScaled + translation.y;
    
    return {
      x: xTranslated,
      y: yTranslated
    };
  };

  arrowShapes['arrow'] = {
    _points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['arrow']._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['arrow']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }

    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['triangle'] = arrowShapes['arrow'];
  
  arrowShapes['triangle-backcurve'] = {
    _ctrlPt: [ 0, -0.15 ],

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['triangle']._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['triangle']._points;
      var firstPt;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        if( i === 0 ){
          firstPt = pt;
        }

        context.lineTo(pt.x, pt.y);
      }

      var ctrlPt = this._ctrlPt;
      var ctrlPtTrans = transform( ctrlPt[0], ctrlPt[1], size, angle, translation );

      context.quadraticCurveTo( ctrlPtTrans.x, ctrlPtTrans.y, firstPt.x, firstPt.y );
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };
  

  arrowShapes['triangle-tee'] = {
    _points: [
      -0.15, -0.3,
      0, 0,
      0.15, -0.3,
      -0.15, -0.3
    ],

    _pointsTee: [
      -0.15, -0.4,
      -0.15, -0.5,
      0.15, -0.5,
      0.15, -0.4
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var triPts = arrowShapes['triangle-tee']._points;
      var teePts = arrowShapes['triangle-tee']._pointsTee;
      
      var inside = $$.math.pointInsidePolygon(x, y, teePts, centerX, centerY, width, height, direction, padding) 
        || $$.math.pointInsidePolygon(x, y, triPts, centerX, centerY, width, height, direction, padding);

      return inside;
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var triPts = arrowShapes['triangle-tee']._points;
      for (var i = 0; i < triPts.length / 2; i++){
        var pt = transform( triPts[ i * 2 ],  triPts[ i * 2 + 1 ], size, angle, translation );
        
        context.lineTo( pt.x, pt.y );
      }

      var teePts = arrowShapes['triangle-tee']._pointsTee;
      var firstTeePt = transform( teePts[0], teePts[1], size, angle, translation );
      context.moveTo( firstTeePt.x, firstTeePt.y );

      for (var i = 0; i < teePts.length / 2; i++){
        var pt = transform( teePts[ i * 2 ],  teePts[ i * 2 + 1 ], size, angle, translation );
        
        context.lineTo( pt.x, pt.y );
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['half-triangle-overshot'] = {
    _points: [
      0, -0.25,
      -0.5, -0.25,
      0.5, 0.25
    ],
    
    leavePathOpen: true,
    matchEdgeWidth: true,

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = this._points;
      
//      console.log("collide(): " + direction);
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = this._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['none'] = {
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      return false;
    },
    
    roughCollide: function(x, y, centerX, centerY, width, height, direction, padding) {
      return false;
    },
    
    draw: function(context) {
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return 0;
    }
  };
  
  arrowShapes['circle'] = {
    _baseRadius: 0.15,
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      // Transform x, y to get non-rotated ellipse
      
      if (width != height) {                  
        var aspectRatio = (height + padding) / (width + padding);
        y /= aspectRatio;
        centerY /= aspectRatio;
        
        return (Math.pow(centerX - x, 2) 
          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)
            * arrowShapes['circle']._baseRadius, 2));
      } else {
        return (Math.pow(centerX - x, 2) 
          + Math.pow(centerY - y, 2) <= Math.pow((width + padding)
            * arrowShapes['circle']._baseRadius, 2));
      }
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      context.arc(translation.x, translation.y, arrowShapes['circle']._baseRadius * size, 0, Math.PI * 2, false);
    },
    
    spacing: function(edge) {
      return rendFunc.getArrowWidth(edge._private.style['width'].pxValue)
        * arrowShapes['circle']._baseRadius;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };
  
  arrowShapes['inhibitor'] = {
    _points: [
      -0.25, 0,
      -0.25, -0.1,
      0.25, -0.1,
      0.25, 0
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['inhibitor']._points;
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['inhibitor']._points;
      
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 1;
    },
    
    gap: function(edge) {
      return 1;
    }
  };

  arrowShapes['tee'] = arrowShapes['inhibitor'];

  arrowShapes['square'] = {
    _points: [
      -0.15, 0.00,
      0.15, 0.00,
      0.15, -0.3,
      -0.15, -0.3
    ],
    
    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['square']._points;
      
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },
    
    roughCollide: bbCollide,
    
    draw: function(context, size, angle, translation) {
      var points = arrowShapes['square']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },

    gap: function(edge) {
      return edge._private.style['width'].pxValue * 2;
    }
  };

  arrowShapes['diamond'] = {
    _points: [
      -0.15, -0.15,
      0, -0.3,
      0.15, -0.15,
      0, 0
    ],

    collide: function(x, y, centerX, centerY, width, height, direction, padding) {
      var points = arrowShapes['diamond']._points;
          
      return $$.math.pointInsidePolygon(
        x, y, points, centerX, centerY, width, height, direction, padding);
    },

    roughCollide: bbCollide,

    draw: function(context, size, angle, translation) {
      var points = arrowShapes['diamond']._points;
    
      for (var i = 0; i < points.length / 2; i++) {
        var pt = transform( points[i * 2], points[i * 2 + 1], size, angle, translation );

        context.lineTo(pt.x, pt.y);
      }
    },
    
    spacing: function(edge) {
      return 0;
    },
    
    gap: function(edge) {
      return edge._private.style['width'].pxValue;
    }
  };

})( cytoscape );
;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  CRp.getCachedNodes = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    if (data.cache.cachedNodes == null) {
      data.cache.cachedNodes = cy.nodes();
    }
    
    return data.cache.cachedNodes;
  };
  
  CRp.updateNodesCache = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    data.cache.cachedNodes = cy.nodes();
  };
  
  CRp.getCachedEdges = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    if (data.cache.cachedEdges == null) {
      data.cache.cachedEdges = cy.edges();
    }
    
    return data.cache.cachedEdges;
  };
  
  CRp.updateEdgesCache = function() {
    var data = this.data; var cy = this.data.cy;
    
    if (data.cache == null) {
      data.cache = {};
    }
    
    data.cache.cachedEdges = cy.edges();
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // Project mouse
  CRp.projectIntoViewport = function(clientX, clientY) {
    var offsets = this.findContainerClientCoords();
    var offsetLeft = offsets[0];
    var offsetTop = offsets[1];
    
    var x = clientX - offsetLeft; 
    var y = clientY - offsetTop;
    
    x -= this.data.cy.pan().x; y -= this.data.cy.pan().y; x /= this.data.cy.zoom(); y /= this.data.cy.zoom();
    return [x, y];
  };

  CRp.findContainerClientCoords = function() {
    var container = this.data.container;

    var bb = this.containerBB = this.containerBB || container.getBoundingClientRect();

    return [bb.left, bb.top, bb.right - bb.left, bb.bottom - bb.top];
  };

  CRp.invalidateContainerClientCoordsCache = function(){
    this.containerBB = null;
  };

  // Find nearest element
  CRp.findNearestElement = function(x, y, visibleElementsOnly, isTouch){
    var self = this;
    var eles = this.getCachedZSortedEles();
    var near = [];
    var zoom = this.data.cy.zoom();
    var hasCompounds = this.data.cy.hasCompoundNodes();
    var edgeThreshold = (isTouch ? 24 : 8) / zoom;
    var nodeThreshold = (isTouch ? 8 : 2) / zoom;

    function checkNode(node){
      var width = node.outerWidth() + 2*nodeThreshold;
      var height = node.outerHeight() + 2*nodeThreshold;
      var hw = width/2;
      var hh = height/2;
      var pos = node._private.position;

      if(
        pos.x - hw <= x && x <= pos.x + hw // bb check x
          &&
        pos.y - hh <= y && y <= pos.y + hh // bb check y
      ){
        var visible = !visibleElementsOnly || ( node.visible() && !node.transparent() );

        // exit early if invisible edge and must be visible
        if( visibleElementsOnly && !visible ){
          return;
        }

        var shape = CanvasRenderer.nodeShapes[ self.getNodeShape(node) ];
        var borderWO = node._private.style['border-width'].pxValue / 2;

        if(
          shape.checkPoint(x, y, 0, width, height, pos.x, pos.y)
        ){
          near.push( node );
        }

      }
    }

    function checkEdge(edge){
      var rs = edge._private.rscratch;
      var style = edge._private.style;
      var width = style['width'].pxValue/2 + edgeThreshold; // more like a distance radius from centre
      var widthSq = width * width;
      var width2 = width * 2;
      var src = edge._private.source;
      var tgt = edge._private.target;
      var inEdgeBB = false;
      var sqDist;

      // exit early if invisible edge and must be visible
      var passedVisibilityCheck;
      var passesVisibilityCheck = function(){
        if( passedVisibilityCheck !== undefined ){
          return passedVisibilityCheck;
        }

        if( !visibleElementsOnly ){
          passedVisibilityCheck = true;
          return true;
        }

        var visible = edge.visible() && !edge.transparent();
        if( visible ){
          passedVisibilityCheck = true;
          return true;
        }

        passedVisibilityCheck = false;
        return false;
      };

      if (rs.edgeType === 'self' || rs.edgeType === 'compound') {
        if(
            (
              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY, widthSq))
                && passesVisibilityCheck() &&
              ( widthSq > (sqDist = $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY)) )
            )
              ||
            (
              (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY, widthSq))
                && passesVisibilityCheck() &&
              ( widthSq > (sqDist = $$.math.sqDistanceToQuadraticBezier(x, y, rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY)) )
            )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'haystack') {
        var radius = style['haystack-radius'].value;
        var halfRadius = radius/2; // b/c have to half width/height

        var tgtPos = tgt._private.position;
        var tgtW = tgt.width();
        var tgtH = tgt.height();
        var srcPos = src._private.position;
        var srcW = src.width();
        var srcH = src.height();

        var startX = srcPos.x + rs.source.x * srcW * halfRadius;
        var startY = srcPos.y + rs.source.y * srcH * halfRadius;
        var endX = tgtPos.x + rs.target.x * tgtW * halfRadius;
        var endY = tgtPos.y + rs.target.y * tgtH * halfRadius;

        if( 
          (inEdgeBB = $$.math.inLineVicinity(x, y, startX, startY, endX, endY, width2))
            && passesVisibilityCheck() &&
          widthSq > ( sqDist = $$.math.sqDistanceToFiniteLine( x, y, startX, startY, endX, endY ) )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'straight') {
        if(
          (inEdgeBB = $$.math.inLineVicinity(x, y, rs.startX, rs.startY, rs.endX, rs.endY, width2))
            && passesVisibilityCheck() &&
          widthSq > ( sqDist = $$.math.sqDistanceToFiniteLine(x, y, rs.startX, rs.startY, rs.endX, rs.endY) )
        ){
          near.push( edge );
        }
      
      } else if (rs.edgeType === 'bezier') {
        if(
          (inEdgeBB = $$.math.inBezierVicinity(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY, widthSq))
            && passesVisibilityCheck() &&
          (widthSq > (sqDist = $$.math.sqDistanceToQuadraticBezier(x, y, rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY)) )
        ){
          near.push( edge );
        }
      }
      
      // if we're close to the edge but didn't hit it, maybe we hit its arrows
      if( inEdgeBB && passesVisibilityCheck() && near.length === 0 || near[near.length - 1] !== edge ){
        var srcShape = CanvasRenderer.arrowShapes[ style['source-arrow-shape'].value ];
        var tgtShape = CanvasRenderer.arrowShapes[ style['target-arrow-shape'].value ];

        var src = src || edge._private.source;
        var tgt = tgt || edge._private.target;

        var tgtPos = tgt._private.position;
        var srcPos = src._private.position;

        var srcArW = self.getArrowWidth( style['width'].pxValue );
        var srcArH = self.getArrowHeight( style['width'].pxValue );

        var tgtArW = srcArW;
        var tgtArH = srcArH;

        if(
          (
            srcShape.roughCollide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], edgeThreshold)
              && 
            srcShape.collide(x, y, rs.arrowStartX, rs.arrowStartY, srcArW, srcArH, [rs.arrowStartX - srcPos.x, rs.arrowStartY - srcPos.y], edgeThreshold)
          )
            ||
          (
            tgtShape.roughCollide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], edgeThreshold)
              &&
            tgtShape.collide(x, y, rs.arrowEndX, rs.arrowEndY, tgtArW, tgtArH, [rs.arrowEndX - tgtPos.x, rs.arrowEndY - tgtPos.y], edgeThreshold)
          )
        ){
          near.push( edge );
        }
      }

      // for compound graphs, hitting edge may actually want a connected node instead (b/c edge may have greater z-index precedence)
      if( hasCompounds &&  near.length > 0 && near[ near.length - 1 ] === edge ){
        checkNode( src );
        checkNode( tgt );
      }
    }

    for( var i = eles.length - 1; i >= 0; i-- ){ // reverse order for precedence
      var ele = eles[i];

      if( near.length > 0 ){ break; } // since we check in z-order, first found is top and best result => exit early

      if( ele._private.group === 'nodes' ){ 
        checkNode( eles[i] );

      } else  { // then edge
        checkEdge( eles[i] );
      }

    }
  
    
    if( near.length > 0 ){
      return near[ near.length - 1 ];
    } else {
      return null;
    }
  }; 

  // 'Give me everything from this box'
  CRp.getAllInBox = function(x1, y1, x2, y2) {
    var nodes = this.getCachedNodes();
    var edges = this.getCachedEdges();
    var box = [];
    
    var x1c = Math.min(x1, x2);
    var x2c = Math.max(x1, x2);
    var y1c = Math.min(y1, y2);
    var y2c = Math.max(y1, y2); 

    x1 = x1c; 
    x2 = x2c; 
    y1 = y1c; 
    y2 = y2c; 

    var heur;
    
    for ( var i = 0; i < nodes.length; i++ ){
      var pos = nodes[i]._private.position;
      var nShape = this.getNodeShape(nodes[i]);
      var w = this.getNodeWidth(nodes[i]);
      var h = this.getNodeHeight(nodes[i]);
      var border = nodes[i]._private.style['border-width'].pxValue / 2;
      var shapeObj = CanvasRenderer.nodeShapes[ nShape ];

      if ( shapeObj.intersectBox(x1, y1, x2, y2, w, h, pos.x, pos.y, border) ){
        box.push(nodes[i]);
      }
    }
    
    for ( var i = 0; i < edges.length; i++ ){
      var rs = edges[i]._private.rscratch;

      if (edges[i]._private.rscratch.edgeType == 'self') {
        if ((heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2ax, rs.cp2ay,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2ax, rs.cp2ay,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))
                ||
          (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2cx, rs.cp2cy,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2cx, rs.cp2cy,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue)))
          )
        { box.push(edges[i]); }
      }
      
      if (rs.edgeType == 'bezier' &&
        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.cp2x, rs.cp2y,
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              &&
            (heur == 2 || (heur == 1 && $$.math.checkBezierInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.cp2x, rs.cp2y,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))
        { box.push(edges[i]); }
    
      if (rs.edgeType == 'straight' &&
        (heur = $$.math.boxInBezierVicinity(x1, y1, x2, y2,
            rs.startX, rs.startY,
            rs.startX * 0.5 + rs.endX * 0.5, 
            rs.startY * 0.5 + rs.endY * 0.5, 
            rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))
              && /* console.log('test', heur) == undefined && */
            (heur == 2 || (heur == 1 && $$.math.checkStraightEdgeInBox(x1, y1, x2, y2,
              rs.startX, rs.startY,
              rs.endX, rs.endY, edges[i]._private.style['width'].pxValue))))
        { box.push(edges[i]); }


      if (rs.edgeType == 'haystack'){
        var tgt = edges[i].target()[0];
        var tgtPos = tgt.position();
        var src = edges[i].source()[0];
        var srcPos = src.position();

        var startX = srcPos.x + rs.source.x;
        var startY = srcPos.y + rs.source.y;
        var endX = tgtPos.x + rs.target.x;
        var endY = tgtPos.y + rs.target.y;

        var startInBox = (x1 <= startX && startX <= x2) && (y1 <= startY && startY <= y2);
        var endInBox = (x1 <= endX && endX <= x2) && (y1 <= endY && endY <= y2);

        if( startInBox && endInBox ){
          box.push( edges[i] );
        }
      }
      
    }
    
    return box;
  };


  /**
   * Returns the width of the given node. If the width is set to auto,
   * returns the value of the autoWidth field.
   *
   * @param node          a node
   * @return {number}     width of the node
   */
  CRp.getNodeWidth = function(node)
  {
    return node.width();
  };

  /**
   * Returns the height of the given node. If the height is set to auto,
   * returns the value of the autoHeight field.
   *
   * @param node          a node
   * @return {number}     width of the node
   */
  CRp.getNodeHeight = function(node)
  {
    return node.height();
  };

  /**
   * Returns the shape of the given node. If the height or width of the given node
   * is set to auto, the node is considered to be a compound.
   *
   * @param node          a node
   * @return {String}     shape of the node
   */
  CRp.getNodeShape = function(node)
  {
    // TODO only allow rectangle for a compound node?
//    if (node._private.style['width'].value == 'auto' ||
//        node._private.style['height'].value == 'auto')
//    {
//      return 'rectangle';
//    }

    var shape = node._private.style['shape'].value;

    if( node.isParent() ){
      if( shape === 'rectangle' || shape === 'roundrectangle' ){
        return shape;
      } else {
        return 'rectangle';
      }
    }

    return shape;
  };


  CRp.getNodePadding = function(node)
  {
    var left = node._private.style['padding-left'].pxValue;
    var right = node._private.style['padding-right'].pxValue;
    var top = node._private.style['padding-top'].pxValue;
    var bottom = node._private.style['padding-bottom'].pxValue;

    if (isNaN(left))
    {
      left = 0;
    }

    if (isNaN(right))
    {
      right = 0;
    }

    if (isNaN(top))
    {
      top = 0;
    }

    if (isNaN(bottom))
    {
      bottom = 0;
    }

    return {left : left,
      right : right,
      top : top,
      bottom : bottom};
  };

  CRp.zOrderSort = $$.Collection.zIndexSort;

  CRp.updateCachedZSortedEles = function(){
    this.getCachedZSortedEles( true );
  };

  CRp.getCachedZSortedEles = function( forceRecalc ){
    var lastNodes = this.lastZOrderCachedNodes;
    var lastEdges = this.lastZOrderCachedEdges;
    var nodes = this.getCachedNodes();
    var edges = this.getCachedEdges();
    var eles = [];

    if( forceRecalc || !lastNodes || !lastEdges || lastNodes !== nodes || lastEdges !== edges ){ 
      //console.time('cachezorder')
      
      for( var i = 0; i < nodes.length; i++ ){
        if( nodes[i].visible() && !nodes[i].transparent() ){
          eles.push( nodes[i] );
        }
      }

      for( var i = 0; i < edges.length; i++ ){
        if( edges[i].visible() && !edges[i].transparent() ){
          eles.push( edges[i] );
        }
      }

      eles.sort( this.zOrderSort );
      this.cachedZSortedEles = eles;
      //console.log('make cache')

      //console.timeEnd('cachezorder')
    } else {
      eles = this.cachedZSortedEles;
      //console.log('read cache')
    }

    this.lastZOrderCachedNodes = nodes;
    this.lastZOrderCachedEdges = edges;

    return eles;
  };

  CRp.projectBezier = function(edge){
    var qbezierAt = $$.math.qbezierAt;
    var rs = edge._private.rscratch;
    var bpts = edge._private.rstyle.bezierPts = [];

    function pushBezierPts(pts){
      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.05 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.05 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.25 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.25 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.4 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.4 )
      });

      var mid = {
        x: qbezierAt( pts[0], pts[2], pts[4], 0.5 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.5 )
      };

      bpts.push( mid );

      if( rs.edgeType === 'self' || rs.edgeType === 'compound' ){
        rs.midX = rs.selfEdgeMidX;
        rs.midY = rs.selfEdgeMidY;
      } else {
        rs.midX = mid.x;
        rs.midY = mid.y;
      }

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.6 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.6 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.75 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.75 )
      });

      bpts.push({
        x: qbezierAt( pts[0], pts[2], pts[4], 0.95 ),
        y: qbezierAt( pts[1], pts[3], pts[5], 0.95 )
      });
    }

    if( rs.edgeType === 'self' ){
      pushBezierPts( [rs.startX, rs.startY, rs.cp2ax, rs.cp2ay, rs.selfEdgeMidX, rs.selfEdgeMidY] );
      pushBezierPts( [rs.selfEdgeMidX, rs.selfEdgeMidY, rs.cp2cx, rs.cp2cy, rs.endX, rs.endY] );
    } else if( rs.edgeType === 'bezier' ){
      pushBezierPts( [rs.startX, rs.startY, rs.cp2x, rs.cp2y, rs.endX, rs.endY] );
    }
  };

  CRp.recalculateNodeLabelProjection = function( node ){ 
    var content = node._private.style['content'].strValue;
    if( !content || content.match(/^\s+$/) ){ return; }

    var textX, textY;
    var nodeWidth = node.outerWidth();
    var nodeHeight = node.outerHeight();
    var nodePos = node._private.position;
    var textHalign = node._private.style['text-halign'].strValue;
    var textValign = node._private.style['text-valign'].strValue;
    var rs = node._private.rscratch;
    var rstyle = node._private.rstyle;

    switch( textHalign ){
      case 'left':
        textX = nodePos.x - nodeWidth / 2;
        break;

      case 'right':
        textX = nodePos.x + nodeWidth / 2;
        break;

      default: // e.g. center
        textX = nodePos.x;
    }

    switch( textValign ){
      case 'top':
        textY = nodePos.y - nodeHeight / 2;
        break;

      case 'bottom':
        textY = nodePos.y + nodeHeight / 2;
        break;

      default: // e.g. middle
        textY = nodePos.y;
    }
  
    rs.labelX = textX;
    rs.labelY = textY;
    rstyle.labelX = textX;
    rstyle.labelY = textY;

    this.applyLabelDimensions( node );
  };

  CRp.recalculateEdgeLabelProjection = function( edge ){
    var content = edge._private.style['content'].strValue;
    if( !content || content.match(/^\s+$/) ){ return; }

    var textX, textY;  
    var edgeCenterX, edgeCenterY;
    var _p = edge._private;
    var rs = _p.rscratch;
    //var style = _p.style;
    var rstyle = _p.rstyle;
    
    if (rs.edgeType == 'self') {
      edgeCenterX = rs.selfEdgeMidX;
      edgeCenterY = rs.selfEdgeMidY;
    } else if (rs.edgeType == 'straight') {
      edgeCenterX = (rs.startX + rs.endX) / 2;
      edgeCenterY = (rs.startY + rs.endY) / 2;
    } else if (rs.edgeType == 'bezier') {
      edgeCenterX = $$.math.qbezierAt( rs.startX, rs.cp2x, rs.endX, 0.5 );
      edgeCenterY = $$.math.qbezierAt( rs.startY, rs.cp2y, rs.endY, 0.5 );
    } else if (rs.edgeType == 'haystack') {
      // var src = _p.source;
      // var tgt = _p.target;
      // var srcPos = src._private.position;
      // var tgtPos = tgt._private.position;
      var pts = rs.haystackPts;

      edgeCenterX = ( pts[0] + pts[2] )/2;
      edgeCenterY = ( pts[1] + pts[3] )/2;
    }
    
    textX = edgeCenterX;
    textY = edgeCenterY;

    // add center point to style so bounding box calculations can use it
    rs.labelX = textX;
    rs.labelY = textY;
    rstyle.labelX = textX;
    rstyle.labelY = textY;

    this.applyLabelDimensions( edge );
  };

  CRp.applyLabelDimensions = function( ele ){
    var rs = ele._private.rscratch;
    var rstyle = ele._private.rstyle;

    var text = this.getLabelText( ele );
    var labelDims = this.calculateLabelDimensions( ele, text );
 
    rstyle.labelWidth = labelDims.width;
    rs.labelWidth = labelDims.width;
 
    rstyle.labelHeight = labelDims.height;
    rs.labelHeight = labelDims.height;
  };

  CRp.getLabelText = function( ele ){ 
    var style = ele._private.style;
    var text = ele._private.style['content'].strValue;
    var textTransform = style['text-transform'].value;
    var rscratch = ele._private.rscratch;
    
    if (textTransform == 'none') {
    } else if (textTransform == 'uppercase') {
      text = text.toUpperCase();
    } else if (textTransform == 'lowercase') {
      text = text.toLowerCase();
    }

    if( style['text-wrap'].value === 'wrap' ){
      //console.log('wrap'); 
      
      // save recalc if the label is the same as before
      if( rscratch.labelWrapKey === rscratch.labelKey ){ 
        // console.log('wrap cache hit');
        return rscratch.labelWrapCachedText;
      }
      // console.log('wrap cache miss');

      var lines = text.split('\n');
      var maxW = style['text-max-width'].pxValue;
      var wrappedLines = [];

      for( var l = 0; l < lines.length; l++ ){
        var line = lines[l];
        var lineDims = this.calculateLabelDimensions( ele, line, 'line=' + line );
        var lineW = lineDims.width;

        if( lineW > maxW ){ // line is too long
          var words = line.split(/\s+/); // NB: assume collapsed whitespace into single space
          var subline = '';

          for( var w = 0; w < words.length; w++ ){
            var word = words[w];
            var testLine = subline.length === 0 ? word : subline + ' ' + word;
            var testDims = this.calculateLabelDimensions( ele, testLine, 'testLine=' + testLine );
            var testW = testDims.width;

            if( testW <= maxW ){ // word fits on current line
              subline += word + ' ';
            } else { // word starts new line
              wrappedLines.push( subline );
              subline = word + ' ';
            }
          }

          // if there's remaining text, put it in a wrapped line
          if( !subline.match(/^\s+$/) ){
            wrappedLines.push( subline );
          }
        } else { // line is already short enough
          wrappedLines.push( line );
        }
      } // for

      rscratch.labelWrapCachedLines = wrappedLines;
      rscratch.labelWrapCachedText = text = wrappedLines.join('\n');
      rscratch.labelWrapKey = rscratch.labelKey;

      // console.log(text)
    } // if wrap

    return text;
  };

  CRp.calculateLabelDimensions = function( ele, text, extraKey ){
    var r = this;
    var style = ele._private.style;
    var fStyle = style['font-style'].strValue;
    var size = style['font-size'].pxValue + 'px';
    var family = style['font-family'].strValue;
    // var variant = style['font-variant'].strValue;
    var weight = style['font-weight'].strValue;

    var cacheKey = ele._private.labelKey;

    if( extraKey ){
      cacheKey += '$@$' + extraKey;
    }

    var cache = r.labelDimCache || (r.labelDimCache = {});

    if( cache[cacheKey] ){
      return cache[cacheKey];
    }

    var div = this.labelCalcDiv;

    if( !div ){
      div = this.labelCalcDiv = document.createElement('div');
      document.body.appendChild( div );
    }

    var ds = div.style;

    // from ele style
    ds.fontFamily = family;
    ds.fontStyle = fStyle;
    ds.fontSize = size;
    // ds.fontVariant = variant;
    ds.fontWeight = weight;

    // forced style
    ds.position = 'absolute';
    ds.left = '-9999px';
    ds.top = '-9999px';
    ds.zIndex = '-1';
    ds.visibility = 'hidden';
    ds.pointerEvents = 'none';
    ds.padding = '0';
    ds.lineHeight = '1';

    if( style['text-wrap'].value === 'wrap' ){
      ds.whiteSpace = 'pre'; // so newlines are taken into account
    } else {
      ds.whiteSpace = 'normal';
    }

    // put label content in div
    div.textContent = text;

    cache[cacheKey] = {
      width: div.clientWidth,
      height: div.clientHeight
    };

    return cache[cacheKey];
  };  

  CRp.recalculateRenderedStyle = function( eles ){
    var edges = [];
    var nodes = [];
    var handledEdge = {};

    for( var i = 0; i < eles.length; i++ ){
      var ele = eles[i];
      var _p = ele._private;
      var style = _p.style;
      var rs = _p.rscratch;
      var rstyle = _p.rstyle;
      var id = _p.data.id;
      var bbStyleSame = rs.boundingBoxKey != null && _p.boundingBoxKey === rs.boundingBoxKey;
      var labelStyleSame = rs.labelKey != null && _p.labelKey === rs.labelKey;
      var styleSame = bbStyleSame && labelStyleSame;

      if( ele._private.group === 'nodes' ){
        var pos = _p.position;
        var posSame = rstyle.nodeX != null && rstyle.nodeY != null && pos.x === rstyle.nodeX && pos.y === rstyle.nodeY;
        var wSame = rstyle.nodeW != null && rstyle.nodeW === style['width'].pxValue;
        var hSame = rstyle.nodeH != null && rstyle.nodeH === style['height'].pxValue;

        if( !posSame || !styleSame || !wSame || !hSame ){
          nodes.push( ele );
        }

        rstyle.nodeX = pos.x;
        rstyle.nodeY = pos.y;
        rstyle.nodeW = style['width'].pxValue;
        rstyle.nodeH = style['height'].pxValue;
      } else { // edges

        var srcPos = ele._private.source._private.position;
        var tgtPos = ele._private.target._private.position;
        var srcSame = rstyle.srcX != null && rstyle.srcY != null && srcPos.x === rstyle.srcX && srcPos.y === rstyle.srcY;
        var tgtSame = rstyle.tgtX != null && rstyle.tgtY != null && tgtPos.x === rstyle.tgtX && tgtPos.y === rstyle.tgtY;
        var positionsSame = srcSame && tgtSame;

        if( !positionsSame || !styleSame ){
          var curveType = _p.style['curve-style'].value;

          if( curveType === 'bezier' ){
            if( !handledEdge[ id ] ){
              edges.push( ele );
              handledEdge[ id ] = true;

              var parallelEdges = ele.parallelEdges();
              for( var i = 0; i < parallelEdges.length; i++ ){
                var pEdge = parallelEdges[i];
                var pId = pEdge._private.data.id;

                if( !handledEdge[ pId ] ){
                  edges.push( pEdge );
                  handledEdge[ pId ] = true;
                }
                
              }
            }
          } else {
            edges.push( ele );
          }
        } // if positions diff

        // update rstyle positions
        rstyle.srcX = srcPos.x;
        rstyle.srcY = srcPos.y;
        rstyle.tgtX = tgtPos.x;
        rstyle.tgtY = tgtPos.y;

      } // if edges

      rs.boundingBoxKey = _p.boundingBoxKey;
      rs.labelKey = _p.labelKey;
    }

    this.recalculateEdgeProjections( edges );
    this.recalculateLabelProjections( nodes, edges );
  };

  CRp.recalculateLabelProjections = function( nodes, edges ){
    for( var i = 0; i < nodes.length; i++ ){
      this.recalculateNodeLabelProjection( nodes[i] );
    }

    for( var i = 0; i < edges.length; i++ ){
      this.recalculateEdgeLabelProjection( edges[i] );
    }
  };

  CRp.recalculateEdgeProjections = function( edges ){
    this.findEdgeControlPoints( edges );
  };


  // Find edge control points
  CRp.findEdgeControlPoints = function(edges) {
    if( !edges || edges.length === 0 ){ return; }

    var cy = this.data.cy;
    var hasCompounds = cy.hasCompoundNodes();
    var hashTable = {};
    var pairIds = [];
    var haystackEdges = [];

    // create a table of edge (src, tgt) => list of edges between them
    var pairId;
    for (var i = 0; i < edges.length; i++){
      var edge = edges[i];
      var style = edge._private.style;
      var edgeIsUnbundled = style['curve-style'].value === 'unbundled-bezier';

      // ignore edges who are not to be displayed
      // they shouldn't take up space
      if( style.display.value === 'none' ){
        continue;
      }

      if( style['curve-style'].value === 'haystack' ){
        haystackEdges.push( edge );
        continue;
      }

      var srcId = edge._private.data.source;
      var tgtId = edge._private.data.target;

      pairId = srcId > tgtId ?
        tgtId + '-' + srcId :
        srcId + '-' + tgtId ;

      if( edgeIsUnbundled ){
        pairId = 'unbundled' + edge._private.data.id;
      }

      if (hashTable[pairId] == null) {
        hashTable[pairId] = [];
        pairIds.push( pairId );
      }
      
      hashTable[pairId].push( edge );

      if( edgeIsUnbundled ){
        hashTable[pairId].hasUnbundled = true;
      }
    }

    var src, tgt, srcPos, tgtPos, srcW, srcH, tgtW, tgtH, srcShape, tgtShape, srcBorder, tgtBorder;
    var vectorNormInverse;
    var badBezier;
    
    // for each pair (src, tgt), create the ctrl pts
    // Nested for loop is OK; total number of iterations for both loops = edgeCount  
    for (var p = 0; p < pairIds.length; p++) {
      pairId = pairIds[p];
      var pairEdges = hashTable[pairId];
    
      // for each pair id, the edges should be sorted by index
      pairEdges.sort(function(edge1, edge2){
        return edge1._private.index - edge2._private.index;
      });

      src = pairEdges[0]._private.source;
      tgt = pairEdges[0]._private.target;

      // make sure src/tgt distinction is consistent
      // (src/tgt in this case are just for ctrlpts and don't actually have to be true src/tgt)
      if( src._private.data.id > tgt._private.data.id ){
        var temp = src;
        src = tgt;
        tgt = temp;
      }

      srcPos = src._private.position;
      tgtPos = tgt._private.position;

      srcW = this.getNodeWidth(src);
      srcH = this.getNodeHeight(src);

      tgtW = this.getNodeWidth(tgt);
      tgtH = this.getNodeHeight(tgt);

      srcShape = CanvasRenderer.nodeShapes[ this.getNodeShape(src) ];
      tgtShape = CanvasRenderer.nodeShapes[ this.getNodeShape(tgt) ];

      srcBorder = src._private.style['border-width'].pxValue;
      tgtBorder = tgt._private.style['border-width'].pxValue;

      badBezier = false;
      

      if( (pairEdges.length > 1 && src !== tgt) || pairEdges.hasUnbundled ){

        // pt outside src shape to calc distance/displacement from src to tgt
        var srcOutside = srcShape.intersectLine(
          srcPos.x,
          srcPos.y,
          srcW,
          srcH,
          tgtPos.x,
          tgtPos.y,
          srcBorder / 2
        );

        // pt outside tgt shape to calc distance/displacement from src to tgt
        var tgtOutside = tgtShape.intersectLine(
          tgtPos.x,
          tgtPos.y,
          tgtW,
          tgtH,
          srcPos.x,
          srcPos.y,
          tgtBorder / 2
        );

        var midptSrcPts = {
          x1: srcOutside[0],
          x2: tgtOutside[0],
          y1: srcOutside[1],
          y2: tgtOutside[1]
        };

        var dy = ( tgtOutside[1] - srcOutside[1] );
        var dx = ( tgtOutside[0] - srcOutside[0] );
        var l = Math.sqrt( dx*dx + dy*dy );

        var vector = {
          x: dx,
          y: dy
        };
        
        var vectorNorm = {
          x: vector.x/l,
          y: vector.y/l
        };
        vectorNormInverse = {
          x: -vectorNorm.y,
          y: vectorNorm.x
        };

        // if src intersection is inside tgt or tgt intersection is inside src, then no ctrl pts to draw
        if( 
          tgtShape.checkPoint( srcOutside[0], srcOutside[1], tgtBorder/2, tgtW, tgtH, tgtPos.x, tgtPos.y )  ||
          srcShape.checkPoint( tgtOutside[0], tgtOutside[1], srcBorder/2, srcW, srcH, srcPos.x, srcPos.y ) 
        ){
          vectorNormInverse = {};
          badBezier = true;
        }
        
      }
      
      var edge;
      var rs;
      
      for (var i = 0; i < pairEdges.length; i++) {
        edge = pairEdges[i];
        rs = edge._private.rscratch;
        
        var edgeIndex1 = rs.lastEdgeIndex;
        var edgeIndex2 = i;

        var numEdges1 = rs.lastNumEdges;
        var numEdges2 = pairEdges.length;

        var eStyle = edge._private.style;
        var stepSize = eStyle['control-point-step-size'].pxValue;
        var stepDist = eStyle['control-point-distance'] !== undefined ? eStyle['control-point-distance'].pxValue : undefined;
        var stepWeight = eStyle['control-point-weight'].value;
        var edgeIsUnbundled = eStyle['curve-style'].value === 'unbundled-bezier';
        
        var swappedDirection = edge._private.source !== src;

        if( swappedDirection && edgeIsUnbundled ){
          stepDist *= -1;
        }

        var srcX1 = rs.lastSrcCtlPtX;
        var srcX2 = srcPos.x;
        var srcY1 = rs.lastSrcCtlPtY;
        var srcY2 = srcPos.y;
        var srcW1 = rs.lastSrcCtlPtW;
        var srcW2 = src.outerWidth();
        var srcH1 = rs.lastSrcCtlPtH;
        var srcH2 = src.outerHeight();

        var tgtX1 = rs.lastTgtCtlPtX;
        var tgtX2 = tgtPos.x;
        var tgtY1 = rs.lastTgtCtlPtY;
        var tgtY2 = tgtPos.y;
        var tgtW1 = rs.lastTgtCtlPtW;
        var tgtW2 = tgt.outerWidth();
        var tgtH1 = rs.lastTgtCtlPtH;
        var tgtH2 = tgt.outerHeight();

        var width1 = rs.lastW;
        var width2 = eStyle['control-point-step-size'].pxValue;

        if( badBezier ){
          rs.badBezier = true;
        } else {
          rs.badBezier = false;
        }

        if( srcX1 === srcX2 && srcY1 === srcY2 && srcW1 === srcW2 && srcH1 === srcH2
        &&  tgtX1 === tgtX2 && tgtY1 === tgtY2 && tgtW1 === tgtW2 && tgtH1 === tgtH2
        &&  width1 === width2
        &&  ((edgeIndex1 === edgeIndex2 && numEdges1 === numEdges2) || edgeIsUnbundled) ){
          // console.log('edge ctrl pt cache HIT')
          continue; // then the control points haven't changed and we can skip calculating them
        } else {
          rs.lastSrcCtlPtX = srcX2;
          rs.lastSrcCtlPtY = srcY2;
          rs.lastSrcCtlPtW = srcW2;
          rs.lastSrcCtlPtH = srcH2;
          rs.lastTgtCtlPtX = tgtX2;
          rs.lastTgtCtlPtY = tgtY2;
          rs.lastTgtCtlPtW = tgtW2;
          rs.lastTgtCtlPtH = tgtH2;
          rs.lastEdgeIndex = edgeIndex2;
          rs.lastNumEdges = numEdges2;
          rs.lastWidth = width2;
          // console.log('edge ctrl pt cache MISS')
        }

        // Self-edge
        if ( src === tgt ) {
            
          rs.edgeType = 'self';
          
          var j = i;
          var loopDist = stepSize;

          if( edgeIsUnbundled ){
            j = 0;
            loopDist = stepDist;
          }

          // New -- fix for large nodes
          rs.cp2ax = srcPos.x;
          rs.cp2ay = srcPos.y - (1 + Math.pow(srcH, 1.12) / 100) * loopDist * (j / 3 + 1);
          
          rs.cp2cx = srcPos.x - (1 + Math.pow(srcW, 1.12) / 100) * loopDist * (j / 3 + 1);
          rs.cp2cy = srcPos.y;
          
          rs.selfEdgeMidX = (rs.cp2ax + rs.cp2cx) / 2.0;
          rs.selfEdgeMidY = (rs.cp2ay + rs.cp2cy) / 2.0;
        
        // Compound edge
        } else if(
          hasCompounds &&
          ( src.isParent() || src.isChild() || tgt.isParent() || tgt.isChild() ) &&
          ( src.parents().anySame(tgt) || tgt.parents().anySame(src) )
        ){

          rs.edgeType = 'compound';

          // because the line approximation doesn't apply for compound beziers
          // (loop/self edges are already elided b/c of cheap src==tgt check)
          rs.badBezier = false;

          var j = i;
          var loopDist = stepSize;

          if( edgeIsUnbundled ){
            j = 0;
            loopDist = stepDist;
          }

          
          var loopW = 50;

          var loopaPos = {
            x: srcPos.x - srcW/2,
            y: srcPos.y - srcH/2
          };

          var loopbPos = {
            x: tgtPos.x - tgtW/2,
            y: tgtPos.y - tgtH/2
          };

          var minCompoundStretch = 1;

          rs.cp2ax = loopaPos.x;
          rs.compoundStretchA = Math.max( minCompoundStretch, Math.log(srcW * 0.01) ); // avoids cases with impossible beziers
          rs.cp2ay = loopaPos.y - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * rs.compoundStretchA;
          
          rs.compoundStretchB = Math.max( minCompoundStretch, Math.log(tgtW * 0.01) ); // avoids cases with impossible beziers
          rs.cp2cx = loopbPos.x - (1 + Math.pow(loopW, 1.12) / 100) * loopDist * (j / 3 + 1) * rs.compoundStretchB;
          rs.cp2cy = loopbPos.y;
          
          rs.selfEdgeMidX = (rs.cp2ax + rs.cp2cx) / 2.0;
          rs.selfEdgeMidY = (rs.cp2ay + rs.cp2cy) / 2.0;

        // Straight edge
        } else if (pairEdges.length % 2 === 1
          && i === Math.floor(pairEdges.length / 2)
          && !edgeIsUnbundled ) {
          
          rs.edgeType = 'straight';
          
        // Bezier edge
        } else {
          var normStepDist = (0.5 - pairEdges.length / 2 + i) * stepSize;
          var manStepDist;
          var sign = $$.math.signum( normStepDist );

          if( edgeIsUnbundled ){
            manStepDist = stepDist;
          } else {
            manStepDist = stepDist !== undefined ? sign * stepDist : undefined; 
          }

          var distanceFromMidpoint = manStepDist !== undefined ? manStepDist : normStepDist;
          
          var w1 = (1 - stepWeight);
          var w2 = stepWeight;

          if( swappedDirection ){
            w1 = stepWeight;
            w2 = (1 - stepWeight);
          }

          var adjustedMidpt = {
            x: midptSrcPts.x1 * w1 + midptSrcPts.x2 * w2,
            y: midptSrcPts.y1 * w1 + midptSrcPts.y2 * w2
          };

          rs.edgeType = 'bezier';
          
          rs.cp2x = adjustedMidpt.x + vectorNormInverse.x * distanceFromMidpoint;
          rs.cp2y = adjustedMidpt.y + vectorNormInverse.y * distanceFromMidpoint;
          
          // console.log(edge, midPointX, displacementX, distanceFromMidpoint);
        }

        // find endpts for edge
        this.findEndpoints( edge );

        var badStart = !$$.is.number( rs.startX ) || !$$.is.number( rs.startY );
        var badAStart = !$$.is.number( rs.arrowStartX ) || !$$.is.number( rs.arrowStartY );
        var badEnd = !$$.is.number( rs.endX ) || !$$.is.number( rs.endY );
        var badAEnd = !$$.is.number( rs.arrowEndX ) || !$$.is.number( rs.arrowEndY );

        var minCpADistFactor = 3;
        var arrowW = this.getArrowWidth( edge._private.style['width'].pxValue ) * CanvasRenderer.arrowShapeHeight;
        var minCpADist = minCpADistFactor * arrowW;
        var startACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.startX, y: rs.startY } );
        var closeStartACp = startACpDist < minCpADist;
        var endACpDist = $$.math.distance( { x: rs.cp2x, y: rs.cp2y }, { x: rs.endX, y: rs.endY } );
        var closeEndACp = endACpDist < minCpADist;

        if( rs.edgeType === 'bezier' ){
          var overlapping = false;

          if( badStart || badAStart || closeStartACp ){
            overlapping = true;

            // project control point along line from src centre to outside the src shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.cp2x - srcPos.x,
              y: rs.cp2y - srcPos.y
            };
            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.cp2x + cpM.x * 2 * radius,
              y: rs.cp2y + cpM.y * 2 * radius
            };

            var srcCtrlPtIntn = srcShape.intersectLine(
              srcPos.x,
              srcPos.y,
              srcW,
              srcH,
              cpProj.x,
              cpProj.y,
              srcBorder / 2
            );

            if( closeStartACp ){
              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - startACpDist); 
              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - startACpDist);
            } else {
              rs.cp2x = srcCtrlPtIntn[0] + cpM.x * minCpADist; 
              rs.cp2y = srcCtrlPtIntn[1] + cpM.y * minCpADist;
            }
          }

          if( badEnd || badAEnd || closeEndACp ){
            overlapping = true;

            // project control point along line from tgt centre to outside the tgt shape
            // (otherwise intersection will yield nothing)
            var cpD = { // delta
              x: rs.cp2x - tgtPos.x,
              y: rs.cp2y - tgtPos.y
            };
            var cpL = Math.sqrt( cpD.x*cpD.x + cpD.y*cpD.y ); // length of line
            var cpM = { // normalised delta
              x: cpD.x / cpL,
              y: cpD.y / cpL
            };
            var radius = Math.max(srcW, srcH);
            var cpProj = { // *2 radius guarantees outside shape
              x: rs.cp2x + cpM.x * 2 * radius,
              y: rs.cp2y + cpM.y * 2 * radius
            };

            var tgtCtrlPtIntn = tgtShape.intersectLine(
              tgtPos.x,
              tgtPos.y,
              tgtW,
              tgtH,
              cpProj.x,
              cpProj.y,
              tgtBorder / 2
            );

            if( closeEndACp ){
              rs.cp2x = rs.cp2x + cpM.x * (minCpADist - endACpDist); 
              rs.cp2y = rs.cp2y + cpM.y * (minCpADist - endACpDist);
            } else {
              rs.cp2x = tgtCtrlPtIntn[0] + cpM.x * minCpADist; 
              rs.cp2y = tgtCtrlPtIntn[1] + cpM.y * minCpADist;
            }
            
          }

          if( overlapping ){
            // recalc endpts
            this.findEndpoints( edge );
          }
        } else if( rs.edgeType === 'straight' ){
          rs.midX = ( srcX2 + tgtX2 )/2;
          rs.midY = ( srcY2 + tgtY2 )/2;
        }

        // project the edge into rstyle
        this.projectBezier( edge );
        this.recalculateEdgeLabelProjection( edge );

      }
    }
      
    for( var i = 0; i < haystackEdges.length; i++ ){
      var edge = haystackEdges[i];
      var _p = edge._private;
      var rscratch = _p.rscratch;
      var rs = rscratch;

      if( !rscratch.haystack ){
        var angle = Math.random() * 2 * Math.PI;

        rscratch.source = {
          x: Math.cos(angle),
          y: Math.sin(angle)
        };

        var angle = Math.random() * 2 * Math.PI;

        rscratch.target = {
          x: Math.cos(angle),
          y: Math.sin(angle)
        };

      }

      var src = _p.source;
      var tgt = _p.target;
      var srcPos = src._private.position;
      var tgtPos = tgt._private.position;
      var srcW = src.width();
      var tgtW = tgt.width();
      var srcH = src.height();
      var tgtH = tgt.height();
      var radius = style['haystack-radius'].value;
      var halfRadius = radius/2; // b/c have to half width/height

      rs.haystackPts = [
        rs.source.x * srcW * halfRadius + srcPos.x,
        rs.source.y * srcH * halfRadius + srcPos.y,
        rs.target.x * tgtW * halfRadius + tgtPos.x,
        rs.target.y * tgtH * halfRadius + tgtPos.y
      ];

      // always override as haystack in case set to different type previously
      rscratch.edgeType = 'haystack';
      rscratch.haystack = true;

      this.recalculateEdgeLabelProjection( edge );
    }

    return hashTable;
  };

  CRp.findEndpoints = function(edge) {
    var intersect;

    var source = edge.source()[0];
    var target = edge.target()[0];
    
    var tgtArShape = edge._private.style['target-arrow-shape'].value;
    var srcArShape = edge._private.style['source-arrow-shape'].value;

    var tgtBorderW = target._private.style['border-width'].pxValue;
    var srcBorderW = source._private.style['border-width'].pxValue;

    var rs = edge._private.rscratch;
    
    if (rs.edgeType == 'self' || rs.edgeType == 'compound') {
      
      var cp = [rs.cp2cx, rs.cp2cy];
      
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        cp[0],
        cp[1], 
        tgtBorderW / 2
      );
      
      var arrowEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));
      
      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
      
      var cp = [rs.cp2ax, rs.cp2ay];

      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        srcBorderW / 2
      );
      
      var arrowStart = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));
      var edgeStart = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[srcArShape].gap(edge));
      
      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];


      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
    } else if (rs.edgeType == 'straight') {
    
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        source.position().x,
        source.position().y,
        tgtBorderW / 2);
        
      if (intersect.length === 0) {
        rs.noArrowPlacement = true;
        // return;
      } else {
        rs.noArrowPlacement = false;
      }
      
      var arrowEnd = $$.math.shortenIntersection(intersect,
        [source.position().x, source.position().y],
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect,
        [source.position().x, source.position().y],
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));

      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
    
      intersect = CanvasRenderer.nodeShapes[this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        target.position().x,
        target.position().y,
        srcBorderW / 2);
      
      if (intersect.length === 0) {
        rs.noArrowPlacement = true;
       // return;
      } else {
        rs.noArrowPlacement = false;
      }
      
      /*
      console.log("1: "
        + CanvasRenderer.arrowShapes[srcArShape],
          srcArShape);
      */
      var arrowStart = $$.math.shortenIntersection(intersect,
        [target.position().x, target.position().y],
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge));
      var edgeStart = $$.math.shortenIntersection(intersect,
        [target.position().x, target.position().y],
        CanvasRenderer.arrowShapes[srcArShape].gap(edge));

      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];
      
      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
      if( !$$.is.number(rs.startX) || !$$.is.number(rs.startY) || !$$.is.number(rs.endX) || !$$.is.number(rs.endY) ){
        rs.badLine = true;
      } else {
        rs.badLine = false;
      }
            
    } else if (rs.edgeType == 'bezier') {
      // if( window.badArrow) debugger;
      var cp = [rs.cp2x, rs.cp2y];
      
      intersect = CanvasRenderer.nodeShapes[
        this.getNodeShape(target)].intersectLine(
        target._private.position.x,
        target._private.position.y,
        this.getNodeWidth(target),
        this.getNodeHeight(target),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        tgtBorderW / 2
      );
      
      /*
      console.log("2: "
        + CanvasRenderer.arrowShapes[srcArShape],
          srcArShape);
      */
      var arrowEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].spacing(edge));
      var edgeEnd = $$.math.shortenIntersection(intersect, cp,
        CanvasRenderer.arrowShapes[tgtArShape].gap(edge));
      
      rs.endX = edgeEnd[0];
      rs.endY = edgeEnd[1];
      
      rs.arrowEndX = arrowEnd[0];
      rs.arrowEndY = arrowEnd[1];
      
      intersect = CanvasRenderer.nodeShapes[
        this.getNodeShape(source)].intersectLine(
        source._private.position.x,
        source._private.position.y,
        this.getNodeWidth(source),
        this.getNodeHeight(source),
        cp[0], //halfPointX,
        cp[1], //halfPointY
        srcBorderW / 2
      );
      
      var arrowStart = $$.math.shortenIntersection(
        intersect, 
        cp,
        CanvasRenderer.arrowShapes[srcArShape].spacing(edge)
      );
      var edgeStart = $$.math.shortenIntersection(
        intersect, 
        cp,
        CanvasRenderer.arrowShapes[srcArShape].gap(edge)
      );
    
      rs.startX = edgeStart[0];
      rs.startY = edgeStart[1];
      
      rs.arrowStartX = arrowStart[0];
      rs.arrowStartY = arrowStart[1];
      
      // if( isNaN(rs.startX) || isNaN(rs.startY) ){
      //   debugger;
      // }

    } else if (rs.isArcEdge) {
      return;
    }
  };

  // Find adjacent edges
  CRp.findEdges = function(nodeSet) {
    
    var edges = this.getCachedEdges();
    
    var hashTable = {};
    var adjacentEdges = [];
    
    for (var i = 0; i < nodeSet.length; i++) {
      hashTable[nodeSet[i]._private.data.id] = nodeSet[i];
    }
    
    for (var i = 0; i < edges.length; i++) {
      if (hashTable[edges[i]._private.data.source]
        || hashTable[edges[i]._private.data.target]) {
        
        adjacentEdges.push(edges[i]);
      }
    }
    
    return adjacentEdges;
  };

  CRp.getArrowWidth = CRp.getArrowHeight = function(edgeWidth) {
    var cache = this.arrowWidthCache = this.arrowWidthCache || {};

    var cachedVal = cache[edgeWidth];
    if( cachedVal ){
      return cachedVal;
    }

    cachedVal =  Math.max(Math.pow(edgeWidth * 13.37, 0.9), 29);
    cache[edgeWidth] = cachedVal;

    return cachedVal;
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

// Draw edge
  CRp.drawEdge = function(context, edge, drawOverlayInstead) {
    var rs = edge._private.rscratch;
    var usePaths = CanvasRenderer.usePaths();

    // if bezier ctrl pts can not be calculated, then die
    if( rs.badBezier || ( (rs.edgeType === 'bezier' || rs.edgeType === 'straight') && isNaN(rs.startX)) ){ // extra isNaN() for safari 7.1 b/c it mangles ctrlpt calcs
      return;
    }

    var style = edge._private.style;
    
    // Edge line width
    if (style['width'].pxValue <= 0) {
      return;
    }

    var overlayPadding = style['overlay-padding'].pxValue;
    var overlayOpacity = style['overlay-opacity'].value;
    var overlayColor = style['overlay-color'].value;

    // Edge color & opacity
    if( drawOverlayInstead ){

      if( overlayOpacity === 0 ){ // exit early if no overlay
        return;
      }

      this.strokeStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);
      context.lineCap = 'round';

      if( edge._private.rscratch.edgeType == 'self' && !usePaths ){
        context.lineCap = 'butt';
      }

    } else {
      var lineColor = style['line-color'].value;

      this.strokeStyle(context, lineColor[0], lineColor[1], lineColor[2], style.opacity.value);
      
      context.lineCap = 'butt'; 
    }
    
    var startNode, endNode, source, target;
    source = startNode = edge._private.source;
    target = endNode = edge._private.target;

    // var targetPos = target._private.position;
    // var targetW = target.width();
    // var targetH = target.height();
    // var sourcePos = source._private.position;
    // var sourceW = source.width();
    // var sourceH = source.height();


    var edgeWidth = style['width'].pxValue + (drawOverlayInstead ? 2 * overlayPadding : 0);
    var lineStyle = drawOverlayInstead ? 'solid' : style['line-style'].value;
    context.lineWidth = edgeWidth;
    
    var shadowBlur = style['shadow-blur'].pxValue;
    var shadowOpacity = style['shadow-opacity'].value;
    var shadowColor = style['shadow-color'].value;
    var shadowOffsetX = style['shadow-offset-x'].pxValue;
    var shadowOffsetY = style['shadow-offset-y'].pxValue;

    this.shadowStyle(context,  shadowColor, drawOverlayInstead ? 0 : shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);
    
    // if( rs.edgeType !== 'haystack' ){
    //   this.findEndpoints(edge);
    // }
    
    if( rs.edgeType === 'haystack' ){
      // var radius = style['haystack-radius'].value;
      // var halfRadius = radius/2; // b/c have to half width/height

      this.drawStyledEdge(
        edge, 
        context, 
        rs.haystackPts,
        lineStyle,
        edgeWidth
      );
    } else if (rs.edgeType === 'self' || rs.edgeType === 'compound') {
      
      var details = edge._private.rscratch;
      var points = [details.startX, details.startY, details.cp2ax,
        details.cp2ay, details.selfEdgeMidX, details.selfEdgeMidY,
        details.selfEdgeMidX, details.selfEdgeMidY,
        details.cp2cx, details.cp2cy, details.endX, details.endY];

      this.drawStyledEdge(edge, context, points, lineStyle, edgeWidth);
      
    } else if (rs.edgeType === 'straight') {
      
      var nodeDirectionX = endNode._private.position.x - startNode._private.position.x;
      var nodeDirectionY = endNode._private.position.y - startNode._private.position.y;
      
      var edgeDirectionX = rs.endX - rs.startX;
      var edgeDirectionY = rs.endY - rs.startY;
      
      if (nodeDirectionX * edgeDirectionX
        + nodeDirectionY * edgeDirectionY < 0) {
        
        rs.straightEdgeTooShort = true;  
      } else {
        
        var details = rs;
        this.drawStyledEdge(edge, context, [details.startX, details.startY,
                                      details.endX, details.endY],
                                      lineStyle,
                                      edgeWidth);
        
        rs.straightEdgeTooShort = false;  
      }  
    } else {
      
      var details = rs;
      
      this.drawStyledEdge(edge, context, [details.startX, details.startY,
        details.cp2x, details.cp2y, details.endX, details.endY],
        lineStyle,
        edgeWidth);
      
    }
    
    if( rs.edgeType === 'haystack' ){
      this.drawArrowheads(context, edge, drawOverlayInstead);
    } else if ( rs.noArrowPlacement !== true && rs.startX !== undefined ){
      this.drawArrowheads(context, edge, drawOverlayInstead);
    }

    this.shadowStyle(context, 'transparent', 0); // reset for next guy

  };
  
  
  CRp.drawStyledEdge = function(
      edge, context, pts, type, width) {

    // 3 points given -> assume Bezier
    // 2 -> assume straight
    
    var rs = edge._private.rscratch;
    var canvasCxt = context;
    var path;
    var pathCacheHit = false;
    var usePaths = CanvasRenderer.usePaths();


    if( usePaths ){

      var pathCacheKey = pts;
      var keyLengthMatches = rs.pathCacheKey && pathCacheKey.length === rs.pathCacheKey.length;
      var keyMatches = keyLengthMatches;

      for( var i = 0; keyMatches && i < pathCacheKey.length; i++ ){
        if( rs.pathCacheKey[i] !== pathCacheKey[i] ){
          keyMatches = false;
        }
      }

      if( keyMatches ){
        path = context = rs.pathCache;
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.pathCacheKey = pathCacheKey;
        rs.pathCache = path;
      }

    }

    if( canvasCxt.setLineDash ){ // for very outofdate browsers
      switch( type ){
        case 'dotted':
          canvasCxt.setLineDash([ 1, 1 ]);
          break;

        case 'dashed':
          canvasCxt.setLineDash([ 6, 3 ]);
          break;

        case 'solid':
          canvasCxt.setLineDash([ ]);
          break;
      }
    }

    if( !pathCacheHit ){
      if( context.beginPath ){ context.beginPath(); }
      context.moveTo(pts[0], pts[1]);
      
      if( pts.length === 6 && !rs.badBezier ){ // bezier
        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);
      } else if( pts.length === 12 && !rs.badBezier ){ // double bezier loop
        context.quadraticCurveTo(pts[2], pts[3], pts[4], pts[5]);
        context.quadraticCurveTo(pts[8], pts[9], pts[10], pts[11]);
      } else if( pts.length === 4 && !rs.badLine ){ // line
        context.lineTo(pts[2], pts[3]);
      }
    }

    context = canvasCxt;
    if( usePaths ){
      context.stroke( path );
    } else {
      context.stroke();
    }
  
    // reset any line dashes
    if( context.setLineDash ){ // for very outofdate browsers
      context.setLineDash([ ]);
    }

  };

  CRp.drawArrowheads = function(context, edge, drawOverlayInstead) {
    if( drawOverlayInstead ){ return; } // don't do anything for overlays 

    var rs = edge._private.rscratch;
    var self = this;
    var isHaystack = rs.edgeType === 'haystack';

    // Displacement gives direction for arrowhead orientation
    var dispX, dispY;
    var startX, startY, endX, endY;

    var srcPos = edge.source().position();
    var tgtPos = edge.target().position();

    if( isHaystack ){
      startX = rs.haystackPts[0];
      startY = rs.haystackPts[1];
      endX = rs.haystackPts[2];
      endY = rs.haystackPts[3];
    } else {
      startX = rs.arrowStartX;
      startY = rs.arrowStartY;
      endX = rs.arrowEndX;
      endY = rs.arrowEndY;
    }

    var style = edge._private.style;
    
    function drawArrowhead( prefix, x, y, dispX, dispY ){
      var arrowShape = style[prefix + '-arrow-shape'].value;

      if( arrowShape === 'none' ){
        return;
      }

      var gco = context.globalCompositeOperation;

      var arrowClearFill = style[prefix + '-arrow-fill'].value === 'hollow' ? 'both' : 'filled';
      var arrowFill = style[prefix + '-arrow-fill'].value;

      if( arrowShape === 'half-triangle-overshot' ){
        arrowFill = 'hollow';
        arrowClearFill = 'hollow';
      }

      if( style.opacity.value !== 1 || arrowFill === 'hollow' ){ // then extra clear is needed
        context.globalCompositeOperation = 'destination-out';
        
        self.fillStyle(context, 255, 255, 255, 1);
        self.strokeStyle(context, 255, 255, 255, 1);
        
        self.drawArrowShape( edge, prefix, context, 
          arrowClearFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, 
          x, y, dispX, dispY
        );

        context.globalCompositeOperation = gco;
      } // otherwise, the opaque arrow clears it for free :)

      var color = style[prefix + '-arrow-color'].value;
      self.fillStyle(context, color[0], color[1], color[2], style.opacity.value);
      self.strokeStyle(context, color[0], color[1], color[2], style.opacity.value);

      self.drawArrowShape( edge, prefix, context, 
        arrowFill, style['width'].pxValue, style[prefix + '-arrow-shape'].value, 
        x, y, dispX, dispY
      );
    }

    dispX = startX - srcPos.x;
    dispY = startY - srcPos.y;

    if( !isHaystack && !isNaN(startX) && !isNaN(startY) && !isNaN(dispX) && !isNaN(dispY) ){
      drawArrowhead( 'source', startX, startY, dispX, dispY );

    } else {
      // window.badArrow = true;
      // debugger;
    }
    
    var midX = rs.midX;
    var midY = rs.midY;

    if( isHaystack ){
      midX = ( startX + endX )/2;
      midY = ( startY + endY )/2;
    }

    dispX = startX - endX;
    dispY = startY - endY;

    if( rs.edgeType === 'self' ){
      dispX = 1;
      dispY = -1;
    }

    if( !isNaN(midX) && !isNaN(midY) ){
      drawArrowhead( 'mid-target', midX, midY, dispX, dispY );
    }

    dispX *= -1;
    dispY *= -1;

    if( !isNaN(midX) && !isNaN(midY) ){
      drawArrowhead( 'mid-source', midX, midY, dispX, dispY );
    }
    
    dispX = endX - tgtPos.x;
    dispY = endY - tgtPos.y;
    
    if( !isHaystack && !isNaN(endX) && !isNaN(endY) && !isNaN(dispX) && !isNaN(dispY) ){
      drawArrowhead( 'target', endX, endY, dispX, dispY );
    }
  };
  
  // Draw arrowshape
  CRp.drawArrowShape = function(edge, arrowType, context, fill, edgeWidth, shape, x, y, dispX, dispY) {
    var usePaths = CanvasRenderer.usePaths();
    var rs = edge._private.rscratch;
    var pathCacheHit = false;
    var path;
    var canvasContext = context;
    var translation = { x: x, y: y };

    // Negative of the angle
    var angle = Math.asin(dispY / (Math.sqrt(dispX * dispX + dispY * dispY)));
  
    if (dispX < 0) {
      angle = angle + Math.PI / 2;
    } else {
      angle = - (Math.PI / 2 + angle);
    }
    
    var size = this.getArrowWidth( edgeWidth );
    var shapeImpl = CanvasRenderer.arrowShapes[shape];

    // context.translate(x, y);

    if( usePaths ){
      var pathCacheKey = size + '$' + shape + '$' + angle + '$' + x + '$' + y;
      rs.arrowPathCacheKey = rs.arrowPathCacheKey || {};
      rs.arrowPathCache = rs.arrowPathCache || {};

      var alreadyCached = rs.arrowPathCacheKey[arrowType] === pathCacheKey;
      if( alreadyCached ){
        path = context = rs.arrowPathCache[arrowType];
        pathCacheHit = true;
      } else {
        path = context = new Path2D();
        rs.arrowPathCacheKey[arrowType] = pathCacheKey;
        rs.arrowPathCache[arrowType] = path;
      }
    }

    if( context.beginPath ){ context.beginPath(); }

    if( !pathCacheHit ){
      shapeImpl.draw(context, size, angle, translation);
    }
    
    if( !shapeImpl.leavePathOpen && context.closePath ){
      context.closePath();
    }

    context = canvasContext;

    if( fill === 'filled' || fill === 'both' ){
      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }
    }

    if( fill === 'hollow' || fill === 'both' ){
      context.lineWidth = ( shapeImpl.matchEdgeWidth ? edgeWidth : 1 );
      context.lineJoin = 'miter';

      if( usePaths ){
        context.stroke( path );
      } else {
        context.stroke();
      }
      
    }

    // context.translate(-x, -y);
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  CRp.getCachedImage = function(url, onLoad) {
    var r = this;
    var imageCache = r.imageCache = r.imageCache || {};

    if( imageCache[url] && imageCache[url].image ){
      return imageCache[url].image;
    }
    
    var cache = imageCache[url] = imageCache[url] || {};

    var image = cache.image = new Image();
    image.addEventListener('load', onLoad);
    image.src = url;
    
    return image;
  };
  
  CRp.safeDrawImage = function( context, img, ix, iy, iw, ih, x, y, w, h ){
    var r = this;
    
    try {
      context.drawImage( img, ix, iy, iw, ih, x, y, w, h );
    } catch(e){
      r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
      r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;
      
      r.drawingImage = true;
      
      r.redraw();
    }
  };
  
  CRp.drawInscribedImage = function(context, img, node) {
    var r = this;
    var nodeX = node._private.position.x;
    var nodeY = node._private.position.y;
    var style = node._private.style;
    var fit = style['background-fit'].value;
    var xPos = style['background-position-x'];
    var yPos = style['background-position-y'];
    var repeat = style['background-repeat'].value;
    var nodeW = node.width();
    var nodeH = node.height();
    var rs = node._private.rscratch;
    var clip = style['background-clip'].value;
    var shouldClip = clip === 'node';
    var imgOpacity = style['background-image-opacity'].value;
    
    var w = img.width;
    var h = img.height;
    
    if( w === 0 || h === 0 ){
      return; // no point in drawing empty image (and chrome is broken in this case)
    }

    var bgW = style['background-width'];
    if( bgW.value !== 'auto' ){
      if( bgW.units === '%' ){
        w = bgW.value/100 * nodeW;
      } else {
        w = bgW.pxValue;
      }
    }

    var bgH = style['background-height'];
    if( bgH.value !== 'auto' ){
      if( bgH.units === '%' ){
        h = bgH.value/100 * nodeH;
      } else {
        h = bgH.pxValue;
      }
    }

    if( w === 0 || h === 0 ){
      return; // no point in drawing empty image (and chrome is broken in this case)
    }

    if( fit === 'contain' ){
      var scale = Math.min( nodeW/w, nodeH/h );

      w *= scale;
      h *= scale;

    } else if( fit === 'cover' ){
      var scale = Math.max( nodeW/w, nodeH/h );

      w *= scale;
      h *= scale;
    }

    var x = (nodeX - nodeW/2); // left
    if( xPos.units === '%' ){
      x += (nodeW - w) * xPos.value/100;
    } else {
      x += xPos.pxValue;
    }

    var y = (nodeY - nodeH/2); // top
    if( yPos.units === '%' ){
      y += (nodeH - h) * yPos.value/100;
    } else {
      y += yPos.pxValue;
    }

    if( rs.pathCache ){
      x -= nodeX;
      y -= nodeY;

      nodeX = 0;
      nodeY = 0;
    }

    var gAlpha = context.globalAlpha;

    context.globalAlpha = imgOpacity;

    if( repeat === 'no-repeat' ){

      if( shouldClip ){
        context.save();

        if( rs.pathCache ){
          context.clip( rs.pathCache );
        } else {
          CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(
            context,
            nodeX, nodeY, 
            nodeW, nodeH);

          context.clip();
        }
      }

      // context.drawImage( img, 0, 0, img.width, img.height, x, y, w, h );
      r.safeDrawImage( context, img, 0, 0, img.width, img.height, x, y, w, h );

      if( shouldClip ){
        context.restore();
      }
    } else {
      var pattern = context.createPattern( img, repeat );
      context.fillStyle = pattern;

      CanvasRenderer.nodeShapes[r.getNodeShape(node)].drawPath(
          context,
          nodeX, nodeY, 
          nodeW, nodeH);

        context.translate(x, y);
        context.fill();
        context.translate(-x, -y);
    }

    context.globalAlpha = gAlpha;
    
  };

  
})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // Draw edge text
  CRp.drawEdgeText = function(context, edge) {
    var text = edge._private.style['content'].strValue;

    if( !text || text.match(/^\s+$/) ){
      return;
    }

    if( this.hideEdgesOnViewport && (this.dragData.didDrag || this.pinching || this.hoverData.dragging || this.data.wheel || this.swipePanning) ){ return; } // save cycles on pinching

    var computedSize = edge._private.style['font-size'].pxValue * edge.cy().zoom();
    var minSize = edge._private.style['min-zoomed-font-size'].pxValue;

    if( computedSize < minSize ){
      return;
    }

    // Calculate text draw position

    context.textAlign = 'center';
    context.textBaseline = 'middle';
    
    var rs = edge._private.rscratch;
    if( !$$.is.number( rs.labelX ) || !$$.is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered

    var style = edge._private.style;
    var autorotate = style['edge-text-rotation'].strValue === 'autorotate';
    var theta, dx, dy;

    if( autorotate ){
      switch( rs.edgeType ){
        case 'haystack':
          dx = rs.haystackPts[2] - rs.haystackPts[0];
          dy = rs.haystackPts[3] - rs.haystackPts[1];
          break;
        default:
          dx = rs.endX - rs.startX;
          dy = rs.endY - rs.startY;
      }

      theta = Math.atan( dy / dx );

      context.translate(rs.labelX, rs.labelY);
      context.rotate(theta);

      this.drawText(context, edge, 0, 0);

      context.rotate(-theta);
      context.translate(-rs.labelX, -rs.labelY);
    } else {
      this.drawText(context, edge, rs.labelX, rs.labelY);
    }

  };

  // Draw node text
  CRp.drawNodeText = function(context, node) {
    var text = node._private.style['content'].strValue;

    if ( !text || text.match(/^\s+$/) ) {
      return;
    }

    var computedSize = node._private.style['font-size'].pxValue * node.cy().zoom();
    var minSize = node._private.style['min-zoomed-font-size'].pxValue;

    if( computedSize < minSize ){
      return;
    }

    // this.recalculateNodeLabelProjection( node );

    var textHalign = node._private.style['text-halign'].strValue;
    var textValign = node._private.style['text-valign'].strValue;
    var rs = node._private.rscratch;
    if( !$$.is.number( rs.labelX ) || !$$.is.number( rs.labelY ) ){ return; } // no pos => label can't be rendered

    switch( textHalign ){
      case 'left':
        context.textAlign = 'right';
        break;

      case 'right':
        context.textAlign = 'left';
        break;

      default: // e.g. center
        context.textAlign = 'center';
    }

    switch( textValign ){
      case 'top':
        context.textBaseline = 'bottom';
        break;

      case 'bottom':
        context.textBaseline = 'top';
        break;

      default: // e.g. center
        context.textBaseline = 'middle';
    }

    this.drawText(context, node, rs.labelX, rs.labelY);
  };

  CRp.getFontCache = function(context){
    var cache;

    this.fontCaches = this.fontCaches || [];

    for( var i = 0; i < this.fontCaches.length; i++ ){
      cache = this.fontCaches[i];

      if( cache.context === context ){
        return cache;
      }
    }

    cache = {
      context: context
    };
    this.fontCaches.push(cache);

    return cache;
  };

  // set up canvas context with font
  // returns transformed text string
  CRp.setupTextStyle = function( context, element ){
    // Font style
    var parentOpacity = element.effectiveOpacity();
    var style = element._private.style;
    var labelStyle = style['font-style'].strValue;
    var labelSize = style['font-size'].pxValue + 'px';
    var labelFamily = style['font-family'].strValue;
    var labelWeight = style['font-weight'].strValue;
    var opacity = style['text-opacity'].value * style['opacity'].value * parentOpacity;
    var outlineOpacity = style['text-outline-opacity'].value * opacity;
    var color = style['color'].value;
    var outlineColor = style['text-outline-color'].value;
    var shadowBlur = style['text-shadow-blur'].pxValue;
    var shadowOpacity = style['text-shadow-opacity'].value;
    var shadowColor = style['text-shadow-color'].value;
    var shadowOffsetX = style['text-shadow-offset-x'].pxValue;
    var shadowOffsetY = style['text-shadow-offset-y'].pxValue;

    var fontCacheKey = element._private.fontKey;
    var cache = this.getFontCache(context);

    if( cache.key !== fontCacheKey ){
      context.font = labelStyle + ' ' + labelWeight + ' ' + labelSize + ' ' + labelFamily;

      cache.key = fontCacheKey;
    }

    var text = this.getLabelText( element );

    // Calculate text draw position based on text alignment

    // so text outlines aren't jagged
    context.lineJoin = 'round';

    this.fillStyle(context, color[0], color[1], color[2], opacity);

    this.strokeStyle(context, outlineColor[0], outlineColor[1], outlineColor[2], outlineOpacity);

    this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

    return text;
  };

  function roundRect(ctx, x, y, width, height, radius) {
    var radius = radius || 5;
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
  }

  // Draw text
  CRp.drawText = function(context, element, textX, textY) {
    var _p = element._private;
    var style = _p.style;
    var rstyle = _p.rstyle;
    var rscratch = _p.rscratch;
    var parentOpacity = element.effectiveOpacity();
    if( parentOpacity === 0 || style['text-opacity'].value === 0){ return; }

    var text = this.setupTextStyle( context, element );
    var halign = style['text-halign'].value;
    var valign = style['text-valign'].value;

    if( element.isEdge() ){
      halign = 'center';
      valign = 'center';
    }

    if ( text != null && !isNaN(textX) && !isNaN(textY)) {
      var backgroundOpacity = style['text-background-opacity'].value;
      var borderOpacity = style['text-border-opacity'].value;
      var textBorderWidth = style['text-border-width'].pxValue;
      
      if( backgroundOpacity > 0 || (textBorderWidth > 0 && borderOpacity > 0) ){
        var margin = 4 + textBorderWidth/2;

        if (element.isNode()) {
          //Move textX, textY to include the background margins
          if (valign === 'top') {
            textY -= margin;
          } else if (valign === 'bottom') {
            textY += margin;
          }
          if (halign === 'left') {
            textX -= margin;
          } else if (halign === 'right') {
            textX += margin;
          }
        }

        var bgWidth = rstyle.labelWidth;
        var bgHeight = rstyle.labelHeight;
        var bgX = textX;

        if (halign) {
          if (halign == 'center') {
            bgX = bgX - bgWidth / 2;
          } else if (halign == 'left') {
            bgX = bgX- bgWidth;
          }
        }

        var bgY = textY;

        if (element.isNode()) {
          if (valign == 'top') {
             bgY = bgY - bgHeight;
          } else if (valign == 'center') {
            bgY = bgY- bgHeight / 2;
          }
        } else {
          bgY = bgY - bgHeight / 2;
        }

        if (style['edge-text-rotation'].strValue === 'autorotate') {
          textY = 0;
          bgWidth += 4;
          bgX = textX - bgWidth / 2;
          bgY = textY - bgHeight / 2;
        } else {
          // Adjust with border width & margin
          bgX -= margin;
          bgY -= margin;
          bgHeight += margin*2;
          bgWidth += margin*2;
        }

        if( backgroundOpacity > 0 ){
          var textFill = context.fillStyle;
          var textBackgroundColor = style['text-background-color'].value;

          context.fillStyle = 'rgba(' + textBackgroundColor[0] + ',' + textBackgroundColor[1] + ',' + textBackgroundColor[2] + ',' + backgroundOpacity * parentOpacity + ')';
          var styleShape = style['text-background-shape'].strValue;
          if (styleShape == 'roundrectangle') {
            roundRect(context, bgX, bgY, bgWidth, bgHeight, 2);
          } else {
            context.fillRect(bgX,bgY,bgWidth,bgHeight);
          }
          context.fillStyle = textFill;
        }

        if( textBorderWidth > 0 && borderOpacity > 0 ){
          var textStroke = context.strokeStyle;
          var textLineWidth = context.lineWidth;
          var textBorderColor = style['text-border-color'].value;
          var textBorderStyle = style['text-border-style'].value;

          context.strokeStyle = 'rgba(' + textBorderColor[0] + ',' + textBorderColor[1] + ',' + textBorderColor[2] + ',' + borderOpacity * parentOpacity + ')';
          context.lineWidth = textBorderWidth;

          if( context.setLineDash ){ // for very outofdate browsers
            switch( textBorderStyle ){
              case 'dotted':
                context.setLineDash([ 1, 1 ]);
                break;
              case 'dashed':
                context.setLineDash([ 4, 2 ]);
                break;
              case 'double':
                context.lineWidth = textBorderWidth/4; // 50% reserved for white between the two borders
                context.setLineDash([ ]);
                break;
              case 'solid':
                context.setLineDash([ ]);
                break;
            }
          }

          context.strokeRect(bgX,bgY,bgWidth,bgHeight);

          if( textBorderStyle === 'double' ){
            var whiteWidth = textBorderWidth/2;

            context.strokeRect(bgX+whiteWidth,bgY+whiteWidth,bgWidth-whiteWidth*2,bgHeight-whiteWidth*2);
          }

          if( context.setLineDash ){ // for very outofdate browsers
            context.setLineDash([ ]);
          }
          context.lineWidth = textLineWidth;
          context.strokeStyle = textStroke;
        }

      }

      var lineWidth = 2  * style['text-outline-width'].pxValue; // *2 b/c the stroke is drawn centred on the middle

      if( lineWidth > 0 ){
        context.lineWidth = lineWidth;
      }

      if( style['text-wrap'].value === 'wrap' ){ //console.log('draw wrap');
        var lines = rscratch.labelWrapCachedLines;
        var lineHeight = rstyle.labelHeight / lines.length;

        //console.log('lines', lines);

        switch( valign ){
          case 'top':
            textY -= (lines.length - 1) * lineHeight;
            break;

          case 'bottom':
            // nothing required
            break;

          default:
          case 'center':
            textY -= (lines.length - 1) * lineHeight / 2;
        }

        for( var l = 0; l < lines.length; l++ ){
          if( lineWidth > 0 ){
            context.strokeText( lines[l], textX, textY );
          }

          context.fillText( lines[l], textX, textY );

          textY += lineHeight;
        }

        // var fontSize = style['font-size'].pxValue;
        // wrapText(context, text, textX, textY, style['text-max-width'].pxValue, fontSize + 1);
      } else {
        if( lineWidth > 0 ){
          context.strokeText( text, textX, textY );
        }

        context.fillText( text, textX, textY );
      }


      this.shadowStyle(context, 'transparent', 0); // reset for next guy
    }
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // Draw node
  CRp.drawNode = function(context, node, drawOverlayInstead) {

    var r = this;
    var nodeWidth, nodeHeight;
    var style = node._private.style;
    var rs = node._private.rscratch;
    var _p = node._private;
    
    var usePaths = CanvasRenderer.usePaths();
    var canvasContext = context;
    var path;
    var pathCacheHit = false;

    var overlayPadding = style['overlay-padding'].pxValue;
    var overlayOpacity = style['overlay-opacity'].value;
    var overlayColor = style['overlay-color'].value;

    if( drawOverlayInstead && overlayOpacity === 0 ){ // exit early if drawing overlay but none to draw
      return;
    }

    var parentOpacity = node.effectiveOpacity();
    if( parentOpacity === 0 ){ return; }

    nodeWidth = this.getNodeWidth(node);
    nodeHeight = this.getNodeHeight(node);
    
    context.lineWidth = style['border-width'].pxValue;

    if( drawOverlayInstead === undefined || !drawOverlayInstead ){

      var url = style['background-image'].value[2] ||
        style['background-image'].value[1];
      var image;

      if (url !== undefined) {
        
        // get image, and if not loaded then ask to redraw when later loaded
        image = this.getCachedImage(url, function(){
          r.data.canvasNeedsRedraw[CanvasRenderer.NODE] = true;
          r.data.canvasNeedsRedraw[CanvasRenderer.DRAG] = true;
          
          r.drawingImage = true;
          
          r.redraw();
        });
        
        var prevBging = _p.backgrounding;
        _p.backgrounding = !image.complete;

        if( prevBging !== _p.backgrounding ){ // update style b/c :backgrounding state changed
          node.updateStyle( false );
        }
      } 

      // Node color & opacity

      var bgColor = style['background-color'].value;
      var borderColor = style['border-color'].value;
      var borderStyle = style['border-style'].value;

      this.fillStyle(context, bgColor[0], bgColor[1], bgColor[2], style['background-opacity'].value * parentOpacity);
      
      this.strokeStyle(context, borderColor[0], borderColor[1], borderColor[2], style['border-opacity'].value * parentOpacity);
      
      var shadowBlur = style['shadow-blur'].pxValue;
      var shadowOpacity = style['shadow-opacity'].value;
      var shadowColor = style['shadow-color'].value;
      var shadowOffsetX = style['shadow-offset-x'].pxValue;
      var shadowOffsetY = style['shadow-offset-y'].pxValue;

      this.shadowStyle(context, shadowColor, shadowOpacity, shadowBlur, shadowOffsetX, shadowOffsetY);

      context.lineJoin = 'miter'; // so borders are square with the node shape

      if( context.setLineDash ){ // for very outofdate browsers
        switch( borderStyle ){
          case 'dotted':
            context.setLineDash([ 1, 1 ]);
            break;

          case 'dashed':
            context.setLineDash([ 4, 2 ]);
            break;

          case 'solid':
          case 'double':
            context.setLineDash([ ]);
            break;
        }
      }

      
      var styleShape = style['shape'].strValue;

      var pos = node._private.position;

      if( usePaths ){
        var pathCacheKey = styleShape + '$' + nodeWidth +'$' + nodeHeight;

        context.translate( pos.x, pos.y );

        if( rs.pathCacheKey === pathCacheKey ){
          path = context = rs.pathCache;
          pathCacheHit = true;
        } else {
          path = context = new Path2D();
          rs.pathCacheKey = pathCacheKey;
          rs.pathCache = path;
        }
      }

      if( !pathCacheHit ){

        var npos = pos;

        if( usePaths ){
          npos = {
            x: 0,
            y: 0
          };
        }

        CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(
              context,
              npos.x,
              npos.y,
              nodeWidth,
              nodeHeight);
      }

      context = canvasContext;

      if( usePaths ){
        context.fill( path );
      } else {
        context.fill();
      }

      this.shadowStyle(context, 'transparent', 0); // reset for next guy

      if (url !== undefined) {
        if( image.complete ){
          this.drawInscribedImage(context, image, node);
        }
      } 
      
      var darkness = style['background-blacken'].value;
      var borderWidth = style['border-width'].pxValue;

      if( this.hasPie(node) ){
        this.drawPie( context, node, parentOpacity );

        // redraw path for blacken and border
        if( darkness !== 0 || borderWidth !== 0 ){

          if( !usePaths ){
            CanvasRenderer.nodeShapes[this.getNodeShape(node)].drawPath(
                context,
                pos.x,
                pos.y,
                nodeWidth,
                nodeHeight);
          }
        }
      }

      if( darkness > 0 ){
        this.fillStyle(context, 0, 0, 0, darkness);

        if( usePaths ){
          context.fill( path );
        } else {
          context.fill();
        }
        
      } else if( darkness < 0 ){
        this.fillStyle(context, 255, 255, 255, -darkness);
        
        if( usePaths ){
          context.fill( path );
        } else {
          context.fill();
        }
      }

      // Border width, draw border
      if (borderWidth > 0) {

        if( usePaths ){
          context.stroke( path );
        } else {
          context.stroke();
        }

        if( borderStyle === 'double' ){
          context.lineWidth = style['border-width'].pxValue/3;

          var gco = context.globalCompositeOperation;
          context.globalCompositeOperation = 'destination-out';

          if( usePaths ){
            context.stroke( path );
          } else {
            context.stroke();
          }

          context.globalCompositeOperation = gco;
        }

      }

      if( usePaths ){
        context.translate( -pos.x, -pos.y );
      }

      // reset in case we changed the border style
      if( context.setLineDash ){ // for very outofdate browsers
        context.setLineDash([ ]);
      }

    // draw the overlay
    } else {

      if( overlayOpacity > 0 ){
        this.fillStyle(context, overlayColor[0], overlayColor[1], overlayColor[2], overlayOpacity);

        CanvasRenderer.nodeShapes['roundrectangle'].drawPath(
          context,
          node._private.position.x,
          node._private.position.y,
          nodeWidth + overlayPadding * 2,
          nodeHeight + overlayPadding * 2
        );

        context.fill();
      }
    }

  };

  // does the node have at least one pie piece?
  CRp.hasPie = function(node){
    node = node[0]; // ensure ele ref
    
    return node._private.hasPie;
  };

  CRp.drawPie = function( context, node, nodeOpacity ){
    node = node[0]; // ensure ele ref

    var _p = node._private;
    var style = _p.style;
    var pieSize = style['pie-size'];
    var nodeW = this.getNodeWidth( node );
    var nodeH = this.getNodeHeight( node );
    var x = _p.position.x;
    var y = _p.position.y;
    var radius = Math.min( nodeW, nodeH ) / 2; // must fit in node
    var lastPercent = 0; // what % to continue drawing pie slices from on [0, 1]
    var usePaths = CanvasRenderer.usePaths();

    if( usePaths ){
      x = 0;
      y = 0;
    }

    if( pieSize.units === '%' ){
      radius = radius * pieSize.value / 100;
    } else if( pieSize.pxValue !== undefined ){
      radius = pieSize.pxValue / 2;
    }

    for( var i = 1; i <= $$.style.pieBackgroundN; i++ ){ // 1..N
      var size = style['pie-' + i + '-background-size'].value;
      var color = style['pie-' + i + '-background-color'].value;
      var opacity = style['pie-' + i + '-background-opacity'].value * nodeOpacity;
      var percent = size / 100; // map integer range [0, 100] to [0, 1]
      var angleStart = 1.5 * Math.PI + 2 * Math.PI * lastPercent; // start at 12 o'clock and go clockwise
      var angleDelta = 2 * Math.PI * percent;
      var angleEnd = angleStart + angleDelta;

      // ignore if
      // - zero size
      // - we're already beyond the full circle
      // - adding the current slice would go beyond the full circle
      if( size === 0 || lastPercent >= 1 || lastPercent + percent > 1 ){
        continue;
      }

      context.beginPath();
      context.moveTo(x, y);
      context.arc( x, y, radius, angleStart, angleEnd );
      context.closePath();

      this.fillStyle(context, color[0], color[1], color[2], opacity);

      context.fill();

      lastPercent += percent;
    }

  };

  
})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CR = CanvasRenderer;
  var CRp = CanvasRenderer.prototype;

  // var isFirefox = typeof InstallTrigger !== 'undefined';

  CRp.getPixelRatio = function(){ 
    var context = this.data.contexts[0];

    if( this.forcedPixelRatio != null ){
      return this.forcedPixelRatio;
    }

    var backingStore = context.backingStorePixelRatio ||
      context.webkitBackingStorePixelRatio ||
      context.mozBackingStorePixelRatio ||
      context.msBackingStorePixelRatio ||
      context.oBackingStorePixelRatio ||
      context.backingStorePixelRatio || 1;

    //console.log(window.devicePixelRatio, backingStore);

    // if( isFirefox ){ // because ff can't scale canvas properly
    //   return 1;
    // }

    return (window.devicePixelRatio || 1) / backingStore;
  };

  CRp.paintCache = function(context){
    var caches = this.paintCaches = this.paintCaches || [];
    var needToCreateCache = true;
    var cache;

    for(var i = 0; i < caches.length; i++ ){
      cache = caches[i];

      if( cache.context === context ){
        needToCreateCache = false;
        break;
      }
    }

    if( needToCreateCache ){
      cache = {
        context: context
      };
      caches.push( cache );
    }

    return cache;
  };

  CRp.fillStyle = function(context, r, g, b, a){
    context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    
    // turn off for now, seems context does its own caching

    // var cache = this.paintCache(context);

    // var fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

    // if( cache.fillStyle !== fillStyle ){
    //   context.fillStyle = cache.fillStyle = fillStyle;
    // }
  };

  CRp.strokeStyle = function(context, r, g, b, a){
    context.strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    
    // turn off for now, seems context does its own caching

    // var cache = this.paintCache(context);

    // var strokeStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';

    // if( cache.strokeStyle !== strokeStyle ){
    //   context.strokeStyle = cache.strokeStyle = strokeStyle;
    // }
  };
  
  CRp.shadowStyle = function(context, color, opacity, blur, offsetX, offsetY){
    var zoom = this.data.cy.zoom();

    var cache = this.paintCache(context);
    
    // don't make expensive changes to the shadow style if it's not used
    if( cache.shadowOpacity === 0 && opacity === 0 ){
      return;
    }

    cache.shadowOpacity = opacity;

    if (opacity > 0) {
      context.shadowBlur = blur * zoom;
      context.shadowColor = "rgba(" + color[0] + "," + color[1] + "," + color[2] + "," + opacity + ")";
      context.shadowOffsetX = offsetX * zoom;
      context.shadowOffsetY = offsetY * zoom;
    } else {
      context.shadowBlur = 0;
      context.shadowColor = "transparent";
    }
  };

  // Resize canvas
  CRp.matchCanvasSize = function(container) {
    var data = this.data;
    var width = container.clientWidth;
    var height = container.clientHeight;
    var pixelRatio = this.getPixelRatio();
    var mbPxRatio = this.motionBlurPxRatio;

    if(
      container === this.data.bufferCanvases[CR.MOTIONBLUR_BUFFER_NODE] ||
      container === this.data.bufferCanvases[CR.MOTIONBLUR_BUFFER_DRAG]
    ){
      pixelRatio = mbPxRatio;
    }

    var canvasWidth = width * pixelRatio;
    var canvasHeight = height * pixelRatio;
    var canvas;

    if( canvasWidth === this.canvasWidth && canvasHeight === this.canvasHeight ){
      return; // save cycles if same
    }

    this.fontCaches = null; // resizing resets the style

    var canvasContainer = data.canvasContainer;
    canvasContainer.style.width = width + 'px';
    canvasContainer.style.height = height + 'px';

    for (var i = 0; i < CanvasRenderer.CANVAS_LAYERS; i++) {

      canvas = data.canvases[i];
      
      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
    }
    
    for (var i = 0; i < CanvasRenderer.BUFFER_COUNT; i++) {
      
      canvas = data.bufferCanvases[i];
      
      if (canvas.width !== canvasWidth || canvas.height !== canvasHeight) {
        
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;

        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
      }
    }

    this.textureMult = 1;
    if( pixelRatio <= 1 ){
      canvas = data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];

      this.textureMult = 2;
      canvas.width = canvasWidth * this.textureMult;
      canvas.height = canvasHeight * this.textureMult;
    }

    this.canvasWidth = canvasWidth;
    this.canvasHeight = canvasHeight;

  };

  CRp.renderTo = function( cxt, zoom, pan, pxRatio ){
    this.redraw({
      forcedContext: cxt,
      forcedZoom: zoom,
      forcedPan: pan,
      drawAllLayers: true,
      forcedPxRatio: pxRatio
    });
  };

  CRp.timeToRender = function(){
    return this.redrawTotalTime / this.redrawCount;
  };

  CanvasRenderer.minRedrawLimit = 1000/60; // people can't see much better than 60fps
  CanvasRenderer.maxRedrawLimit = 1000;  // don't cap max b/c it's more important to be responsive than smooth
  CanvasRenderer.motionBlurDelay = 100;

  // Redraw frame
  CRp.redraw = function( options ) {
    options = options || {};

    // console.log('redraw()');

    var forcedContext = options.forcedContext;
    var drawAllLayers = options.drawAllLayers;
    var drawOnlyNodeLayer = options.drawOnlyNodeLayer;
    var forcedZoom = options.forcedZoom;
    var forcedPan = options.forcedPan;
    var r = this;
    var pixelRatio = options.forcedPxRatio === undefined ? this.getPixelRatio() : options.forcedPxRatio;
    var cy = r.data.cy; var data = r.data; 
    var needDraw = data.canvasNeedsRedraw;
    var textureDraw = r.textureOnViewport && !forcedContext && (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming);
    var motionBlur = options.motionBlur !== undefined ? options.motionBlur : r.motionBlur;
    var mbPxRatio = r.motionBlurPxRatio;
    var hasCompoundNodes = cy.hasCompoundNodes();
    var inNodeDragGesture = r.hoverData.draggingEles;
    var inBoxSelection = r.hoverData.selecting || r.touchData.selecting ? true : false;
    motionBlur = motionBlur && !forcedContext && r.motionBlurEnabled && !inBoxSelection;
    var motionBlurFadeEffect = motionBlur;

    // console.log('textureDraw?', textureDraw);


    if( !forcedContext && r.motionBlurTimeout ){
      clearTimeout( r.motionBlurTimeout );
    }

    if( !forcedContext && this.redrawTimeout ){
      clearTimeout( this.redrawTimeout );
    }
    this.redrawTimeout = null;

    if( this.averageRedrawTime === undefined ){ this.averageRedrawTime = 0; }

    var minRedrawLimit = CanvasRenderer.minRedrawLimit; 
    var maxRedrawLimit = CanvasRenderer.maxRedrawLimit;

    var redrawLimit = this.averageRedrawTime; // estimate the ideal redraw limit based on how fast we can draw
    redrawLimit = minRedrawLimit > redrawLimit ? minRedrawLimit : redrawLimit;
    redrawLimit = redrawLimit < maxRedrawLimit ? redrawLimit : maxRedrawLimit;

    //console.log('--\nideal: %i; effective: %i', this.averageRedrawTime, redrawLimit);

    if( this.lastDrawTime === undefined ){ this.lastDrawTime = 0; }

    var nowTime = Date.now();
    var timeElapsed = nowTime - this.lastDrawTime;
    var callAfterLimit = timeElapsed >= redrawLimit;

    if( !forcedContext && !r.clearingMotionBlur ){
      if( !callAfterLimit || this.currentlyDrawing ){
        // console.log('-- skip', redrawLimit);

        // we have new things to draw but we're busy, so try again when possibly free
        this.redrawTimeout = setTimeout(function(){
          r.redraw();
        }, redrawLimit);
        return;
      }

      this.lastDrawTime = nowTime;
      this.currentlyDrawing = true;
    }

    if( motionBlur ){
      if( r.mbFrames == null ){
        r.mbFrames = 0;
      }

      if( !r.drawingImage ){ // image loading frames don't count towards motion blur blurry frames
        r.mbFrames++;
      }
      
      if( r.mbFrames < 3 ){ // need several frames before even high quality motionblur
        motionBlurFadeEffect = false;
      }

      // go to lower quality blurry frames when several m/b frames have been rendered (avoids flashing)
      if( r.mbFrames > r.minMbLowQualFrames ){
        //r.fullQualityMb = false;
        r.motionBlurPxRatio = r.mbPxRBlurry;
      }
    } 

    // console.log('mb: %s, N: %s, q: %s', motionBlur, r.mbFrames, r.motionBlurPxRatio);

    if( r.clearingMotionBlur ){
      //r.fullQualityMb = true; // TODO enable when doesn't cause scaled flashing issue

      r.motionBlurPxRatio = 1;
    }


    var startTime = Date.now();

    // console.log('-- redraw --')
    
    function drawToContext(){ 
      // startTime = Date.now();
      // console.profile('draw' + startTime)
      
      // b/c drawToContext() may be async w.r.t. redraw(), keep track of last texture frame
      // because a rogue async texture frame would clear needDraw
      if( r.textureDrawLastFrame && !textureDraw ){
        needDraw[CR.NODE] = true;
        needDraw[CR.SELECT_BOX] = true;
      }
      
      // console.log('drawToContext()');
      // console.log( 'needDraw', needDraw[CR.NODE], needDraw[CR.DRAG], needDraw[CR.SELECT_BOX] );

      var edges = r.getCachedEdges();
      var coreStyle = cy.style()._private.coreStyle;
      
      var zoom = cy.zoom();
      var effectiveZoom = forcedZoom !== undefined ? forcedZoom : zoom;
      var pan = cy.pan();
      var effectivePan = {
        x: pan.x,
        y: pan.y
      };

      var vp = {
        zoom: zoom,
        pan: {
          x: pan.x,
          y: pan.y
        }
      };
      var prevVp = r.prevViewport;
      var viewportIsDiff = prevVp === undefined || vp.zoom !== prevVp.zoom || vp.pan.x !== prevVp.pan.x || vp.pan.y !== prevVp.pan.y;

      // we want the low quality motionblur only when the viewport is being manipulated etc (where it's not noticed)
      if( !viewportIsDiff && !(inNodeDragGesture && !hasCompoundNodes) ){
        r.motionBlurPxRatio = 1;
      }

      if( forcedPan ){
        effectivePan = forcedPan;
      }

      // apply pixel ratio

      effectiveZoom *= pixelRatio;
      effectivePan.x *= pixelRatio;
      effectivePan.y *= pixelRatio;
      
      var eles = {
        drag: {
          nodes: [],
          edges: [],
          eles: []
        },
        nondrag: {
          nodes: [],
          edges: [],
          eles: []
        }
      };

      function mbclear( context, x, y, w, h ){
        var gco = context.globalCompositeOperation;

        context.globalCompositeOperation = 'destination-out';
        r.fillStyle( context, 255, 255, 255, r.motionBlurTransparency );
        context.fillRect(x, y, w, h);

        context.globalCompositeOperation = gco;
      }

      function setContextTransform(context, clear){
        var ePan, eZoom, w, h;

        if( /*!r.fullQualityMb &&*/ !r.clearingMotionBlur && (context === data.bufferContexts[CR.MOTIONBLUR_BUFFER_NODE] || context === data.bufferContexts[CR.MOTIONBLUR_BUFFER_DRAG]) ){
          ePan = {
            x: pan.x * mbPxRatio,
            y: pan.y * mbPxRatio
          };

          eZoom = zoom * mbPxRatio;

          w = r.canvasWidth * mbPxRatio;
          h = r.canvasHeight * mbPxRatio;
        } else {
          ePan = effectivePan;
          eZoom = effectiveZoom;

          w = r.canvasWidth;
          h = r.canvasHeight;
        }

        context.setTransform(1, 0, 0, 1, 0, 0);

        if( clear === 'motionBlur' ){ 
          mbclear(context, 0, 0, w, h);
        } else if( !forcedContext && (clear === undefined || clear) ){
          context.clearRect(0, 0, w, h);
        }
        
        if( !drawAllLayers ){
          context.translate( ePan.x, ePan.y );
          context.scale( eZoom, eZoom );
        }
        if( forcedPan ){
          context.translate( forcedPan.x, forcedPan.y );
        } 
        if( forcedZoom ){
          context.scale( forcedZoom, forcedZoom );
        }
      }

      if( !textureDraw ){
        r.textureDrawLastFrame = false;
      }

      if( textureDraw ){
        // console.log('textureDraw')
        
        r.textureDrawLastFrame = true;

        var bb;

        if( !r.textureCache ){
          r.textureCache = {};

          bb = r.textureCache.bb = cy.elements().boundingBox();

          r.textureCache.texture = r.data.bufferCanvases[ CanvasRenderer.TEXTURE_BUFFER ];

          var cxt = r.data.bufferContexts[ CanvasRenderer.TEXTURE_BUFFER ];

          cxt.setTransform(1, 0, 0, 1, 0, 0);
          cxt.clearRect(0, 0, r.canvasWidth * r.textureMult, r.canvasHeight * r.textureMult);
          
          r.redraw({
            forcedContext: cxt,
            drawOnlyNodeLayer: true,
            forcedPxRatio: pixelRatio * r.textureMult
          });

          var vp = r.textureCache.viewport = {
            zoom: cy.zoom(),
            pan: cy.pan(),
            width: r.canvasWidth,
            height: r.canvasHeight
          };

          vp.mpan = {
            x: (0 - vp.pan.x)/vp.zoom,
            y: (0 - vp.pan.y)/vp.zoom
          };
        }

        needDraw[CR.DRAG] = false;
        needDraw[CR.NODE] = false;

        var context = data.contexts[CR.NODE];

        var texture = r.textureCache.texture;
        var vp = r.textureCache.viewport;
        bb = r.textureCache.bb;

        context.setTransform(1, 0, 0, 1, 0, 0);

        if( motionBlur ){
          mbclear(context, 0, 0, vp.width, vp.height);
        } else {
          context.clearRect(0, 0, vp.width, vp.height);
        }

        var outsideBgColor = coreStyle['outside-texture-bg-color'].value;
        var outsideBgOpacity = coreStyle['outside-texture-bg-opacity'].value;
        r.fillStyle( context, outsideBgColor[0], outsideBgColor[1], outsideBgColor[2], outsideBgOpacity );
        context.fillRect( 0, 0, vp.width, vp.height );

        var zoom = cy.zoom();
        
        setContextTransform( context, false );

        context.clearRect( vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );
        context.drawImage( texture, vp.mpan.x, vp.mpan.y, vp.width/vp.zoom/pixelRatio, vp.height/vp.zoom/pixelRatio );

      } else if( r.textureOnViewport && !forcedContext ){ // clear the cache since we don't need it
        r.textureCache = null;
      }

      var vpManip = (r.pinching || r.hoverData.dragging || r.swipePanning || r.data.wheelZooming || r.hoverData.draggingEles);
      var hideEdges = r.hideEdgesOnViewport && vpManip;
      var hideLabels = r.hideLabelsOnViewport && vpManip;

      if (needDraw[CR.DRAG] || needDraw[CR.NODE] || drawAllLayers || drawOnlyNodeLayer) {
        //NB : VERY EXPENSIVE

        if( hideEdges ){ 
        } else {
          r.findEdgeControlPoints(edges);
        }

        var zEles = r.getCachedZSortedEles();
        var extent = cy.extent();

        for (var i = 0; i < zEles.length; i++) {
          var ele = zEles[i];
          var list;
          var bb = forcedContext ? null : ele.boundingBox();
          var insideExtent = forcedContext ? true : $$.math.boundingBoxesIntersect( extent, bb );

          if( !insideExtent ){ continue; } // no need to render

          if ( ele._private.rscratch.inDragLayer ) {
            list = eles.drag;
          } else {
            list = eles.nondrag;
          }

          list.eles.push( ele );
        }

      }
      
      
      function drawElements( list, context ){
        var eles = list.eles;

        for( var i = 0; i < eles.length; i++ ){
          var ele = eles[i];

          if( ele.isNode() ){
            r.drawNode(context, ele);

            if( !hideLabels ){
              r.drawNodeText(context, ele);
            }

            r.drawNode(context, ele, true);
          } else if( !hideEdges ) {
            r.drawEdge(context, ele);

            if( !hideLabels ){
              r.drawEdgeText(context, ele);
            }

            r.drawEdge(context, ele, true);
          }
          
          
        }

      }

      var needMbClear = [];

      needMbClear[CR.NODE] = !needDraw[CR.NODE] && motionBlur && !r.clearedForMotionBlur[CR.NODE] || r.clearingMotionBlur;
      if( needMbClear[CR.NODE] ){ r.clearedForMotionBlur[CR.NODE] = true; }

      needMbClear[CR.DRAG] = !needDraw[CR.DRAG] && motionBlur && !r.clearedForMotionBlur[CR.DRAG] || r.clearingMotionBlur;
      if( needMbClear[CR.DRAG] ){ r.clearedForMotionBlur[CR.DRAG] = true; }

      // console.log('--');

      // if( needDraw[CR.DRAG] && motionBlur && needDraw[CR.NODE] && inNodeDragGesture ){
      //   console.log('NODE blurclean');
      // 
      //   var context = data.contexts[CR.NODE];
      // 
      //   setContextTransform( context, true );
      //   drawElements(eles.nondrag, context);
      // 
      //   needDraw[CR.NODE] = false; 
      //   needMbClear[CR.NODE] = false;
      // 
      // } else 
      if( needDraw[CR.NODE] || drawAllLayers || drawOnlyNodeLayer || needMbClear[CR.NODE] ){
        // console.log('NODE', needDraw[CR.NODE], needMbClear[CR.NODE]);

        var useBuffer = motionBlur && !needMbClear[CR.NODE] && mbPxRatio !== 1;
        var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ CR.MOTIONBLUR_BUFFER_NODE ] : data.contexts[CR.NODE] );
        var clear = motionBlur && !useBuffer ? 'motionBlur' : undefined;

        // if( needDraw[CR.DRAG] && needDraw[CR.NODE] ){
        //   clear = true;
        // }

        setContextTransform( context, clear );
        drawElements(eles.nondrag, context);
        
        if( !drawAllLayers && !motionBlur ){
          needDraw[CR.NODE] = false; 
        }
      }

      if ( !drawOnlyNodeLayer && (needDraw[CR.DRAG] || drawAllLayers || needMbClear[CR.DRAG]) ) {
        // console.log('DRAG');

        var useBuffer = motionBlur && !needMbClear[CR.DRAG] && mbPxRatio !== 1;
        var context = forcedContext || ( useBuffer ? r.data.bufferContexts[ CR.MOTIONBLUR_BUFFER_DRAG ] : data.contexts[CR.DRAG] );
        
        setContextTransform( context, motionBlur && !useBuffer ? 'motionBlur' : undefined );
        drawElements(eles.drag, context);
        
        if( !drawAllLayers && !motionBlur ){
          needDraw[CR.DRAG] = false;
        }
      }
      
      if( r.showFps || (!drawOnlyNodeLayer && (needDraw[CR.SELECT_BOX] && !drawAllLayers)) ) {
        // console.log('redrawing selection box');
        
        var context = forcedContext || data.contexts[CR.SELECT_BOX];

        setContextTransform( context );

        if( data.select[4] == 1 && ( r.hoverData.selecting || r.touchData.selecting ) ){
          var zoom = data.cy.zoom();
          var borderWidth = coreStyle['selection-box-border-width'].value / zoom;
          
          context.lineWidth = borderWidth;
          context.fillStyle = "rgba(" 
            + coreStyle['selection-box-color'].value[0] + ","
            + coreStyle['selection-box-color'].value[1] + ","
            + coreStyle['selection-box-color'].value[2] + ","
            + coreStyle['selection-box-opacity'].value + ")";
          
          context.fillRect(
            data.select[0],
            data.select[1],
            data.select[2] - data.select[0],
            data.select[3] - data.select[1]);
          
          if (borderWidth > 0) {
            context.strokeStyle = "rgba(" 
              + coreStyle['selection-box-border-color'].value[0] + ","
              + coreStyle['selection-box-border-color'].value[1] + ","
              + coreStyle['selection-box-border-color'].value[2] + ","
              + coreStyle['selection-box-opacity'].value + ")";
            
            context.strokeRect(
              data.select[0],
              data.select[1],
              data.select[2] - data.select[0],
              data.select[3] - data.select[1]);
          }
        }

        if( data.bgActivePosistion && !r.hoverData.selecting ){
          var zoom = data.cy.zoom();
          var pos = data.bgActivePosistion;

          context.fillStyle = "rgba(" 
            + coreStyle['active-bg-color'].value[0] + ","
            + coreStyle['active-bg-color'].value[1] + ","
            + coreStyle['active-bg-color'].value[2] + ","
            + coreStyle['active-bg-opacity'].value + ")";

          context.beginPath();
          context.arc(pos.x, pos.y, coreStyle['active-bg-size'].pxValue / zoom, 0, 2 * Math.PI); 
          context.fill();
        }
        
        var timeToRender = r.averageRedrawTime;
        if( r.showFps && timeToRender ){
          timeToRender = Math.round( timeToRender );
          var fps = Math.round(1000/timeToRender);

          context.setTransform(1, 0, 0, 1, 0, 0);

          //context.font = '20px helvetica';
          context.fillStyle = 'rgba(255, 0, 0, 0.75)';
          context.strokeStyle = 'rgba(255, 0, 0, 0.75)';
          context.lineWidth = 1;
          context.fillText( '1 frame = ' + timeToRender + ' ms = ' + fps + ' fps', 0, 20);

          var maxFps = 60;
          context.strokeRect(0, 30, 250, 20);
          context.fillRect(0, 30, 250 * Math.min(fps/maxFps, 1), 20);
        }

        if( !drawAllLayers ){
          needDraw[CR.SELECT_BOX] = false; 
        }
      }

      // motionblur: blit rendered blurry frames
      if( motionBlur && mbPxRatio !== 1 ){
        var cxtNode = data.contexts[CR.NODE];
        var txtNode = r.data.bufferCanvases[ CR.MOTIONBLUR_BUFFER_NODE ];

        var cxtDrag = data.contexts[CR.DRAG];
        var txtDrag = r.data.bufferCanvases[ CR.MOTIONBLUR_BUFFER_DRAG ];

        var drawMotionBlur = function( cxt, txt, needClear ){
          cxt.setTransform(1, 0, 0, 1, 0, 0);

          if( needClear || !motionBlurFadeEffect ){
            cxt.clearRect( 0, 0, r.canvasWidth, r.canvasHeight );
          } else {
            mbclear( cxt, 0, 0, r.canvasWidth, r.canvasHeight );
          }
          
          var pxr = /*r.fullQualityMb ? 1 :*/ mbPxRatio;

          cxt.drawImage( 
            txt, // img
            0, 0, // sx, sy
            r.canvasWidth * pxr, r.canvasHeight * pxr, // sw, sh
            0, 0, // x, y
            r.canvasWidth, r.canvasHeight // w, h
          );
        };

        if( needDraw[CR.NODE] || needMbClear[CR.NODE] ){
          // console.log('mb NODE', needMbClear[CR.NODE]);

          drawMotionBlur( cxtNode, txtNode, needMbClear[CR.NODE] );
          needDraw[CR.NODE] = false;
        }

        if( needDraw[CR.DRAG] || needMbClear[CR.DRAG] ){
          // console.log('mb DRAG');

          drawMotionBlur( cxtDrag, txtDrag, needMbClear[CR.DRAG] );
          needDraw[CR.DRAG] = false;
          //needMbClear[CR.NODE] = true;
        }
      }


      var endTime = Date.now();

      if( r.averageRedrawTime === undefined ){
        r.averageRedrawTime = endTime - startTime;
      }

      if( r.redrawCount === undefined ){
        r.redrawCount = 0;
      }

      r.redrawCount++;

      if( r.redrawTotalTime === undefined ){
        r.redrawTotalTime = 0;
      }

      r.redrawTotalTime += endTime - startTime;
      r.lastRedrawTime = endTime - startTime;

      // use a weighted average with a bias from the previous average so we don't spike so easily
      r.averageRedrawTime = r.averageRedrawTime/2 + (endTime - startTime)/2;
      //console.log('actual: %i, average: %i', endTime - startTime, this.averageRedrawTime);

      r.currentlyDrawing = false;

      r.prevViewport = vp;

      // console.profileEnd('draw' + startTime)

      if( r.clearingMotionBlur ){
        r.clearingMotionBlur = false;
        r.motionBlurCleared = true;
        r.motionBlur = true;
      }

      if( motionBlur ){ 
        r.motionBlurTimeout = setTimeout(function(){
          r.motionBlurTimeout = null;
          // console.log('mb CLEAR');

          r.clearedForMotionBlur[CR.NODE] = false;
          r.clearedForMotionBlur[CR.DRAG] = false;
          r.motionBlur = false;
          r.clearingMotionBlur = !textureDraw;
          r.mbFrames = 0;

          needDraw[CR.NODE] = true; 
          needDraw[CR.DRAG] = true; 

          r.redraw();
        }, CanvasRenderer.motionBlurDelay);
      }

      r.drawingImage = false;

    } // draw to context

    if( !forcedContext ){
      $$.util.requestAnimationFrame(drawToContext); // makes direct renders to screen a bit more responsive
    } else {
      drawToContext();
    }

    if( !forcedContext && !r.initrender ){
      r.initrender = true;
      cy.trigger('initrender');
    }

    if( !forcedContext ){
      cy.triggerOnRender();
    }
    
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  // @O Polygon drawing
  CRp.drawPolygonPath = function(
    context, x, y, width, height, points) {

    var halfW = width / 2;
    var halfH = height / 2;

    if( context.beginPath ){ context.beginPath(); }

    context.moveTo( x + halfW * points[0], y + halfH * points[1] );

    for (var i = 1; i < points.length / 2; i++) {
      context.lineTo( x + halfW * points[i * 2], y + halfH * points[i * 2 + 1] );
    }
    
    context.closePath();
  };
  
  CRp.drawPolygon = function(
    context, x, y, width, height, points) {

    // Draw path
    this.drawPolygonPath(context, x, y, width, height, points);
    
    // Fill path
    context.fill();
  };
  
  // Round rectangle drawing
  CRp.drawRoundRectanglePath = function(
    context, x, y, width, height, radius) {
    
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var cornerRadius = $$.math.getRoundRectangleRadius(width, height);
    
    if( context.beginPath ){ context.beginPath(); }
    
    // Start at top middle
    context.moveTo(x, y - halfHeight);
    // Arc from middle top to right side
    context.arcTo(x + halfWidth, y - halfHeight, x + halfWidth, y, cornerRadius);
    // Arc from right side to bottom
    context.arcTo(x + halfWidth, y + halfHeight, x, y + halfHeight, cornerRadius);
    // Arc from bottom to left side
    context.arcTo(x - halfWidth, y + halfHeight, x - halfWidth, y, cornerRadius);
    // Arc from left side to topBorder
    context.arcTo(x - halfWidth, y - halfHeight, x, y - halfHeight, cornerRadius);
    // Join line
    context.lineTo(x, y - halfHeight);
    
    
    context.closePath();
  };
  
  CRp.drawRoundRectangle = function(
    context, x, y, width, height, radius) {
    
    this.drawRoundRectanglePath(context, x, y, width, height, radius);
    
    context.fill();
  };


})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CRp = CanvasRenderer.prototype;

  CRp.createBuffer = function(w, h) {
    var buffer = document.createElement('canvas');
    buffer.width = w;
    buffer.height = h;
    
    return [buffer, buffer.getContext('2d')];
  };

  CRp.bufferCanvasImage = function( options ){
    var data = this.data;
    var cy = data.cy;
    var bb = cy.elements().boundingBox();
    var width = options.full ? Math.ceil(bb.w) : this.data.container.clientWidth;
    var height = options.full ? Math.ceil(bb.h) : this.data.container.clientHeight;
    var scale = 1;

    if( options.scale !== undefined ){
      width *= options.scale;
      height *= options.scale;

      scale = options.scale;
    } else if( $$.is.number(options.maxWidth) || $$.is.number(options.maxHeight) ){
      var maxScaleW = Infinity;
      var maxScaleH = Infinity;

      if( $$.is.number(options.maxWidth) ){
        maxScaleW = scale * options.maxWidth / width;
      }

      if( $$.is.number(options.maxHeight) ){
        maxScaleH = scale * options.maxHeight / height;
      }

      scale = Math.min( maxScaleW, maxScaleH );

      width *= scale;
      height *= scale;
    }

    var buffCanvas = document.createElement('canvas');

    buffCanvas.width = width;
    buffCanvas.height = height;

    buffCanvas.style.width = width + 'px';
    buffCanvas.style.height = height + 'px';

    var buffCxt = buffCanvas.getContext('2d');

    // Rasterize the layers, but only if container has nonzero size
    if (width > 0 && height > 0) {

      buffCxt.clearRect( 0, 0, width, height );

      if( options.bg ){
        buffCxt.fillStyle = options.bg;
        buffCxt.rect( 0, 0, width, height );
        buffCxt.fill();
      }

      buffCxt.globalCompositeOperation = 'source-over';

      if( options.full ){ // draw the full bounds of the graph
        this.redraw({
          forcedContext: buffCxt,
          drawAllLayers: true,
          forcedZoom: scale,
          forcedPan: { x: -bb.x1*scale, y: -bb.y1*scale },
          forcedPxRatio: 1
        });
      } else { // draw the current view
        var cyPan = cy.pan();
        var pan = {
          x: cyPan.x * scale,
          y: cyPan.y * scale
        };
        var zoom = cy.zoom() * scale;

        this.redraw({
          forcedContext: buffCxt,
          drawAllLayers: true,
          forcedZoom: zoom,
          forcedPan: pan,
          forcedPxRatio: 1
        });
      }
    }

    return buffCanvas;
  }; 

  CRp.png = function( options ){
    return this.bufferCanvasImage( options ).toDataURL('image/png');
  };
  
  CRp.jpg = function( options ){
    return this.bufferCanvasImage( options ).toDataURL('image/jpeg');
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var CR = CanvasRenderer;
  var CRp = CR.prototype;

  CRp.registerBinding = function(target, event, handler, useCapture){
    this.bindings.push({
      target: target,
      event: event,
      handler: handler,
      useCapture: useCapture
    });

    target.addEventListener(event, handler, useCapture);
  };

  CRp.nodeIsDraggable = function(node) {
    if (node._private.style['opacity'].value !== 0
      && node._private.style['visibility'].value == 'visible'
      && node._private.style['display'].value == 'element'
      && !node.locked()
      && node.grabbable() ) {

      return true;
    }

    return false;
  };

  CRp.load = function() {
    var r = this;

    var getDragListIds = function(opts){
      var listHasId;

      if( opts.addToList && r.data.cy.hasCompoundNodes() ){ // only needed for compound graphs
        if( !opts.addToList.hasId ){ // build ids lookup if doesn't already exist
          opts.addToList.hasId = {};

          for( var i = 0; i < opts.addToList.length; i++ ){
            var ele = opts.addToList[i];

            opts.addToList.hasId[ ele.id() ] = true;
          }
        }

        listHasId = opts.addToList.hasId;
      }

      return listHasId || {};
    };

    // helper function to determine which child nodes and inner edges
    // of a compound node to be dragged as well as the grabbed and selected nodes
    var addDescendantsToDrag = function(node, opts){
      if( !node._private.cy.hasCompoundNodes() ){
        return;
      }

      if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

      var listHasId = getDragListIds( opts );

      var innerNodes = node.descendants();

      // TODO do not drag hidden children & children of hidden children?
      for( var i = 0; i < innerNodes.size(); i++ ){
        var iNode = innerNodes[i];
        var _p = iNode._private;

        if( opts.inDragLayer ){
          _p.rscratch.inDragLayer = true;
        }

        if( opts.addToList && !listHasId[ iNode.id() ] ){
          opts.addToList.push( iNode );
          listHasId[ iNode.id() ] = true;

          _p.grabbed = true;
        }

        var edges = _p.edges;
        for( var j = 0; opts.inDragLayer && j < edges.length; j++ ){
          edges[j]._private.rscratch.inDragLayer = true;
        }
      }
    };

    // adds the given nodes, and its edges to the drag layer
    var addNodeToDrag = function(node, opts){

      var _p = node._private;
      var listHasId = getDragListIds( opts );

      if( opts.inDragLayer ){
        _p.rscratch.inDragLayer = true;
      }

      if( opts.addToList && !listHasId[ node.id() ] ){
        opts.addToList.push( node );
        listHasId[ node.id() ] = true;

        _p.grabbed = true;
      }

      var edges = _p.edges;
      for( var i = 0; opts.inDragLayer && i < edges.length; i++ ){
        edges[i]._private.rscratch.inDragLayer = true;
      }

      addDescendantsToDrag( node, opts ); // always add to drag

      // also add nodes and edges related to the topmost ancestor
      updateAncestorsInDragLayer( node, {
        inDragLayer: opts.inDragLayer
      } );
    };
    
    var freeDraggedElements = function( draggedElements ){
      if( !draggedElements ){ return; }
      
      for (var i=0; i < draggedElements.length; i++) {

        var dEi_p = draggedElements[i]._private;

        if(dEi_p.group === 'nodes') {
          dEi_p.rscratch.inDragLayer = false;
          dEi_p.grabbed = false;

          var sEdges = dEi_p.edges;
          for( var j = 0; j < sEdges.length; j++ ){ sEdges[j]._private.rscratch.inDragLayer = false; }

          // for compound nodes, also remove related nodes and edges from the drag layer
          updateAncestorsInDragLayer(draggedElements[i], { inDragLayer: false });

        } else if( dEi_p.group === 'edges' ){
          dEi_p.rscratch.inDragLayer = false;
        }

      }
    };

    // helper function to determine which ancestor nodes and edges should go
    // to the drag layer (or should be removed from drag layer).
    var updateAncestorsInDragLayer = function(node, opts) {

      if( opts.inDragLayer == null && opts.addToList == null ){ return; } // nothing to do

      // find top-level parent
      var parent = node;

      if( !node._private.cy.hasCompoundNodes() ){
        return;
      }

      while( parent.parent().nonempty() ){
        parent = parent.parent()[0];
      }

      // no parent node: no nodes to add to the drag layer
      if( parent == node ){
        return;
      }

      var nodes = parent.descendants()
        .merge( parent )
        .unmerge( node )
        .unmerge( node.descendants() )
      ;

      var edges = nodes.connectedEdges();

      var listHasId = getDragListIds( opts );

      for( var i = 0; i < nodes.size(); i++ ){
        if( opts.inDragLayer !== undefined ){
          nodes[i]._private.rscratch.inDragLayer = opts.inDragLayer;
        }

        if( opts.addToList && !listHasId[ nodes[i].id() ] ){
          opts.addToList.push( nodes[i] );
          listHasId[ nodes[i].id() ] = true;

          nodes[i]._private.grabbed = true;
        }
      }

      for( var j = 0; opts.inDragLayer !== undefined && j < edges.length; j++ ) {
        edges[j]._private.rscratch.inDragLayer = opts.inDragLayer;
      }
    };

    if( typeof MutationObserver !== 'undefined' ){
      r.removeObserver = new MutationObserver(function( mutns ){
        for( var i = 0; i < mutns.length; i++ ){
          var mutn = mutns[i];
          var rNodes = mutn.removedNodes;

          if( rNodes ){ for( var j = 0; j < rNodes.length; j++ ){
            var rNode = rNodes[j];

            if( rNode === r.data.container ){
              r.destroy();
              break;
            }
          } }
        }
      });

      r.removeObserver.observe( r.data.container.parentNode, { childList: true } );
    } else {
      r.registerBinding(r.data.container, 'DOMNodeRemoved', function(e){
        r.destroy();
      });
    }



    // auto resize
    r.registerBinding(window, 'resize', $$.util.debounce( function(e) {
      r.invalidateContainerClientCoordsCache();

      r.matchCanvasSize(r.data.container);
      r.data.canvasNeedsRedraw[CR.NODE] = true;
      r.redraw();
    }, 100 ) );

    var invalCtnrBBOnScroll = function(domEle){
      r.registerBinding(domEle, 'scroll', function(e){
        r.invalidateContainerClientCoordsCache();
      } );
    };

    var bbCtnr = r.data.cy.container();

    for( ;; ){

      invalCtnrBBOnScroll( bbCtnr );

      if( bbCtnr.parentNode ){
        bbCtnr = bbCtnr.parentNode;
      } else {
        break;
      }

    }

    // stop right click menu from appearing on cy
    r.registerBinding(r.data.container, 'contextmenu', function(e){
      e.preventDefault();
    });

    var inBoxSelection = function(){
      return r.data.select[4] !== 0;
    };

    // Primary key
    r.registerBinding(r.data.container, 'mousedown', function(e) {
      e.preventDefault();
      r.hoverData.capture = true;
      r.hoverData.which = e.which;

      var cy = r.data.cy;
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var select = r.data.select;
      var near = r.findNearestElement(pos[0], pos[1], true, false);
      var draggedElements = r.dragData.possibleDragElements;

      r.hoverData.mdownPos = pos;
      
      var needsRedraw = r.data.canvasNeedsRedraw;

      var checkForTaphold = function(){
        r.hoverData.tapholdCancelled = false;

        clearTimeout( r.hoverData.tapholdTimeout );

        r.hoverData.tapholdTimeout = setTimeout(function(){

          if( r.hoverData.tapholdCancelled ){
            return;
          } else {
            var ele = r.hoverData.down;

            if( ele ){
              ele.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: pos[0], y: pos[1] }
              }) );
            } else {
              cy.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: pos[0], y: pos[1] }
              }) );
            }
          }

        }, r.tapholdDuration);
      };

      // Right click button
      if( e.which == 3 ){

        r.hoverData.cxtStarted = true;

        var cxtEvt = new $$.Event(e, {
          type: 'cxttapstart',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( near ){
          near.activate();
          near.trigger( cxtEvt );

          r.hoverData.down = near;
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.downTime = (new Date()).getTime();
        r.hoverData.cxtDragged = false;

      // Primary button
      } else if (e.which == 1) {

        if( near ){
          near.activate();
        }

        // Element dragging
        {
          // If something is under the cursor and it is draggable, prepare to grab it
          if (near != null) {

            if( r.nodeIsDraggable(near) ){

              var grabEvent = new $$.Event(e, {
                type: 'grab',
                cyPosition: { x: pos[0], y: pos[1] }
              });

              if ( near.isNode() && !near.selected() ){

                draggedElements = r.dragData.possibleDragElements = [];
                addNodeToDrag( near, { addToList: draggedElements } );

                near.trigger(grabEvent);

              } else if ( near.isNode() && near.selected() ){
                draggedElements = r.dragData.possibleDragElements = [  ];

                var selectedNodes = cy.$(function(){ return this.isNode() && this.selected(); });

                for( var i = 0; i < selectedNodes.length; i++ ){

                  // Only add this selected node to drag if it is draggable, eg. has nonzero opacity
                  if( r.nodeIsDraggable( selectedNodes[i] ) ){
                    addNodeToDrag( selectedNodes[i], { addToList: draggedElements } );
                  }
                }

                near.trigger( grabEvent );
              }

              needsRedraw[CR.NODE] = true;
              needsRedraw[CR.DRAG] = true;

            }

            near
              .trigger(new $$.Event(e, {
                type: 'mousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapstart',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;

          } else if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'mousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapstart',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmousedown',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          }

          r.hoverData.down = near;
          r.hoverData.downTime = (new Date()).getTime();

        }

        // Selection box
        if ( near == null || near.isEdge() ) {
          select[4] = 1;
          var timeUntilActive = Math.max( 0, CR.panOrBoxSelectDelay - (+new Date() - r.hoverData.downTime) );

          clearTimeout( r.bgActiveTimeout );

          if( cy.boxSelectionEnabled() || ( near && near.isEdge() ) ){
            r.bgActiveTimeout = setTimeout(function(){
              if( near ){
                near.unactivate();
              }

              r.data.bgActivePosistion = {
                x: pos[0],
                y: pos[1]
              };

              r.hoverData.dragging = true;

              //checkForTaphold();

              needsRedraw[CR.SELECT_BOX] = true;

              r.redraw();
            }, timeUntilActive);
          } else {
            r.data.bgActivePosistion = {
              x: pos[0],
              y: pos[1]
            };

            //r.hoverData.dragging = true;

            //checkForTaphold();

            needsRedraw[CR.SELECT_BOX] = true;

            r.redraw();
          }

        }

        checkForTaphold();

      }

      // Initialize selection box coordinates
      select[0] = select[2] = pos[0];
      select[1] = select[3] = pos[1];

    }, false);

    r.registerBinding(window, 'mousemove', $$.util.throttle( function(e) {
      var preventDefault = false;
      var capture = r.hoverData.capture;

      // save cycles if mouse events aren't to be captured
      if ( !capture ){
        var containerPageCoords = r.findContainerClientCoords();

        if (e.clientX > containerPageCoords[0] && e.clientX < containerPageCoords[0] + r.canvasWidth
          && e.clientY > containerPageCoords[1] && e.clientY < containerPageCoords[1] + r.canvasHeight
        ) {
          // inside container bounds so OK
        } else {
          return;
        }

        var cyContainer = r.data.container;
        var target = e.target;
        var tParent = target.parentNode;
        var containerIsTarget = false;

        while( tParent ){
          if( tParent === cyContainer ){
            containerIsTarget = true;
            break;
          }

          tParent = tParent.parentNode;
        }

        if( !containerIsTarget ){ return; } // if target is outisde cy container, then this event is not for us
      }

      var cy = r.data.cy;
      var zoom = cy.zoom();
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var select = r.data.select;
      var needsRedraw = r.data.canvasNeedsRedraw;

      var near = null;
      if( !r.hoverData.draggingEles ){
        near = r.findNearestElement(pos[0], pos[1], true, false);
      }
      var last = r.hoverData.last;
      var down = r.hoverData.down;

      var disp = [pos[0] - select[2], pos[1] - select[3]];

      var draggedElements = r.dragData.possibleDragElements;

      var dx = select[2] - select[0];
      var dx2 = dx * dx;
      var dy = select[3] - select[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      r.hoverData.tapholdCancelled = true;

      var updateDragDelta = function(){
        var dragDelta = r.hoverData.dragDelta = r.hoverData.dragDelta || [];

        if( dragDelta.length === 0 ){
          dragDelta.push( disp[0] );
          dragDelta.push( disp[1] );
        } else {
          dragDelta[0] += disp[0];
          dragDelta[1] += disp[1];
        }
      };


      preventDefault = true;

      // Mousemove event
      {
        if (near != null) {
          near
            .trigger(new $$.Event(e, {
              type: 'mousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
          ;

        } else if (near == null) {
          cy
            .trigger(new $$.Event(e, {
              type: 'mousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: pos[0], y: pos[1] }
            }))
          ;
        }

      }

      // trigger context drag if rmouse down
      if( r.hoverData.which === 3 ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxtdrag',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        r.hoverData.cxtDragged = true;

        if( !r.hoverData.cxtOver || near !== r.hoverData.cxtOver ){

          if( r.hoverData.cxtOver ){
            r.hoverData.cxtOver.trigger( new $$.Event(e, {
              type: 'cxtdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            // console.log('cxtdragout ' + r.hoverData.cxtOver.id());
          }

          r.hoverData.cxtOver = near;

          if( near ){
            near.trigger( new $$.Event(e, {
              type: 'cxtdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            // console.log('cxtdragover ' + near.id());
          }

        }

      // Check if we are drag panning the entire graph
      } else if (r.hoverData.dragging) {
        preventDefault = true;

        if( cy.panningEnabled() && cy.userPanningEnabled() ){
          var deltaP;

          if( r.hoverData.justStartedPan ){
            var mdPos = r.hoverData.mdownPos;

            deltaP = {
              x: ( pos[0] - mdPos[0] ) * zoom,
              y: ( pos[1] - mdPos[1] ) * zoom
            };

            r.hoverData.justStartedPan = false;

          } else {
            deltaP = {
              x: disp[0] * zoom,
              y: disp[1] * zoom
            };

          }

          cy.panBy( deltaP );

          r.hoverData.dragged = true;
        }

        // Needs reproject due to pan changing viewport
        pos = r.projectIntoViewport(e.clientX, e.clientY);

      // Checks primary button down & out of time & mouse not moved much
      } else if(
          select[4] == 1 && (down == null || down.isEdge())
          && ( !cy.boxSelectionEnabled() || (+new Date() - r.hoverData.downTime >= CR.panOrBoxSelectDelay) )
          //&& (Math.abs(select[3] - select[1]) + Math.abs(select[2] - select[0]) < 4)
          && !r.hoverData.selecting
          && rdist2 >= r.desktopTapThreshold2
          && cy.panningEnabled() && cy.userPanningEnabled()
      ){
        r.hoverData.dragging = true;
        r.hoverData.selecting = false;
        r.hoverData.justStartedPan = true;
        select[4] = 0;

      } else {
        // deactivate bg on box selection
        if (cy.boxSelectionEnabled() && !r.hoverData.dragging && Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]){
          clearTimeout( r.bgActiveTimeout );
          r.data.bgActivePosistion = undefined;
          r.hoverData.selecting = true;

          needsRedraw[CR.SELECT_BOX] = true;
          r.redraw();
        }

        if( down && down.isEdge() && down.active() ){ down.unactivate(); }

        if (near != last) {

          if (last) {
            last.trigger( new $$.Event(e, {
              type: 'mouseout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            last.trigger( new $$.Event(e, {
              type: 'tapdragout',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );
          }

          if (near) {
            near.trigger( new $$.Event(e, {
              type: 'mouseover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );

            near.trigger( new $$.Event(e, {
              type: 'tapdragover',
              cyPosition: { x: pos[0], y: pos[1] }
            }) );
          }

          r.hoverData.last = near;
        }

        if( down && down.isNode() && r.nodeIsDraggable(down) ){

          if( rdist2 >= r.desktopTapThreshold2 ){ // then drag

            var justStartedDrag = !r.dragData.didDrag;

            if( justStartedDrag ) {
              needsRedraw[CR.NODE] = true;
            }

            r.dragData.didDrag = true; // indicate that we actually did drag the node

            var toTrigger = [];

            for( var i = 0; i < draggedElements.length; i++ ){
              var dEle = draggedElements[i];

              // now, add the elements to the drag layer if not done already
              if( !r.hoverData.draggingEles ){
                addNodeToDrag( dEle, { inDragLayer: true } );
              }

              // Locked nodes not draggable, as well as non-visible nodes
              if( dEle.isNode() && r.nodeIsDraggable(dEle) && dEle.grabbed() ){
                var dPos = dEle._private.position;

                toTrigger.push( dEle );

                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];

                  if( justStartedDrag ){
                    var dragDelta = r.hoverData.dragDelta;

                    if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){
                      dPos.x += dragDelta[0];
                      dPos.y += dragDelta[1];
                    }
                  }
                }

              }
            }

            r.hoverData.draggingEles = true;

            var tcol = (new $$.Collection(cy, toTrigger));

            tcol.updateCompoundBounds();
            tcol.trigger('position drag');

            needsRedraw[CR.DRAG] = true;
            r.redraw();

          } else { // otherwise save drag delta for when we actually start dragging so the relative grab pos is constant
            updateDragDelta();
          }
        }

        // prevent the dragging from triggering text selection on the page
        preventDefault = true;
      }

      select[2] = pos[0]; select[3] = pos[1];

      if( preventDefault ){
        if(e.stopPropagation) e.stopPropagation();
          if(e.preventDefault) e.preventDefault();
          return false;
        }
    }, 1000/30, { trailing: true }), false);

    r.registerBinding(window, 'mouseup', function(e) {
      // console.log('--\nmouseup', e)

      var capture = r.hoverData.capture;
      if (!capture) { return; }
      r.hoverData.capture = false;

      var cy = r.data.cy; var pos = r.projectIntoViewport(e.clientX, e.clientY); var select = r.data.select;
      var near = r.findNearestElement(pos[0], pos[1], true, false);
      var draggedElements = r.dragData.possibleDragElements; var down = r.hoverData.down;
      var shiftDown = e.shiftKey;
      var needsRedraw = r.data.canvasNeedsRedraw;

      if( r.data.bgActivePosistion ){
        needsRedraw[CR.SELECT_BOX] = true;
        r.redraw();
      }

      r.data.bgActivePosistion = undefined; // not active bg now
      clearTimeout( r.bgActiveTimeout );

      if( down ){
        down.unactivate();
      }

      if( r.hoverData.which === 3 ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxttapend',
          cyPosition: { x: pos[0], y: pos[1] }
        });

        if( down ){
          down.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        if( !r.hoverData.cxtDragged ){
          var cxtTap = new $$.Event(e, {
            type: 'cxttap',
            cyPosition: { x: pos[0], y: pos[1] }
          });

          if( down ){
            down.trigger( cxtTap );
          } else {
            cy.trigger( cxtTap );
          }
        }

        r.hoverData.cxtDragged = false;
        r.hoverData.which = null;

      // if not right mouse
      } else {

        // Deselect all elements if nothing is currently under the mouse cursor and we aren't dragging something
        if ( (down == null) // not mousedown on node
          && !r.dragData.didDrag // didn't move the node around
          //&& !(Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4]) // not box selection
          && !r.hoverData.dragged // didn't pan
        ) {

          cy.$(function(){
            return this.selected();
          }).unselect();

          if (draggedElements.length > 0) {
            needsRedraw[CR.NODE] = true;
          }

          r.dragData.possibleDragElements = draggedElements = [];
        }


        // Mouseup event
        {
          // console.log('trigger mouseup et al');

          if (near != null) {
            near
              .trigger(new $$.Event(e, {
                type: 'mouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          } else if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'mouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: pos[0], y: pos[1] }
              }))
            ;
          }
        }

        // Click event
        {
          // console.log('trigger click et al');

          if(
            //Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) === 0
            !r.dragData.didDrag // didn't move a node around
            && !r.hoverData.dragged // didn't pan
          ){
            if (near != null) {
              near
                .trigger( new $$.Event(e, {
                  type: 'click',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'tap',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'vclick',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
              ;
            } else if (near == null) {
              cy
                .trigger( new $$.Event(e, {
                  type: 'click',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'tap',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
                .trigger( new $$.Event(e, {
                  type: 'vclick',
                  cyPosition: { x: pos[0], y: pos[1] }
                }) )
              ;
            }
          }
        }

        // Single selection
        if (near == down && !r.dragData.didDrag) {
          if (near != null && near._private.selectable) {

            // console.log('single selection')

            if( r.hoverData.dragging ){
              // if panning, don't change selection state
            } else if( cy.selectionType() === 'additive' || shiftDown ){
              if( near.selected() ){
                near.unselect();
              } else {
                near.select();
              }
            } else {
              if( !shiftDown ){
                cy.$(':selected').unmerge( near ).unselect();
                near.select();
              }
            }

            needsRedraw[CR.NODE] = true;

          }

        }

        if ( r.hoverData.selecting && cy.boxSelectionEnabled() &&  Math.pow(select[2] - select[0], 2) + Math.pow(select[3] - select[1], 2) > 7 && select[4] ) {
          var newlySelected = [];
          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

          needsRedraw[CR.SELECT_BOX] = true;

          if( box.length > 0 ) {
            needsRedraw[CR.NODE] = true;
          }

          for( var i = 0; i < box.length; i++ ){
            if( box[i]._private.selectable ){
              newlySelected.push( box[i] );
            }
          }

          var newlySelCol = new $$.Collection( cy, newlySelected );

          if( cy.selectionType() === 'additive' ){
            newlySelCol.select();
          } else {
            if( !shiftDown ){
              cy.$(':selected').unmerge( newlySelCol ).unselect();
            }

            newlySelCol.select();
          }

          // always need redraw in case eles unselectable
          r.redraw();

        }

        // Cancel drag pan
        if( r.hoverData.dragging ){
          r.hoverData.dragging = false;
          
          needsRedraw[CR.SELECT_BOX] = true;
          needsRedraw[CR.NODE] = true;
          
          r.redraw();
        }

        if (!select[4]) {
          // console.log('free at end', draggedElements)

          needsRedraw[CR.DRAG] = true;
          needsRedraw[CR.NODE] = true;

          freeDraggedElements( draggedElements );

          if( down ){ down.trigger('free'); }

  //        draggedElements = r.dragData.possibleDragElements = [];

        }

      } // else not right mouse

      select[4] = 0; r.hoverData.down = null;

      //r.data.canvasNeedsRedraw[CR.SELECT_BOX] = true;

//      console.log('mu', pos[0], pos[1]);
//      console.log('ss', select);

      r.hoverData.cxtStarted = false;
      r.hoverData.draggingEles = false;
      r.hoverData.selecting = false;
      r.dragData.didDrag = false;
      r.hoverData.dragged = false;
      r.hoverData.dragDelta = [];

    }, false);

    var wheelHandler = function(e) {
      if( r.scrollingPage ){ return; } // while scrolling, ignore wheel-to-zoom

      var cy = r.data.cy;
      var pos = r.projectIntoViewport(e.clientX, e.clientY);
      var rpos = [pos[0] * cy.zoom() + cy.pan().x,
                    pos[1] * cy.zoom() + cy.pan().y];

      if( r.hoverData.draggingEles || r.hoverData.dragging || r.hoverData.cxtStarted || inBoxSelection() ){ // if pan dragging or cxt dragging, wheel movements make no zoom
        e.preventDefault();
        return;
      }

      if( cy.panningEnabled() && cy.userPanningEnabled() && cy.zoomingEnabled() && cy.userZoomingEnabled() ){
        e.preventDefault();

        r.data.wheelZooming = true;
        clearTimeout( r.data.wheelTimeout );
        r.data.wheelTimeout = setTimeout(function(){
          r.data.wheelZooming = false;

          r.data.canvasNeedsRedraw[CR.NODE] = true;
          r.redraw();
        }, 150);

        var diff = e.deltaY / -250 || e.wheelDeltaY / 1000 || e.wheelDelta / 1000;
        diff = diff * r.wheelSensitivity;

        var needsWheelFix = e.deltaMode === 1;
        if( needsWheelFix ){ // fixes slow wheel events on ff/linux and ff/windows
          diff *= 33;
        }

        cy.zoom({
          level: cy.zoom() * Math.pow(10, diff),
          renderedPosition: { x: rpos[0], y: rpos[1] }
        });
      }

    };

    // Functions to help with whether mouse wheel should trigger zooming
    // --
    r.registerBinding(r.data.container, 'wheel', wheelHandler, true);

    // disable nonstandard wheel events
    // r.registerBinding(r.data.container, 'mousewheel', wheelHandler, true);
    // r.registerBinding(r.data.container, 'DOMMouseScroll', wheelHandler, true);
    // r.registerBinding(r.data.container, 'MozMousePixelScroll', wheelHandler, true); // older firefox

    r.registerBinding(window, 'scroll', function(e){
      r.scrollingPage = true;

      clearTimeout( r.scrollingPageTimeout );
      r.scrollingPageTimeout = setTimeout(function(){
        r.scrollingPage = false;
      }, 250);
    }, true);

    // Functions to help with handling mouseout/mouseover on the Cytoscape container
          // Handle mouseout on Cytoscape container
    r.registerBinding(r.data.container, 'mouseout', function(e) {
      var pos = r.projectIntoViewport(e.clientX, e.clientY);

      r.data.cy.trigger(new $$.Event(e, {
        type: 'mouseout',
        cyPosition: { x: pos[0], y: pos[1] }
      }));
    }, false);

    r.registerBinding(r.data.container, 'mouseover', function(e) {
      var pos = r.projectIntoViewport(e.clientX, e.clientY);

      r.data.cy.trigger(new $$.Event(e, {
        type: 'mouseover',
        cyPosition: { x: pos[0], y: pos[1] }
      }));
    }, false);

    var f1x1, f1y1, f2x1, f2y1; // starting points for pinch-to-zoom
    var distance1, distance1Sq; // initial distance between finger 1 and finger 2 for pinch-to-zoom
    var center1, modelCenter1; // center point on start pinch to zoom
    var offsetLeft, offsetTop;
    var containerWidth, containerHeight;
    var twoFingersStartInside;

    var distance = function(x1, y1, x2, y2){
      return Math.sqrt( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) );
    };

    var distanceSq = function(x1, y1, x2, y2){
      return (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1);
    };

    r.registerBinding(r.data.container, 'touchstart', function(e) {

      clearTimeout( this.threeFingerSelectTimeout );

      if( e.target !== r.data.link ){
        e.preventDefault();
      }

      r.touchData.capture = true;
      r.data.bgActivePosistion = undefined;

      var cy = r.data.cy;
      var nodes = r.getCachedNodes();
      var edges = r.getCachedEdges();
      var now = r.touchData.now;
      var earlier = r.touchData.earlier;
      var needsRedraw = r.data.canvasNeedsRedraw;

      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }


      // record starting points for pinch-to-zoom
      if( e.touches[1] ){

        // anything in the set of dragged eles should be released
        var release = function( eles ){
          for( var i = 0; i < eles.length; i++ ){
            eles[i]._private.grabbed = false;
            eles[i]._private.rscratch.inDragLayer = false;
            if( eles[i].active() ){ eles[i].unactivate(); }
          }
        };
        release(nodes);
        release(edges);

        var offsets = r.findContainerClientCoords();
        offsetLeft = offsets[0];
        offsetTop = offsets[1];
        containerWidth = offsets[2];
        containerHeight = offsets[3];

        f1x1 = e.touches[0].clientX - offsetLeft;
        f1y1 = e.touches[0].clientY - offsetTop;

        f2x1 = e.touches[1].clientX - offsetLeft;
        f2y1 = e.touches[1].clientY - offsetTop;

        twoFingersStartInside =
             0 <= f1x1 && f1x1 <= containerWidth
          && 0 <= f2x1 && f2x1 <= containerWidth
          && 0 <= f1y1 && f1y1 <= containerHeight
          && 0 <= f2y1 && f2y1 <= containerHeight
        ;

        var pan = cy.pan();
        var zoom = cy.zoom();

        distance1 = distance( f1x1, f1y1, f2x1, f2y1 );
        distance1Sq = distanceSq( f1x1, f1y1, f2x1, f2y1 );
        center1 = [ (f1x1 + f2x1)/2, (f1y1 + f2y1)/2 ];
        modelCenter1 = [
          (center1[0] - pan.x) / zoom,
          (center1[1] - pan.y) / zoom
        ];

        // consider context tap
        var cxtDistThreshold = 200;
        var cxtDistThresholdSq = cxtDistThreshold * cxtDistThreshold;
        if( distance1Sq < cxtDistThresholdSq && !e.touches[2] ){

          var near1 = r.findNearestElement(now[0], now[1], true, true);
          var near2 = r.findNearestElement(now[2], now[3], true, true);

          //console.log(distance1)

          if( near1 && near1.isNode() ){
            near1.activate().trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = near1;

          } else if( near2 && near2.isNode() ){
            near2.activate().trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = near2;

          } else {
            cy.trigger( new $$.Event(e, {
              type: 'cxttapstart',
              cyPosition: { x: now[0], y: now[1] }
            }) );
            r.touchData.start = null;
          }

          if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
          r.touchData.cxt = true;
          r.touchData.cxtDragged = false;
          r.data.bgActivePosistion = undefined;

          //console.log('cxttapstart')

          r.redraw();
          return;

        }

        // console.log(center1);
        // console.log('touchstart ptz');
        // console.log(offsetLeft, offsetTop);
        // console.log(f1x1, f1y1);
        // console.log(f2x1, f2y1);
        // console.log(distance1);
        // console.log(center1);
      }

      // console.log('another tapstart')


      if (e.touches[2]) {

      } else if (e.touches[1]) {

      } else if (e.touches[0]) {
        var near = r.findNearestElement(now[0], now[1], true, true);

        if (near != null) {
          near.activate();

          r.touchData.start = near;

          if( near.isNode() && r.nodeIsDraggable(near) ){

            var draggedEles = r.dragData.touchDragEles = [];

            needsRedraw[CR.NODE] = true;
            needsRedraw[CR.DRAG] = true;

            if( near.selected() ){
              // reset drag elements, since near will be added again

              var selectedNodes = cy.$(function(){
                return this.isNode() && this.selected();
              });

              for( var k = 0; k < selectedNodes.length; k++ ){
                var selectedNode = selectedNodes[k];

                if( r.nodeIsDraggable(selectedNode) ){
                  addNodeToDrag( selectedNode, { addToList: draggedEles } );
                }
              }
            } else {
              addNodeToDrag( near, { addToList: draggedEles } );
            }

            near.trigger( new $$.Event(e, {
              type: 'grab',
              cyPosition: { x: now[0], y: now[1] }
            }) );
          }

          near
            .trigger(new $$.Event(e, {
              type: 'touchstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousdown',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;
        } if (near == null) {
          cy
            .trigger(new $$.Event(e, {
              type: 'touchstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapstart',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmousedown',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;

          r.data.bgActivePosistion = {
            x: pos[0],
            y: pos[1]
          };

          needsRedraw[CR.SELECT_BOX] = true;
          r.redraw();
        }


        // Tap, taphold
        // -----

        for (var i=0; i<now.length; i++) {
          earlier[i] = now[i];
          r.touchData.startPosition[i] = now[i];
        }

        r.touchData.singleTouchMoved = false;
        r.touchData.singleTouchStartTime = +new Date();

        clearTimeout( r.touchData.tapholdTimeout );
        r.touchData.tapholdTimeout = setTimeout(function() {
          if(
              r.touchData.singleTouchMoved === false
              && !r.pinching // if pinching, then taphold unselect shouldn't take effect

              // This time double constraint prevents multiple quick taps
              // followed by a taphold triggering multiple taphold events
              //&& Date.now() - r.touchData.singleTouchStartTime > 250
          ){
            if (r.touchData.start) {
              r.touchData.start.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            } else {
              r.data.cy.trigger( new $$.Event(e, {
                type: 'taphold',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              cy.$(':selected').unselect();
            }

//            console.log('taphold');
          }
        }, r.tapholdDuration);
      }

      //r.redraw();

    }, false);

// console.log = function(m){ $('#console').append('<div>'+m+'</div>'); };

    r.registerBinding(window, 'touchmove', $$.util.throttle(function(e) {

      var select = r.data.select;
      var capture = r.touchData.capture; //if (!capture) { return; };
      if( capture ){ e.preventDefault(); }

      var cy = r.data.cy;
      var now = r.touchData.now; var earlier = r.touchData.earlier;
      var zoom = cy.zoom();
      
      var needsRedraw = r.data.canvasNeedsRedraw;

      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }
      var disp = []; for (var j=0;j<now.length;j++) { disp[j] = now[j] - earlier[j]; }

      var startPos = r.touchData.startPosition;

      var dx = now[0] - startPos[0];
      var dx2 = dx * dx;
      var dy = now[1] - startPos[1];
      var dy2 = dy * dy;
      var dist2 = dx2 + dy2;
      var rdist2 = dist2 * zoom * zoom;

      if( capture && r.touchData.cxt ){
        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;
        // var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
        var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
        var factorSq = distance2Sq / distance1Sq;

        var distThreshold = 150;
        var distThresholdSq = distThreshold * distThreshold;
        var factorThreshold = 1.5;
        var factorThresholdSq = factorThreshold * factorThreshold;

        //console.log(factor, distance2)

        // cancel ctx gestures if the distance b/t the fingers increases
        if( factorSq >= factorThresholdSq || distance2Sq >= distThresholdSq ){
          r.touchData.cxt = false;
          if( r.touchData.start ){ r.touchData.start.unactivate(); r.touchData.start = null; }
          r.data.bgActivePosistion = undefined;
          needsRedraw[CR.SELECT_BOX] = true;

          var cxtEvt = new $$.Event(e, {
            type: 'cxttapend',
            cyPosition: { x: now[0], y: now[1] }
          });
          if( r.touchData.start ){
            r.touchData.start.trigger( cxtEvt );
          } else {
            cy.trigger( cxtEvt );
          }
        }

      }

      if( capture && r.touchData.cxt ){
        var cxtEvt = new $$.Event(e, {
          type: 'cxtdrag',
          cyPosition: { x: now[0], y: now[1] }
        });
        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;

        if( r.touchData.start ){
          r.touchData.start.trigger( cxtEvt );
        } else {
          cy.trigger( cxtEvt );
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxtDragged = true;

        //console.log('cxtdrag')

        var near = r.findNearestElement(now[0], now[1], true, true);

        if( !r.touchData.cxtOver || near !== r.touchData.cxtOver ){

          if( r.touchData.cxtOver ){
            r.touchData.cxtOver.trigger( new $$.Event(e, {
              type: 'cxtdragout',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            // console.log('cxtdragout');
          }

          r.touchData.cxtOver = near;

          if( near ){
            near.trigger( new $$.Event(e, {
              type: 'cxtdragover',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            // console.log('cxtdragover');
          }

        }

      } else if( capture && e.touches[2] && cy.boxSelectionEnabled() ){
        r.data.bgActivePosistion = undefined;
        clearTimeout( this.threeFingerSelectTimeout );
        this.lastThreeTouch = +new Date();
        r.touchData.selecting = true;

        needsRedraw[CR.SELECT_BOX] = true;

        if( !select || select.length === 0 || select[0] === undefined ){
          select[0] = (now[0] + now[2] + now[4])/3;
          select[1] = (now[1] + now[3] + now[5])/3;
          select[2] = (now[0] + now[2] + now[4])/3 + 1;
          select[3] = (now[1] + now[3] + now[5])/3 + 1;
        } else {
          select[2] = (now[0] + now[2] + now[4])/3;
          select[3] = (now[1] + now[3] + now[5])/3;
        }

        select[4] = 1;
        r.touchData.selecting = true;

        r.redraw();

      } else if ( capture && e.touches[1] && cy.zoomingEnabled() && cy.panningEnabled() && cy.userZoomingEnabled() && cy.userPanningEnabled() ) { // two fingers => pinch to zoom
        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;

        var draggedEles = r.dragData.touchDragEles;
        if( draggedEles ){
          needsRedraw[CR.DRAG] = true;

          for( var i = 0; i < draggedEles.length; i++ ){
            draggedEles[i]._private.grabbed = false;
            draggedEles[i]._private.rscratch.inDragLayer = false;
          }
        }

        // console.log('touchmove ptz');

        // (x2, y2) for fingers 1 and 2
        var f1x2 = e.touches[0].clientX - offsetLeft, f1y2 = e.touches[0].clientY - offsetTop;
        var f2x2 = e.touches[1].clientX - offsetLeft, f2y2 = e.touches[1].clientY - offsetTop;

        // console.log( f1x2, f1y2 )
        // console.log( f2x2, f2y2 )

        var distance2 = distance( f1x2, f1y2, f2x2, f2y2 );
        // var distance2Sq = distanceSq( f1x2, f1y2, f2x2, f2y2 );
        // var factor = Math.sqrt( distance2Sq ) / Math.sqrt( distance1Sq );
        var factor = distance2 / distance1;

        // console.log(distance2)
        // console.log(factor)

        if( factor != 1 && twoFingersStartInside){

          // console.log(factor)
          // console.log(distance2 + ' / ' + distance1);
          // console.log('--');

          // delta finger1
          var df1x = f1x2 - f1x1;
          var df1y = f1y2 - f1y1;

          // delta finger 2
          var df2x = f2x2 - f2x1;
          var df2y = f2y2 - f2y1;

          // translation is the normalised vector of the two fingers movement
          // i.e. so pinching cancels out and moving together pans
          var tx = (df1x + df2x)/2;
          var ty = (df1y + df2y)/2;

          // adjust factor by the speed multiplier
          // var speed = 1.5;
          // if( factor > 1 ){
          //   factor = (factor - 1) * speed + 1;
          // } else {
          //   factor = 1 - (1 - factor) * speed;
          // }

          // now calculate the zoom
          var zoom1 = cy.zoom();
          var zoom2 = zoom1 * factor;
          var pan1 = cy.pan();

          // the model center point converted to the current rendered pos
          var ctrx = modelCenter1[0] * zoom1 + pan1.x;
          var ctry = modelCenter1[1] * zoom1 + pan1.y;

          var pan2 = {
            x: -zoom2/zoom1 * (ctrx - pan1.x - tx) + ctrx,
            y: -zoom2/zoom1 * (ctry - pan1.y - ty) + ctry
          };

          // console.log(pan2);
          // console.log(zoom2);

          // remove dragged eles
          if( r.touchData.start ){
            var draggedEles = r.dragData.touchDragEles;

            if( draggedEles ){ for( var i = 0; i < draggedEles.length; i++ ){
              var dEi_p = draggedEles[i]._private;
              
              dEi_p.grabbed = false;
              dEi_p.rscratch.inDragLayer = false;
            } }

            var start_p = r.touchData.start._private;
            start_p.active = false;
            start_p.grabbed = false;
            start_p.rscratch.inDragLayer = false;

            needsRedraw[CR.DRAG] = true;

            r.touchData.start
              .trigger('free')
              .trigger('unactivate')
            ;
          }

          cy.viewport({
            zoom: zoom2,
            pan: pan2,
            cancelOnFailedZoom: true
          });

          distance1 = distance2;
          f1x1 = f1x2;
          f1y1 = f1y2;
          f2x1 = f2x2;
          f2y1 = f2y2;

          r.pinching = true;
        }

        // Re-project
        if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
        if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
        if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

      } else if (e.touches[0]) {
        var start = r.touchData.start;
        var last = r.touchData.last;
        var near = near || r.findNearestElement(now[0], now[1], true, true);

        if( start != null && start._private.group == 'nodes' && r.nodeIsDraggable(start) ){

          if( rdist2 >= r.touchTapThreshold2 ){ // then dragging can happen
            var draggedEles = r.dragData.touchDragEles;

            for( var k = 0; k < draggedEles.length; k++ ){
              var draggedEle = draggedEles[k];

              if( r.nodeIsDraggable(draggedEle) && draggedEle.isNode() && draggedEle.grabbed() ){
                r.dragData.didDrag = true;
                var dPos = draggedEle._private.position;
                var justStartedDrag = !r.hoverData.draggingEles;

                if( $$.is.number(disp[0]) && $$.is.number(disp[1]) ){
                  dPos.x += disp[0];
                  dPos.y += disp[1];
                }

                if( justStartedDrag ){
                  addNodeToDrag( draggedEle, { inDragLayer: true } );
                  
                  needsRedraw[CR.NODE] = true;

                  var dragDelta = r.touchData.dragDelta;

                  if( $$.is.number(dragDelta[0]) && $$.is.number(dragDelta[1]) ){
                    dPos.x += dragDelta[0];
                    dPos.y += dragDelta[1];
                  }

                }
              }
            }

            var tcol = new $$.Collection(cy, draggedEle);

            tcol.updateCompoundBounds();
            tcol.trigger('position drag');

            r.hoverData.draggingEles = true;

            needsRedraw[CR.DRAG] = true;

            if(
                 r.touchData.startPosition[0] == earlier[0]
              && r.touchData.startPosition[1] == earlier[1]
            ){

              needsRedraw[CR.NODE] = true;
            }

            r.redraw();
          } else { // otherise keep track of drag delta for later
            var dragDelta = r.touchData.dragDelta = r.touchData.dragDelta || [];

            if( dragDelta.length === 0 ){
              dragDelta.push( disp[0] );
              dragDelta.push( disp[1] );
            } else {
              dragDelta[0] += disp[0];
              dragDelta[1] += disp[1];
            }
          }
        }

        // Touchmove event
        {

          if (start != null) {
            start.trigger( new $$.Event(e, {
              type: 'touchmove',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            start.trigger( new $$.Event(e, {
              type: 'tapdrag',
              cyPosition: { x: now[0], y: now[1] }
            }) );

            start.trigger( new $$.Event(e, {
              type: 'vmousemove',
              cyPosition: { x: now[0], y: now[1] }
            }) );
          }

          if (start == null) {

            if (near != null) {
              near.trigger( new $$.Event(e, {
                type: 'touchmove',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              near.trigger( new $$.Event(e, {
                type: 'tapdrag',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              near.trigger( new $$.Event(e, {
                type: 'vmousemove',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            }

            if (near == null) {
              cy.trigger( new $$.Event(e, {
                type: 'touchmove',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              cy.trigger( new $$.Event(e, {
                type: 'tapdrag',
                cyPosition: { x: now[0], y: now[1] }
              }) );

              cy.trigger( new $$.Event(e, {
                type: 'vmousemove',
                cyPosition: { x: now[0], y: now[1] }
              }) );
            }
          }

          if (near != last) {
            if (last) { last.trigger(new $$.Event(e, { type: 'tapdragout', cyPosition: { x: now[0], y: now[1] } })); }
            if (near) { near.trigger(new $$.Event(e, { type: 'tapdragover', cyPosition: { x: now[0], y: now[1] } })); }
          }

          r.touchData.last = near;
        }

        // Check to cancel taphold
        for (var i=0;i<now.length;i++) {
          if (now[i]
            && r.touchData.startPosition[i]
            && Math.abs(now[i] - r.touchData.startPosition[i]) > 4) {

            r.touchData.singleTouchMoved = true;
          }
        }

        if(
            capture
            && ( start == null || start.isEdge() )
            && cy.panningEnabled() && cy.userPanningEnabled()
        ){

          if( r.swipePanning ){
            cy.panBy({
              x: disp[0] * zoom,
              y: disp[1] * zoom
            });

          } else if( rdist2 >= r.touchTapThreshold2 ){
            r.swipePanning = true;

            cy.panBy({
              x: dx * zoom,
              y: dy * zoom
            });
          }

          if( start ){
            start.unactivate();

            if( !r.data.bgActivePosistion ){
              r.data.bgActivePosistion = {
                x: now[0],
                y: now[1]
              };
            }

            needsRedraw[CR.SELECT_BOX] = true;

            r.touchData.start = null;
          }

          // Re-project
          var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY);
          now[0] = pos[0]; now[1] = pos[1];
        }
      }

      for (var j=0; j<now.length; j++) { earlier[j] = now[j]; }
      //r.redraw();

    }, 1000/30, { trailing: true }), false);

    r.registerBinding(window, 'touchcancel', function(e) {
      var start = r.touchData.start;

      r.touchData.capture = false;

      if( start ){
        start.unactivate();
      }
    });

    r.registerBinding(window, 'touchend', function(e) {
      var start = r.touchData.start;

      var capture = r.touchData.capture;

      if( capture ){
        r.touchData.capture = false;
      } else {
        return;
      }

      e.preventDefault();
      var select = r.data.select;

      r.swipePanning = false;
      r.hoverData.draggingEles = false;

      var cy = r.data.cy;
      var zoom = cy.zoom();
      var now = r.touchData.now;
      var earlier = r.touchData.earlier;
      
      var needsRedraw = r.data.canvasNeedsRedraw;

      if (e.touches[0]) { var pos = r.projectIntoViewport(e.touches[0].clientX, e.touches[0].clientY); now[0] = pos[0]; now[1] = pos[1]; }
      if (e.touches[1]) { var pos = r.projectIntoViewport(e.touches[1].clientX, e.touches[1].clientY); now[2] = pos[0]; now[3] = pos[1]; }
      if (e.touches[2]) { var pos = r.projectIntoViewport(e.touches[2].clientX, e.touches[2].clientY); now[4] = pos[0]; now[5] = pos[1]; }

      if( start ){
        start.unactivate();
      }

      var ctxTapend;
      if( r.touchData.cxt ){
        ctxTapend = new $$.Event(e, {
          type: 'cxttapend',
          cyPosition: { x: now[0], y: now[1] }
        });

        if( start ){
          start.trigger( ctxTapend );
        } else {
          cy.trigger( ctxTapend );
        }

        //console.log('cxttapend')

        if( !r.touchData.cxtDragged ){
          var ctxTap = new $$.Event(e, {
            type: 'cxttap',
            cyPosition: { x: now[0], y: now[1] }
          });

          if( start ){
            start.trigger( ctxTap );
          } else {
            cy.trigger( ctxTap );
          }

          //console.log('cxttap')
        }

        if( r.touchData.start ){ r.touchData.start._private.grabbed = false; }
        r.touchData.cxt = false;
        r.touchData.start = null;

        r.redraw();
        return;
      }

      // no more box selection if we don't have three fingers
      if( !e.touches[2] && cy.boxSelectionEnabled() && r.touchData.selecting ){
        r.touchData.selecting = false;
        clearTimeout( this.threeFingerSelectTimeout );
        //this.threeFingerSelectTimeout = setTimeout(function(){
          var newlySelected = [];
          var box = r.getAllInBox( select[0], select[1], select[2], select[3] );

          select[0] = undefined;
          select[1] = undefined;
          select[2] = undefined;
          select[3] = undefined;
          select[4] = 0;

          needsRedraw[CR.SELECT_BOX] = true;

          // console.log(box);
          for( var i = 0; i< box.length; i++ ) {
            if( box[i]._private.selectable ){
              newlySelected.push( box[i] );
            }
          }

          var newlySelCol = new $$.Collection( cy, newlySelected );

          if( cy.selectionType() === 'single' ){
            cy.$(':selected').unmerge( newlySelCol ).unselect();
          }

          newlySelCol.select();

          if( newlySelCol.length > 0 ) {
            needsRedraw[CR.NODE] = true;
          } else {
            r.redraw();
          }

        //}, 100);
      }

      var updateStartStyle = false;

      if( start != null ){
        start._private.active = false;
        updateStartStyle = true;
        start.unactivate();
      }

      if (e.touches[2]) {
        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;
      } else if (e.touches[1]) {

      } else if (e.touches[0]) {

      // Last touch released
      } else if (!e.touches[0]) {

        r.data.bgActivePosistion = undefined;
        needsRedraw[CR.SELECT_BOX] = true;
        
        var draggedEles = r.dragData.touchDragEles;

        if (start != null ) {

          var startWasGrabbed = start._private.grabbed;
          
          freeDraggedElements( draggedEles );

          needsRedraw[CR.DRAG] = true;
          needsRedraw[CR.NODE] = true;
          
          if( startWasGrabbed ){
            start.trigger('free');
          }

          start
            .trigger(new $$.Event(e, {
              type: 'touchend',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'tapend',
              cyPosition: { x: now[0], y: now[1] }
            }))
            .trigger(new $$.Event(e, {
              type: 'vmouseup',
              cyPosition: { x: now[0], y: now[1] }
            }))
          ;

          start.unactivate();

          r.touchData.start = null;

        } else {
          var near = r.findNearestElement(now[0], now[1], true, true);

          if (near != null) {
            near
              .trigger(new $$.Event(e, {
                type: 'touchend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }

          if (near == null) {
            cy
              .trigger(new $$.Event(e, {
                type: 'touchend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'tapend',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vmouseup',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }
        }

        var dx = r.touchData.startPosition[0] - now[0];
        var dx2 = dx * dx;
        var dy = r.touchData.startPosition[1] - now[1];
        var dy2 = dy * dy;
        var dist2 = dx2 + dy2;
        var rdist2 = dist2 * zoom * zoom;

        // Prepare to select the currently touched node, only if it hasn't been dragged past a certain distance
        if (start != null
            && !r.dragData.didDrag // didn't drag nodes around
            && start._private.selectable
            && rdist2 < r.touchTapThreshold2
            && !r.pinching // pinch to zoom should not affect selection
        ) {

          if( cy.selectionType() === 'single' ){
            cy.$(':selected').unmerge( start ).unselect();
            start.select();
          } else {
            if( start.selected() ){
              start.unselect();
            } else {
              start.select();
            }
          }

          updateStartStyle = true;


          needsRedraw[CR.NODE] = true;
        }

        // Tap event, roughly same as mouse click event for touch
        if ( r.touchData.singleTouchMoved === false ) {

          if (start) {
            start
              .trigger(new $$.Event(e, {
                type: 'tap',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vclick',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          } else {
            cy
              .trigger(new $$.Event(e, {
                type: 'tap',
                cyPosition: { x: now[0], y: now[1] }
              }))
              .trigger(new $$.Event(e, {
                type: 'vclick',
                cyPosition: { x: now[0], y: now[1] }
              }))
            ;
          }

//          console.log('tap');
        }

        r.touchData.singleTouchMoved = true;
      }

      for( var j = 0; j < now.length; j++ ){ earlier[j] = now[j]; }

      r.dragData.didDrag = false; // reset for next mousedown

      if( e.touches.length === 0 ){
        r.touchData.dragDelta = [];
      }

      if( updateStartStyle && start ){
        start.updateStyle(false);
      }

      if( e.touches.length < 2 ){
        r.pinching = false;
        needsRedraw[CR.NODE] = true;
        r.redraw();
      }

      //r.redraw();

    }, false);
  };

})( cytoscape );

;(function($$){ 'use strict';

  var CanvasRenderer = $$('renderer', 'canvas');
  var renderer = CanvasRenderer.prototype;
  var usePaths = CanvasRenderer.usePaths();

  // Node shape contract:
  //
  // draw: draw
  // intersectLine: report intersection from x, y, to node center
  // checkPoint: check x, y in node

  var nodeShapes = CanvasRenderer.nodeShapes = {};

  var sin0 = Math.sin(0);
  var cos0 = Math.cos(0);

  var sin = {};
  var cos = {};

  var ellipseStepSize = 0.1;

  for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
    sin[i] = Math.sin(i);
    cos[i] = Math.cos(i);
  }

  nodeShapes['ellipse'] = {
    draw: function(context, centerX, centerY, width, height) {
      nodeShapes['ellipse'].drawPath(context, centerX, centerY, width, height);
      context.fill();
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      
      if( usePaths ){
        if( context.beginPath ){ context.beginPath(); }

        var xPos, yPos;
        var rw = width/2;
        var rh = height/2;
        for (var i = 0 * Math.PI; i < 2 * Math.PI; i += ellipseStepSize ) {
            xPos = centerX - (rw * sin[i]) * sin0 + (rw * cos[i]) * cos0;
            yPos = centerY + (rh * cos[i]) * sin0 + (rh * sin[i]) * cos0;

            if (i === 0) {
                context.moveTo(xPos, yPos);
            } else {
                context.lineTo(xPos, yPos);
            }
        }
        context.closePath();

      } else {

        if( context.beginPath ){ context.beginPath(); }
        context.translate(centerX, centerY);
        context.scale(width / 2, height / 2);
        // At origin, radius 1, 0 to 2pi
        context.arc(0, 0, 1, 0, Math.PI * 2 * 0.999, false); // *0.999 b/c chrome rendering bug on full circle
        context.closePath();

        context.scale(2/width, 2/height);
        context.translate(-centerX, -centerY);

      }
      
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      var intersect = $$.math.intersectLineEllipse(
        x, y,
        nodeX,
        nodeY,
        width / 2 + padding,
        height / 2 + padding);
      
      return intersect;
    },
    
    intersectBox: function(
      x1, y1, x2, y2, width, height, centerX, centerY, padding) {
      
      return $$.math.boxIntersectEllipse(
        x1, y1, x2, y2, padding, width, height, centerX, centerY);
    },
    
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
//      console.log(arguments);
      
      x -= centerX;
      y -= centerY;
      
      x /= (width / 2 + padding);
      y /= (height / 2 + padding);
      
      return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);
    }
  };
  
  function generatePolygon( name, points ){
    nodeShapes[name] = {
      points: points,
      
      draw: function(context, centerX, centerY, width, height) {
        renderer.drawPolygon(context,
          centerX, centerY,
          width, height,
          nodeShapes[name].points);
      },
      
      drawPath: function(context, centerX, centerY, width, height) {
        renderer.drawPolygonPath(context,
          centerX, centerY,
          width, height,
          nodeShapes[name].points);
      },
      
      intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
        return $$.math.polygonIntersectLine(
            x, y,
            nodeShapes[name].points,
            nodeX,
            nodeY,
            width / 2, height / 2,
            padding);
      },
      
      intersectBox: function(
        x1, y1, x2, y2,
        width, height, centerX, 
        centerY, padding) {
        
        var points = nodeShapes[name].points;
        
        return $$.math.boxIntersectPolygon(
          x1, y1, x2, y2,
          points, width, height, centerX, 
          centerY, [0, -1], padding);
      },
      
      checkPoint: function(
        x, y, padding, width, height, centerX, centerY) {
        
        return $$.math.pointInsidePolygon(x, y, nodeShapes[name].points,
          centerX, centerY, width, height, [0, -1], padding);
      }
    };
  }
  
  generatePolygon( 'triangle', $$.math.generateUnitNgonPointsFitToSquare(3, 0) );
  
  generatePolygon( 'square', $$.math.generateUnitNgonPointsFitToSquare(4, 0) );
  nodeShapes['rectangle'] = nodeShapes['square'];
  
  nodeShapes['roundrectangle'] = {
    points: $$.math.generateUnitNgonPointsFitToSquare(4, 0),
    
    draw: function(context, centerX, centerY, width, height) {
      renderer.drawRoundRectangle(context,
        centerX, centerY,
        width, height,
        10);
    },
    
    drawPath: function(context, centerX, centerY, width, height) {
      renderer.drawRoundRectanglePath(context,
        centerX, centerY,
        width, height,
        10);
    },
    
    intersectLine: function(nodeX, nodeY, width, height, x, y, padding) {
      return $$.math.roundRectangleIntersectLine(
          x, y,
          nodeX,
          nodeY,
          width, height,
          padding);
    },
    
    intersectBox: function(
      x1, y1, x2, y2,
      width, height, centerX, 
      centerY, padding) {

      return $$.math.roundRectangleIntersectBox(
        x1, y1, x2, y2, 
        width, height, centerX, centerY, padding);
    },
    
    // Looks like the width passed into this function is actually the total width / 2
    checkPoint: function(
      x, y, padding, width, height, centerX, centerY) {
      
      var cornerRadius = $$.math.getRoundRectangleRadius(width, height);
      
      // Check hBox
      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,
        centerX, centerY, width, height - 2 * cornerRadius, [0, -1], padding)) {
        return true;
      }
      
      // Check vBox
      if ($$.math.pointInsidePolygon(x, y, nodeShapes['roundrectangle'].points,
        centerX, centerY, width - 2 * cornerRadius, height, [0, -1], padding)) {
        return true;
      }
      
      var checkInEllipse = function(x, y, centerX, centerY, width, height, padding) {
        x -= centerX;
        y -= centerY;
        
        x /= (width / 2 + padding);
        y /= (height / 2 + padding);
        
        return (Math.pow(x, 2) + Math.pow(y, 2) <= 1);
      };
      
      
      // Check top left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      /*
      if (renderer.boxIntersectEllipse(x, y, x, y, padding, 
        cornerRadius * 2, cornerRadius * 2,
        centerX - width + cornerRadius,
        centerY - height + cornerRadius)) {
        return true;
      }
      */
      
      // Check top right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY - height / 2 + cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      // Check bottom right quarter circle
      if (checkInEllipse(x, y,
        centerX + width / 2 - cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      // Check bottom left quarter circle
      if (checkInEllipse(x, y,
        centerX - width / 2 + cornerRadius,
        centerY + height / 2 - cornerRadius,
        cornerRadius * 2, cornerRadius * 2, padding)) {
        
        return true;
      }
      
      return false;
    }
  };
  
  generatePolygon( 'diamond', [
    0, 1,
    1, 0,
    0, -1,
    -1, 0
  ] );
  
  generatePolygon( 'pentagon', $$.math.generateUnitNgonPointsFitToSquare(5, 0) );
  
  generatePolygon( 'hexagon', $$.math.generateUnitNgonPointsFitToSquare(6, 0) );
  
  generatePolygon( 'heptagon', $$.math.generateUnitNgonPointsFitToSquare(7, 0) );
  
  generatePolygon( 'octagon', $$.math.generateUnitNgonPointsFitToSquare(8, 0) );
    
  var star5Points = new Array(20);
  {
    var outerPoints = $$.math.generateUnitNgonPoints(5, 0);
    var innerPoints = $$.math.generateUnitNgonPoints(5, Math.PI / 5);
    
  //  console.log(outerPoints);
  //  console.log(innerPoints);
    
    // Outer radius is 1; inner radius of star is smaller
    var innerRadius = 0.5 * (3 - Math.sqrt(5));
    innerRadius *= 1.57;
    
    for (var i=0;i<innerPoints.length/2;i++) {
      innerPoints[i*2] *= innerRadius;
      innerPoints[i*2+1] *= innerRadius;
    }
    
    for (var i=0;i<20/4;i++) {
      star5Points[i*4] = outerPoints[i*2];
      star5Points[i*4+1] = outerPoints[i*2+1];
      
      star5Points[i*4+2] = innerPoints[i*2];
      star5Points[i*4+3] = innerPoints[i*2+1];
    }
    
  //  console.log(star5Points);
  }

  star5Points = $$.math.fitPolygonToSquare( star5Points );
  
  generatePolygon( 'star', star5Points );
  
  generatePolygon( 'vee', [
    -1, -1,
    0, -0.333,
    1, -1,
    0, 1
  ] );
  
  generatePolygon( 'rhomboid', [
    -1, -1,
    0.333, -1,
    1, 1,
    -0.333, 1
  ] );

})( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    animate: true, // whether to show the layout as it's running
    maxSimulationTime: 4000, // max length in ms to run the layout
    fit: true, // on every layout reposition of nodes, fit the viewport
    padding: 30, // padding around the simulation
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout

    // callbacks on layout events
    ready: undefined, // callback on layoutready 
    stop: undefined, // callback on layoutstop

    // forces used by arbor (use arbor default on undefined)
    repulsion: undefined,
    stiffness: undefined,
    friction: undefined,
    gravity: true,
    fps: undefined,
    precision: undefined,

    // static numbers or functions that dynamically return what these
    // values should be for each element
    // e.g. nodeMass: function(n){ return n.data('weight') }
    nodeMass: undefined, 
    edgeLength: undefined,

    stepSize: 0.1, // smoothing of arbor bounding box

    // function that returns true if the system is stable to indicate
    // that the layout can be stopped
    stableEnergy: function( energy ){
      var e = energy; 
      return (e.max <= 0.5) || (e.mean <= 0.3);
    },

    // infinite layout options
    infinite: false // overrides all other options for a forces-all-the-time mode
  };
  
  function ArborLayout(options){
    this._private = {};

    this._private.options = $$.util.extend({}, defaults, options);
  }
    
  ArborLayout.prototype.run = function(){
    var layout = this;
    var options = this._private.options;

    $$.util.require('arbor', function(arbor){

      var cy = options.cy;
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var edges = eles.edges();
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );
      var simUpdatingPos = false;

      layout.trigger({ type: 'layoutstart', layout: layout });

      // backward compatibility for old animation option
      if( options.liveUpdate !== undefined ){
        options.animate = options.liveUpdate;
      }

      // arbor doesn't work with just 1 node 
      if( eles.nodes().size() <= 1 ){
        if( options.fit ){
          cy.reset();
        }

        eles.nodes().position({
          x: Math.round( (bb.x1 + bb.x2)/2 ),
          y: Math.round( (bb.y1 + bb.y2)/2 )
        });

        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });

        return;
      }

      var sys = layout._private.system = arbor.ParticleSystem();

      sys.parameters({
        repulsion: options.repulsion,
        stiffness: options.stiffness, 
        friction: options.friction, 
        gravity: options.gravity, 
        fps: options.fps, 
        dt: options.dt, 
        precision: options.precision
      });

      if( options.animate && options.fit ){
        cy.fit( bb, options.padding );
      }
      
      var doneTime = 250;
      var doneTimeout;
      
      var ready = false;
      
      var lastDraw = +new Date();
      var sysRenderer = {
        init: function(system){
        },
        redraw: function(){
          var energy = sys.energy();

          // if we're stable (according to the client), we're done
          if( !options.infinite && options.stableEnergy != null && energy != null && energy.n > 0 && options.stableEnergy(energy) ){
            layout.stop();
            return;
          }

          if( !options.infinite && doneTime != Infinity ){
            clearTimeout(doneTimeout);
            doneTimeout = setTimeout(doneHandler, doneTime);
          }
          
          var movedNodes = cy.collection();
          
          sys.eachNode(function(n, point){ 
            var data = n.data;
            var node = data.element;
            
            if( node == null ){
              return;
            }

            if( !node.locked() && !node.grabbed() ){
              node.silentPosition({
                x: bb.x1 + point.x,
                y: bb.y1 + point.y
              });

              movedNodes.merge( node );
            }
          });
          

          if( options.animate && movedNodes.length > 0 ){
            simUpdatingPos = true;

            movedNodes.rtrigger('position');

            if( options.fit ){
              cy.fit( options.padding );
            }

            lastDraw = +new Date();
            simUpdatingPos = false;
          }

          
          if( !ready ){
            ready = true;
            layout.one('layoutready', options.ready);
            layout.trigger({ type: 'layoutready', layout: layout });
          }
        }
        
      };
      sys.renderer = sysRenderer;
      sys.screenSize( bb.w, bb.h );
      sys.screenPadding( options.padding, options.padding, options.padding, options.padding );
      sys.screenStep( options.stepSize );

      function calculateValueForElement(element, value){
        if( value == null ){
          return undefined;
        } else if( typeof value == typeof function(){} ){
          return value.apply(element, [element._private.data, {
            nodes: nodes.length,
            edges: edges.length,
            element: element
          }]); 
        } else {
          return value;
        }
      }

      var grabHandler;
      nodes.on('grab free position', grabHandler = function(e){
        if( simUpdatingPos ){ return; }

        var pos = this.position();
        var apos = sys.fromScreen( pos );
        if( !apos ){ return; }

        var p = arbor.Point(apos.x, apos.y);
        var padding = options.padding;

        if(
          bb.x1 + padding <= pos.x && pos.x <= bb.x2 - padding &&
          bb.y1 + padding <= pos.y && pos.y <= bb.y2 - padding
        ){
          this.scratch().arbor.p = p;
        }
        
        switch( e.type ){
        case 'grab':
          this.scratch().arbor.fixed = true;
          break;
        case 'free':
          this.scratch().arbor.fixed = false;
          //this.scratch().arbor.tempMass = 1000;
          break;
        }
      });

      var lockHandler;
      nodes.on('lock unlock', lockHandler = function(e){
        node.scratch().arbor.fixed = node.locked();
      });
            
      var removeHandler;
      eles.on('remove', removeHandler = function(e){ return; // TODO enable when layout add/remove api added
        // var ele = this;
        // var arborEle = ele.scratch().arbor;

        // if( !arborEle ){ return; }

        // if( ele.isNode() ){
        //   sys.pruneNode( arborEle );
        // } else {
        //   sys.pruneEdge( arborEle );
        // }
      });

      var addHandler;
      cy.on('add', '*', addHandler = function(){ return; // TODO enable when layout add/remove api added
        // var ele = this;

        // if( ele.isNode() ){
        //   addNode( ele );
        // } else {
        //   addEdge( ele );
        // }
      });

      var resizeHandler;
      cy.on('resize', resizeHandler = function(){
        if( options.boundingBox == null && layout._private.system != null ){
          var w = cy.width();
          var h = cy.height();

          sys.screenSize( w, h );
        }
      });

      function addNode( node ){
        if( node.isFullAutoParent() ){ return; } // they don't exist in the sim

        var id = node._private.data.id;
        var mass = calculateValueForElement(node, options.nodeMass);
        var locked = node._private.locked;
        var nPos = node.position();
        
        var pos = sys.fromScreen({
          x: nPos.x,
          y: nPos.y
        });

        node.scratch().arbor = sys.addNode(id, {
          element: node,
          mass: mass,
          fixed: locked,
          x: locked ? pos.x : undefined,
          y: locked ? pos.y : undefined
        });
      }

      function addEdge( edge ){
        var src = edge.source().id();
        var tgt = edge.target().id();
        var length = calculateValueForElement(edge, options.edgeLength);
        
        edge.scratch().arbor = sys.addEdge(src, tgt, {
          length: length
        }); 
      }

      nodes.each(function(i, node){
        addNode( node );
      });
      
      edges.each(function(i, edge){
        addEdge( edge );
      });
      
      var grabbableNodes = nodes.filter(":grabbable");
      // disable grabbing if so set
      if( options.ungrabifyWhileSimulating ){
        grabbableNodes.ungrabify();
      }
      
      var doneHandler = layout._private.doneHandler = function(){
        layout._private.doneHandler = null;

        if( !options.animate ){
          if( options.fit ){
            cy.reset();
          }

          nodes.rtrigger('position');
        }

        // unbind handlers
        nodes.off('grab free position', grabHandler);
        nodes.off('lock unlock', lockHandler);
        eles.off('remove', removeHandler);
        cy.off('add', '*', addHandler);
        cy.off('resize', resizeHandler);
        
        // enable back grabbing if so set
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      };
      
      sys.start();
      if( !options.infinite && options.maxSimulationTime != null && options.maxSimulationTime > 0 && options.maxSimulationTime !== Infinity ){
        setTimeout(function(){
          layout.stop();
        }, options.maxSimulationTime);
      }
    
    }); // require

    return this; // chaining
  };


  ArborLayout.prototype.stop = function(){
    if( this._private.system != null ){
      this._private.system.stop();
    }

    if( this._private.doneHandler ){
      this._private.doneHandler();
    }

    return this; // chaining
  };
  
  $$('layout', 'arbor', ArborLayout);
  
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    directed: false, // whether the tree is directed downwards (or edges can point in any direction if false)
    padding: 30, // padding on fit
    circle: false, // put depths in concentric circles if true, put depths top down if false
    spacingFactor: 1.75, // positive spacing factor, larger => more space between nodes (N.B. n/a if causes overlap)
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    roots: undefined, // the roots of the trees
    maximalAdjustments: 0, // how many times to try to position the nodes in a maximal way (i.e. no backtracking)
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function BreadthFirstLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  BreadthFirstLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    var graph = eles;
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var roots;
    if( $$.is.elementOrCollection(options.roots) ){
      roots = options.roots;
    } else if( $$.is.array(options.roots) ){
      var rootsArray = [];

      for( var i = 0; i < options.roots.length; i++ ){
        var id = options.roots[i];
        var ele = cy.getElementById( id );
        rootsArray.push( ele );
      }

      roots = new $$.Collection( cy, rootsArray );
    } else if( $$.is.string(options.roots) ){
      roots = cy.$( options.roots );

    } else {
      if( options.directed ){
        roots = nodes.roots();
      } else {
        var components = [];
        var unhandledNodes = nodes;

        while( unhandledNodes.length > 0 ){
          var currComp = cy.collection();

          eles.bfs({
            roots: unhandledNodes[0],
            visit: function(i, depth, node, edge, pNode){
              currComp = currComp.add( node );
            },
            directed: false
          });

          unhandledNodes = unhandledNodes.not( currComp );
          components.push( currComp );
        }

        roots = cy.collection();
        for( var i = 0; i < components.length; i++ ){
          var comp = components[i];
          var maxDegree = comp.maxDegree( false );
          var compRoots = comp.filter(function(){
            return this.degree(false) === maxDegree;
          });

          roots = roots.add( compRoots );
        }
        
      }
    }


    var depths = [];
    var foundByBfs = {};
    var id2depth = {};
    var prevNode = {};
    var prevEdge = {};
    var successors = {};

    // find the depths of the nodes
    graph.bfs({
      roots: roots,
      directed: options.directed,
      visit: function(i, depth, node, edge, pNode){
        var ele = this[0];
        var id = ele.id();

        if( !depths[depth] ){
          depths[depth] = [];
        }

        depths[depth].push( ele );
        foundByBfs[ id ] = true;
        id2depth[ id ] = depth;
        prevNode[ id ] = pNode;
        prevEdge[ id ] = edge;

        if( pNode ){
          var prevId = pNode.id();
          var succ = successors[ prevId ] = successors[ prevId ] || [];
          
          succ.push( node );
        }
      }
    });

    // check for nodes not found by bfs
    var orphanNodes = [];
    for( var i = 0; i < nodes.length; i++ ){
      var ele = nodes[i];

      if( foundByBfs[ ele.id() ] ){
        continue;
      } else {
        orphanNodes.push( ele );
      }
    }

    // assign orphan nodes a depth from their neighborhood
    var maxChecks = orphanNodes.length * 3;
    var checks = 0;
    while( orphanNodes.length !== 0 && checks < maxChecks ){
      var node = orphanNodes.shift();
      var neighbors = node.neighborhood().nodes();
      var assignedDepth = false;

      for( var i = 0; i < neighbors.length; i++ ){
        var depth = id2depth[ neighbors[i].id() ];

        if( depth !== undefined ){
          depths[depth].push( node );
          assignedDepth = true;
          break;
        }
      }

      if( !assignedDepth ){
        orphanNodes.push( node );
      }

      checks++;
    }

    // assign orphan nodes that are still left to the depth of their subgraph
    while( orphanNodes.length !== 0 ){
      var node = orphanNodes.shift();
      //var subgraph = graph.bfs( node ).path;
      var assignedDepth = false;

      // for( var i = 0; i < subgraph.length; i++ ){
      //   var depth = id2depth[ subgraph[i].id() ];

      //   if( depth !== undefined ){
      //     depths[depth].push( node );
      //     assignedDepth = true;
      //     break;
      //   }
      // }

      if( !assignedDepth ){ // worst case if the graph really isn't tree friendly, then just dump it in 0
        if( depths.length === 0 ){
          depths.push([]);
        }
        
        depths[0].push( node );
      }
    }

    // assign the nodes a depth and index
    var assignDepthsToEles = function(){
      for( var i = 0; i < depths.length; i++ ){
        var eles = depths[i];

        for( var j = 0; j < eles.length; j++ ){
          var ele = eles[j];

          ele._private.scratch.breadthfirst = {
            depth: i,
            index: j
          };
        }
      }
    };
    assignDepthsToEles();


    var intersectsDepth = function( node ){ // returns true if has edges pointing in from a higher depth
      var edges = node.connectedEdges(function(){
        return this.data('target') === node.id();
      });
      var thisInfo = node._private.scratch.breadthfirst;
      var highestDepthOfOther = 0;
      var highestOther;
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];
        var otherNode = edge.source()[0];
        var otherInfo = otherNode._private.scratch.breadthfirst;

        if( thisInfo.depth <= otherInfo.depth && highestDepthOfOther < otherInfo.depth ){
          highestDepthOfOther = otherInfo.depth;
          highestOther = otherNode;
        }
      }

      return highestOther;
    };

     // make maximal if so set by adjusting depths
    for( var adj = 0; adj < options.maximalAdjustments; adj++ ){

      var nDepths = depths.length;
      var elesToMove = [];
      for( var i = 0; i < nDepths; i++ ){
        var depth = depths[i];

        var nDepth = depth.length;
        for( var j = 0; j < nDepth; j++ ){
          var ele = depth[j];
          var info = ele._private.scratch.breadthfirst;
          var intEle = intersectsDepth(ele);

          if( intEle ){
            info.intEle = intEle;
            elesToMove.push( ele );
          }
        }
      }

      for( var i = 0; i < elesToMove.length; i++ ){ 
        var ele = elesToMove[i];
        var info = ele._private.scratch.breadthfirst;
        var intEle = info.intEle;
        var intInfo = intEle._private.scratch.breadthfirst;

        depths[ info.depth ].splice( info.index, 1 ); // remove from old depth & index

        // add to end of new depth
        var newDepth = intInfo.depth + 1;
        while( newDepth > depths.length - 1 ){
          depths.push([]);
        }
        depths[ newDepth ].push( ele );

        info.depth = newDepth;
        info.index = depths[newDepth].length - 1;
      }

      assignDepthsToEles();
    }

    // find min distance we need to leave between nodes
    var minDistance = 0;
    if( options.avoidOverlap ){
      for( var i = 0; i < nodes.length; i++ ){
        var w = nodes[i].outerWidth();
        var h = nodes[i].outerHeight();
        
        minDistance = Math.max(minDistance, w, h);
      }
      minDistance *= options.spacingFactor; // just to have some nice spacing
    }

    // get the weighted percent for an element based on its connectivity to other levels
    var cachedWeightedPercent = {};
    var getWeightedPercent = function( ele ){
      if( cachedWeightedPercent[ ele.id() ] ){
        return cachedWeightedPercent[ ele.id() ];
      }

      var eleDepth = ele._private.scratch.breadthfirst.depth;
      var neighbors = ele.neighborhood().nodes().not(':parent');
      var percent = 0;
      var samples = 0;

      for( var i = 0; i < neighbors.length; i++ ){
        var neighbor = neighbors[i];
        var bf = neighbor._private.scratch.breadthfirst;
        var index = bf.index;
        var depth = bf.depth;
        var nDepth = depths[depth].length;

        if( eleDepth > depth || eleDepth === 0 ){ // only get influenced by elements above
          percent += index / nDepth;
          samples++;
        }
      }

      samples = Math.max(1, samples);
      percent = percent / samples;

      if( samples === 0 ){ // so lone nodes have a "don't care" state in sorting
        percent = undefined;
      }

      cachedWeightedPercent[ ele.id() ] = percent;
      return percent;
    };


    // rearrange the indices in each depth level based on connectivity

    var sortFn = function(a, b){
      var apct = getWeightedPercent( a );
      var bpct = getWeightedPercent( b );

      return apct - bpct;
    };

    for( var times = 0; times < 3; times++ ){ // do it a few times b/c the depths are dynamic and we want a more stable result

      for( var i = 0; i < depths.length; i++ ){
        depths[i] = depths[i].sort( sortFn );
      }
      assignDepthsToEles(); // and update

    }

    var biggestDepthSize = 0;
    for( var i = 0; i < depths.length; i++ ){
      biggestDepthSize = Math.max( depths[i].length, biggestDepthSize );
    }

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.x1 + bb.h/2
    };
   
    var getPosition = function( ele, isBottomDepth ){
      var info = ele._private.scratch.breadthfirst;
      var depth = info.depth;
      var index = info.index;
      var depthSize = depths[depth].length;

      var distanceX = Math.max( bb.w / (depthSize + 1), minDistance );
      var distanceY = Math.max( bb.h / (depths.length + 1), minDistance );
      var radiusStepSize = Math.min( bb.w / 2 / depths.length, bb.h / 2 / depths.length );
      radiusStepSize = Math.max( radiusStepSize, minDistance );

      if( !options.circle ){
        
        var epos = {
          x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
          y: (depth + 1) * distanceY
        };

        if( isBottomDepth ){
          return epos;
        }

        // var succs = successors[ ele.id() ];
        // if( succs ){
        //   epos.x = 0;
        // 
        //   for( var i = 0 ; i < succs.length; i++ ){
        //     var spos = pos[ succs[i].id() ];
        //     
        //     epos.x += spos.x;
        //   }
        // 
        //   epos.x /= succs.length;
        // } else {
        //   //debugger;
        // }

        return epos;

      } else {
        if( options.circle ){
          var radius = radiusStepSize * depth + radiusStepSize - (depths.length > 0 && depths[0].length <= 3 ? radiusStepSize/2 : 0);
          var theta = 2 * Math.PI / depths[depth].length * index;

          if( depth === 0 && depths[0].length === 1 ){
            radius = 1;
          }

          return {
            x: center.x + radius * Math.cos(theta),
            y: center.y + radius * Math.sin(theta)
          };

        } else {
          return {
            x: center.x + (index + 1 - (depthSize + 1)/2) * distanceX,
            y: (depth + 1) * distanceY
          };
        }
      }
      
    };

    // get positions in reverse depth order
    var pos = {};
    for( var i = depths.length - 1; i >=0; i-- ){
      var depth = depths[i];

      for( var j = 0; j < depth.length; j++ ){
        var node = depth[j];

        pos[ node.id() ] = getPosition( node, i === depths.length - 1 );
      }
    }

    nodes.layoutPositions(this, options, function(){
      return pos[ this.id() ];
    });
    
    return this; // chaining
  };
  
  $$('layout', 'breadthfirst', BreadthFirstLayout);
  
})( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // the padding on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox and radius if not enough space
    radius: undefined, // the radius of the circle
    startAngle: 3/2 * Math.PI, // the position of the first node
    counterclockwise: false, // whether the layout should go counterclockwise (true) or clockwise (false)
    sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function CircleLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  CircleLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
      
    var nodes = eles.nodes().not(':parent');

    if( options.sort ){
      nodes = nodes.sort( options.sort );
    }
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.y1 + bb.h/2
    };
    
    var theta = options.startAngle;
    var dTheta = 2 * Math.PI / nodes.length;
    var r;

    var minDistance = 0;
    for( var i = 0; i < nodes.length; i++ ){
      var w = nodes[i].outerWidth();
      var h = nodes[i].outerHeight();
      
      minDistance = Math.max(minDistance, w, h);
    }

    if( $$.is.number(options.radius) ){
      r = options.radius;
    } else if( nodes.length <= 1 ){
      r = 0;
    } else {
      r = Math.min( bb.h, bb.w )/2 - minDistance;
    }

    // calculate the radius
    if( nodes.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
      minDistance *= 1.75; // just to have some nice spacing

      var dTheta = 2 * Math.PI / nodes.length;
      var dcos = Math.cos(dTheta) - Math.cos(0);
      var dsin = Math.sin(dTheta) - Math.sin(0);
      var rMin = Math.sqrt( minDistance * minDistance / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
      r = Math.max( rMin, r );
    }

    var getPos = function( i, ele ){
      var rx = r * Math.cos( theta );
      var ry = r * Math.sin( theta );
      var pos = {
        x: center.x + rx,
        y: center.y + ry
      };

      theta = options.counterclockwise ? theta - dTheta : theta + dTheta;
      return pos;
    };
    
    nodes.layoutPositions( this, options, getPos );

    return this; // chaining
  };
  
  $$('layout', 'circle', CircleLayout);
  
})( cytoscape );

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    animate: true, // whether to show the layout as it's running
    refresh: 1, // number of ticks per frame; higher is faster but more jerky
    maxSimulationTime: 4000, // max length in ms to run the layout
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout
    fit: true, // on every layout reposition of nodes, fit the viewport
    padding: 30, // padding around the simulation
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }

    // layout event callbacks
    ready: function(){}, // on layoutready
    stop: function(){}, // on layoutstop

    // positioning options
    randomize: false, // use random node positions at beginning of layout
    avoidOverlap: true, // if true, prevents overlap of node bounding boxes
    handleDisconnected: true, // if true, avoids disconnected components from overlapping
    nodeSpacing: function( node ){ return 10; }, // extra spacing around nodes
    flow: undefined, // use DAG/tree flow layout if specified, e.g. { axis: 'y', minSeparation: 30 }
    alignment: undefined, // relative alignment constraints on nodes, e.g. function( node ){ return { x: 0, y: 1 } }

    // different methods of specifying edge length
    // each can be a constant numerical value or a function like `function( edge ){ return 2; }`
    edgeLength: undefined, // sets edge length directly in simulation
    edgeSymDiffLength: undefined, // symmetric diff edge length in simulation
    edgeJaccardLength: undefined, // jaccard edge length in simulation

    // iterations of cola algorithm; uses default values on undefined
    unconstrIter: undefined, // unconstrained initial layout iterations
    userConstIter: undefined, // initial layout iterations with user-specified constraints
    allConstIter: undefined, // initial layout iterations with all constraints including non-overlap

    // infinite layout options
    infinite: false // overrides all other options for a forces-all-the-time mode
  };

  // constructor
  // options : object containing layout options
  function ColaLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  ColaLayout.prototype.run = function(){
    var layout = this;
    var options = this.options;
    
    layout.manuallyStopped = false;

    $$.util.require('cola', function(cola){

      var cy = options.cy; // cy is automatically populated for us in the constructor
      var eles = options.eles;
      var nodes = eles.nodes();
      var edges = eles.edges();
      var ready = false;
      
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );

      var getOptVal = function( val, ele ){
        if( $$.is.fn(val) ){
          var fn = val;
          return fn.apply( ele, [ ele ] );
        } else {
          return val;
        }
      };

      var updateNodePositions = function(){
        var x = { min: Infinity, max: -Infinity };
        var y = { min: Infinity, max: -Infinity };

        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var scratch = node._private.scratch.cola;

          x.min = Math.min( x.min, scratch.x || 0 );
          x.max = Math.max( x.max, scratch.x || 0 );

          y.min = Math.min( y.min, scratch.y || 0 );
          y.max = Math.max( y.max, scratch.y || 0 );
        }

        nodes.positions(function(i, node){
          var scratch = node._private.scratch.cola;
          var retPos;

          if( !node.grabbed() && !node.isParent() ){
            retPos = {
              x: bb.x1 + scratch.x - x.min,
              y: bb.y1 + scratch.y - y.min
            };

            if( !$$.is.number(retPos.x) || !$$.is.number(retPos.y) ){
              retPos = undefined;
            }
          }

          return retPos;
        });

        nodes.updateCompoundBounds(); // because the way this layout sets positions is buggy for some reason; ref #878

        if( !ready ){
          onReady();
          ready = true;
        }

        if( options.fit ){
          cy.fit( options.padding );
        }
      };

      var onDone = function(){
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        nodes.off('grab free position', grabHandler);
        nodes.off('lock unlock', lockHandler);

        // trigger layoutstop when the layout stops (e.g. finishes)
        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });
      };

      var onReady = function(){
        // trigger layoutready when each node has had its position set at least once
        layout.one('layoutready', options.ready);
        layout.trigger({ type: 'layoutready', layout: layout });
      };

      var ticksPerFrame = options.refresh;
      var tickSkip = 1; // frames until a tick; used to slow down sim for debugging

      if( options.refresh < 0 ){
        tickSkip = Math.abs( options.refresh );
        ticksPerFrame = 1;
      } else {
        ticksPerFrame = Math.max( 1, ticksPerFrame ); // at least 1
      }

      var adaptor = layout.adaptor = cola.adaptor({
        trigger: function( e ){ // on sim event      
          var TICK = cola.EventType ? cola.EventType.tick : null;
          var END = cola.EventType ? cola.EventType.end : null;
          
          switch( e.type ){
            case 'tick':
            case TICK:
              if( options.animate ){
                updateNodePositions();
              }
              break;

            case 'end':
            case END:
              updateNodePositions();
              if( !options.infinite ){ onDone(); }           
              break;
          }
        },

        kick: function(){ // kick off the simulation
          var skip = 0;

          var inftick = function(){
            if( layout.manuallyStopped ){
              onDone();
              
              return true;
            }
            
            var ret = adaptor.tick();

            if( ret && options.infinite ){ // resume layout if done
              adaptor.resume(); // resume => new kick
            }
            
            return ret; // allow regular finish b/c of new kick
          };

          var multitick = function(){ // multiple ticks in a row
            var ret;

            // skip ticks to slow down layout for debugging
            // var thisSkip = skip;
            // skip = (skip + 1) % tickSkip;
            // if( thisSkip !== 0 ){
            //   return false;
            // }

            for( var i = 0; i < ticksPerFrame && !ret; i++ ){
              ret = ret || inftick(); // pick up true ret vals => sim done
            }

            return ret;
          };

          if( options.animate ){
            var frame = function(){
              if( multitick() ){ return; }

              $$.util.requestAnimationFrame( frame );
            };

            $$.util.requestAnimationFrame( frame );
          } else {
            while( !inftick() ){}
          }
        },

        on: function( type, listener ){}, // dummy; not needed

        drag: function(){} // not needed for our case
      });
      layout.adaptor = adaptor;

      // if set no grabbing during layout
      var grabbableNodes = nodes.filter(':grabbable');
      if( options.ungrabifyWhileSimulating ){
        grabbableNodes.ungrabify();
      }

      // handle node dragging
      var grabHandler;
      nodes.on('grab free position', grabHandler = function(e){
        var node = this;
        var scrCola = node._private.scratch.cola;
        var pos = node._private.position;

        if( node.grabbed() ){
          scrCola.x = pos.x - bb.x1;
          scrCola.y = pos.y - bb.y1;

          adaptor.dragstart( scrCola );
        } else if( $$.is.number(scrCola.x) && $$.is.number(scrCola.y) ){
          pos.x = scrCola.x + bb.x1;
          pos.y = scrCola.y + bb.y1;
        }

        switch( e.type ){
          case 'grab':
            adaptor.dragstart( scrCola );
            adaptor.resume();
            break;
          case 'free':
            adaptor.dragend( scrCola );
            break;
        }
        
      });

      var lockHandler;
      nodes.on('lock unlock', lockHandler = function(e){
        var node = this;
        var scrCola = node._private.scratch.cola;
      
        if( node.locked() ){
          adaptor.dragstart( scrCola );
        } else {
          adaptor.dragend( scrCola );
        }
      });

      var nonparentNodes = nodes.stdFilter(function( node ){
        return !node.isParent();
      });

      // add nodes to cola
      adaptor.nodes( nonparentNodes.map(function( node, i ){
        var padding = getOptVal( options.nodeSpacing, node );
        var pos = node.position();

        var struct = node._private.scratch.cola = {
          x: options.randomize ? Math.round( Math.random() * bb.w ) : pos.x,
          y: options.randomize ? Math.round( Math.random() * bb.h ) : pos.y,
          width: node.outerWidth() + 2*padding,
          height: node.outerHeight() + 2*padding,
          index: i
        };

        return struct;
      }) );

      if( options.alignment ){ // then set alignment constraints

        var offsetsX = [];
        var offsetsY = [];

        nonparentNodes.forEach(function( node ){
          var align = getOptVal( options.alignment, node );
          var scrCola = node._private.scratch.cola;
          var index = scrCola.index;

          if( !align ){ return; }

          if( align.x != null ){
            offsetsX.push({
              node: index,
              offset: align.x
            });
          }

          if( align.y != null ){
            offsetsY.push({
              node: index,
              offset: align.y
            });
          }
        });

        // add alignment constraints on nodes
        var constraints = [];

        if( offsetsX.length > 0 ){
          constraints.push({
            type: 'alignment',
            axis: 'x',
            offsets: offsetsX
          });
        }

        if( offsetsY.length > 0 ){
          constraints.push({
            type: 'alignment',
            axis: 'y',
            offsets: offsetsY
          });
        }
        
        adaptor.constraints( constraints );

      }

      // add compound nodes to cola
      adaptor.groups( nodes.stdFilter(function( node ){
        return node.isParent();
      }).map(function( node, i ){ // add basic group incl leaf nodes
        node._private.scratch.cola = {
          index: i,

          leaves: node.descendants().stdFilter(function( child ){
            return !child.isParent();
          }).map(function( child ){
            return child[0]._private.scratch.cola.index;
          })
        };

        return node;
      }).map(function( node ){ // add subgroups
        node._private.scratch.cola.groups = node.descendants().stdFilter(function( child ){
          return child.isParent();
        }).map(function( child ){
          return child._private.scratch.cola.index;
        });

        return node._private.scratch.cola;
      }) );

      // get the edge length setting mechanism
      var length;
      var lengthFnName;
      if( options.edgeLength != null ){
        length = options.edgeLength;
        lengthFnName = 'linkDistance';
      } else if( options.edgeSymDiffLength != null ){
        length = options.edgeSymDiffLength;
        lengthFnName = 'symmetricDiffLinkLengths';
      } else if( options.edgeJaccardLength != null ){
        length = options.edgeJaccardLength;
        lengthFnName = 'jaccardLinkLengths';
      } else {
        length = 100;
        lengthFnName = 'linkDistance';
      }

      var lengthGetter = function( link ){
        return link.calcLength;
      };

      // add the edges to cola
      adaptor.links( edges.stdFilter(function( edge ){
        return !edge.source().isParent() && !edge.target().isParent();
      }).map(function( edge, i ){
        var c = edge._private.scratch.cola = {
          source: edge.source()[0]._private.scratch.cola.index,
          target: edge.target()[0]._private.scratch.cola.index
        };

        if( length != null ){
          c.calcLength = getOptVal( length, edge );
        }

        return c;
      }) );

      adaptor.size([ bb.w, bb.h ]);

      if( length != null ){
        adaptor[ lengthFnName ]( lengthGetter );
      }

      // set the flow of cola
      if( options.flow ){
        var flow;
        var defAxis = 'y';
        var defMinSep = 50;

        if( $$.is.string(options.flow) ){
          flow = {
            axis: options.flow,
            minSeparation: defMinSep
          };
        } else if( $$.is.number(options.flow) ){
          flow = {
            axis: defAxis,
            minSeparation: options.flow
          };
        } else if( $$.is.plainObject(options.flow) ){
          flow = options.flow;

          flow.axis = flow.axis || defAxis;
          flow.minSeparation = flow.minSeparation != null ? flow.minSeparation : defMinSep;
        } else { // e.g. options.flow: true
          flow = {
            axis: defAxis,
            minSeparation: defMinSep
          };
        }

        adaptor.flowLayout( flow.axis , flow.minSeparation );
      }

      layout.trigger({ type: 'layoutstart', layout: layout });

      adaptor
        .avoidOverlaps( options.avoidOverlap )
        .handleDisconnected( options.handleDisconnected )
        .start( options.unconstrIter, options.userConstIter, options.allConstIter)
      ;

      if( !options.infinite ){
        setTimeout(function(){
          if( !layout.manuallyStopped ){
            adaptor.stop();
          }
        }, options.maxSimulationTime);
      }

    }); // require

    return this; // chaining
  };

  // called on continuous layouts to stop them before they finish
  ColaLayout.prototype.stop = function(){
    if( this.adaptor ){
      this.manuallyStopped = true;
      this.adaptor.stop();
    }

    return this; // chaining
  };

  // register the layout
  $$('layout', 'cola', ColaLayout);

})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // the padding on fit
    startAngle: 3/2 * Math.PI, // the position of the first node
    counterclockwise: false, // whether the layout should go counterclockwise/anticlockwise (true) or clockwise (false)
    minNodeSpacing: 10, // min spacing between outside of nodes (used for radius adjustment)
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    height: undefined, // height of layout area (overrides container height)
    width: undefined, // width of layout area (overrides container width)
    concentric: function(node){ // returns numeric value for each node, placing higher nodes in levels towards the centre
      return node.degree();
    },
    levelWidth: function(nodes){ // the variation of concentric values in each level
      return nodes.maxDegree() / 4;
    },
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function ConcentricLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  ConcentricLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var center = {
      x: bb.x1 + bb.w/2,
      y: bb.y1 + bb.h/2
    };
    
    var nodeValues = []; // { node, value }
    var theta = options.startAngle;
    var maxNodeSize = 0;

    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];
      var value;
      
      // calculate the node value
      value = options.concentric.apply(node, [ node ]);
      nodeValues.push({
        value: value,
        node: node
      });

      // for style mapping
      node._private.scratch.concentric = value;
    }

    // in case we used the `concentric` in style
    nodes.updateStyle();

    // calculate max size now based on potentially updated mappers
    for( var i = 0; i < nodes.length; i++ ){
      var node = nodes[i];

      maxNodeSize = Math.max( maxNodeSize, node.outerWidth(), node.outerHeight() );
    }

    // sort node values in descreasing order
    nodeValues.sort(function(a, b){
      return b.value - a.value;
    });

    var levelWidth = options.levelWidth( nodes );

    // put the values into levels
    var levels = [ [] ];
    var currentLevel = levels[0];
    for( var i = 0; i < nodeValues.length; i++ ){
      var val = nodeValues[i];

      if( currentLevel.length > 0 ){
        var diff = Math.abs( currentLevel[0].value - val.value );

        if( diff >= levelWidth ){
          currentLevel = [];
          levels.push( currentLevel );
        }
      }

      currentLevel.push( val );
    }

    // create positions from levels

    var pos = {}; // id => position
    var r = 0;
    var minDist = maxNodeSize + options.minNodeSpacing; // min dist between nodes

    if( !options.avoidOverlap ){ // then strictly constrain to bb
      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;
      var maxR = ( Math.min(bb.w, bb.h) / 2 - minDist );
      var rStep = maxR / ( levels.length + firstLvlHasMulti ? 1 : 0 );

      minDist = Math.min( minDist, rStep );
    }

    for( var i = 0; i < levels.length; i++ ){
      var level = levels[i];
      var dTheta = 2 * Math.PI / level.length;

      // calculate the radius
      if( level.length > 1 && options.avoidOverlap ){ // but only if more than one node (can't overlap)
        var dcos = Math.cos(dTheta) - Math.cos(0);
        var dsin = Math.sin(dTheta) - Math.sin(0);
        var rMin = Math.sqrt( minDist * minDist / ( dcos*dcos + dsin*dsin ) ); // s.t. no nodes overlapping
        r = Math.max( rMin, r );
      }

      for( var j = 0; j < level.length; j++ ){
        var val = level[j];
        var theta = options.startAngle + (options.counterclockwise ? -1 : 1) * dTheta * j;

        var p = {
          x: center.x + r * Math.cos(theta),
          y: center.y + r * Math.sin(theta)
        };

        pos[ val.node.id() ] = p;
      }

      r += minDist;
      
    } 

    // position the nodes
    nodes.layoutPositions(this, options, function(){
      var id = this.id();

      return pos[id];
    });
  
    return this; // chaining
  };
  
  $$('layout', 'concentric', ConcentricLayout);
  
})( cytoscape );

/*
  The CoSE layout was written by Gerardo Huck.

  Modifications tracked on Github.
*/

;(function($$) { 'use strict';

  var DEBUG;

  /**
   * @brief :  default layout options
   */
  var defaults = {
    // Called on `layoutready`
    ready               : function() {},

    // Called on `layoutstop`
    stop                : function() {},

    // Whether to animate while running the layout
    animate             : true,

    // Number of iterations between consecutive screen positions update (0 -> only updated on the end)
    refresh             : 4,
    
    // Whether to fit the network view after when done
    fit                 : true, 

    // Padding on fit
    padding             : 30, 

    // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    boundingBox         : undefined,

    // Whether to randomize node positions on the beginning
    randomize           : true,
    
    // Whether to use the JS console to print debug messages
    debug               : false,

    // Node repulsion (non overlapping) multiplier
    nodeRepulsion       : 400000,
    
    // Node repulsion (overlapping) multiplier
    nodeOverlap         : 10,
    
    // Ideal edge (non nested) length
    idealEdgeLength     : 10,
    
    // Divisor to compute edge forces
    edgeElasticity      : 100,
    
    // Nesting factor (multiplier) to compute ideal edge length for nested edges
    nestingFactor       : 5, 
    
    // Gravity force (constant)
    gravity             : 250, 
    
    // Maximum number of iterations to perform
    numIter             : 100,
    
    // Initial temperature (maximum node displacement)
    initialTemp         : 200,
    
    // Cooling factor (how the temperature is reduced between consecutive iterations
    coolingFactor       : 0.95, 
    
    // Lower temperature threshold (below this point the layout will end)
    minTemp             : 1.0
  };


  /**
   * @brief       : constructor
   * @arg options : object containing layout options
   */
  function CoseLayout(options) {
    this.options = $$.util.extend({}, defaults, options); 
  }


  /**
   * @brief : runs the layout
   */
  CoseLayout.prototype.run = function() {
    var options = this.options;
    var cy      = options.cy;
    var layout  = this;

    layout.stopped = false;

    layout.trigger({ type: 'layoutstart', layout: layout });

    // Set DEBUG - Global variable
    if (true === options.debug) {
      DEBUG = true;
    } else {
      DEBUG = false;
    }

    // Get start time
    var startTime = new Date();

    // Initialize layout info
    var layoutInfo = createLayoutInfo(cy, layout, options);
    
    // Show LayoutInfo contents if debugging
    if (DEBUG) {
      printLayoutInfo(layoutInfo);
    }

    // If required, randomize node positions
    if (true === options.randomize) {
      randomizePositions(layoutInfo, cy);
    }

    updatePositions(layoutInfo, cy, options);

    var mainLoop = function(i){
      if( layout.stopped ){
        // logDebug("Layout manually stopped. Stopping computation in step " + i);
        return false;
      }

      // Do one step in the phisical simulation
      step(layoutInfo, cy, options, i);
      
      // Update temperature
      layoutInfo.temperature = layoutInfo.temperature * options.coolingFactor;
      // logDebug("New temperature: " + layoutInfo.temperature);

      if (layoutInfo.temperature < options.minTemp) {
        // logDebug("Temperature drop below minimum threshold. Stopping computation in step " + i);
        return false;
      }

      return true;
    };

    var done = function(){
      refreshPositions(layoutInfo, cy, options);

      // Fit the graph if necessary
      if (true === options.fit) {
        cy.fit( options.padding );
      }
      
      // Get end time
      var endTime = new Date();

      console.info('Layout took ' + (endTime - startTime) + ' ms');

      // Layout has finished
      layout.one('layoutstop', options.stop);
      layout.trigger({ type: 'layoutstop', layout: layout });
    };

    if( options.animate ){
      var i = 0;
      var frame = function(){

        var f = 0;
        var loopRet;
        while( f < options.refresh && i < options.numIter ){
          var loopRet = mainLoop(i);
          if( loopRet === false ){ break; }

          f++;
          i++;
        }

        refreshPositions(layoutInfo, cy, options);
        if( options.fit ){
          cy.fit( options.padding );
        }

        if ( loopRet !== false && i + 1 < options.numIter ) {
          $$.util.requestAnimationFrame( frame );
        } else {
          done();
        }
      };

      $$.util.requestAnimationFrame( frame );
    } else {
      for (var i = 0; i < options.numIter; i++) {
        if( mainLoop(i) === false ){ break; }
      }

      done();
    }
   
    return this; // chaining
  };


  /**
   * @brief : called on continuous layouts to stop them before they finish
   */
  CoseLayout.prototype.stop = function(){
    this.stopped = true;

    return this; // chaining
  };


  /**
   * @brief     : Creates an object which is contains all the data
   *              used in the layout process
   * @arg cy    : cytoscape.js object
   * @return    : layoutInfo object initialized
   */
  var createLayoutInfo = function(cy, layout, options) {
    // Shortcut
    var edges = options.eles.edges();
    var nodes = options.eles.nodes();

    var layoutInfo   = {
      layout       : layout,
      layoutNodes  : [], 
      idToIndex    : {},
      nodeSize     : nodes.size(),
      graphSet     : [],
      indexToGraph : [], 
      layoutEdges  : [],
      edgeSize     : edges.size(),
      temperature  : options.initialTemp,
      clientWidth  : cy.width(),
      clientHeight : cy.width(),
      boundingBox  : $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
                       x1: 0, y1: 0, w: cy.width(), h: cy.height()
                     } )
    }; 
    
    // Iterate over all nodes, creating layout nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var tempNode        = {};
      tempNode.id         = nodes[i].data('id');
      tempNode.parentId   = nodes[i].data('parent');      
      tempNode.children   = [];
      tempNode.positionX  = nodes[i].position('x');
      tempNode.positionY  = nodes[i].position('y');
      tempNode.offsetX    = 0;      
      tempNode.offsetY    = 0;
      tempNode.height     = nodes[i].height();
      tempNode.width      = nodes[i].width();
      tempNode.maxX       = tempNode.positionX + tempNode.width  / 2;
      tempNode.minX       = tempNode.positionX - tempNode.width  / 2;
      tempNode.maxY       = tempNode.positionY + tempNode.height / 2;
      tempNode.minY       = tempNode.positionY - tempNode.height / 2;
      tempNode.padLeft    = nodes[i]._private.style['padding-left'].pxValue;
      tempNode.padRight   = nodes[i]._private.style['padding-right'].pxValue;
      tempNode.padTop     = nodes[i]._private.style['padding-top'].pxValue;
      tempNode.padBottom  = nodes[i]._private.style['padding-bottom'].pxValue;
      
      // Add new node
      layoutInfo.layoutNodes.push(tempNode);
      // Add entry to id-index map
      layoutInfo.idToIndex[tempNode.id] = i;
    }

    // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0;   // Points to the start the queue
    var end   = -1;  // Points to the end of the queue

    var tempGraph = [];

    // Second pass to add child information and 
    // initialize queue for hierarchical traversal
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      var p_id = n.parentId;
      // Check if node n has a parent node
      if (null != p_id) {
      // Add node Id to parent's list of children
      layoutInfo.layoutNodes[layoutInfo.idToIndex[p_id]].children.push(n.id);
      } else {
      // If a node doesn't have a parent, then it's in the root graph
      queue[++end] = n.id;
      tempGraph.push(n.id);    
      }
    }
    
    // Add root graph to graphSet
    layoutInfo.graphSet.push(tempGraph);

    // Traverse the graph, level by level, 
    while (start <= end) {
      // Get the node to visit and remove it from queue
      var node_id  = queue[start++];
      var node_ix  = layoutInfo.idToIndex[node_id];
      var node     = layoutInfo.layoutNodes[node_ix];
      var children = node.children;
      if (children.length > 0) {
      // Add children nodes as a new graph to graph set
      layoutInfo.graphSet.push(children);
      // Add children to que queue to be visited
      for (var i = 0; i < children.length; i++) {
        queue[++end] = children[i];
      }
      }
    }

    // Create indexToGraph map
    for (var i = 0; i < layoutInfo.graphSet.length; i++) {      
      var graph = layoutInfo.graphSet[i];
      for (var j = 0; j < graph.length; j++) {
      var index = layoutInfo.idToIndex[graph[j]];
      layoutInfo.indexToGraph[index] = i;
      }
    }
    
    // Iterate over all edges, creating Layout Edges
    for (var i = 0; i < layoutInfo.edgeSize; i++) {
      var e = edges[i];
      var tempEdge = {};      
      tempEdge.id       = e.data('id');
      tempEdge.sourceId = e.data('source');
      tempEdge.targetId = e.data('target');

      // Compute ideal length
      var idealLength = options.idealEdgeLength;

      // Check if it's an inter graph edge
      var sourceIx    = layoutInfo.idToIndex[tempEdge.sourceId];
      var targetIx    = layoutInfo.idToIndex[tempEdge.targetId];
      var sourceGraph = layoutInfo.indexToGraph[sourceIx];
      var targetGraph = layoutInfo.indexToGraph[targetIx];

      if (sourceGraph != targetGraph) {
      // Find lowest common graph ancestor
      var lca = findLCA(tempEdge.sourceId, tempEdge.targetId, layoutInfo);

      // Compute sum of node depths, relative to lca graph
      var lcaGraph = layoutInfo.graphSet[lca];
      var depth    = 0;

      // Source depth
      var tempNode = layoutInfo.layoutNodes[sourceIx];
      while (-1 === $.inArray(tempNode.id, lcaGraph)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // Target depth
      tempNode = layoutInfo.layoutNodes[targetIx];
      while (-1 === $.inArray(tempNode.id, lcaGraph)) {
        tempNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[tempNode.parentId]];
        depth++;
      }

      // logDebug('LCA of nodes ' + tempEdge.sourceId + ' and ' + tempEdge.targetId +  
        //  ". Index: " + lca + " Contents: " + lcaGraph.toString() + 
        //  ". Depth: " + depth);

      // Update idealLength
      idealLength *= depth * options.nestingFactor;
      }

      tempEdge.idealLength = idealLength;

      layoutInfo.layoutEdges.push(tempEdge);
    }

    // Finally, return layoutInfo object
    return layoutInfo;
  };

  
  /**
   * @brief : This function finds the index of the lowest common 
   *          graph ancestor between 2 nodes in the subtree 
   *          (from the graph hierarchy induced tree) whose
   *          root is graphIx
   *
   * @arg node1: node1's ID
   * @arg node2: node2's ID
   * @arg layoutInfo: layoutInfo object
   *
   */
  var findLCA = function(node1, node2, layoutInfo) {
    // Find their common ancester, starting from the root graph
    var res = findLCA_aux(node1, node2, 0, layoutInfo);
    if (2 > res.count) {
      // If aux function couldn't find the common ancester, 
      // then it is the root graph
      return 0;
    } else {
      return res.graph;
    }
  };


  /**
   * @brief          : Auxiliary function used for LCA computation
   * 
   * @arg node1      : node1's ID
   * @arg node2      : node2's ID
   * @arg graphIx    : subgraph index
   * @arg layoutInfo : layoutInfo object
   *
   * @return         : object of the form {count: X, graph: Y}, where:
   *                   X is the number of ancesters (max: 2) found in 
   *                   graphIx (and it's subgraphs),
   *                   Y is the graph index of the lowest graph containing 
   *                   all X nodes
   */
  var findLCA_aux = function(node1, node2, graphIx, layoutInfo) {
    var graph = layoutInfo.graphSet[graphIx];
    // If both nodes belongs to graphIx
    if (-1 < $.inArray(node1, graph) && -1 < $.inArray(node2, graph)) {
      return {count:2, graph:graphIx};
    }

    // Make recursive calls for all subgraphs
    var c = 0;
    for (var i = 0; i < graph.length; i++) {
      var nodeId   = graph[i];
      var nodeIx   = layoutInfo.idToIndex[nodeId];
      var children = layoutInfo.layoutNodes[nodeIx].children;

      // If the node has no child, skip it
      if (0 === children.length) {
      continue;
      }

      var childGraphIx = layoutInfo.indexToGraph[layoutInfo.idToIndex[children[0]]];
      var result = findLCA_aux(node1, node2, childGraphIx, layoutInfo);
      if (0 === result.count) {
      // Neither node1 nor node2 are present in this subgraph
      continue;
      } else if (1 === result.count) {
      // One of (node1, node2) is present in this subgraph
      c++;
      if (2 === c) {
        // We've already found both nodes, no need to keep searching
        break;
      }
      } else {
      // Both nodes are present in this subgraph
      return result;
      }      
    }
    
    return {count:c, graph:graphIx};
  };


  /**
   * @brief: printsLayoutInfo into js console
   *         Only used for debbuging 
   */
  var printLayoutInfo = function(layoutInfo) {
    if (!DEBUG) {
      return;
    }
    console.debug("layoutNodes:");
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      var s = 
      "\nindex: "     + i + 
      "\nId: "        + n.id + 
      "\nChildren: "  + n.children.toString() +  
      "\nparentId: "  + n.parentId  + 
      "\npositionX: " + n.positionX + 
      "\npositionY: " + n.positionY +
      "\nOffsetX: " + n.offsetX + 
      "\nOffsetY: " + n.offsetY + 
      "\npadLeft: " + n.padLeft + 
      "\npadRight: " + n.padRight + 
      "\npadTop: " + n.padTop + 
      "\npadBottom: " + n.padBottom;

      console.debug(s);    
    }  
    
    console.debug('idToIndex');
    for (var i in layoutInfo.idToIndex) {
      console.debug("Id: " + i + "\nIndex: " + layoutInfo.idToIndex[i]);
    }

    console.debug('Graph Set');
    var set = layoutInfo.graphSet;
    for (var i = 0; i < set.length; i ++) {
      console.debug("Set : " + i + ": " + set[i].toString());
    } 

    var s = 'IndexToGraph';
    for (var i = 0; i < layoutInfo.indexToGraph.length; i ++) {
      s += "\nIndex : " + i + " Graph: "+ layoutInfo.indexToGraph[i];
    }
    console.debug(s);

    s = 'Layout Edges';
    for (var i = 0; i < layoutInfo.layoutEdges.length; i++) {
      var e = layoutInfo.layoutEdges[i];
      s += "\nEdge Index: " + i + " ID: " + e.id + 
      " SouceID: " + e.sourceId + " TargetId: " + e.targetId + 
      " Ideal Length: " + e.idealLength;
    }
    console.debug(s);

    s =  "nodeSize: " + layoutInfo.nodeSize;
    s += "\nedgeSize: " + layoutInfo.edgeSize;
    s += "\ntemperature: " + layoutInfo.temperature;
    console.debug(s);

    return;
  };


  /**
   * @brief : Randomizes the position of all nodes
   */
  var randomizePositions = function(layoutInfo, cy) {
    var width     = layoutInfo.clientWidth;
    var height    = layoutInfo.clientHeight;

    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      // No need to randomize compound nodes
      if (true || 0 === n.children.length) {
        n.positionX = Math.random() * width;
        n.positionY = Math.random() * height;
      }
    }
  };

  
  /**
   * @brief          : Updates the positions of nodes in the network
   * @arg layoutInfo : LayoutInfo object
   * @arg cy         : Cytoscape object
   * @arg options    : Layout options
   */
  var refreshPositions = function(layoutInfo, cy, options) {  
    // var s = 'Refreshing positions';
    // logDebug(s);

    var layout = layoutInfo.layout;
    var nodes = options.eles.nodes();
    var bb = layoutInfo.boundingBox;
    var coseBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
    
    if( options.boundingBox ){
      nodes.forEach(function( node ){
        var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[node.data('id')]];

        coseBB.x1 = Math.min( coseBB.x1, lnode.positionX );
        coseBB.x2 = Math.max( coseBB.x2, lnode.positionX );

        coseBB.y1 = Math.min( coseBB.y1, lnode.positionY );
        coseBB.y2 = Math.max( coseBB.y2, lnode.positionY );
      });

      coseBB.w = coseBB.x2 - coseBB.x1;
      coseBB.h = coseBB.y2 - coseBB.y1;
    }

    nodes.positions(function(i, ele) {
      var lnode = layoutInfo.layoutNodes[layoutInfo.idToIndex[ele.data('id')]];
      // s = "Node: " + lnode.id + ". Refreshed position: (" + 
      // lnode.positionX + ", " + lnode.positionY + ").";
      // logDebug(s);

      if( options.boundingBox ){ // then add extra bounding box constraint
        var pctX = (lnode.positionX - coseBB.x1) / coseBB.w;
        var pctY = (lnode.positionY - coseBB.y1) / coseBB.h;

        return {
          x: bb.x1 + pctX * bb.w,
          y: bb.y1 + pctY * bb.h
        };
      } else {
        return {
          x: lnode.positionX,
          y: lnode.positionY
        };
      }
    });

    // Trigger layoutReady only on first call
    if (true !== layoutInfo.ready) {
      // s = 'Triggering layoutready';
      // logDebug(s);
      layoutInfo.ready = true;
      layout.one('layoutready', options.ready);
      layout.trigger({ type: 'layoutready', layout: this });
    }
  };


  /**
   * @brief          : Performs one iteration of the physical simulation
   * @arg layoutInfo : LayoutInfo object already initialized
   * @arg cy         : Cytoscape object
   * @arg options    : Layout options
   */
  var step = function(layoutInfo, cy, options, step) {  
    // var s = "\n\n###############################";
    // s += "\nSTEP: " + step;
    // s += "\n###############################\n";
    // logDebug(s);

    // Calculate node repulsions
    calculateNodeForces(layoutInfo, cy, options);
    // Calculate edge forces
    calculateEdgeForces(layoutInfo, cy, options);
    // Calculate gravity forces
    calculateGravityForces(layoutInfo, cy, options);
    // Propagate forces from parent to child
    propagateForces(layoutInfo, cy, options);
    // Update positions based on calculated forces
    updatePositions(layoutInfo, cy, options);
  };

  
  /**
   * @brief : Computes the node repulsion forces
   */
  var calculateNodeForces = function(layoutInfo, cy, options) {
    // Go through each of the graphs in graphSet
    // Nodes only repel each other if they belong to the same graph
    // var s = 'calculateNodeForces';
    // logDebug(s);
    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
      var graph    = layoutInfo.graphSet[i];
      var numNodes = graph.length;

      // s = "Set: " + graph.toString();
      // logDebug(s);

      // Now get all the pairs of nodes 
      // Only get each pair once, (A, B) = (B, A)
      for (var j = 0; j < numNodes; j++) {
      var node1 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
      for (var k = j + 1; k < numNodes; k++) {
        var node2 = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[k]]];
        nodeRepulsion(node1, node2, layoutInfo, cy, options);
      } 
      }
    } 
  };


  /**
   * @brief : Compute the node repulsion forces between a pair of nodes
   */
  var nodeRepulsion = function(node1, node2, layoutInfo, cy, options) {
    // var s = "Node repulsion. Node1: " + node1.id + " Node2: " + node2.id;

    // Get direction of line connecting both node centers
    var directionX = node2.positionX - node1.positionX;
    var directionY = node2.positionY - node1.positionY;
    // s += "\ndirectionX: " + directionX + ", directionY: " + directionY;

    // If both centers are the same, apply a random force
    if (0 === directionX && 0 === directionY) {
      // s += "\nNodes have the same position.";
      return; // TODO
    }

    var overlap = nodesOverlap(node1, node2, directionX, directionY);
    
    if (overlap > 0) {
      // s += "\nNodes DO overlap.";
      // s += "\nOverlap: " + overlap;
      // If nodes overlap, repulsion force is proportional 
      // to the overlap
      var force    = options.nodeOverlap * overlap;

      // Compute the module and components of the force vector
      var distance = Math.sqrt(directionX * directionX + directionY * directionY);
      // s += "\nDistance: " + distance;
      var forceX   = force * directionX / distance;
      var forceY   = force * directionY / distance;

    } else {
      // s += "\nNodes do NOT overlap.";
      // If there's no overlap, force is inversely proportional 
      // to squared distance

      // Get clipping points for both nodes
      var point1 = findClippingPoint(node1, directionX, directionY);
      var point2 = findClippingPoint(node2, -1 * directionX, -1 * directionY);

      // Use clipping points to compute distance
      var distanceX   = point2.x - point1.x;
      var distanceY   = point2.y - point1.y;
      var distanceSqr = distanceX * distanceX + distanceY * distanceY;
      var distance    = Math.sqrt(distanceSqr);
      // s += "\nDistance: " + distance;

      // Compute the module and components of the force vector
      var force  = options.nodeRepulsion / distanceSqr;
      var forceX = force * distanceX / distance;
      var forceY = force * distanceY / distance;
    }

    // Apply force
    node1.offsetX -= forceX;
    node1.offsetY -= forceY;
    node2.offsetX += forceX;
    node2.offsetY += forceY;

    // s += "\nForceX: " + forceX + " ForceY: " + forceY;
    // logDebug(s);

    return;
  };


  /**
   * @brief : Finds the point in which an edge (direction dX, dY) intersects 
   *          the rectangular bounding box of it's source/target node 
   */
  var findClippingPoint = function(node, dX, dY) {

    // Shorcuts
    var X = node.positionX;
    var Y = node.positionY;
    var H = node.height;
    var W = node.width;
    var dirSlope     = dY / dX;
    var nodeSlope    = H / W;

    // var s = 'Computing clipping point of node ' + node.id + 
    //   " . Height:  " + H + ", Width: " + W + 
    //   "\nDirection " + dX + ", " + dY; 
    // 
    // Compute intersection
    var res = {};
    do {
      // Case: Vertical direction (up)
      if (0 === dX && 0 < dY) {
        res.x = X;
        // s += "\nUp direction";
        res.y = Y + H / 2;
        break;
      }

      // Case: Vertical direction (down)
      if (0 === dX && 0 > dY) {
        res.x = X;
        res.y = Y + H / 2;
        // s += "\nDown direction";
        break;
      }      

      // Case: Intersects the right border
      if (0 < dX && 
      -1 * nodeSlope <= dirSlope && 
      dirSlope <= nodeSlope) {
        res.x = X + W / 2;
        res.y = Y + (W * dY / 2 / dX);
        // s += "\nRightborder";
        break;
      }

      // Case: Intersects the left border
      if (0 > dX && 
      -1 * nodeSlope <= dirSlope && 
      dirSlope <= nodeSlope) {
        res.x = X - W / 2;
        res.y = Y - (W * dY / 2 / dX);
        // s += "\nLeftborder";
        break;
      }

      // Case: Intersects the top border
      if (0 < dY && 
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope )) {
        res.x = X + (H * dX / 2 / dY);
        res.y = Y + H / 2;
        // s += "\nTop border";
        break;
      }

      // Case: Intersects the bottom border
      if (0 > dY && 
      ( dirSlope <= -1 * nodeSlope ||
        dirSlope >= nodeSlope )) {
        res.x = X - (H * dX / 2 / dY);
        res.y = Y - H / 2;
        // s += "\nBottom border";
        break;
      }

    } while (false);

    // s += "\nClipping point found at " + res.x + ", " + res.y;
    // logDebug(s);
    return res;
  };


  /**
   * @brief  : Determines whether two nodes overlap or not
   * @return : Amount of overlapping (0 => no overlap)
   */
  var nodesOverlap = function(node1, node2, dX, dY) {

    if (dX > 0) {
      var overlapX = node1.maxX - node2.minX;
    } else {
      var overlapX = node2.maxX - node1.minX;
    }

    if (dY > 0) {
      var overlapY = node1.maxY - node2.minY;
    } else {
      var overlapY = node2.maxY - node1.minY;
    }

    if (overlapX >= 0 && overlapY >= 0) {
      return Math.sqrt(overlapX * overlapX + overlapY * overlapY);
    } else {
      return 0;
    }
  };
    
  
  /**
   * @brief : Calculates all edge forces
   */
  var calculateEdgeForces = function(layoutInfo, cy, options) {
    // Iterate over all edges
    for (var i = 0; i < layoutInfo.edgeSize; i++) {
      // Get edge, source & target nodes
      var edge     = layoutInfo.layoutEdges[i];
      var sourceIx = layoutInfo.idToIndex[edge.sourceId];
      var source   = layoutInfo.layoutNodes[sourceIx];
      var targetIx = layoutInfo.idToIndex[edge.targetId];
      var target   = layoutInfo.layoutNodes[targetIx];

      // Get direction of line connecting both node centers
      var directionX = target.positionX - source.positionX;
      var directionY = target.positionY - source.positionY;
      
      // If both centers are the same, do nothing.
      // A random force has already been applied as node repulsion
      if (0 === directionX && 0 === directionY) {
      return;
      }

      // Get clipping points for both nodes
      var point1 = findClippingPoint(source, directionX, directionY);
      var point2 = findClippingPoint(target, -1 * directionX, -1 * directionY);


      var lx = point2.x - point1.x;
      var ly = point2.y - point1.y;
      var l  = Math.sqrt(lx * lx + ly * ly);

      var force  = Math.pow(edge.idealLength - l, 2) / options.edgeElasticity; 

      if (0 !== l) {
        var forceX = force * lx / l;
        var forceY = force * ly / l;
      } else {
        var forceX = 0;
        var forceY = 0;
      }

      // Add this force to target and source nodes
      source.offsetX += forceX;
      source.offsetY += forceY;
      target.offsetX -= forceX;
      target.offsetY -= forceY;

      // var s = 'Edge force between nodes ' + source.id + ' and ' + target.id;
      // s += "\nDistance: " + l + " Force: (" + forceX + ", " + forceY + ")";
      // logDebug(s);
    }
  };


  /**
   * @brief : Computes gravity forces for all nodes
   */
  var calculateGravityForces = function(layoutInfo, cy, options) {
    // var s = 'calculateGravityForces';
    // logDebug(s);
    for (var i = 0; i < layoutInfo.graphSet.length; i ++) {
      var graph    = layoutInfo.graphSet[i];
      var numNodes = graph.length;

      // s = "Set: " + graph.toString();
      // logDebug(s);
          
      // Compute graph center
      if (0 === i) {
        var centerX   = layoutInfo.clientHeight / 2;
        var centerY   = layoutInfo.clientWidth  / 2;    
      } else {
        // Get Parent node for this graph, and use its position as center
        var temp    = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[0]]];
        var parent  = layoutInfo.layoutNodes[layoutInfo.idToIndex[temp.parentId]];
        var centerX = parent.positionX;
        var centerY = parent.positionY;
      }
      // s = "Center found at: " + centerX + ", " + centerY;
      // logDebug(s);

      // Apply force to all nodes in graph
      for (var j = 0; j < numNodes; j++) {
        var node = layoutInfo.layoutNodes[layoutInfo.idToIndex[graph[j]]];
        // s = "Node: " + node.id;
        var dx = centerX - node.positionX;
        var dy = centerY - node.positionY;
        var d  = Math.sqrt(dx * dx + dy * dy);
        if (d > 1.0) { // TODO: Use global variable for distance threshold
          var fx = options.gravity * dx / d;
          var fy = options.gravity * dy / d;
          node.offsetX += fx;
          node.offsetY += fy;
          // s += ": Applied force: " + fx + ", " + fy;
        } else {
          // s += ": skypped since it's too close to center";
        }
        // logDebug(s);
      }
    }
  };


  /**
   * @brief          : This function propagates the existing offsets from 
   *                   parent nodes to its descendents.
   * @arg layoutInfo : layoutInfo Object
   * @arg cy         : cytoscape Object
   * @arg options    : Layout options
   */
  var propagateForces = function(layoutInfo, cy, options) {  
    // Inline implementation of a queue, used for traversing the graph in BFS order
    var queue = [];
    var start = 0;   // Points to the start the queue
    var end   = -1;  // Points to the end of the queue

    // logDebug('propagateForces');

    // Start by visiting the nodes in the root graph
    queue.push.apply(queue, layoutInfo.graphSet[0]);
    end += layoutInfo.graphSet[0].length;

    // Traverse the graph, level by level, 
    while (start <= end) {
      // Get the node to visit and remove it from queue
      var nodeId    = queue[start++];
      var nodeIndex = layoutInfo.idToIndex[nodeId];
      var node      = layoutInfo.layoutNodes[nodeIndex];
      var children  = node.children;

      // We only need to process the node if it's compound
      if (0 < children.length) {    
      var offX = node.offsetX;
      var offY = node.offsetY;

      // var s = "Propagating offset from parent node : " + node.id + 
      //   ". OffsetX: " + offX + ". OffsetY: " + offY;
      // s += "\n Children: " + children.toString();
      // logDebug(s);
      
      for (var i = 0; i < children.length; i++) {
        var childNode = layoutInfo.layoutNodes[layoutInfo.idToIndex[children[i]]];
        // Propagate offset
        childNode.offsetX += offX;
        childNode.offsetY += offY;
        // Add children to queue to be visited
        queue[++end] = children[i];
      }
      
      // Reset parent offsets
      node.offsetX = 0;
      node.offsetY = 0;
      }
      
    }
  };


  /**
   * @brief : Updates the layout model positions, based on 
   *          the accumulated forces
   */
  var updatePositions = function(layoutInfo, cy, options) {
    // var s = 'Updating positions';
    // logDebug(s);

    // Reset boundaries for compound nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        // logDebug("Resetting boundaries of compound node: " + n.id);
        n.maxX = undefined;
        n.minX = undefined;
        n.maxY = undefined;
        n.minY = undefined;
      }
    }

    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        // No need to set compound node position
        // logDebug("Skipping position update of node: " + n.id);
        continue;
      }
      // s = "Node: " + n.id + " Previous position: (" + 
      // n.positionX + ", " + n.positionY + ")."; 

      // Limit displacement in order to improve stability
      var tempForce = limitForce(n.offsetX, n.offsetY, layoutInfo.temperature);
      n.positionX += tempForce.x; 
      n.positionY += tempForce.y;
      n.offsetX = 0;
      n.offsetY = 0;
      n.minX    = n.positionX - n.width; 
      n.maxX    = n.positionX + n.width; 
      n.minY    = n.positionY - n.height; 
      n.maxY    = n.positionY + n.height; 
      // s += " New Position: (" + n.positionX + ", " + n.positionY + ").";
      // logDebug(s);

      // Update ancestry boudaries
      updateAncestryBoundaries(n, layoutInfo);
    }

    // Update size, position of compund nodes
    for (var i = 0; i < layoutInfo.nodeSize; i++) {
      var n = layoutInfo.layoutNodes[i];
      if (0 < n.children.length) {
        n.positionX = (n.maxX + n.minX) / 2;
        n.positionY = (n.maxY + n.minY) / 2;
        n.width     = n.maxX - n.minX;
        n.height    = n.maxY - n.minY;
        // s = "Updating position, size of compound node " + n.id;
        // s += "\nPositionX: " + n.positionX + ", PositionY: " + n.positionY;
        // s += "\nWidth: " + n.width + ", Height: " + n.height;
        // logDebug(s);
      }
    }  
  };


  /**
   * @brief : Limits a force (forceX, forceY) to be not 
   *          greater (in modulo) than max. 
   8          Preserves force direction. 
   */
  var limitForce = function(forceX, forceY, max) {
    // var s = "Limiting force: (" + forceX + ", " + forceY + "). Max: " + max;
    var force = Math.sqrt(forceX * forceX + forceY * forceY);

    if (force > max) {
      var res = {
      x : max * forceX / force,
      y : max * forceY / force
      };      

    } else {
      var res = {
      x : forceX,
      y : forceY
      };
    }

    // s += ".\nResult: (" + res.x + ", " + res.y + ")";
    // logDebug(s);

    return res;
  };


  /**
   * @brief : Function used for keeping track of compound node 
   *          sizes, since they should bound all their subnodes.
   */
  var updateAncestryBoundaries = function(node, layoutInfo) {
    // var s = "Propagating new position/size of node " + node.id;
    var parentId = node.parentId;
    if (null == parentId) {
      // If there's no parent, we are done
      // s += ". No parent node.";
      // logDebug(s);
      return;
    }

    // Get Parent Node
    var p = layoutInfo.layoutNodes[layoutInfo.idToIndex[parentId]];
    var flag = false;

    // MaxX
    if (null == p.maxX || node.maxX + p.padRight > p.maxX) {
      p.maxX = node.maxX + p.padRight;
      flag = true;
      // s += "\nNew maxX for parent node " + p.id + ": " + p.maxX;
    }

    // MinX
    if (null == p.minX || node.minX - p.padLeft < p.minX) {
      p.minX = node.minX - p.padLeft;
      flag = true;
      // s += "\nNew minX for parent node " + p.id + ": " + p.minX;
    }

    // MaxY
    if (null == p.maxY || node.maxY + p.padBottom > p.maxY) {
      p.maxY = node.maxY + p.padBottom;
      flag = true;
      // s += "\nNew maxY for parent node " + p.id + ": " + p.maxY;
    }

    // MinY
    if (null == p.minY || node.minY - p.padTop < p.minY) {
      p.minY = node.minY - p.padTop;
      flag = true;
      // s += "\nNew minY for parent node " + p.id + ": " + p.minY;
    }

    // If updated boundaries, propagate changes upward
    if (flag) {
      // logDebug(s);
      return updateAncestryBoundaries(p, layoutInfo);
    } 

    // s += ". No changes in boundaries/position of parent node " + p.id;  
    // logDebug(s);
    return;
  };


  /**
   * @brief : Logs a debug message in JS console, if DEBUG is ON
   */
  // var logDebug = function(text) {
  //   if (DEBUG) {
  //     console.debug(text);
  //   }
  // };


  // register the layout
  $$('layout', 'cose', CoseLayout);

})(cytoscape);

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    // dagre algo options, uses default value on undefined
    nodeSep: undefined, // the separation between adjacent nodes in the same rank
    edgeSep: undefined, // the separation between adjacent edges in the same rank
    rankSep: undefined, // the separation between adjacent nodes in the same rank
    rankDir: undefined, // 'TB' for top to bottom flow, 'LR' for left to right
    minLen: function( edge ){ return 1; }, // number of ranks to keep between the source and target of the edge
    edgeWeight: function( edge ){ return 1; }, // higher weight edges are generally made shorter and straighter than lower weight edges
    
    // general layout options
    fit: true, // whether to fit to viewport
    padding: 30, // fit padding
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    ready: function(){}, // on layoutready
    stop: function(){} // on layoutstop
  };

  // constructor
  // options : object containing layout options
  function DagreLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  DagreLayout.prototype.run = function(){
    var options = this.options;
    var layout = this;

    $$.util.require('dagre', function(dagre){

      var cy = options.cy; // cy is automatically populated for us in the constructor
      var eles = options.eles;

      var getVal = function( ele, val ){
        return $$.is.fn(val) ? val.apply( ele, [ ele ] ) : val;
      };

      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );

      var g = new dagre.graphlib.Graph({
        multigraph: true,
        compound: true
      });

      var gObj = {};
      var setGObj = function( name, val ){
        if( val != null ){
          gObj[ name ] = val;
        }
      };
      
      setGObj( 'nodesep', options.nodeSep );
      setGObj( 'edgesep', options.edgeSep );
      setGObj( 'ranksep', options.rankSep );
      setGObj( 'rankdir', options.rankDir );

      g.setGraph( gObj );

      g.setDefaultEdgeLabel(function() { return {}; });
      g.setDefaultNodeLabel(function() { return {}; });

      // add nodes to dagre
      var nodes = eles.nodes();
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];

        g.setNode( node.id(), {
          width: node.width(),
          height: node.height(),
          name: node.id()
        } );

        // console.log( g.node(node.id()) );
      }

      // set compound parents
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];

        if( node.isChild() ){
          g.setParent( node.id(), node.parent().id() );
        }
      }

      // add edges to dagre
      var edges = eles.edges().stdFilter(function( edge ){
        return !edge.source().isParent() && !edge.target().isParent(); // dagre can't handle edges on compound nodes
      });
      for( var i = 0; i < edges.length; i++ ){
        var edge = edges[i];

        g.setEdge( edge.source().id(), edge.target().id(), {
          minlen: getVal( edge, options.minLen ),
          weight: getVal( edge, options.edgeWeight ),
          name: edge.id()
        }, edge.id() );

        // console.log( g.edge(edge.source().id(), edge.target().id(), edge.id()) );
      }

      dagre.layout( g );

      var gNodeIds = g.nodes();
      for( var i = 0; i < gNodeIds.length; i++ ){
        var id = gNodeIds[i];
        var n = g.node( id );

        cy.getElementById(id).scratch().dagre = n;
      }

      var dagreBB;

      if( options.boundingBox ){
        dagreBB = { x1: Infinity, x2: -Infinity, y1: Infinity, y2: -Infinity };
        nodes.forEach(function( node ){
          var dModel = node.scratch().dagre;

          dagreBB.x1 = Math.min( dagreBB.x1, dModel.x );
          dagreBB.x2 = Math.max( dagreBB.x2, dModel.x );

          dagreBB.y1 = Math.min( dagreBB.y1, dModel.y );
          dagreBB.y2 = Math.max( dagreBB.y2, dModel.y );
        });

        dagreBB.w = dagreBB.x2 - dagreBB.x1;
        dagreBB.h = dagreBB.y2 - dagreBB.y1;
      } else {
        dagreBB = bb;
      }

      var constrainPos = function( p ){
        if( options.boundingBox ){
          var xPct = (p.x - dagreBB.x1) / dagreBB.w;
          var yPct = (p.y - dagreBB.y1) / dagreBB.h;

          return {
            x: bb.x1 + xPct * bb.w,
            y: bb.y1 + yPct * bb.h
          };
        } else {
          return p;
        }
      };

      nodes.layoutPositions(layout, options, function(){
        var dModel = this.scratch().dagre;

        return constrainPos({
          x: dModel.x,
          y: dModel.y
        });
      });

    }); // require

    return this; // chaining
  };

  // register the layout
  $$('layout', 'dagre', DagreLayout);

})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // padding used on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    avoidOverlap: true, // prevents node overlap, may overflow boundingBox if not enough space
    rows: undefined, // force num of rows in the grid
    columns: undefined, // force num of cols in the grid
    position: function( node ){}, // returns { row, col } for element
    sort: undefined, // a sorting function to order the nodes; e.g. function(a, b){ return a.data('weight') - b.data('weight') }
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function GridLayout( options ){
    this.options = $$.util.extend({}, defaults, options);
  }
  
  GridLayout.prototype.run = function(){
    var params = this.options;
    var options = params;
    
    var cy = params.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');

    if( options.sort ){
      nodes = nodes.sort( options.sort );
    }
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    if( bb.h === 0 || bb.w === 0){
      nodes.layoutPositions(this, options, function(){
        return { x: bb.x1, y: bb.y1 };
      });
      
    } else {
      
      // width/height * splits^2 = cells where splits is number of times to split width
      var cells = nodes.size();
      var splits = Math.sqrt( cells * bb.h/bb.w );
      var rows = Math.round( splits );
      var cols = Math.round( bb.w/bb.h * splits );

      var small = function(val){
        if( val == null ){
          return Math.min(rows, cols);
        } else {
          var min = Math.min(rows, cols);
          if( min == rows ){
            rows = val;
          } else {
            cols = val;
          }
        }
      };
      
      var large = function(val){
        if( val == null ){
          return Math.max(rows, cols);
        } else {
          var max = Math.max(rows, cols);
          if( max == rows ){
            rows = val;
          } else {
            cols = val;
          }
        }
      };
      
      // if rows or columns were set in options, use those values
      if( options.rows != null && options.columns != null ){
        rows = options.rows;
        cols = options.columns;
      } else if( options.rows != null && options.columns == null ){
        rows = options.rows;
        cols = Math.ceil( cells / rows );
      } else if( options.rows == null && options.columns != null ){
        cols = options.columns;
        rows = Math.ceil( cells / cols );
      }
      
      // otherwise use the automatic values and adjust accordingly
      
      // if rounding was up, see if we can reduce rows or columns
      else if( cols * rows > cells ){
        var sm = small();
        var lg = large();
        
        // reducing the small side takes away the most cells, so try it first
        if( (sm - 1) * lg >= cells ){
          small(sm - 1);
        } else if( (lg - 1) * sm >= cells ){
          large(lg - 1);
        } 
      } else {
        
        // if rounding was too low, add rows or columns
        while( cols * rows < cells ){
          var sm = small();
          var lg = large();
          
          // try to add to larger side first (adds less in multiplication)
          if( (lg + 1) * sm >= cells ){
            large(lg + 1);
          } else {
            small(sm + 1);
          }
        }
      }
      
      var cellWidth = bb.w / cols;
      var cellHeight = bb.h / rows;

      if( options.avoidOverlap ){
        for( var i = 0; i < nodes.length; i++ ){
          var node = nodes[i];
          var w = node.outerWidth();
          var h = node.outerHeight();

          cellWidth = Math.max( cellWidth, w );
          cellHeight = Math.max( cellHeight, h );
        }
      }
      
      var cellUsed = {}; // e.g. 'c-0-2' => true
      
      var used = function(row, col){
        return cellUsed['c-' + row + '-' + col] ? true : false;
      };
      
      var use = function(row, col){
        cellUsed['c-' + row + '-' + col] = true;
      };

      // to keep track of current cell position
      var row = 0;
      var col = 0;
      var moveToNextCell = function(){
        col++;
        if( col >= cols ){
          col = 0;
          row++;
        }
      };

      // get a cache of all the manual positions
      var id2manPos = {};
      for( var i = 0; i < nodes.length; i++ ){
        var node = nodes[i];
        var rcPos = options.position( node );

        if( rcPos && (rcPos.row !== undefined || rcPos.col !== undefined) ){ // must have at least row or col def'd
          var pos = {
            row: rcPos.row,
            col: rcPos.col
          };

          if( pos.col === undefined ){ // find unused col
            pos.col = 0;

            while( used(pos.row, pos.col) ){
              pos.col++;
            }
          } else if( pos.row === undefined ){ // find unused row
            pos.row = 0;

            while( used(pos.row, pos.col) ){
              pos.row++;
            }
          }

          id2manPos[ node.id() ] = pos;
          use( pos.row, pos.col );
        }
      }

      var getPos = function(i, element){
        var x, y;

        if( element.locked() || element.isFullAutoParent() ){
          return false;
        }

        // see if we have a manual position set
        var rcPos = id2manPos[ element.id() ];
        if( rcPos ){
          x = rcPos.col * cellWidth + cellWidth/2 + bb.x1;
          y = rcPos.row * cellHeight + cellHeight/2 + bb.y1;
        
        } else { // otherwise set automatically
        
          while( used(row, col) ){
            moveToNextCell();
          }

          x = col * cellWidth + cellWidth/2 + bb.x1;
          y = row * cellHeight + cellHeight/2 + bb.y1;
          use( row, col );
          
          moveToNextCell();
        }
        
        return { x: x, y: y };
        
      };

      nodes.layoutPositions( this, options, getPos );
    }

    return this; // chaining
    
  };
  
  $$('layout', 'grid', GridLayout);
  
})( cytoscape );

;(function($$){ 'use strict';

  // default layout options
  var defaults = {
    ready: function(){}, // on layoutready
    stop: function(){} // on layoutstop
  };

  // constructor
  // options : object containing layout options
  function NullLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options); 
  }

  // runs the layout
  NullLayout.prototype.run = function(){
    var options = this.options;
    var eles = options.eles; // elements to consider in the layout
    var layout = this;

    // cy is automatically populated for us in the constructor
    var cy = options.cy; // jshint ignore:line

    layout.trigger('layoutstart');

    // puts all nodes at (0, 0)
    eles.nodes().positions(function(){
      return {
        x: 0,
        y: 0
      };
    });

    // trigger layoutready when each node has had its position set at least once
    layout.one('layoutready', options.ready);
    layout.trigger('layoutready');

    // trigger layoutstop when the layout stops (e.g. finishes)
    layout.one('layoutstop', options.stop);
    layout.trigger('layoutstop');

    return this; // chaining
  };

  // called on continuous layouts to stop them before they finish
  NullLayout.prototype.stop = function(){
    return this; // chaining
  };

  // register the layout
  $$('layout', 'null', NullLayout);

})(cytoscape);
;(function($$){ 'use strict';
  
  var defaults = {
    positions: undefined, // map of (node id) => (position obj); or function(node){ return somPos; }
    zoom: undefined, // the zoom level to set (prob want fit = false if set)
    pan: undefined, // the pan level to set (prob want fit = false if set)
    fit: true, // whether to fit to viewport
    padding: 30, // padding on fit
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function PresetLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  PresetLayout.prototype.run = function(){
    var options = this.options;
    var eles = options.eles;

    var nodes = eles.nodes();
    var posIsFn = $$.is.fn( options.positions );

    function getPosition(node){
      if( options.positions == null ){
        return null;
      }

      if( posIsFn ){
        return options.positions.apply( node, [ node ] );
      }
      
      var pos = options.positions[node._private.data.id];

      if( pos == null ){
        return null;
      }
      
      return pos;
    }
    
    nodes.layoutPositions(this, options, function(i, node){
      var position = getPosition(node);
      
      if( node.locked() || position == null ){
        return false;
      }
      
      return position;
    });
        
    return this; // chaining
  };
  
  $$('layout', 'preset', PresetLayout);
  
})(cytoscape);

;(function($$){ 'use strict';
  
  var defaults = {
    fit: true, // whether to fit to viewport
    padding: 30, // fit padding
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    animate: false, // whether to transition the node positions
    animationDuration: 500, // duration of animation in ms if enabled
    ready: undefined, // callback on layoutready
    stop: undefined // callback on layoutstop
  };
  
  function RandomLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  RandomLayout.prototype.run = function(){
    var options = this.options;
    var cy = options.cy;
    var eles = options.eles;
    var nodes = eles.nodes().not(':parent');
    
    var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
      x1: 0, y1: 0, w: cy.width(), h: cy.height()
    } );

    var getPos = function( i, node ){
      return {
        x: bb.x1 + Math.round( Math.random() * bb.w ),
        y: bb.y1 + Math.round( Math.random() * bb.h )
      };
    };

    nodes.layoutPositions( this, options, getPos );

    return this; // chaining
  };
  
  // register the layout
  $$(
    'layout', // we're registering a layout
    'random', // the layout name
    RandomLayout // the layout prototype
  );
  
})(cytoscape);

;( function( $$ ){ 'use strict';

  /*
   * This layout combines several algorithms:
   *
   * - It generates an initial position of the nodes by using the
   *   Fruchterman-Reingold algorithm (doi:10.1002/spe.4380211102)
   *
   * - Finally it eliminates overlaps by using the method described by
   *   Gansner and North (doi:10.1007/3-540-37623-2_28)
   */

  var defaults = {
    animate: true, // whether to show the layout as it's running
    ready: undefined, // Callback on layoutready
    stop: undefined, // Callback on layoutstop
    fit: true, // Reset viewport to fit default simulationBounds
    minDist: 20, // Minimum distance between nodes
    padding: 20, // Padding
    expandingFactor: -1.0, // If the network does not satisfy the minDist
    // criterium then it expands the network of this amount
    // If it is set to -1.0 the amount of expansion is automatically
    // calculated based on the minDist, the aspect ratio and the
    // number of nodes
    maxFruchtermanReingoldIterations: 50, // Maximum number of initial force-directed iterations
    maxExpandIterations: 4, // Maximum number of expanding iterations
    boundingBox: undefined // Constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  };

  function SpreadLayout( options ) {
    this.options = $$.util.extend( {}, defaults, options );
  }

  function cellCentroid( cell ) {
    var hes = cell.halfedges;
    var area = 0,
      x = 0,
      y = 0;
    var p1, p2, f;

    for( var i = 0; i < hes.length; ++i ) {
      p1 = hes[ i ].getEndpoint();
      p2 = hes[ i ].getStartpoint();

      area += p1.x * p2.y;
      area -= p1.y * p2.x;

      f = p1.x * p2.y - p2.x * p1.y;
      x += ( p1.x + p2.x ) * f;
      y += ( p1.y + p2.y ) * f;
    }

    area /= 2;
    f = area * 6;
    return {
      x: x / f,
      y: y / f
    };
  }

  function sitesDistance( ls, rs ) {
    var dx = ls.x - rs.x;
    var dy = ls.y - rs.y;
    return Math.sqrt( dx * dx + dy * dy );
  }

  SpreadLayout.prototype.run = function() {

    var layout = this;
    // var self = this;
    var options = this.options;

    $$.util.requires(['foograph', 'Voronoi'], function(foograph, Voronoi){

      var cy = options.cy;
      // var allNodes = cy.nodes();
      var nodes = cy.nodes();
      //var allEdges = cy.edges();
      var edges = cy.edges();
      var cWidth = cy.width();
      var cHeight = cy.height();
      var simulationBounds = options.boundingBox ? $$.util.makeBoundingBox( options.boundingBox ) : null;
      var padding = options.padding;
      var simBBFactor = Math.max( 1, Math.log(nodes.length) * 0.8 );
      
      if( nodes.length < 100 ){
        simBBFactor /= 2;
      }

      layout.trigger( {
        type: 'layoutstart',
        layout: layout
      } );

      var simBB = {
        x1: 0,
        y1: 0,
        x2: cWidth * simBBFactor,
        y2: cHeight * simBBFactor
      };

      if( simulationBounds ) {
        simBB.x1 = simulationBounds.x1;
        simBB.y1 = simulationBounds.y1;
        simBB.x2 = simulationBounds.x2;
        simBB.y2 = simulationBounds.y2;
      }

      simBB.x1 += padding;
      simBB.y1 += padding;
      simBB.x2 -= padding;
      simBB.y2 -= padding;

      var width = simBB.x2 - simBB.x1;
      var height = simBB.y2 - simBB.y1;

      // Get start time
      var startTime = Date.now();

      // layout doesn't work with just 1 node
      if( nodes.size() <= 1 ) {
        nodes.positions( {
          x: Math.round( ( simBB.x1 + simBB.x2 ) / 2 ),
          y: Math.round( ( simBB.y1 + simBB.y2 ) / 2 )
        } );

        if( options.fit ) {
          cy.fit( options.padding );
        }

        // Get end time
        var endTime = Date.now();
        console.info( "Layout on " + nodes.size() + " nodes took " + ( endTime - startTime ) + " ms" );

        layout.one( "layoutready", options.ready );
        layout.trigger( "layoutready" );

        layout.one( "layoutstop", options.stop );
        layout.trigger( "layoutstop" );

        return;
      }

      // First I need to create the data structure to pass to the worker
      var pData = {
        'width': width,
        'height': height,
        'minDist': options.minDist,
        'expFact': options.expandingFactor,
        'expIt': 0,
        'maxExpIt': options.maxExpandIterations,
        'vertices': [],
        'edges': [],
        'startTime': startTime,
        'maxFruchtermanReingoldIterations': options.maxFruchtermanReingoldIterations
      };

      nodes.each(
        function( i, node ) {
          var nodeId = this._private.data.id;
          pData[ 'vertices' ].push( {
            id: nodeId,
            x: 0,
            y: 0
          } );
        } );

      edges.each(
        function() {
          var srcNodeId = this.source().id();
          var tgtNodeId = this.target().id();
          pData[ 'edges' ].push( {
            src: srcNodeId,
            tgt: tgtNodeId
          } );
        } );

      //Decleration
      var t1 = $$.Thread();
      // And to add the required scripts
      //EXTERNAL 1
      t1.require( foograph, 'foograph' );
      //EXTERNAL 2
      t1.require( Voronoi );

      //Local function
      t1.require( sitesDistance );
      t1.require( cellCentroid );

      function setPositions( pData ){ //console.log('set posns')
        // First we retrieve the important data
        // var expandIteration = pData[ 'expIt' ];
        var dataVertices = pData[ 'vertices' ];
        var vertices = [];
        for( var i = 0; i < dataVertices.length; ++i ) {
          var dv = dataVertices[ i ];
          vertices[ dv.id ] = {
            x: dv.x,
            y: dv.y
          };
        }
        /*
         * FINALLY:
         *
         * We position the nodes based on the calculation
         */
        nodes.positions(
          function( i, node ) {
            var id = node._private.data.id;
            // var pos = node._private.position;
            var vertex = vertices[ id ];

            return {
              x: Math.round( simBB.x1 + vertex.x ),
              y: Math.round( simBB.y1 + vertex.y )
            };
          } );

        if( options.fit ) {
          cy.fit( options.padding );
        }

        cy.nodes().rtrigger( "position" );
      }

      var didLayoutReady = false;
      t1.on('message', function(e){
        var pData = e.message; //console.log('message', e)

        if( !options.animate ){
          return;
        }

        setPositions( pData );

        if( !didLayoutReady ){
          layout.trigger( "layoutready" );

          didLayoutReady = true;
        }
      });

      layout.one( "layoutready", options.ready );

      t1.pass( pData ).run( function( pData ) {
        
        foograph = eval('foograph');
        Voronoi = eval('Voronoi');
        
        // I need to retrieve the important data
        var lWidth = pData[ 'width' ];
        var lHeight = pData[ 'height' ];
        var lMinDist = pData[ 'minDist' ];
        var lExpFact = pData[ 'expFact' ];
        var lMaxExpIt = pData[ 'maxExpIt' ];
        var lMaxFruchtermanReingoldIterations = pData[ 'maxFruchtermanReingoldIterations' ];

        // Prepare the data to output
        var savePositions = function(){
          pData[ 'width' ] = lWidth;
          pData[ 'height' ] = lHeight;
          pData[ 'expIt' ] = expandIteration;
          pData[ 'expFact' ] = lExpFact;

          pData[ 'vertices' ] = [];
          for( var i = 0; i < fv.length; ++i ) {
            pData[ 'vertices' ].push( {
              id: fv[ i ].label,
              x: fv[ i ].x,
              y: fv[ i ].y
            } );
          }
        };

        var messagePositions = function(){
          broadcast( pData );
        };

        /*
         * FIRST STEP: Application of the Fruchterman-Reingold algorithm
         *
         * We use the version implemented by the foograph library
         *
         * Ref.: https://code.google.com/p/foograph/
         */

        // We need to create an instance of a graph compatible with the library
        var frg = new foograph.Graph( "FRgraph", false );

        var frgNodes = {};

        // Then we have to add the vertices
        var dataVertices = pData[ 'vertices' ];
        for( var ni = 0; ni < dataVertices.length; ++ni ) {
          var id = dataVertices[ ni ][ 'id' ];
          var v = new foograph.Vertex( id, Math.round( Math.random() * lHeight ), Math.round( Math.random() * lHeight ) );
          frgNodes[ id ] = v;
          frg.insertVertex( v );
        }

        var dataEdges = pData[ 'edges' ];
        for( var ei = 0; ei < dataEdges.length; ++ei ) {
          var srcNodeId = dataEdges[ ei ][ 'src' ];
          var tgtNodeId = dataEdges[ ei ][ 'tgt' ];
          frg.insertEdge( "", 1, frgNodes[ srcNodeId ], frgNodes[ tgtNodeId ] );
        }

        var fv = frg.vertices;

        // Then we apply the layout
        var iterations = lMaxFruchtermanReingoldIterations;
        var frLayoutManager = new foograph.ForceDirectedVertexLayout( lWidth, lHeight, iterations, false, lMinDist );

        frLayoutManager.callback = function(){
          savePositions();
          messagePositions();
        };

        frLayoutManager.layout( frg );

        savePositions();
        messagePositions();

        /*
         * SECOND STEP: Tiding up of the graph.
         *
         * We use the method described by Gansner and North, based on Voronoi
         * diagrams.
         *
         * Ref: doi:10.1007/3-540-37623-2_28
         */

        // We calculate the Voronoi diagram dor the position of the nodes
        var voronoi = new Voronoi();
        var bbox = {
          xl: 0,
          xr: lWidth,
          yt: 0,
          yb: lHeight
        };
        var vSites = [];
        for( var i = 0; i < fv.length; ++i ) {
          vSites[ fv[ i ].label ] = fv[ i ];
        }

        function checkMinDist( ee ) {
          var infractions = 0;
          // Then we check if the minimum distance is satisfied
          for( var eei = 0; eei < ee.length; ++eei ) {
            var e = ee[ eei ];
            if( ( e.lSite != null ) && ( e.rSite != null ) && sitesDistance( e.lSite, e.rSite ) < lMinDist ) {
              ++infractions;
            }
          }
          return infractions;
        }

        var diagram = voronoi.compute( fv, bbox );

        // Then we reposition the nodes at the centroid of their Voronoi cells
        var cells = diagram.cells;
        for( var i = 0; i < cells.length; ++i ) {
          var cell = cells[ i ];
          var site = cell.site;
          var centroid = cellCentroid( cell );
          var currv = vSites[ site.label ];
          currv.x = centroid.x;
          currv.y = centroid.y;
        }

        if( lExpFact < 0.0 ) {
          // Calculates the expanding factor
          lExpFact = Math.max( 0.05, Math.min( 0.10, lMinDist / Math.sqrt( ( lWidth * lHeight ) / fv.length ) * 0.5 ) );
          //console.info("Expanding factor is " + (options.expandingFactor * 100.0) + "%");
        }

        var prevInfractions = checkMinDist( diagram.edges );
        //console.info("Initial infractions " + prevInfractions);

        var bStop = ( prevInfractions <= 0 );

        var voronoiIteration = 0;
        var expandIteration = 0;

        // var initWidth = lWidth;

        while( !bStop ) {
          ++voronoiIteration;
          for( var it = 0; it <= 4; ++it ) {
            voronoi.recycle( diagram );
            diagram = voronoi.compute( fv, bbox );

            // Then we reposition the nodes at the centroid of their Voronoi cells
            cells = diagram.cells;
            for( var i = 0; i < cells.length; ++i ) {
              var cell = cells[ i ];
              var site = cell.site;
              var centroid = cellCentroid( cell );
              var currv = vSites[ site.label ];
              currv.x = centroid.x;
              currv.y = centroid.y;
            }
          }

          var currInfractions = checkMinDist( diagram.edges );
          //console.info("Current infractions " + currInfractions);

          if( currInfractions <= 0 ) {
            bStop = true;
          } else {
            if( currInfractions >= prevInfractions || voronoiIteration >= 4 ) {
              if( expandIteration >= lMaxExpIt ) {
                bStop = true;
              } else {
                lWidth += lWidth * lExpFact;
                lHeight += lHeight * lExpFact;
                bbox = {
                  xl: 0,
                  xr: lWidth,
                  yt: 0,
                  yb: lHeight
                };
                ++expandIteration;
                voronoiIteration = 0;
                //console.info("Expanded to ("+width+","+height+")");
              }
            }
          }
          prevInfractions = currInfractions;

          savePositions();
          messagePositions();
        }

        savePositions();
        return pData;

      } ).then( function( pData ) {
        // var expandIteration = pData[ 'expIt' ];
        var dataVertices = pData[ 'vertices' ];

        setPositions( pData );

        // Get end time
        var startTime = pData[ 'startTime' ];
        var endTime = new Date();
        console.info( "Layout on " + dataVertices.length + " nodes took " + ( endTime - startTime ) + " ms" );

        layout.one( "layoutstop", options.stop );

        if( !options.animate ){
          layout.trigger( "layoutready" );
        }

        layout.trigger( "layoutstop" );

        t1.stop();
      } );

    });

    return this;
  }; // run

  SpreadLayout.prototype.stop = function() {};

  $$( 'layout', 'spread', SpreadLayout );


} )( cytoscape );

;(function($$){ 'use strict';
  
  var defaults = {
    animate: true, // whether to show the layout as it's running
    maxSimulationTime: 4000, // max length in ms to run the layout
    ungrabifyWhileSimulating: false, // so you can't drag nodes during layout
    fit: true, // whether to fit the viewport to the graph
    padding: 30, // padding on fit
    boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
    random: false, // whether to use random initial positions
    infinite: false, // overrides all other options for a forces-all-the-time mode
    ready: undefined, // callback on layoutready
    stop: undefined, // callback on layoutstop

    // springy forces
    stiffness: 400,
    repulsion: 400,
    damping: 0.5
  };

  function SpringyLayout( options ){
    this.options = $$.util.extend(true, {}, defaults, options);
  }
  
  SpringyLayout.prototype.run = function(){
    var layout = this;
    var self = this;
    var options = this.options;

    $$.util.require('Springy', function(Springy){

      var simUpdatingPos = false;

      var cy = options.cy;
      layout.trigger({ type: 'layoutstart', layout: layout });
      
      var eles = options.eles;
      var nodes = eles.nodes().not(':parent');
      var edges = eles.edges();
   
      var bb = $$.util.makeBoundingBox( options.boundingBox ? options.boundingBox : {
        x1: 0, y1: 0, w: cy.width(), h: cy.height()
      } );
      
      // make a new graph
      var graph = new Springy.Graph();

      // make some nodes
      nodes.each(function(i, node){
        node.scratch('springy', {
          model: graph.newNode({
            element: node
          })
        });
      });

      // connect them with edges
      edges.each(function(i, edge){
        var fdSrc = edge.source().scratch('springy').model;
        var fdTgt = edge.target().scratch('springy').model;
        
        edge.scratch('springy', {
          model: graph.newEdge(fdSrc, fdTgt, {
            element: edge
          })
        });
      });
      
      var sim = window.sim = new Springy.Layout.ForceDirected(graph, options.stiffness, options.repulsion, options.damping);

      if( options.infinite ){
        sim.minEnergyThreshold = -Infinity;
      }

      var currentBB = sim.getBoundingBox();
      // var targetBB = {bottomleft: new Springy.Vector(-2, -2), topright: new Springy.Vector(2, 2)};
      
      // convert to/from screen coordinates
      var toScreen = function(p) {
        currentBB = sim.getBoundingBox();

        var size = currentBB.topright.subtract(currentBB.bottomleft);
        var sx = p.subtract(currentBB.bottomleft).divide(size.x).x * bb.w + bb.x1;
        var sy = p.subtract(currentBB.bottomleft).divide(size.y).y * bb.h + bb.x1;

        return new Springy.Vector(sx, sy);
      };

      var fromScreen = function(s) {
        currentBB = sim.getBoundingBox();

        var size = currentBB.topright.subtract(currentBB.bottomleft);
        var px = ((s.x - bb.x1) / bb.w) * size.x + currentBB.bottomleft.x;
        var py = ((s.y - bb.y1) / bb.h) * size.y + currentBB.bottomleft.y;

        return new Springy.Vector(px, py);
      };
      
      var movedNodes = cy.collection();
      
      var numNodes = cy.nodes().size();
      var drawnNodes = 1;
      var fdRenderer = new Springy.Renderer(sim,
        function clear() {
          if( self.stopped ){ return; } // because springy is a buggy layout
          
          if( movedNodes.length > 0 && options.animate ){
            simUpdatingPos = true;

            movedNodes.rtrigger('position');

            if( options.fit ){
              cy.fit( options.padding );
            }

            movedNodes = cy.collection();

            simUpdatingPos = false;
          }
        },

        function drawEdge(edge, p1, p2) {
          // draw an edge
        },

        function drawNode(node, p) {
          if( self.stopped ){ return; } // because springy is a buggy layout

          var v = toScreen(p);
          var element = node.data.element;
          
          if( !element.locked() && !element.grabbed() ){
              element._private.position = {
                x: v.x,
                y: v.y
              };
              movedNodes.merge(element);
          } else {
            //setLayoutPositionForElement(element);
          }
          
          if( drawnNodes == numNodes ){
            layout.one('layoutready', options.ready);
            layout.trigger({ type: 'layoutready', layout: layout });
          } 
          
          drawnNodes++;
        
        }
      );
      
      // set initial node points
      nodes.each(function(i, ele){
        if( !options.random ){
          setLayoutPositionForElement(ele);
        }
      });
      
      // update node positions when dragging
      var dragHandler;
      nodes.on('position', dragHandler = function(){
        if( simUpdatingPos ){ return; }

        setLayoutPositionForElement(this);
      });
      
      function setLayoutPositionForElement(element){
        var fdId = element.scratch('springy').model.id;
        var fdP = fdRenderer.layout.nodePoints[fdId].p;
        var pos = element.position();
        var positionInFd = (pos.x != null && pos.y != null) ? fromScreen(element.position()) : {
          x: Math.random() * 4 - 2,
          y: Math.random() * 4 - 2
        };
        
        fdP.x = positionInFd.x;
        fdP.y = positionInFd.y;
      }
      
      var grabbableNodes = nodes.filter(":grabbable");
      
      function start(){
        self.stopped = false;

        // disable grabbing if so set
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.ungrabify();
        }
        
        fdRenderer.start();
      }
      
      self.stopSystem = function(){
        self.stopped = true;

        graph.filterNodes(function(){
          return false; // remove all nodes
        });
        
        if( options.ungrabifyWhileSimulating ){
          grabbableNodes.grabify();
        }

        if( options.fit ){
          cy.fit( options.padding );
        }
        
        nodes.off('drag position', dragHandler);

        layout.one('layoutstop', options.stop);
        layout.trigger({ type: 'layoutstop', layout: layout });

        self.stopSystem = null;
      };
      
      start();
      if( !options.infinite ){
        setTimeout(function(){
          self.stop();
        }, options.maxSimulationTime);
      }

    }); // require

    return this; // chaining
  };

  SpringyLayout.prototype.stop = function(){
    if( this.stopSystem != null ){
      this.stopSystem();
    }

    return this; // chaining
  };
  
  $$('layout', 'springy', SpringyLayout);

  
})(cytoscape);

;(function($$){ 'use strict';
    
  function NullRenderer(options){
    this.options = options;
  }
  
  NullRenderer.prototype.recalculateRenderedStyle = function(){
  };

  NullRenderer.prototype.notify = function(){
    // the null renderer does nothing
  };
  
  $$('renderer', 'null', NullRenderer);
  
})( cytoscape );

}).call(this,require('_process'),"/../bower_components/cytoscape/dist")

},{"_process":4,"child_process":1,"os":2,"path":3}],6:[function(require,module,exports){
(function (global){
/*! imjs - v3.13.0 - 2015-05-08 */

// This library is open source software according to the definition of the
// GNU Lesser General Public Licence, Version 3, (LGPLv3) a copy of which is
// included with this software. All use of this software is covered according to
// the terms of the LGPLv3.
// 
// The copyright is held by InterMine (www.intermine.org) and Alex Kalderimis (alex@intermine.org).

(function (intermine) {
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.imjs=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function() {
  exports.ACCEPT_HEADER = {
    'xml': 'application/xml',
    'json': 'application/json',
    'tsv': 'text/tab-separated-values',
    'tab': 'text/tab-separated-values',
    'csv': 'text/comma-separated-values',
    'fasta': 'text/x-fasta',
    'gff3': 'text/x-gff3',
    'bed': 'text/x-bed',
    'objects': 'application/json;type=objects',
    'jsonobjects': 'application/json;type=objects',
    'jsontable': 'application/json;type=table',
    'jsonrows': 'application/json;type=rows',
    'jsoncount': 'application/json;type=count',
    'jsonp': 'application/javascript',
    'jsonpobjects': 'application/javascript;type=objects',
    'jsonptable': 'application/javascript;type=table',
    'jsonprows': 'application/javascript;type=rows',
    'jsonpcount': 'application/javascript;type=count'
  };

}).call(this);

},{}],2:[function(_dereq_,module,exports){
(function (global){
(function() {
  var expose, imjs, merge;

  _dereq_('./shiv');

  module.exports = imjs = _dereq_('./service');

  merge = imjs.utils.merge;

  expose = function(name, thing) {
    if ('function' === typeof define && define.amd) {
      return define(name, [], thing);
    } else {
      return global[name] = thing;
    }
  };

  expose('imjs', imjs);

  if (typeof intermine === 'undefined') {
    expose('intermine', imjs);
  } else {
    expose('intermine', merge(intermine, imjs));
  }

}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./service":10,"./shiv":12}],3:[function(_dereq_,module,exports){
(function() {
  var ACCEPT_HEADER, JSONStream, PESKY_COMMA, URL, URLENC, USER_AGENT, VERSION, blocking, defer, error, getMsg, http, invoke, merge, parseOptions, rejectAfter, streaming, utils, _ref;

  URL = _dereq_('url');

  JSONStream = _dereq_('JSONStream');

  http = _dereq_('http');

  ACCEPT_HEADER = _dereq_('./constants').ACCEPT_HEADER;

  VERSION = _dereq_('./version').VERSION;

  _ref = utils = _dereq_('./util'), error = _ref.error, defer = _ref.defer, merge = _ref.merge, invoke = _ref.invoke;

  USER_AGENT = "node-http/imjs-" + VERSION;

  PESKY_COMMA = /,\s*$/;

  URLENC = "application/x-www-form-urlencoded";

  exports.supports = function() {
    return true;
  };

  streaming = function(opts, resolve, reject) {
    return function(resp) {
      var errors, results;
      if (resp.pipe == null) {
        return reject(new Error('response is not a stream'));
      }
      resp.on('error', reject);
      if ((resp.statusCode != null) && resp.statusCode !== 200) {
        errors = JSONStream.parse('error');
        errors.pause();
        resp.pipe(errors);
        return reject([resp.statusCode, errors]);
      } else {
        results = JSONStream.parse('results.*');
        results.pause();
        resp.pipe(results);
        return resolve(results);
      }
    };
  };

  getMsg = function(_arg, text, e, code) {
    var type, url;
    type = _arg.type, url = _arg.url;
    return "Could not parse response to " + type + " " + url + ": \"" + text + "\" (" + code + ": " + e + ")";
  };

  blocking = function(opts, resolve, reject) {
    return function(resp) {
      var containerBuffer;
      containerBuffer = '';
      resp.on('data', function(chunk) {
        return containerBuffer += chunk;
      });
      resp.on('error', reject);
      return resp.on('end', function() {
        var ct, e, err, f, match, parsed, _ref1;
        ct = resp.headers['content-type'];
        if ('application/json' === ct || /json/.test(opts.dataType) || /json/.test(opts.data.format)) {
          if ('' === containerBuffer && resp.statusCode === 200) {
            return resolve();
          } else {
            try {
              parsed = JSON.parse(containerBuffer);
              if (err = parsed.error) {
                return reject(new Error(err));
              } else {
                return resolve(parsed);
              }
            } catch (_error) {
              e = _error;
              if (resp.statusCode >= 400) {
                return reject(new Error(resp.statusCode));
              } else {
                return reject(new Error(getMsg(opts, containerBuffer, e, resp.statusCode)));
              }
            }
          }
        } else {
          if (match = containerBuffer.match(/\[ERROR\] (\d+)([\s\S]*)/)) {
            return reject(new Error(match[2]));
          } else {
            f = (200 <= (_ref1 = resp.statusCode) && _ref1 < 400) ? resolve : reject;
            return f(containerBuffer);
          }
        }
      });
    };
  };

  exports.iterReq = function(method, path, format) {
    return function(q, page, cb, eb, onEnd) {
      var attach, promise, readErrors, req, _ref1;
      if (page == null) {
        page = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (eb == null) {
        eb = (function() {});
      }
      if (onEnd == null) {
        onEnd = (function() {});
      }
      if (utils.isFunction(page)) {
        _ref1 = [{}, page, cb, eb], page = _ref1[0], cb = _ref1[1], eb = _ref1[2], onEnd = _ref1[3];
      }
      req = merge({
        format: format
      }, page, {
        query: q.toXML()
      });
      attach = function(stream) {
        stream.on('data', cb);
        stream.on('error', eb);
        stream.on('end', onEnd);
        setTimeout((function() {
          if (stream.resume != null) {
            return stream.resume();
          }
        }), 3);
        return stream;
      };
      readErrors = function(_arg) {
        var errors, sc;
        sc = _arg[0], errors = _arg[1];
        errors.on('data', eb);
        errors.on('error', eb);
        errors.on('end', onEnd);
        if (errors.resume != null) {
          errors.resume();
        }
        return error(sc);
      };
      promise = this.makeRequest(method, path, req, null, true);
      promise.then(attach, readErrors);
      return promise;
    };
  };

  rejectAfter = function(timeout, reject, promise) {
    var to;
    to = setTimeout((function() {
      return reject("Request timed out.");
    }), timeout);
    return promise.then(function() {
      return cancelTimeout(to);
    });
  };

  parseOptions = function(opts) {
    var k, parsed, postdata, sep, v, _ref1, _ref2, _ref3;
    if (!opts.url) {
      throw new Error("No url provided in " + (JSON.stringify(opts)));
    }
    if (typeof opts.data === 'string') {
      postdata = opts.data;
      if ((_ref1 = opts.type) === 'GET' || _ref1 === 'DELETE') {
        throw new Error("Invalid request. " + opts.type + " requests must not have bodies");
      }
    } else {
      postdata = utils.querystring(opts.data);
    }
    parsed = URL.parse(opts.url, true);
    parsed.withCredentials = false;
    parsed.method = opts.type || 'GET';
    if (opts.port != null) {
      parsed.port = opts.port;
    }
    parsed.headers = {
      'User-Agent': USER_AGENT,
      'Accept': ACCEPT_HEADER[opts.dataType]
    };
    if (((_ref2 = parsed.method) === 'GET' || _ref2 === 'DELETE') && (postdata != null ? postdata.length : void 0)) {
      sep = /\?/.test(parsed.path) ? '&' : '?';
      parsed.path += sep + postdata;
      postdata = null;
    } else {
      parsed.headers['Content-Type'] = (opts.contentType || URLENC) + '; charset=UTF-8';
      parsed.headers['Content-Length'] = postdata.length;
    }
    if (opts.headers != null) {
      _ref3 = opts.headers;
      for (k in _ref3) {
        v = _ref3[k];
        parsed.headers[k] = v;
      }
    }
    if (opts.auth != null) {
      parsed.auth = opts.auth;
    }
    return [parsed, postdata];
  };

  exports.doReq = function(opts, iter) {
    var e, handler, postdata, promise, reject, req, resolve, timeout, url, _ref1, _ref2;
    _ref1 = defer(), promise = _ref1.promise, resolve = _ref1.resolve, reject = _ref1.reject;
    promise.then(null, opts.error);
    try {
      _ref2 = parseOptions(opts), url = _ref2[0], postdata = _ref2[1];
      handler = (iter ? streaming : blocking)(opts, resolve, reject);
      req = http.request(url, handler);
      req.on('error', function(err) {
        return reject(new Error("Error: " + url.method + " " + opts.url + ": " + err));
      });
      if (postdata != null) {
        req.write(postdata);
      }
      req.end();
      timeout = opts.timeout;
      if (timeout > 0) {
        rejectAfter(timeout, reject, promise);
      }
    } catch (_error) {
      e = _error;
      reject(e);
    }
    return promise;
  };

}).call(this);

},{"./constants":1,"./util":15,"./version":16,"JSONStream":18,"http":50,"url":47}],4:[function(_dereq_,module,exports){
(function() {
  var CategoryResults, IDResolutionJob, IdResults, ONE_MINUTE, concatMap, defer, difference, fold, funcutils, get, id, intermine, uniqBy, withCB,
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  funcutils = _dereq_('./util');

  intermine = exports;

  uniqBy = funcutils.uniqBy, difference = funcutils.difference, defer = funcutils.defer, withCB = funcutils.withCB, id = funcutils.id, get = funcutils.get, fold = funcutils.fold, concatMap = funcutils.concatMap;

  ONE_MINUTE = 60 * 1000;

  CategoryResults = (function() {
    var getIssueMatches;

    function CategoryResults(results) {
      var k, v;
      for (k in results) {
        if (!__hasProp.call(results, k)) continue;
        v = results[k];
        this[k] = v;
      }
    }

    CategoryResults.prototype.getStats = function(type) {
      if (type != null) {
        return this.stats[type];
      } else {
        return this.stats;
      }
    };

    getIssueMatches = concatMap(get('matches'));

    CategoryResults.prototype.getMatches = function(k) {
      var _ref;
      if (k === 'MATCH') {
        return this.matches[k];
      } else {
        return (_ref = getIssueMatches(this.matches[k])) != null ? _ref : [];
      }
    };

    CategoryResults.prototype.getMatchIds = function(k) {
      if (k != null) {
        return this.getMatches(k).map(get('id'));
      } else {
        return this.allMatchIds();
      }
    };

    CategoryResults.prototype.goodMatchIds = function() {
      return this.getMatchIds('MATCH');
    };

    CategoryResults.prototype.allMatchIds = function() {
      var combineIds;
      combineIds = fold((function(_this) {
        return function(res, issueSet) {
          return res.concat(_this.getMatchIds(issueSet));
        };
      })(this));
      return combineIds(this.goodMatchIds(), ['DUPLICATE', 'WILDCARD', 'TYPE_CONVERTED', 'OTHER']);
    };

    return CategoryResults;

  })();

  IdResults = (function() {
    var flatten, getReasons, isGood, unique;

    unique = uniqBy(id);

    flatten = concatMap(id);

    getReasons = function(match) {
      var k, vals;
      return flatten((function() {
        var _ref, _results;
        _ref = match.identifiers;
        _results = [];
        for (k in _ref) {
          vals = _ref[k];
          _results.push(vals);
        }
        return _results;
      })());
    };

    isGood = function(match, k) {
      return (k == null) || __indexOf.call(getReasons(match), k) >= 0;
    };

    function IdResults(results) {
      var k, v;
      for (k in results) {
        if (!__hasProp.call(results, k)) continue;
        v = results[k];
        this[k] = v;
      }
    }

    IdResults.prototype.getStats = function(type) {
      switch (type) {
        case 'objects':
          return this.getObjectStats();
        case 'identifiers':
          return this.getIdentifierStats();
        default:
          return {
            objects: this.getObjectStats(),
            identifiers: this.getIdentifierStats()
          };
      }
    };

    IdResults.prototype.getIdentifierStats = function() {
      var all, allIdents, issues, matchIdents, matches, toIdents;
      toIdents = function(ms) {
        var ident, match;
        return unique(flatten((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = ms.length; _i < _len; _i++) {
            match = ms[_i];
            _results.push((function() {
              var _results1;
              _results1 = [];
              for (ident in match != null ? match.identifiers : void 0) {
                _results1.push(ident);
              }
              return _results1;
            })());
          }
          return _results;
        })()));
      };
      matchIdents = toIdents(this.getMatches('MATCH'));
      allIdents = toIdents(this.getMatches());
      matches = matchIdents.length;
      all = allIdents.length;
      issues = (difference(allIdents, matchIdents)).length;
      return {
        matches: matches,
        all: all,
        issues: issues
      };
    };

    IdResults.prototype.getObjectStats = function() {
      var all, issues, match, matches;
      matches = this.goodMatchIds().length;
      all = this.allMatchIds().length;
      issues = ((function() {
        var _results;
        _results = [];
        for (id in this) {
          if (!__hasProp.call(this, id)) continue;
          match = this[id];
          if (__indexOf.call(getReasons(match), 'MATCH') < 0) {
            _results.push(id);
          }
        }
        return _results;
      }).call(this)).length;
      return {
        matches: matches,
        all: all,
        issues: issues
      };
    };

    IdResults.prototype.getMatches = function(k) {
      var match, _results;
      _results = [];
      for (id in this) {
        if (!__hasProp.call(this, id)) continue;
        match = this[id];
        if (isGood(match, k)) {
          _results.push(match);
        }
      }
      return _results;
    };

    IdResults.prototype.getMatchIds = function(k) {
      var match, _results;
      _results = [];
      for (id in this) {
        if (!__hasProp.call(this, id)) continue;
        match = this[id];
        if (isGood(match, k)) {
          _results.push(id);
        }
      }
      return _results;
    };

    IdResults.prototype.goodMatchIds = function() {
      return this.getMatchIds('MATCH');
    };

    IdResults.prototype.allMatchIds = function() {
      return this.getMatchIds();
    };

    return IdResults;

  })();

  IDResolutionJob = (function() {
    function IDResolutionJob(uid, service) {
      this.uid = uid;
      this.service = service;
      this.del = __bind(this.del, this);
      this.fetchResults = __bind(this.fetchResults, this);
      this.fetchErrorMessage = __bind(this.fetchErrorMessage, this);
      this.fetchStatus = __bind(this.fetchStatus, this);
    }

    IDResolutionJob.prototype.fetchStatus = function(cb) {
      return withCB(cb, this.service.get("ids/" + this.uid + "/status").then(get('status')));
    };

    IDResolutionJob.prototype.fetchErrorMessage = function(cb) {
      return withCB(cb, this.service.get("ids/" + this.uid + "/status").then(get('message')));
    };

    IDResolutionJob.prototype.fetchResults = function(cb) {
      var gettingRes, gettingVer;
      gettingRes = this.service.get("ids/" + this.uid + "/result").then(get('results'));
      gettingVer = this.service.fetchVersion();
      return gettingVer.then(function(v) {
        return gettingRes.then(function(results) {
          if (v >= 16) {
            return new CategoryResults(results);
          } else {
            return new IdResults(results);
          }
        });
      });
    };

    IDResolutionJob.prototype.del = function(cb) {
      return withCB(cb, this.service.makeRequest('DELETE', "ids/" + this.uid));
    };

    IDResolutionJob.prototype.decay = 50;

    IDResolutionJob.prototype.poll = function(onSuccess, onError, onProgress) {
      var backOff, notify, promise, reject, resolve, resp, _ref;
      _ref = defer(), promise = _ref.promise, resolve = _ref.resolve, reject = _ref.reject;
      promise.then(onSuccess, onError);
      notify = onProgress != null ? onProgress : (function() {});
      resp = this.fetchStatus();
      resp.then(null, reject);
      backOff = this.decay;
      this.decay = Math.min(ONE_MINUTE, backOff * 1.25);
      resp.then((function(_this) {
        return function(status) {
          notify(status);
          switch (status) {
            case 'SUCCESS':
              return _this.fetchResults().then(resolve, reject);
            case 'ERROR':
              return _this.fetchErrorMessage().then(reject, reject);
            default:
              return setTimeout((function() {
                return _this.poll(resolve, reject, notify);
              }), backOff);
          }
        };
      })(this));
      return promise;
    };

    return IDResolutionJob;

  })();

  IDResolutionJob.prototype.wait = IDResolutionJob.prototype.poll;

  IDResolutionJob.create = function(service) {
    return function(uid) {
      return new IDResolutionJob(uid, service);
    };
  };

  intermine.IDResolutionJob = IDResolutionJob;

  intermine.CategoryResults = CategoryResults;

  intermine.IdResults = IdResults;

}).call(this);

},{"./util":15}],5:[function(_dereq_,module,exports){
(function() {
  var INVITES, List, REQUIRES_VERSION, SHARES, TAGS_PATH, dejoin, get, getFolderName, intermine, invoke, isFolder, merge, set, utils, withCB,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  utils = _dereq_('./util');

  intermine = exports;

  merge = utils.merge, withCB = utils.withCB, get = utils.get, invoke = utils.invoke, REQUIRES_VERSION = utils.REQUIRES_VERSION, set = utils.set, dejoin = utils.dejoin;

  TAGS_PATH = "list/tags";

  SHARES = "lists/shares";

  INVITES = 'lists/invitations';

  isFolder = function(t) {
    return t.substr(0, t.indexOf(':')) === '__folder__';
  };

  getFolderName = function(t) {
    return t.substr(t.indexOf(':') + 1);
  };

  List = (function() {
    var getTags;

    function List(properties, service) {
      var k, v;
      this.service = service;
      this._updateTags = __bind(this._updateTags, this);
      this.hasTag = __bind(this.hasTag, this);
      for (k in properties) {
        if (!__hasProp.call(properties, k)) continue;
        v = properties[k];
        this[k] = v;
      }
      this.dateCreated = (this.dateCreated != null) ? new Date(this.dateCreated) : null;
      this.folders = this.tags.filter(isFolder).map(getFolderName);
    }

    List.prototype.hasTag = function(t) {
      return __indexOf.call(this.tags, t) >= 0;
    };

    List.prototype.query = function(view) {
      if (view == null) {
        view = ['*'];
      }
      return this.service.query({
        select: view,
        from: this.type,
        where: [[this.type, 'IN', this.name]]
      });
    };

    List.prototype.del = function(cb) {
      return this.service.makeRequest('DELETE', 'lists', {
        name: this.name
      }, cb);
    };

    getTags = function(_arg) {
      var tags;
      tags = _arg.tags;
      return tags;
    };

    List.prototype._updateTags = function(err, tags) {
      if (err != null) {
        return;
      }
      this.tags = tags.slice();
      return this.folders = this.tags.filter(isFolder).map(getFolderName);
    };

    List.prototype.fetchTags = function(cb) {
      return withCB(this._updateTags, cb, this.service.makeRequest('GET', 'list/tags', {
        name: this.name
      }).then(getTags));
    };

    List.prototype.addTags = function(tags, cb) {
      var req;
      req = {
        name: this.name,
        tags: tags
      };
      return withCB(this._updateTags, cb, this.service.makeRequest('POST', 'list/tags', req).then(getTags));
    };

    List.prototype.removeTags = function(tags, cb) {
      var req;
      req = {
        name: this.name,
        tags: tags
      };
      return withCB(this._updateTags, cb, this.service.makeRequest('DELETE', 'list/tags', req).then(getTags));
    };

    List.prototype.contents = function(cb) {
      return withCB(cb, this.query().then(dejoin).then(invoke('records')));
    };

    List.prototype.rename = function(newName, cb) {
      var promise;
      promise = this.service.post('lists/rename', {
        oldname: this.name,
        newname: newName
      }).then(get('listName')).then((function(_this) {
        return function(n) {
          return _this.name = n;
        };
      })(this)).then(this.service.fetchList);
      return withCB(cb, promise);
    };

    List.prototype.copy = function(opts, cb) {
      var baseName, name, query, tags, _ref, _ref1, _ref2;
      if (opts == null) {
        opts = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (arguments.length === 1 && utils.isFunction(opts)) {
        _ref = [{}, opts], opts = _ref[0], cb = _ref[1];
      }
      if (typeof opts === 'string') {
        opts = {
          name: opts
        };
      }
      name = baseName = (_ref1 = opts.name) != null ? _ref1 : "" + this.name + "_copy";
      tags = this.tags.concat((_ref2 = opts.tags) != null ? _ref2 : []);
      query = this.query(['id']);
      return withCB(cb, this.service.fetchLists().then(invoke('map', get('name'))).then((function(_this) {
        return function(names) {
          var c;
          c = 1;
          while (__indexOf.call(names, name) >= 0) {
            name = "" + baseName + "-" + (c++);
          }
          return query.then(invoke('saveAsList', {
            name: name,
            tags: tags,
            description: _this.description
          }));
        };
      })(this)));
    };

    List.prototype.enrichment = function(opts, cb) {
      return this.service.enrichment(merge({
        list: this.name
      }, opts), cb);
    };

    List.prototype.shareWithUser = function(recipient, cb) {
      return withCB(cb, this.service.post(SHARES, {
        'list': this.name,
        'with': recipient
      }));
    };

    List.prototype.inviteUserToShare = function(recipient, notify, cb) {
      if (notify == null) {
        notify = true;
      }
      if (cb == null) {
        cb = (function() {});
      }
      return withCB(cb, this.service.post(INVITES, {
        list: this.name,
        to: recipient,
        notify: !!notify
      }));
    };

    return List;

  })();

  intermine.List = List;

}).call(this);

},{"./util":15}],6:[function(_dereq_,module,exports){
(function() {
  var JAVA_LANG_OBJ, Model, PathInfo, Table, error, find, flatten, intermine, omap, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Table = _dereq_('./table').Table;

  PathInfo = _dereq_('./path').PathInfo;

  _ref = _dereq_('./util'), flatten = _ref.flatten, find = _ref.find, error = _ref.error, omap = _ref.omap;

  intermine = exports;

  JAVA_LANG_OBJ = new Table({
    name: 'Object',
    tags: [],
    displayName: 'Object',
    attributes: {},
    references: {},
    collections: {}
  });

  Model = (function() {
    function Model(_arg) {
      var classes, liftToTable;
      this.name = _arg.name, classes = _arg.classes;
      this.findCommonType = __bind(this.findCommonType, this);
      this.findSharedAncestor = __bind(this.findSharedAncestor, this);
      this.getAncestorsOf = __bind(this.getAncestorsOf, this);
      this.getSubclassesOf = __bind(this.getSubclassesOf, this);
      this.getPathInfo = __bind(this.getPathInfo, this);
      liftToTable = omap((function(_this) {
        return function(k, v) {
          return [k, new Table(v, _this)];
        };
      })(this));
      this.classes = liftToTable(classes);
      this.classes['java.lang.Object'] = JAVA_LANG_OBJ;
    }

    Model.prototype.getPathInfo = function(path, subcls) {
      return PathInfo.parse(this, path, subcls);
    };

    Model.prototype.getSubclassesOf = function(cls) {
      var cd, clazz, ret, _, _ref1, _ref2;
      clazz = cls && cls.name ? cls : this.classes[cls];
      if (clazz == null) {
        throw new Error("" + cls + " is not a table");
      }
      ret = [clazz.name];
      _ref1 = this.classes;
      for (_ in _ref1) {
        cd = _ref1[_];
        if (_ref2 = clazz.name, __indexOf.call(cd.parents(), _ref2) >= 0) {
          ret = ret.concat(this.getSubclassesOf(cd));
        }
      }
      return ret;
    };

    Model.prototype.getAncestorsOf = function(cls) {
      var clazz, parents;
      clazz = cls && cls.name ? cls : this.classes[cls];
      if (clazz == null) {
        throw new Error("" + cls + " is not a table");
      }
      parents = clazz.parents();
      return parents.filter((function(_this) {
        return function(p) {
          return _this.classes[p];
        };
      })(this)).reduce(((function(_this) {
        return function(as, p) {
          return as.concat(_this.getAncestorsOf(p));
        };
      })(this)), parents);
    };

    Model.prototype.findSharedAncestor = function(classA, classB) {
      var a_ancestry, b_ancestry, firstCommon;
      if (classB === null || classA === null) {
        return null;
      }
      if (classA === classB) {
        return classA;
      }
      a_ancestry = this.getAncestorsOf(classA);
      if (__indexOf.call(a_ancestry, classB) >= 0) {
        return classB;
      }
      b_ancestry = this.getAncestorsOf(classB);
      if (__indexOf.call(b_ancestry, classA) >= 0) {
        return classA;
      }
      firstCommon = find(a_ancestry, function(a) {
        return __indexOf.call(b_ancestry, a) >= 0;
      });
      return firstCommon;
    };

    Model.prototype.findCommonType = function(xs) {
      if (xs == null) {
        xs = [];
      }
      return xs.reduce(this.findSharedAncestor);
    };

    return Model;

  })();

  Model.prototype.makePath = Model.prototype.getPathInfo;

  Model.prototype.findCommonTypeOfMultipleClasses = Model.prototype.findCommonType;

  Model.load = function(data) {
    var e;
    try {
      return new Model(data);
    } catch (_error) {
      e = _error;
      throw new Error("Error loading model: " + e);
    }
  };

  Model.INTEGRAL_TYPES = ["int", "Integer", "long", "Long"];

  Model.FRACTIONAL_TYPES = ["double", "Double", "float", "Float"];

  Model.NUMERIC_TYPES = Model.INTEGRAL_TYPES.concat(Model.FRACTIONAL_TYPES);

  Model.BOOLEAN_TYPES = ["boolean", "Boolean"];

  intermine.Model = Model;

}).call(this);

},{"./path":7,"./table":13,"./util":15}],7:[function(_dereq_,module,exports){
(function() {
  var NAMES, PARSED, PathInfo, any, concatMap, copy, error, get, intermine, makeKey, set, success, utils, withCB,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  intermine = exports;

  utils = _dereq_('./util');

  withCB = utils.withCB, concatMap = utils.concatMap, get = utils.get, any = utils.any, set = utils.set, copy = utils.copy, success = utils.success, error = utils.error;

  NAMES = {};

  PARSED = {};

  makeKey = function(model, path, subclasses) {
    var k, v, _ref;
    return "" + (model != null ? model.name : void 0) + "|" + (model != null ? (_ref = model.service) != null ? _ref.root : void 0 : void 0) + "|" + path + ":" + ((function() {
      var _results;
      _results = [];
      for (k in subclasses) {
        v = subclasses[k];
        _results.push("" + k + "=" + v);
      }
      return _results;
    })());
  };

  PathInfo = (function() {
    function PathInfo(_arg) {
      var _i, _ref;
      this.root = _arg.root, this.model = _arg.model, this.descriptors = _arg.descriptors, this.subclasses = _arg.subclasses, this.displayName = _arg.displayName, this.ident = _arg.ident;
      this.allDescriptors = __bind(this.allDescriptors, this);
      this.getChildNodes = __bind(this.getChildNodes, this);
      this.getDisplayName = __bind(this.getDisplayName, this);
      this.isa = __bind(this.isa, this);
      this.append = __bind(this.append, this);
      this.getParent = __bind(this.getParent, this);
      this.getEndClass = __bind(this.getEndClass, this);
      this.containsCollection = __bind(this.containsCollection, this);
      this.isCollection = __bind(this.isCollection, this);
      this.isReverseReference = __bind(this.isReverseReference, this);
      this.isReference = __bind(this.isReference, this);
      this.isClass = __bind(this.isClass, this);
      this.isAttribute = __bind(this.isAttribute, this);
      this.isRoot = __bind(this.isRoot, this);
      _ref = this.descriptors, this.mid = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), this.end = _ref[_i++];
      if (this.ident == null) {
        this.ident = makeKey(this.model, this, this.subclasses);
      }
    }

    PathInfo.prototype.isRoot = function() {
      return this.descriptors.length === 0;
    };

    PathInfo.prototype.isAttribute = function() {
      return (this.end != null) && !this.isReference();
    };

    PathInfo.prototype.isClass = function() {
      return this.isRoot() || this.isReference();
    };

    PathInfo.prototype.isReference = function() {
      var _ref;
      return ((_ref = this.end) != null ? _ref.referencedType : void 0) != null;
    };

    PathInfo.prototype.isReverseReference = function() {
      var gp, p, referencedType, reverseReference, _ref;
      if (this.isReference() && (this.mid.length > 0)) {
        _ref = this.end, reverseReference = _ref.reverseReference, referencedType = _ref.referencedType;
        p = this.getParent();
        gp = p.getParent();
        return (referencedType != null) && (gp.isa(referencedType)) && (p.end.name === reverseReference);
      }
      return false;
    };

    PathInfo.prototype.isCollection = function() {
      var _ref, _ref1;
      return (_ref = (_ref1 = this.end) != null ? _ref1.isCollection : void 0) != null ? _ref : false;
    };

    PathInfo.prototype.containsCollection = function() {
      return any(this.descriptors, function(x) {
        return x.isCollection;
      });
    };

    PathInfo.prototype.getEndClass = function() {
      var _ref;
      return this.model.classes[this.subclasses[this.toString()] || ((_ref = this.end) != null ? _ref.referencedType : void 0)] || this.root;
    };

    PathInfo.prototype.getParent = function() {
      var data;
      if (this.isRoot()) {
        throw new Error("Root paths do not have parents");
      }
      data = {
        root: this.root,
        model: this.model,
        descriptors: this.mid.slice(),
        subclasses: this.subclasses
      };
      return new PathInfo(data);
    };

    PathInfo.prototype.append = function(attr) {
      var data, fld;
      if (this.isAttribute()) {
        throw new Error("" + this + " is an attribute.");
      }
      fld = typeof attr === 'string' ? this.getType().fields[attr] : attr;
      if (fld == null) {
        throw new Error("" + attr + " is not a field of " + (this.getType()));
      }
      data = {
        root: this.root,
        model: this.model,
        descriptors: this.descriptors.concat([fld]),
        subclasses: this.subclasses
      };
      return new PathInfo(data);
    };

    PathInfo.prototype.isa = function(clazz) {
      var name, type;
      if (clazz == null) {
        return false;
      }
      if (this.isAttribute()) {
        return this.getType() === clazz;
      } else {
        name = clazz.name ? clazz.name : '' + clazz;
        type = this.getType();
        return (name === type.name) || (__indexOf.call(this.model.getAncestorsOf(type), name) >= 0);
      }
    };

    PathInfo.prototype.getDisplayName = function(cb) {
      var cached, custom, params, path;
      if (custom = this.displayName) {
        return success(custom);
      }
      if (this.namePromise == null) {
        this.namePromise = (cached = NAMES[this.ident]) ? success(cached) : this.isRoot() && this.root.displayName ? success(this.root.displayName) : this.model.service == null ? error("No service") : (path = 'model' + (concatMap(function(d) {
          return '/' + d.name;
        }))(this.allDescriptors()), params = (set({
          format: 'json'
        }))(copy(this.subclasses)), this.model.service.get(path, params).then(get('display')).then((function(_this) {
          return function(n) {
            var _name;
            return NAMES[_name = _this.ident] != null ? NAMES[_name] : NAMES[_name] = n;
          };
        })(this)));
      }
      return withCB(cb, this.namePromise);
    };

    PathInfo.prototype.getChildNodes = function() {
      var fld, name, _ref, _ref1, _results;
      _ref1 = ((_ref = this.getEndClass()) != null ? _ref.fields : void 0) || {};
      _results = [];
      for (name in _ref1) {
        fld = _ref1[name];
        _results.push(this.append(fld));
      }
      return _results;
    };

    PathInfo.prototype.allDescriptors = function() {
      return [this.root].concat(this.descriptors);
    };

    PathInfo.prototype.toString = function() {
      return this.allDescriptors().map(get('name')).join('.');
    };

    PathInfo.prototype.equals = function(other) {
      return this === other || (this.ident && (other != null ? other.ident : void 0) === this.ident);
    };

    PathInfo.prototype.getType = function() {
      var _ref, _ref1;
      return ((_ref = this.end) != null ? (_ref1 = _ref.type) != null ? _ref1.replace(/java\.lang\./, '') : void 0 : void 0) || this.getEndClass();
    };

    return PathInfo;

  })();

  PathInfo.prototype.toPathString = PathInfo.prototype.toString;

  PathInfo.parse = function(model, path, subclasses) {
    var cached, cd, descriptors, fld, ident, keyPath, part, parts, root;
    if (subclasses == null) {
      subclasses = {};
    }
    ident = makeKey(model, path, subclasses);
    if (cached = PARSED[ident]) {
      return cached;
    }
    parts = (path + '').split('.');
    root = cd = model.classes[parts.shift()];
    keyPath = root.name;
    descriptors = (function() {
      var _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = parts.length; _i < _len; _i++) {
        part = parts[_i];
        fld = (cd != null ? cd.fields[part] : void 0) || ((_ref = (cd = model.classes[subclasses[keyPath]])) != null ? _ref.fields[part] : void 0);
        if (!fld) {
          throw new Error("Could not find " + part + " in " + cd + " when parsing " + path);
        }
        keyPath += "." + part;
        cd = model.classes[fld.type || fld.referencedType];
        _results.push(fld);
      }
      return _results;
    })();
    return PARSED[ident] = new PathInfo({
      root: root,
      model: model,
      descriptors: descriptors,
      subclasses: subclasses,
      ident: ident
    });
  };

  PathInfo.flushCache = function() {
    PARSED = {};
    return NAMES = {};
  };

  intermine.PathInfo = PathInfo;

}).call(this);

},{"./util":15}],8:[function(_dereq_,module,exports){
(function() {
  var Promise;

  Promise = _dereq_('es6-promise').Promise;

  module.exports = Promise;

}).call(this);

},{"es6-promise":22}],9:[function(_dereq_,module,exports){
(function() {
  var BASIC_ATTRS, CODES, Events, LIST_PIPE, Query, REQUIRES_VERSION, RESULTS_METHODS, SIMPLE_ATTRS, bioUriArgs, conAttrs, conStr, conToJSON, conValStr, concatMap, copyCon, decapitate, didntRemove, f, filter, fold, get, get_canonical_op, headLess, id, idConStr, intermine, interpretConArray, interpretConstraint, invoke, merge, mth, multiConStr, noUndefVals, noValueConStr, partition, removeIrrelevantSortOrders, simpleConStr, stringToSortOrder, stringifySortOrder, toQueryString, typeConStr, union, utils, withCB, _fn, _get_data_fetcher, _i, _j, _len, _len1, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  Events = _dereq_('backbone-events-standalone');

  intermine = exports;

  intermine.xml = _dereq_('./xml');

  utils = _dereq_('./util');

  REQUIRES_VERSION = utils.REQUIRES_VERSION, withCB = utils.withCB, merge = utils.merge, filter = utils.filter, partition = utils.partition, fold = utils.fold, concatMap = utils.concatMap, id = utils.id, get = utils.get, invoke = utils.invoke;

  toQueryString = utils.querystring;

  get_canonical_op = function(orig) {
    var canonical;
    canonical = (orig != null ? orig.toLowerCase : void 0) != null ? Query.OP_DICT[orig.toLowerCase()] : null;
    if (!canonical) {
      throw new Error("Illegal constraint operator: " + orig);
    }
    return canonical;
  };

  BASIC_ATTRS = ['path', 'op', 'code'];

  SIMPLE_ATTRS = BASIC_ATTRS.concat(['value', 'extraValue']);

  RESULTS_METHODS = ['rowByRow', 'eachRow', 'recordByRecord', 'eachRecord', 'records', 'rows', 'table', 'tableRows', 'values'];

  LIST_PIPE = function(service) {
    return utils.compose(service.fetchList, get('listName'));
  };

  CODES = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];

  decapitate = function(x) {
    if (x == null) {
      x = '';
    }
    return x.substr(x.indexOf('.'));
  };

  conValStr = function(v) {
    if (v != null) {
      return "<value>" + (utils.escape(v)) + "</value>";
    } else {
      return "<nullValue/>";
    }
  };

  conAttrs = function(c, names) {
    var k, v;
    return ((function() {
      var _results;
      _results = [];
      for (k in c) {
        v = c[k];
        if ((__indexOf.call(names, k) >= 0)) {
          _results.push("" + k + "=\"" + (utils.escape(v)) + "\" ");
        }
      }
      return _results;
    })()).join('');
  };

  noValueConStr = function(c) {
    return "<constraint " + (conAttrs(c, BASIC_ATTRS)) + "/>";
  };

  typeConStr = function(c) {
    return "<constraint " + (conAttrs(c, ['path', 'type'])) + "/>";
  };

  simpleConStr = function(c) {
    return "<constraint " + (conAttrs(c, SIMPLE_ATTRS)) + "/>";
  };

  multiConStr = function(c) {
    return "<constraint " + (conAttrs(c, BASIC_ATTRS)) + ">" + (concatMap(conValStr)(c.values)) + "</constraint>";
  };

  idConStr = function(c) {
    return "<constraint " + (conAttrs(c, BASIC_ATTRS)) + "ids=\"" + (c.ids.join(',')) + "\"/>";
  };

  conStr = function(c) {
    var _ref;
    if (c.values != null) {
      return multiConStr(c);
    } else if (c.ids != null) {
      return idConStr(c);
    } else if (c.op == null) {
      return typeConStr(c);
    } else if (_ref = c.op, __indexOf.call(Query.NULL_OPS, _ref) >= 0) {
      return noValueConStr(c);
    } else {
      return simpleConStr(c);
    }
  };

  headLess = function(path) {
    return path.replace(/^[^\.]+\./, '');
  };

  copyCon = function(con) {
    var code, editable, extraValue, ids, op, path, switchable, switched, type, value, values;
    path = con.path, type = con.type, op = con.op, value = con.value, values = con.values, extraValue = con.extraValue, ids = con.ids, code = con.code, editable = con.editable, switched = con.switched, switchable = con.switchable;
    ids = ids != null ? ids.slice() : void 0;
    values = values != null ? values.slice() : void 0;
    return noUndefVals({
      path: path,
      type: type,
      op: op,
      value: value,
      values: values,
      extraValue: extraValue,
      ids: ids,
      code: code,
      editable: editable,
      switched: switched,
      switchable: switchable
    });
  };

  conToJSON = function(con) {
    var copy;
    copy = copyCon(con);
    copy.path = headLess(copy.path);
    return copy;
  };

  noUndefVals = function(x) {
    var k, v;
    for (k in x) {
      v = x[k];
      if (v == null) {
        delete x[k];
      }
    }
    return x;
  };

  didntRemove = function(orig, reduced) {
    return "Did not remove a single constraint. original = " + orig + ", reduced = " + reduced;
  };

  interpretConstraint = function(path, con) {
    var constraint, k, keys, v, x, _ref, _ref1;
    constraint = {
      path: path
    };
    if (con === null) {
      constraint.op = 'IS NULL';
    } else if (utils.isArray(con)) {
      constraint.op = 'ONE OF';
      constraint.values = con;
    } else if ((_ref = typeof con) === 'string' || _ref === 'number' || _ref === 'boolean') {
      if (_ref1 = typeof con.toUpperCase === "function" ? con.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref1) >= 0) {
        constraint.op = con;
      } else {
        constraint.op = '=';
        constraint.value = con;
      }
    } else {
      keys = (function() {
        var _results;
        _results = [];
        for (k in con) {
          x = con[k];
          _results.push(k);
        }
        return _results;
      })();
      if (__indexOf.call(keys, 'isa') >= 0) {
        if (utils.isArray(con.isa)) {
          constraint.op = k;
          constraint.values = con.isa;
        } else {
          constraint.type = con.isa;
        }
      } else {
        if (__indexOf.call(keys, 'extraValue') >= 0) {
          constraint.extraValue = con.extraValue;
        }
        for (k in con) {
          v = con[k];
          if (!(k !== 'extraValue')) {
            continue;
          }
          constraint.op = k;
          if (utils.isArray(v)) {
            constraint.values = v;
          } else {
            constraint.value = v;
          }
        }
      }
    }
    return constraint;
  };

  interpretConArray = function(conArgs) {
    var a0, constraint, v, _ref;
    conArgs = conArgs.slice();
    constraint = {
      path: conArgs.shift()
    };
    if (conArgs.length === 1) {
      a0 = conArgs[0];
      if (_ref = typeof a0.toUpperCase === "function" ? a0.toUpperCase() : void 0, __indexOf.call(Query.NULL_OPS, _ref) >= 0) {
        constraint.op = a0;
      } else {
        constraint.type = a0;
      }
    } else if (conArgs.length >= 2) {
      constraint.op = conArgs[0];
      v = conArgs[1];
      if (utils.isArray(v)) {
        constraint.values = v;
      } else {
        constraint.value = v;
      }
      if (conArgs.length === 3) {
        constraint.extraValue = conArgs[2];
      }
    }
    return constraint;
  };

  stringifySortOrder = function(sortOrder) {
    var oe;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = sortOrder.length; _i < _len; _i++) {
        oe = sortOrder[_i];
        _results.push("" + oe.path + " " + oe.direction);
      }
      return _results;
    })()).join(' ');
  };

  stringToSortOrder = function(str) {
    var i, parts, pathIndices, x, _i, _len, _results;
    if (str == null) {
      return [];
    }
    parts = str.split(/\s+/);
    pathIndices = (function() {
      var _i, _ref, _results;
      _results = [];
      for (x = _i = 0, _ref = parts.length / 2; 0 <= _ref ? _i < _ref : _i > _ref; x = 0 <= _ref ? ++_i : --_i) {
        _results.push(x * 2);
      }
      return _results;
    })();
    _results = [];
    for (_i = 0, _len = pathIndices.length; _i < _len; _i++) {
      i = pathIndices[_i];
      _results.push([parts[i], parts[i + 1]]);
    }
    return _results;
  };

  removeIrrelevantSortOrders = function() {
    var oe, oldOrder;
    oldOrder = this.sortOrder;
    this.sortOrder = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = oldOrder.length; _i < _len; _i++) {
        oe = oldOrder[_i];
        if (this.isRelevant(oe.path)) {
          _results.push(oe);
        }
      }
      return _results;
    }).call(this);
    if (oldOrder.length !== this.sortOrder.length) {
      return this.trigger('change:sortorder change:orderby', this.sortOrder.slice());
    }
  };

  Query = (function() {
    var addPI, cAttrs, kids, parseSummary, qAttrs, scFold, toAttrPairs, toPathAndType, xmlAttr;

    Query.JOIN_STYLES = ['INNER', 'OUTER'];

    Query.BIO_FORMATS = ['gff3', 'fasta', 'bed'];

    Query.NULL_OPS = ['IS NULL', 'IS NOT NULL'];

    Query.ATTRIBUTE_VALUE_OPS = ["=", "!=", ">", ">=", "<", "<=", "CONTAINS", "LIKE", "NOT LIKE"];

    Query.MULTIVALUE_OPS = ['ONE OF', 'NONE OF'];

    Query.RANGE_OPS = ['OVERLAPS', 'DOES NOT OVERLAP', 'OUTSIDE', 'WITHIN', 'CONTAINS', 'DOES NOT CONTAIN'];

    Query.TERNARY_OPS = ['LOOKUP'];

    Query.LOOP_OPS = ['=', '!='];

    Query.LIST_OPS = ['IN', 'NOT IN'];

    Query.OP_DICT = {
      '=': '=',
      '==': '==',
      'eq': '=',
      'eqq': '==',
      '!=': '!=',
      'ne': '!=',
      '>': '>',
      'gt': '>',
      '>=': '>=',
      'ge': '>=',
      '<': '<',
      'lt': '<',
      '<=': '<=',
      'le': '<=',
      'contains': 'CONTAINS',
      'CONTAINS': 'CONTAINS',
      'does not contain': 'DOES NOT CONTAIN',
      'DOES NOT CONTAIN': 'DOES NOT CONTAIN',
      'like': 'LIKE',
      'LIKE': 'LIKE',
      'not like': 'NOT LIKE',
      'NOT LIKE': 'NOT LIKE',
      'lookup': 'LOOKUP',
      'IS NULL': 'IS NULL',
      'is null': 'IS NULL',
      'IS NOT NULL': 'IS NOT NULL',
      'is not null': 'IS NOT NULL',
      'ONE OF': 'ONE OF',
      'one of': 'ONE OF',
      'NONE OF': 'NONE OF',
      'none of': 'NONE OF',
      'in': 'IN',
      'not in': 'NOT IN',
      'IN': 'IN',
      'NOT IN': 'NOT IN',
      'WITHIN': 'WITHIN',
      'within': 'WITHIN',
      'OVERLAPS': 'OVERLAPS',
      'overlaps': 'OVERLAPS',
      'DOES NOT OVERLAP': 'DOES NOT OVERLAP',
      'does not overlap': 'DOES NOT OVERLAP',
      'OUTSIDE': 'OUTSIDE',
      'outside': 'OUTSIDE',
      'ISA': 'ISA',
      'isa': 'ISA'
    };

    qAttrs = ['name', 'view', 'sortOrder', 'constraintLogic', 'title', 'description', 'comment'];

    cAttrs = ['path', 'type', 'op', 'code', 'value', 'ids'];

    toAttrPairs = function(el, attrs) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = attrs.length; _i < _len; _i++) {
        x = attrs[_i];
        if (el.hasAttribute(x)) {
          _results.push([x, el.getAttribute(x)]);
        }
      }
      return _results;
    };

    kids = function(el, name) {
      var kid, _i, _len, _ref, _results;
      _ref = el.getElementsByTagName(name);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        kid = _ref[_i];
        _results.push(kid);
      }
      return _results;
    };

    xmlAttr = function(name) {
      return function(el) {
        return el.getAttribute(name);
      };
    };

    Query.fromXML = function(xml) {
      var con, dom, j, pathOf, q, query, styleOf;
      dom = intermine.xml.parse(xml);
      query = kids(dom, 'query')[0] || kids(dom, 'template')[0];
      if (!query) {
        throw new Error("no query in xml");
      }
      pathOf = xmlAttr('path');
      styleOf = xmlAttr('style');
      q = utils.pairsToObj(toAttrPairs(query, qAttrs));
      q.view = q.view.split(/\s+/);
      q.sortOrder = stringToSortOrder(q.sortOrder);
      q.joins = (function() {
        var _i, _len, _ref, _results;
        _ref = kids(query, 'join');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          j = _ref[_i];
          if (styleOf(j) === 'OUTER') {
            _results.push(pathOf(j));
          }
        }
        return _results;
      })();
      q.constraints = (function() {
        var _i, _len, _ref, _results;
        _ref = kids(query, 'constraint');
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          con = _ref[_i];
          _results.push((function(con) {
            var c, tn, v, values, x;
            c = utils.pairsToObj(toAttrPairs(con, cAttrs));
            if (c.ids != null) {
              c.ids = (function() {
                var _j, _len1, _ref1, _results1;
                _ref1 = c.ids.split(',');
                _results1 = [];
                for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
                  x = _ref1[_j];
                  _results1.push(parseInt(x, 10));
                }
                return _results1;
              })();
            }
            values = kids(con, 'value');
            if (values.length) {
              c.values = (function() {
                var _j, _len1, _results1;
                _results1 = [];
                for (_j = 0, _len1 = values.length; _j < _len1; _j++) {
                  v = values[_j];
                  _results1.push(((function() {
                    var _k, _len2, _ref1, _results2;
                    _ref1 = v.childNodes;
                    _results2 = [];
                    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
                      tn = _ref1[_k];
                      _results2.push(tn.data);
                    }
                    return _results2;
                  })()).join(''));
                }
                return _results1;
              })();
            }
            return c;
          })(con));
        }
        return _results;
      })();
      return q;
    };

    Query.prototype.constraints = [];

    Query.prototype.views = [];

    Query.prototype.joins = {};

    Query.prototype.constraintLogic = '';

    Query.prototype.sortOrder = '';

    Query.prototype.name = null;

    Query.prototype.title = null;

    Query.prototype.comment = null;

    Query.prototype.description = null;

    function Query(properties, service, _arg) {
      var model, prop, summaryFields, _i, _len, _ref, _ref1, _ref10, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
      _ref = _arg != null ? _arg : {}, model = _ref.model, summaryFields = _ref.summaryFields;
      this.addConstraint = __bind(this.addConstraint, this);
      this.expandStar = __bind(this.expandStar, this);
      this.adjustPath = __bind(this.adjustPath, this);
      this.select = __bind(this.select, this);
      if (properties == null) {
        properties = {};
      }
      this.constraints = [];
      this.views = [];
      this.joins = {};
      this.displayNames = utils.copy((_ref1 = (_ref2 = properties.displayNames) != null ? _ref2 : properties.aliases) != null ? _ref1 : {});
      _ref3 = ['name', 'title', 'comment', 'description', 'type'];
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        prop = _ref3[_i];
        if (properties[prop] != null) {
          this[prop] = properties[prop];
        }
      }
      this.service = service != null ? service : {};
      this.model = (_ref4 = model != null ? model : properties.model) != null ? _ref4 : {};
      this.summaryFields = (_ref5 = summaryFields != null ? summaryFields : properties.summaryFields) != null ? _ref5 : {};
      this.root = (_ref6 = properties.root) != null ? _ref6 : properties.from;
      this.maxRows = (_ref7 = (_ref8 = properties.size) != null ? _ref8 : properties.limit) != null ? _ref7 : properties.maxRows;
      this.start = (_ref9 = (_ref10 = properties.start) != null ? _ref10 : properties.offset) != null ? _ref9 : 0;
      this.select(properties.views || properties.view || properties.select || []);
      this.addConstraints(properties.constraints || properties.where || []);
      this.addJoins(properties.joins || properties.join || []);
      this.orderBy(properties.sortOrder || properties.orderBy || []);
      if (properties.constraintLogic != null) {
        this.constraintLogic = properties.constraintLogic;
      }
      this.on('change:views', removeIrrelevantSortOrders, this);
    }

    Query.prototype.removeFromSelect = function(unwanted) {
      var mapFn, so, uw, v;
      if (unwanted == null) {
        unwanted = [];
      }
      unwanted = utils.stringList(unwanted);
      mapFn = utils.compose(this.expandStar, this.adjustPath);
      unwanted = utils.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = unwanted.length; _i < _len; _i++) {
          uw = unwanted[_i];
          _results.push(mapFn(uw));
        }
        return _results;
      })());
      this.sortOrder = (function() {
        var _i, _len, _ref, _ref1, _results;
        _ref = this.sortOrder;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          so = _ref[_i];
          if (!(_ref1 = so.path, __indexOf.call(unwanted, _ref1) >= 0)) {
            _results.push(so);
          }
        }
        return _results;
      }).call(this);
      this.views = (function() {
        var _i, _len, _ref, _results;
        _ref = this.views;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          v = _ref[_i];
          if (!(__indexOf.call(unwanted, v) >= 0)) {
            _results.push(v);
          }
        }
        return _results;
      }).call(this);
      this.trigger('remove:view', unwanted);
      this.trigger('change:views', this.views);
      return this.trigger('change', this.views);
    };

    Query.prototype.removeConstraint = function(con, silent) {
      var c, iscon, orig, reduced;
      if (silent == null) {
        silent = false;
      }
      orig = this.constraints;
      iscon = typeof con === 'string' ? (function(c) {
        return c.code === con;
      }) : (function(c) {
        var _ref, _ref1;
        return (c.path === con.path) && (c.op === con.op) && (c.value === con.value) && (c.extraValue === con.extraValue) && (con.type === c.type) && (((_ref = c.values) != null ? _ref.join('%%') : void 0) === ((_ref1 = con.values) != null ? _ref1.join('%%') : void 0));
      });
      reduced = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = orig.length; _i < _len; _i++) {
          c = orig[_i];
          if (!iscon(c)) {
            _results.push(c);
          }
        }
        return _results;
      })();
      if (reduced.length !== orig.length - 1) {
        throw new Error(didntRemove(orig, reduced));
      }
      this.constraints = reduced;
      if (!silent) {
        this.trigger('change:constraints');
        this.trigger('change');
        return this.trigger('removed:constraint', utils.find(orig, iscon));
      }
    };

    Query.prototype.addToSelect = function(views, opts) {
      var dups, mapFn, p, toAdd, v, x, _ref, _ref1;
      if (views == null) {
        views = [];
      }
      if (opts == null) {
        opts = {};
      }
      views = utils.stringList(views);
      mapFn = utils.compose(this.expandStar, this.adjustPath);
      toAdd = utils.flatten((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = views.length; _i < _len; _i++) {
          v = views[_i];
          _results.push(mapFn(v));
        }
        return _results;
      })());
      dups = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = toAdd.length; _i < _len; _i++) {
          p = toAdd[_i];
          if (__indexOf.call(this.views, p) >= 0) {
            _results.push(p);
          }
        }
        return _results;
      }).call(this);
      if (dups.length) {
        throw new Error("" + dups + " already in the select list");
      }
      dups = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = toAdd.length; _i < _len; _i++) {
          p = toAdd[_i];
          if (((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = toAdd.length; _j < _len1; _j++) {
              x = toAdd[_j];
              if (x === p) {
                _results1.push(x);
              }
            }
            return _results1;
          })()).length > 1) {
            _results.push(p);
          }
        }
        return _results;
      })();
      if (dups.length) {
        throw new Error("" + dups + " specified multiple times as arguments to addToSelect");
      }
      (_ref = this.views).push.apply(_ref, toAdd);
      if (opts.silent) {
        opts.events = ((_ref1 = opts.events) != null ? _ref1 : []).concat(['change', 'add:view', 'change:views']);
      } else {
        this.trigger('add:view change:views', toAdd);
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.select = function(views, opts) {
      var e, oldViews;
      oldViews = this.views.slice();
      try {
        this.views = [];
        this.addToSelect(views, opts);
      } catch (_error) {
        e = _error;
        this.views = oldViews;
        utils.error(e);
      }
      return this;
    };

    Query.prototype.adjustPath = function(path) {
      path = path && path.name ? path.name : "" + path;
      if (this.root != null) {
        if (!path.match("^" + this.root)) {
          path = this.root + "." + path;
        }
      } else {
        this.root = path.split('.')[0];
      }
      return path;
    };

    Query.prototype.getPossiblePaths = function(depth, allowReverseReferences, predicate) {
      var getPaths, key, ret, test, _base;
      if (depth == null) {
        depth = 3;
      }
      if (allowReverseReferences == null) {
        allowReverseReferences = true;
      }
      if (predicate == null) {
        predicate = null;
      }
      test = typeof predicate === 'string' ? function(p) {
        return p[predicate]();
      } : predicate;
      getPaths = (function(_this) {
        return function(root, d) {
          var cd, field, name, others, path, subPaths;
          path = _this.getPathInfo(root);
          if ((!allowReverseReferences) && path.isReverseReference()) {
            return [];
          } else if (path.isAttribute()) {
            return [path];
          } else {
            cd = path.getType();
            subPaths = concatMap(function(ref) {
              return getPaths("" + root + "." + ref.name, d - 1);
            });
            others = cd && (d > 0) ? subPaths((function() {
              var _ref, _results;
              _ref = cd.fields;
              _results = [];
              for (name in _ref) {
                field = _ref[name];
                _results.push(field);
              }
              return _results;
            })()) : [];
            return [path].concat(others);
          }
        };
      })(this);
      key = "" + depth + "-" + allowReverseReferences;
      if (this._possiblePaths == null) {
        this._possiblePaths = {};
      }
      ret = ((_base = this._possiblePaths)[key] != null ? _base[key] : _base[key] = getPaths(this.root, depth)).slice();
      if (test != null) {
        return ret.filter(test);
      } else {
        return ret;
      }
    };

    Query.prototype.getPathInfo = function(path) {
      var adjusted, pi, _ref;
      adjusted = this.adjustPath(path);
      pi = (_ref = this.model) != null ? typeof _ref.getPathInfo === "function" ? _ref.getPathInfo(adjusted, this.getSubclasses()) : void 0 : void 0;
      if (pi && adjusted in this.displayNames) {
        pi.displayName = this.displayNames[adjusted];
      }
      return pi;
    };

    Query.prototype.makePath = Query.prototype.getPathInfo;

    toPathAndType = function(c) {
      return [c.path, c.type];
    };

    scFold = utils.compose(utils.pairsToObj, utils.map(toPathAndType), filter(get('type')));

    Query.prototype.getSubclasses = function() {
      return scFold(this.constraints);
    };

    Query.prototype.getType = function(path) {
      return this.getPathInfo(path).getType();
    };

    Query.prototype.getViewNodes = function() {
      var p, toParentNode;
      toParentNode = (function(_this) {
        return function(v) {
          return _this.getPathInfo(v).getParent();
        };
      })(this);
      return utils.uniqBy(String, (function() {
        var _i, _len, _ref, _results;
        _ref = this.views;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(toParentNode(p));
        }
        return _results;
      }).call(this));
    };

    Query.prototype.isInView = function(path) {
      var pi, pstr, _ref;
      pi = this.getPathInfo(path);
      if (!pi) {
        throw new Error("Invalid path: " + path);
      }
      if (pi.isAttribute()) {
        return _ref = pi.toString(), __indexOf.call(this.views, _ref) >= 0;
      } else {
        pstr = pi.toString();
        return utils.any(this.getViewNodes(), function(n) {
          return n.toString() === pstr;
        });
      }
    };

    Query.prototype.isConstrained = function(path, includeAttrs) {
      var pi, test;
      if (includeAttrs == null) {
        includeAttrs = false;
      }
      pi = this.getPathInfo(path);
      if (!pi) {
        throw new Error("Invalid path: " + path);
      }
      test = function(c) {
        return (c.op != null) && c.path === pi.toString();
      };
      if ((!pi.isAttribute()) && includeAttrs) {
        test = (function(_this) {
          return function(c) {
            return (c.op != null) && (c.path === pi.toString() || pi.equals(_this.getPathInfo(c.path).getParent()));
          };
        })(this);
      }
      return utils.any(this.constraints, test);
    };

    Query.prototype.canHaveMultipleValues = function(path) {
      return this.getPathInfo(path).containsCollection();
    };

    Query.prototype.getQueryNodes = function() {
      var c, constrainedNodes, pi, viewNodes;
      viewNodes = this.getViewNodes();
      constrainedNodes = (function() {
        var _i, _len, _ref, _results;
        _ref = this.constraints;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if (!(c.type == null)) {
            continue;
          }
          pi = this.getPathInfo(c.path);
          if (pi.isAttribute()) {
            _results.push(pi.getParent());
          } else {
            _results.push(pi);
          }
        }
        return _results;
      }).call(this);
      return utils.uniqBy(String, viewNodes.concat(constrainedNodes));
    };

    Query.prototype.isInQuery = function(p) {
      var c, pi, pstr, _i, _len, _ref;
      pi = this.getPathInfo(p);
      if (pi) {
        pstr = pi.toPathString();
        _ref = this.views.concat((function() {
          var _j, _len, _ref, _results;
          _ref = this.constraints;
          _results = [];
          for (_j = 0, _len = _ref.length; _j < _len; _j++) {
            c = _ref[_j];
            if (c.type == null) {
              _results.push(c.path);
            }
          }
          return _results;
        }).call(this));
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          if (0 === p.indexOf(pstr)) {
            return true;
          }
        }
        return false;
      }
      return true;
    };

    Query.prototype.isRelevant = function(path) {
      var nodes, pi, sought;
      pi = this.getPathInfo(path);
      if (pi.isAttribute()) {
        pi = pi.getParent();
      }
      sought = pi.toString();
      nodes = this.getViewNodes();
      return utils.any(nodes, function(n) {
        return n.toPathString() === sought;
      });
    };

    Query.prototype.expandStar = function(path) {
      var attrViews, cd, expand, fn, n, name, pathStem, starViews;
      if (/\*$/.test(path)) {
        pathStem = path.substr(0, path.lastIndexOf('.'));
        expand = function(x) {
          return pathStem + x;
        };
        cd = this.getType(pathStem);
        if (/\.\*$/.test(path)) {
          if (cd && this.summaryFields[cd.name]) {
            fn = utils.compose(expand, decapitate);
            return (function() {
              var _i, _len, _ref, _results;
              _ref = this.summaryFields[cd.name];
              _results = [];
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                n = _ref[_i];
                if (!this.hasView(n)) {
                  _results.push(fn(n));
                }
              }
              return _results;
            }).call(this);
          }
        } else if (/\.\*\*$/.test(path)) {
          starViews = this.expandStar(pathStem + '.*');
          attrViews = (function() {
            var _results;
            _results = [];
            for (name in cd.attributes) {
              _results.push(expand("." + name));
            }
            return _results;
          })();
          return utils.uniqBy(id, starViews.concat(attrViews));
        }
      }
      return path;
    };

    Query.prototype.isOuterJoin = function(p) {
      return this.joins[this.adjustPath(p)] === 'OUTER';
    };

    Query.prototype.hasView = function(v) {
      var _ref;
      return this.views && (_ref = this.adjustPath(v), __indexOf.call(this.views, _ref) >= 0);
    };

    Query.prototype.count = function(cont) {
      if (this.service.count) {
        return this.service.count(this, cont);
      } else {
        throw new Error("This query has no service with count functionality attached.");
      }
    };

    Query.prototype.appendToList = function(target, cb) {
      var name, processor, req, toRun, updateTarget;
      if (target != null ? target.name : void 0) {
        name = target.name;
        updateTarget = function(err, list) {
          if (err == null) {
            return target.size = list.size;
          }
        };
      } else {
        name = String(target);
        updateTarget = null;
      }
      toRun = this.makeListQuery();
      req = {
        listName: name,
        query: toRun.toXML()
      };
      processor = LIST_PIPE(this.service);
      return withCB(updateTarget, cb, this.service.post('query/append/tolist', req).then(processor));
    };

    Query.prototype.selectPreservingImpliedConstraints = function(paths) {
      var n, toRun, _i, _len, _ref;
      if (paths == null) {
        paths = [];
      }
      toRun = this.clone();
      toRun.select(paths);
      _ref = this.getViewNodes();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (!this.isOuterJoined(n)) {
          if (!(toRun.isInView(n || toRun.isConstrained(n))) && (n.getEndClass().fields.id != null)) {
            toRun.addConstraint([n.append('id'), 'IS NOT NULL']);
          }
        }
      }
      return toRun;
    };

    Query.prototype.makeListQuery = function() {
      var paths, _ref;
      paths = this.views.slice();
      if (paths.length !== 1 || !((_ref = paths[0]) != null ? _ref.match(/\.id$/) : void 0)) {
        paths = ['id'];
      }
      return this.selectPreservingImpliedConstraints(paths);
    };

    Query.prototype.saveAsList = function(options, cb) {
      var req, toRun;
      toRun = this.makeListQuery();
      req = utils.copy(options);
      req.listName = req.listName || req.name;
      req.query = toRun.toXML();
      if (options.tags) {
        req.tags = options.tags.join(';');
      }
      return withCB(cb, this.service.post('query/tolist', req).then(LIST_PIPE(this.service)));
    };

    Query.prototype.summarise = function(path, limit, cont) {
      return this.filterSummary(path, '', limit, cont);
    };

    Query.prototype.summarize = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.summarise.apply(this, args);
    };

    parseSummary = function(data) {
      var isNumeric, r, stats, _i, _len, _ref, _ref1;
      isNumeric = ((_ref = data.results[0]) != null ? _ref.max : void 0) != null;
      _ref1 = data.results;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        r = _ref1[_i];
        r.count = parseInt(r.count, 10);
      }
      stats = {
        uniqueValues: data.uniqueValues,
        filteredCount: data.filteredCount
      };
      if (isNumeric) {
        stats = merge(stats, data.results[0]);
      }
      data.stats = stats;
      return data;
    };

    Query.prototype.filterSummary = function(path, term, limit, cont) {
      var req, toRun, _ref;
      if (cont == null) {
        cont = (function() {});
      }
      if (utils.isFunction(limit)) {
        _ref = [limit, null], cont = _ref[0], limit = _ref[1];
      }
      path = this.adjustPath(path);
      toRun = this.clone();
      if (__indexOf.call(toRun.views, path) < 0) {
        toRun.views.push(path);
      }
      req = {
        query: toRun.toXML(),
        summaryPath: path,
        format: 'jsonrows'
      };
      if (limit) {
        req.size = limit;
      }
      if (term) {
        req.filterTerm = term;
      }
      return withCB(cont, this.service.post('query/results', req).then(parseSummary));
    };

    Query.prototype.clone = function(cloneEvents) {
      var cloned, k, v, _ref;
      cloned = new Query(this, this.service);
      if (cloned._callbacks == null) {
        cloned._callbacks = {};
      }
      if (cloneEvents) {
        _ref = this._callbacks;
        for (k in _ref) {
          if (!__hasProp.call(_ref, k)) continue;
          v = _ref[k];
          cloned._callbacks[k] = v;
        }
        cloned.off('change:views', removeIrrelevantSortOrders, this);
      }
      return cloned;
    };

    Query.prototype.next = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start + this.maxRows;
      }
      return clone;
    };

    Query.prototype.previous = function() {
      var clone;
      clone = this.clone();
      if (this.maxRows) {
        clone.start = this.start - this.maxRows;
      } else {
        clone.start = 0;
      }
      return clone;
    };

    Query.prototype.getSortDirection = function(sorted) {
      var a, so;
      a = this.adjustPath(sorted);
      if (!(this.isInQuery(a) || this.isRelevant(a))) {
        throw new Error("" + sorted + " is not in the query");
      }
      so = utils.find(this.sortOrder, function(_arg) {
        var path;
        path = _arg.path;
        return a === path;
      });
      return so != null ? so.direction : void 0;
    };

    Query.prototype.isOuterJoined = function(path) {
      var dir, jp, _ref;
      path = this.adjustPath(path);
      _ref = this.joins;
      for (jp in _ref) {
        dir = _ref[jp];
        if (dir === 'OUTER' && path.indexOf(jp) === 0) {
          return true;
        }
      }
      return false;
    };

    Query.prototype.getOuterJoin = function(path) {
      var joinPaths, k;
      path = this.adjustPath(path);
      joinPaths = ((function() {
        var _results;
        _results = [];
        for (k in this.joins) {
          _results.push(k);
        }
        return _results;
      }).call(this)).sort(function(a, b) {
        return b.length - a.length;
      });
      return utils.find(joinPaths, (function(_this) {
        return function(p) {
          return _this.joins[p] === 'OUTER' && path.indexOf(p) === 0;
        };
      })(this));
    };

    Query.prototype._parse_sort_order = function(input) {
      var direction, k, path, so, v, _ref;
      if (input == null) {
        throw new Error('No input');
      }
      if (typeof input === 'string') {
        so = {
          path: input,
          direction: 'ASC'
        };
      } else if (utils.isArray(input)) {
        path = input[0], direction = input[1];
        so = {
          path: path,
          direction: direction
        };
      } else if (input.path == null) {
        for (k in input) {
          v = input[k];
          _ref = [k, v], path = _ref[0], direction = _ref[1];
        }
        so = {
          path: path,
          direction: direction
        };
      } else {
        path = input.path, direction = input.direction;
        so = {
          path: path,
          direction: direction
        };
      }
      so.path = this.adjustPath(so.path);
      if (so.direction == null) {
        so.direction = 'ASC';
      }
      so.direction = so.direction.toUpperCase();
      return so;
    };

    Query.prototype.addOrSetSortOrder = function(so) {
      var currentDirection, oe;
      so = this._parse_sort_order(so);
      currentDirection = this.getSortDirection(so.path);
      if (currentDirection == null) {
        this.addSortOrder(so);
      } else if (currentDirection !== so.direction) {
        oe = utils.find(this.sortOrder, function(_arg) {
          var path;
          path = _arg.path;
          return path === so.path;
        });
        oe.direction = so.direction;
        this.trigger('change:sortorder', this.sortOrder);
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.addSortOrder = function(so, _arg) {
      var silent;
      silent = (_arg != null ? _arg : {}).silent;
      this.sortOrder.push(this._parse_sort_order(so));
      if (!silent) {
        this.trigger('add:sortorder', so);
        this.trigger('change:sortorder', this.sortOrder);
        return this.trigger('change');
      }
    };

    Query.prototype.orderBy = function(oes, opts) {
      var copy, direction, oe, oldSO, path, _i, _len, _ref;
      if (opts == null) {
        opts = {};
      }
      oldSO = this.sortOrder.slice();
      this.sortOrder = [];
      for (_i = 0, _len = oes.length; _i < _len; _i++) {
        oe = oes[_i];
        this.addSortOrder(this._parse_sort_order(oe), {
          silent: true
        });
      }
      copy = (function() {
        var _j, _len1, _ref, _ref1, _results;
        _ref = this.sortOrder;
        _results = [];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          _ref1 = _ref[_j], path = _ref1.path, direction = _ref1.direction;
          _results.push({
            path: path,
            direction: direction
          });
        }
        return _results;
      }).call(this);
      this.trigger('set:sortorder', copy);
      if ((stringifySortOrder(oldSO)) !== this.getSorting()) {
        if (opts.silent) {
          opts.events = ((_ref = opts.events) != null ? _ref : []).concat(['change', 'change:sortorder']);
        } else {
          this.trigger('change:sortorder', copy);
          this.trigger('change');
        }
      }
      return this;
    };

    Query.prototype.addJoins = function(joins) {
      var j, k, v, _i, _len, _results, _results1;
      if (utils.isArray(joins)) {
        _results = [];
        for (_i = 0, _len = joins.length; _i < _len; _i++) {
          j = joins[_i];
          _results.push(this.addJoin(j));
        }
        return _results;
      } else {
        _results1 = [];
        for (k in joins) {
          v = joins[k];
          _results1.push(this.addJoin({
            path: k,
            style: v
          }));
        }
        return _results1;
      }
    };

    Query.prototype.addJoin = function(join) {
      if (typeof join === 'string') {
        join = {
          path: join,
          style: 'OUTER'
        };
      }
      return this.setJoinStyle(join.path, join.style);
    };

    Query.prototype.setJoinStyle = function(path, style) {
      if (style == null) {
        style = 'OUTER';
      }
      path = this.adjustPath(path);
      style = style.toUpperCase();
      if (__indexOf.call(Query.JOIN_STYLES, style) < 0) {
        throw new Error("Invalid join style: " + style);
      }
      if (this.joins[path] !== style) {
        this.joins[path] = style;
        this.trigger('change:joins', {
          path: path,
          style: style
        });
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.addConstraints = function(constraints, conj) {
      var c, con, oldLogic, path, _fn, _i, _len;
      if (conj == null) {
        conj = 'and';
      }
      this.__silent__ = true;
      oldLogic = this.constraintLogic;
      if (utils.isArray(constraints)) {
        for (_i = 0, _len = constraints.length; _i < _len; _i++) {
          c = constraints[_i];
          this.addConstraint(c, conj);
        }
      } else {
        _fn = (function(_this) {
          return function(path, con) {
            return _this.addConstraint(interpretConstraint(path, con), conj);
          };
        })(this);
        for (path in constraints) {
          con = constraints[path];
          _fn(path, con);
        }
      }
      this.__silent__ = false;
      this.trigger('add:constraint');
      this.trigger('change:constraints');
      if (oldLogic !== this.constraintLogic) {
        this.trigger('change:logic', this.constraintLogic);
      }
      return this.trigger('change');
    };

    Query.prototype.addConstraint = function(constraint, conj) {
      var i, logic, needsLogicClause, newConLen, newLogic, oldLogic, _ref;
      if (conj == null) {
        conj = 'and';
      }
      if (conj !== 'and' && conj !== 'or') {
        throw new Error('Unknown logical conjunction: ' + conj);
      }
      if (utils.isArray(constraint)) {
        constraint = interpretConArray(constraint);
      } else {
        constraint = copyCon(constraint);
      }
      if (constraint.switched === 'OFF') {
        return this;
      }
      constraint.path = this.adjustPath(constraint.path);
      if (constraint.type == null) {
        constraint.op = get_canonical_op(constraint.op);
      }
      this.constraints.push(constraint);
      needsLogicClause = (conj === 'or') || (((_ref = this.constraintLogic) != null ? _ref.length : void 0) > 0);
      newConLen = this.constraints.length;
      oldLogic = this.constraintLogic;
      if (needsLogicClause) {
        newLogic = newConLen === 2 ? "" + CODES[0] + " " + conj + " " + CODES[1] : (logic = this.constraintLogic, logic || (logic = ((function() {
          var _i, _ref1, _results;
          _results = [];
          for (i = _i = 0, _ref1 = newConLen - 2; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
            _results.push(CODES[i]);
          }
          return _results;
        })()).join(' and ')), "(" + logic + ") " + conj + " " + CODES[newConLen - 1]);
        this.constraintLogic = newLogic;
      }
      if (!this.__silent__) {
        this.trigger('add:constraint', constraint);
        this.trigger('change:constraints');
        if (oldLogic !== this.constraintLogic) {
          this.trigger('change:logic', this.constraintLogic);
        }
        this.trigger('change');
      }
      return this;
    };

    Query.prototype.getSorting = function() {
      return stringifySortOrder(this.sortOrder);
    };

    Query.prototype.getConstraintXML = function() {
      var c, toSerialise;
      toSerialise = (function() {
        var _i, _len, _ref, _results;
        _ref = this.constraints;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          c = _ref[_i];
          if ((c.type == null) || this.isInQuery(c.path)) {
            _results.push(c);
          }
        }
        return _results;
      }).call(this);
      if (toSerialise.length) {
        return concatMap(conStr)(concatMap(id)(partition(function(c) {
          return c.type != null;
        })(toSerialise)));
      } else {
        return '';
      }
    };

    Query.prototype.getJoinXML = function() {
      var p, s, strs;
      strs = (function() {
        var _ref, _results;
        _ref = this.joins;
        _results = [];
        for (p in _ref) {
          s = _ref[p];
          if (this.isInQuery(p) && s === 'OUTER') {
            _results.push("<join path=\"" + p + "\" style=\"OUTER\"/>");
          }
        }
        return _results;
      }).call(this);
      return strs.join('');
    };

    Query.prototype.toXML = function() {
      var attrs, headAttrs, k, v;
      attrs = {
        model: this.model.name,
        view: this.views.join(' '),
        sortOrder: this.getSorting(),
        constraintLogic: this.constraintLogic
      };
      if (this.name != null) {
        attrs.name = this.name;
      }
      headAttrs = ((function() {
        var _results;
        _results = [];
        for (k in attrs) {
          v = attrs[k];
          if (v) {
            _results.push(k + '="' + v + '"');
          }
        }
        return _results;
      })()).join(' ');
      return "<query " + headAttrs + " >" + (this.getJoinXML()) + (this.getConstraintXML()) + "</query>";
    };

    Query.prototype.toJSON = function() {
      var c, direction, path, style, v;
      return noUndefVals({
        name: this.name,
        title: this.title,
        comment: this.comment,
        description: this.description,
        constraintLogic: this.constraintLogic,
        from: this.root,
        select: (function() {
          var _i, _len, _ref, _results;
          _ref = this.views;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            _results.push(headLess(v));
          }
          return _results;
        }).call(this),
        orderBy: (function() {
          var _i, _len, _ref, _ref1, _results;
          _ref = this.sortOrder;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], path = _ref1.path, direction = _ref1.direction;
            _results.push({
              path: headLess(path),
              direction: direction
            });
          }
          return _results;
        }).call(this),
        joins: (function() {
          var _ref, _results;
          _ref = this.joins;
          _results = [];
          for (path in _ref) {
            style = _ref[path];
            if (style === 'OUTER') {
              _results.push(headLess(path));
            }
          }
          return _results;
        }).call(this),
        where: (function() {
          var _i, _len, _ref, _results;
          _ref = this.constraints;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(conToJSON(c));
          }
          return _results;
        }).call(this)
      });
    };

    Query.prototype.fetchCode = function(lang, cb) {
      var req;
      req = {
        query: this.toXML(),
        lang: lang
      };
      return withCB(cb, this.service.post('query/code', req).then(this.service.VERIFIER).then(get('code')));
    };

    Query.prototype.setName = function(name) {
      this.name = name;
    };

    Query.prototype.save = function(name, cb) {
      return REQUIRES_VERSION(this.service, 16, (function(_this) {
        return function() {
          var req, _ref;
          if (utils.isFunction(name)) {
            _ref = [null, name], name = _ref[0], cb = _ref[1];
          }
          if (name != null) {
            _this.setName(name);
          }
          req = {
            type: 'PUT',
            path: 'user/queries',
            data: _this.toXML(),
            contentType: 'application/xml',
            dataType: 'json'
          };
          return withCB(cb, _this.service.authorise(req)).then(function(authed) {
            return _this.service.doReq(authed);
          }).then(function(resp) {
            return resp.queries;
          });
        };
      })(this));
    };

    Query.prototype.store = function(name, cb) {
      return REQUIRES_VERSION(this.service, 16, (function(_this) {
        return function() {
          var getName, req, updateName, _ref;
          if (utils.isFunction(name)) {
            _ref = [null, name], name = _ref[0], cb = _ref[1];
          }
          if (name != null) {
            _this.setName(name);
          }
          updateName = function(err, name) {
            if (err == null) {
              return _this.setName(name);
            }
          };
          getName = utils.compose(get(_this.name), get('queries'));
          req = {
            type: 'POST',
            path: 'user/queries',
            data: _this.toXML(),
            contentType: 'application/xml',
            dataType: 'json'
          };
          return withCB(cb, updateName, _this.service.authorise(req)).then(function(authed) {
            return _this.service.doReq(authed);
          }).then(getName);
        };
      })(this));
    };

    Query.prototype.saveAsTemplate = function(name, cb) {
      return REQUIRES_VERSION(this.service, 16, (function(_this) {
        return function() {
          var req, _ref;
          if (utils.isFunction(name)) {
            _ref = [null, name], name = _ref[0], cb = _ref[1];
          }
          if (name != null) {
            _this.setName(name);
          }
          if (!_this.name) {
            throw new Error("Templates must have a name");
          }
          req = {
            type: 'POST',
            path: 'templates',
            data: "<template " + (conAttrs(_this, ['name', 'title', 'comment'])) + ">" + (_this.toXML()) + "</template>",
            contentType: 'application/xml',
            dataType: 'json'
          };
          return withCB(cb, _this.service.authorise(req).then(function(authed) {
            return _this.service.doReq(authed);
          }));
        };
      })(this));
    };

    Query.prototype.getCodeURI = function(lang) {
      var req, _ref;
      req = {
        query: this.toXML(),
        lang: lang,
        format: 'text'
      };
      if (((_ref = this.service) != null ? _ref.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/code?" + (toQueryString(req));
    };

    Query.prototype.getExportURI = function(format, options) {
      var req, _ref;
      if (format == null) {
        format = 'tab';
      }
      if (options == null) {
        options = {};
      }
      if (__indexOf.call(Query.BIO_FORMATS, format) >= 0) {
        return this["get" + (format.toUpperCase()) + "URI"](options);
      }
      req = merge(options, {
        query: this.toXML(),
        format: format
      });
      if (((_ref = this.service) != null ? _ref.token : void 0) != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results?" + (toQueryString(req));
    };

    Query.prototype.needsAuthentication = function() {
      return utils.any(this.constraints, function(c) {
        var _ref;
        return (_ref = c.op) === 'NOT IN' || _ref === 'IN';
      });
    };

    Query.prototype.fetchQID = function(cb) {
      return withCB(cb, this.service.post('queries', {
        query: this.toXML()
      }).then(get('id')));
    };

    addPI = function(p) {
      return p.append('primaryIdentifier').toString();
    };

    Query.prototype.__bio_req = function(types, n) {
      var isSuitable, toRun;
      toRun = this.makeListQuery();
      isSuitable = function(p) {
        return utils.any(types, function(t) {
          return p.isa(t);
        });
      };
      toRun.views = utils.take(n)((function() {
        var _i, _len, _ref, _results;
        _ref = this.getViewNodes();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          if (isSuitable(n)) {
            _results.push(addPI(n));
          }
        }
        return _results;
      }).call(this));
      return {
        query: toRun.toXML(),
        format: 'text'
      };
    };

    Query.prototype._fasta_req = function() {
      return this.__bio_req(["SequenceFeature", 'Protein'], 1);
    };

    Query.prototype._gff3_req = function() {
      return this.__bio_req(['SequenceFeature']);
    };

    Query.prototype._bed_req = Query.prototype._gff3_req;

    return Query;

  })();

  union = fold(function(xs, ys) {
    return xs.concat(ys);
  });

  Query.prototype.toString = Query.prototype.toXML;

  Query.ATTRIBUTE_OPS = union([Query.ATTRIBUTE_VALUE_OPS, Query.MULTIVALUE_OPS, Query.NULL_OPS]);

  Query.REFERENCE_OPS = union([Query.TERNARY_OPS, Query.LOOP_OPS, Query.LIST_OPS]);

  bioUriArgs = function(reqMeth, f) {
    return function(opts, cb) {
      var ensureAttr, obj, req, v, _ref;
      if (opts == null) {
        opts = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      if (utils.isFunction(opts)) {
        _ref = [{}, opts], opts = _ref[0], cb = _ref[1];
      }
      ensureAttr = (function(_this) {
        return function(p) {
          var path;
          path = _this.getPathInfo(p);
          if (path.isAttribute()) {
            return path;
          } else {
            return path.append('id');
          }
        };
      })(this);
      if ((opts != null ? opts.view : void 0) != null) {
        opts.view = (function() {
          var _i, _len, _ref1, _results;
          _ref1 = opts.view;
          _results = [];
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            v = _ref1[_i];
            _results.push(this.getPathInfo(v).toString());
          }
          return _results;
        }).call(this);
      }
      obj = opts["export"] != null ? this.selectPreservingImpliedConstraints(opts["export"].map(ensureAttr)) : this;
      req = merge(obj[reqMeth](), opts);
      return f.call(obj, req, cb);
    };
  };

  _ref = Query.BIO_FORMATS;
  _fn = function(f) {
    var getMeth, reqMeth, uriMeth;
    reqMeth = "_" + f + "_req";
    getMeth = "get" + (f.toUpperCase());
    uriMeth = getMeth + "URI";
    Query.prototype[getMeth] = bioUriArgs(reqMeth, function(req, cb) {
      return withCB(cb, this.service.post('query/results/' + f, req));
    });
    return Query.prototype[uriMeth] = bioUriArgs(reqMeth, function(req, cb) {
      if (this.service.token != null) {
        req.token = this.service.token;
      }
      return "" + this.service.root + "query/results/" + f + "?" + (toQueryString(req));
    });
  };
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    f = _ref[_i];
    _fn(f);
  }

  _get_data_fetcher = function(server_fn) {
    return function() {
      var cbs, page, x, _ref1;
      page = arguments[0], cbs = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (this.service[server_fn]) {
        if (page == null) {
          page = {};
        } else if (utils.isFunction(page)) {
          page = {};
          cbs = (function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = arguments.length; _j < _len1; _j++) {
              x = arguments[_j];
              _results.push(x);
            }
            return _results;
          }).apply(this, arguments);
        }
        page = noUndefVals(merge({
          start: this.start,
          size: this.maxRows
        }, page));
        return (_ref1 = this.service)[server_fn].apply(_ref1, [this, page].concat(__slice.call(cbs)));
      } else {
        throw new Error("Service does not provide '" + server_fn + "'.");
      }
    };
  };

  for (_j = 0, _len1 = RESULTS_METHODS.length; _j < _len1; _j++) {
    mth = RESULTS_METHODS[_j];
    Query.prototype[mth] = _get_data_fetcher(mth);
  }

  Events.mixin(Query.prototype);

  Query.prototype.emit = Query.prototype.trigger;

  Query.prototype.bind = Query.prototype.on;

  intermine.Query = Query;

}).call(this);

},{"./util":15,"./xml":17,"backbone-events-standalone":21}],10:[function(_dereq_,module,exports){
(function() {
  var ALWAYS_AUTH, CLASSKEYS, CLASSKEY_PATH, DEFAULT_ERROR_HANDLER, DEFAULT_PROTOCOL, ENRICHMENT_PATH, HAS_PROTOCOL, HAS_SUFFIX, IDResolutionJob, ID_RESOLUTION_PATH, LISTS_PATH, LIST_OPERATION_PATHS, LIST_PIPE, List, MODELS, MODEL_PATH, Model, NEEDS_AUTH, NO_AUTH, PATH_VALUES_PATH, PREF_PATH, Promise, QUERY_RESULTS_PATH, QUICKSEARCH_PATH, Query, RELEASES, RELEASE_PATH, REQUIRES_VERSION, SUBTRACT_PATH, SUFFIX, SUMMARYFIELDS_PATH, SUMMARY_FIELDS, Service, TABLE_ROW_PATH, TEMPLATES_PATH, TO_NAMES, USER_TOKENS, User, VERSIONS, VERSION_PATH, WHOAMI_PATH, WIDGETS, WIDGETS_PATH, WITH_OBJ_PATH, dejoin, error, get, getListFinder, http, invoke, map, merge, p, set, success, to_query_string, utils, version, withCB, _get_or_fetch, _i, _j, _len, _len1, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __slice = [].slice;

  Promise = _dereq_('./promise');

  Model = _dereq_('./model').Model;

  Query = _dereq_('./query').Query;

  List = _dereq_('./lists').List;

  User = _dereq_('./user').User;

  IDResolutionJob = _dereq_('./id-resolution-job').IDResolutionJob;

  version = _dereq_('./version');

  utils = _dereq_('./util');

  http = _dereq_('./http');

  to_query_string = utils.querystring;

  withCB = utils.withCB, map = utils.map, merge = utils.merge, get = utils.get, set = utils.set, invoke = utils.invoke, success = utils.success, error = utils.error, REQUIRES_VERSION = utils.REQUIRES_VERSION, dejoin = utils.dejoin;

  VERSIONS = {};

  CLASSKEYS = {};

  RELEASES = {};

  MODELS = {};

  SUMMARY_FIELDS = {};

  WIDGETS = {};

  DEFAULT_PROTOCOL = "http://";

  VERSION_PATH = "version";

  TEMPLATES_PATH = "templates";

  RELEASE_PATH = "version/release";

  CLASSKEY_PATH = "classkeys";

  LISTS_PATH = "lists";

  MODEL_PATH = "model";

  SUMMARYFIELDS_PATH = "summaryfields";

  QUERY_RESULTS_PATH = "query/results";

  QUICKSEARCH_PATH = "search";

  WIDGETS_PATH = "widgets";

  ENRICHMENT_PATH = "list/enrichment";

  WITH_OBJ_PATH = "listswithobject";

  LIST_OPERATION_PATHS = {
    union: "lists/union",
    intersection: "lists/intersect",
    difference: "lists/diff"
  };

  SUBTRACT_PATH = 'lists/subtract';

  WHOAMI_PATH = "user/whoami";

  TABLE_ROW_PATH = QUERY_RESULTS_PATH + '/tablerows';

  PREF_PATH = 'user/preferences';

  PATH_VALUES_PATH = 'path/values';

  USER_TOKENS = 'user/tokens';

  ID_RESOLUTION_PATH = 'ids';

  NO_AUTH = {};

  _ref = [VERSION_PATH, RELEASE_PATH, CLASSKEY_PATH, WIDGETS_PATH, MODEL_PATH, SUMMARYFIELDS_PATH, QUICKSEARCH_PATH, PATH_VALUES_PATH];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    p = _ref[_i];
    NO_AUTH[p] = true;
  }

  ALWAYS_AUTH = {};

  _ref1 = [WHOAMI_PATH, PREF_PATH, LIST_OPERATION_PATHS, SUBTRACT_PATH, WITH_OBJ_PATH, ENRICHMENT_PATH, TEMPLATES_PATH, USER_TOKENS];
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    p = _ref1[_j];
    ALWAYS_AUTH[p] = true;
  }

  NEEDS_AUTH = function(path, q) {
    if (NO_AUTH[path]) {
      return false;
    } else if (ALWAYS_AUTH[path]) {
      return true;
    } else if (!(q != null ? q.needsAuthentication : void 0)) {
      return true;
    } else {
      return q.needsAuthentication();
    }
  };

  HAS_PROTOCOL = /^https?:\/\//i;

  HAS_SUFFIX = /service\/?$/i;

  SUFFIX = "/service/";

  DEFAULT_ERROR_HANDLER = function(e) {
    var f, _ref2;
    f = (_ref2 = console.error) != null ? _ref2 : console.log;
    return f(e);
  };

  _get_or_fetch = function(propName, store, path, key, cb) {
    var opts, promise, root, useCache, value;
    root = this.root, useCache = this.useCache;
    promise = this[propName] != null ? this[propName] : this[propName] = useCache && (value = store[root]) ? success(value) : (opts = {
      type: 'GET',
      dataType: 'json',
      data: {
        format: 'json'
      }
    }, this.doReq(merge(opts, {
      url: this.root + path
    })).then(function(x) {
      return store[root] = x[key];
    }));
    return withCB(cb, promise);
  };

  getListFinder = function(name) {
    return function(lists) {
      return new Promise(function(resolve, reject) {
        var list;
        if (list = utils.find(lists, function(l) {
          return l.name === name;
        })) {
          return resolve(list);
        } else {
          return reject("List \"" + name + "\" not found among: " + (lists.map(get('name'))));
        }
      });
    };
  };

  LIST_PIPE = function(service, prop) {
    if (prop == null) {
      prop = 'listName';
    }
    return utils.compose(service.fetchList, get(prop));
  };

  TO_NAMES = function(xs) {
    var x, _k, _len2, _ref2, _ref3, _results;
    if (xs == null) {
      xs = [];
    }
    _ref2 = (utils.isArray(xs) ? xs : [xs]);
    _results = [];
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      x = _ref2[_k];
      _results.push((_ref3 = x.name) != null ? _ref3 : x);
    }
    return _results;
  };

  Service = (function() {
    var FIVE_MIN, checkNameParam, getNewUserToken, loadQ, pathValuesReq, toMapByName;

    Service.prototype.doReq = http.doReq;

    function Service(_arg) {
      var noCache;
      this.root = _arg.root, this.token = _arg.token, this.errorHandler = _arg.errorHandler, this.DEBUG = _arg.DEBUG, this.help = _arg.help, noCache = _arg.noCache;
      this.connectAs = __bind(this.connectAs, this);
      this.createList = __bind(this.createList, this);
      this.resolveIds = __bind(this.resolveIds, this);
      this.templateQuery = __bind(this.templateQuery, this);
      this.savedQuery = __bind(this.savedQuery, this);
      this.query = __bind(this.query, this);
      this.fetchRelease = __bind(this.fetchRelease, this);
      this.fetchClassKeys = __bind(this.fetchClassKeys, this);
      this.fetchVersion = __bind(this.fetchVersion, this);
      this.fetchSummaryFields = __bind(this.fetchSummaryFields, this);
      this.fetchModel = __bind(this.fetchModel, this);
      this.fetchWidgetMap = __bind(this.fetchWidgetMap, this);
      this.fetchWidgets = __bind(this.fetchWidgets, this);
      this.complement = __bind(this.complement, this);
      this.fetchListsContaining = __bind(this.fetchListsContaining, this);
      this.fetchList = __bind(this.fetchList, this);
      this.findLists = __bind(this.findLists, this);
      this.fetchLists = __bind(this.fetchLists, this);
      this.fetchTemplates = __bind(this.fetchTemplates, this);
      this.tableRows = __bind(this.tableRows, this);
      this.values = __bind(this.values, this);
      this.rows = __bind(this.rows, this);
      this.records = __bind(this.records, this);
      this.table = __bind(this.table, this);
      this.pathValues = __bind(this.pathValues, this);
      this.fetchUser = __bind(this.fetchUser, this);
      this.whoami = __bind(this.whoami, this);
      this.findById = __bind(this.findById, this);
      this.count = __bind(this.count, this);
      this.enrichment = __bind(this.enrichment, this);
      if (this.root == null) {
        throw new Error("No service root provided. This is required");
      }
      if (!HAS_PROTOCOL.test(this.root)) {
        this.root = DEFAULT_PROTOCOL + this.root;
      }
      if (!HAS_SUFFIX.test(this.root)) {
        this.root = this.root + SUFFIX;
      }
      this.root = this.root.replace(/ice$/, "ice/");
      if (this.errorHandler == null) {
        this.errorHandler = DEFAULT_ERROR_HANDLER;
      }
      if (this.help == null) {
        this.help = 'no.help.available@dev.null';
      }
      this.useCache = !noCache;
      this.getFormat = (function(_this) {
        return function(intended) {
          if (intended == null) {
            intended = 'json';
          }
          return intended;
        };
      })(this);
    }

    Service.prototype.post = function(path, data) {
      return this.makeRequest('POST', path, data);
    };

    Service.prototype.get = function(path, data) {
      return this.makeRequest('GET', path, data);
    };

    Service.prototype.makeRequest = function(method, path, data, cb, indiv) {
      var dataType, errBack, opts, timeout, _ref2, _ref3, _ref4;
      if (method == null) {
        method = 'GET';
      }
      if (path == null) {
        path = '';
      }
      if (data == null) {
        data = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (indiv == null) {
        indiv = false;
      }
      if (utils.isArray(cb)) {
        _ref2 = cb, cb = _ref2[0], errBack = _ref2[1];
      }
      if (utils.isArray(data)) {
        data = utils.pairsToObj(data);
      }
      if (errBack == null) {
        errBack = this.errorHandler;
      }
      data = utils.copy(data);
      dataType = this.getFormat(data.format);
      if (!http.supports(method)) {
        _ref3 = [method, http.getMethod(method)], data.method = _ref3[0], method = _ref3[1];
      }
      opts = {
        data: data,
        dataType: dataType,
        success: cb,
        error: errBack,
        path: path,
        type: method
      };
      if (data.auth != null) {
        opts.auth = data.auth;
        delete opts.data.auth;
      }
      if (data.headers != null) {
        opts.headers = utils.copy(data.headers);
        delete opts.data.headers;
      }
      if (timeout = (_ref4 = data.timeout) != null ? _ref4 : this.timeout) {
        opts.timeout = timeout;
        delete data.timeout;
      }
      return this.authorise(opts).then((function(_this) {
        return function(authed) {
          return _this.doReq(authed, indiv);
        };
      })(this));
    };

    Service.prototype.authorise = function(req) {
      return this.fetchVersion().then((function(_this) {
        return function(version) {
          var opts, pathAdditions, _ref2;
          opts = utils.copy(req);
          if (opts.headers == null) {
            opts.headers = {};
          }
          opts.url = _this.root + opts.path;
          pathAdditions = [];
          if (version < 14) {
            if ('string' === typeof opts.data) {
              pathAdditions.push(['format', opts.dataType]);
            } else {
              opts.data.format = opts.dataType;
            }
          }
          if ((_this.token != null) && NEEDS_AUTH(req.path, (_ref2 = opts.data) != null ? _ref2.query : void 0)) {
            if (version >= 14) {
              opts.headers.Authorization = "Token " + _this.token;
            } else if ('string' === typeof opts.data) {
              pathAdditions.push(['token', _this.token]);
            } else {
              opts.data.token = _this.token;
            }
          }
          if (pathAdditions.length) {
            opts.url += '?' + to_query_string(pathAdditions);
          }
          return opts;
        };
      })(this));
    };

    Service.prototype.enrichment = function(opts, cb) {
      return REQUIRES_VERSION(this, 8, (function(_this) {
        return function() {
          var req;
          req = merge({
            maxp: 0.05,
            correction: 'Holm-Bonferroni'
          }, opts);
          return withCB(cb, _this.get(ENRICHMENT_PATH, req).then(get('results')));
        };
      })(this));
    };

    Service.prototype.search = function(options, cb) {
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          var k, req, v, _ref2;
          if (utils.isFunction(options)) {
            _ref2 = [options, {}], cb = _ref2[0], options = _ref2[1];
          }
          if (typeof options === 'string') {
            req = {
              q: options
            };
          } else {
            req = {
              q: options.q
            };
            for (k in options) {
              if (!__hasProp.call(options, k)) continue;
              v = options[k];
              if (k !== 'q') {
                req["facet_" + k] = v;
              }
            }
          }
          return withCB(cb, _this.post(QUICKSEARCH_PATH, req));
        };
      })(this));
    };

    Service.prototype.makePath = function(path, subclasses, cb) {
      if (subclasses == null) {
        subclasses = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      return withCB(cb, this.fetchModel().then(function(m) {
        return m.makePath(path, subclasses);
      }));
    };

    Service.prototype.count = function(q, cb) {
      var promise, req;
      if (cb == null) {
        cb = (function() {});
      }
      promise = !q ? error("Not enough arguments") : q.toPathString != null ? (p = q.isClass() ? q.append('id') : q, this.pathValues(p, 'count')) : q.toXML != null ? (req = {
        query: q,
        format: 'jsoncount'
      }, this.post(QUERY_RESULTS_PATH, req).then(get('count'))) : typeof q === 'string' ? this.fetchModel().then((function(_this) {
        return function(m) {
          var e;
          try {
            return _this.count(m.makePath(q));
          } catch (_error) {
            e = _error;
            return _this.query({
              select: [q]
            }).then(_this.count);
          }
        };
      })(this)) : this.query(q).then(this.count);
      return withCB(cb, promise);
    };

    Service.prototype.findById = function(type, id, fields, cb) {
      var promise, _ref2;
      if (fields == null) {
        fields = ['**'];
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (utils.isFunction(fields)) {
        _ref2 = [['**'], fields], fields = _ref2[0], cb = _ref2[1];
      }
      promise = this.query({
        from: type,
        select: fields,
        where: {
          id: id
        }
      }).then(dejoin).then(invoke('records')).then(get(0));
      return withCB(cb, promise);
    };

    Service.prototype.lookup = function(type, term, context, cb) {
      var promise, _ref2;
      if (utils.isFunction(context)) {
        _ref2 = [null, context], context = _ref2[0], cb = _ref2[1];
      }
      promise = this.query({
        from: type,
        select: ['**'],
        where: [[type, 'LOOKUP', term, context]]
      }).then(dejoin).then(invoke('records'));
      return withCB(cb, promise);
    };

    Service.prototype.find = function(type, term, context, cb) {
      var _ref2;
      if (utils.isFunction(context)) {
        _ref2 = [null, context], context = _ref2[0], cb = _ref2[1];
      }
      return withCB(cb, this.lookup(type, term, context).then(function(found) {
        if ((found == null) || found.length === 0) {
          return error("Nothing found");
        } else if (found.length > 1) {
          return error("Multiple items found: " + (found.slice(0, 3)) + "...");
        } else {
          return success(found[0]);
        }
      }));
    };

    Service.prototype.whoami = function(cb) {
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          return withCB(cb, _this.get(WHOAMI_PATH).then(get('user')).then(function(x) {
            return new User(_this, x);
          }));
        };
      })(this));
    };

    Service.prototype.fetchUser = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return this.whoami.apply(this, args);
    };

    pathValuesReq = function(format, path) {
      return {
        format: format,
        path: String(path),
        typeConstraints: JSON.stringify(path.subclasses)
      };
    };

    Service.prototype.pathValues = function(path, typeConstraints, cb) {
      if (typeConstraints == null) {
        typeConstraints = {};
      }
      return REQUIRES_VERSION(this, 6, (function(_this) {
        return function() {
          var e, format, promise, wanted, _ref2;
          if (typeof typeConstraints === 'string') {
            wanted = typeConstraints;
            typeConstraints = {};
          }
          if (utils.isFunction(typeConstraints)) {
            _ref2 = [cb, typeConstraints], typeConstraints = _ref2[0], cb = _ref2[1];
          }
          if (wanted !== 'count') {
            wanted = 'results';
          }
          format = wanted === 'count' ? 'jsoncount' : 'json';
          promise = (function() {
            var _ref3;
            try {
              return this.fetchModel().then(invoke('makePath', path, (_ref3 = path.subclasses) != null ? _ref3 : typeConstraints)).then(function(path) {
                return pathValuesReq(format, path);
              }).then((function(_this) {
                return function(req) {
                  return _this.post(PATH_VALUES_PATH, req);
                };
              })(this)).then(get(wanted));
            } catch (_error) {
              e = _error;
              return error(e);
            }
          }).call(_this);
          return withCB(cb, promise);
        };
      })(this));
    };

    Service.prototype.doPagedRequest = function(q, path, page, format, cb) {
      var req, _ref2;
      if (page == null) {
        page = {};
      }
      if (cb == null) {
        cb = (function() {});
      }
      if (q.toXML != null) {
        if (utils.isFunction(page)) {
          _ref2 = [page, {}], cb = _ref2[0], page = _ref2[1];
        }
        req = merge(page, {
          query: q,
          format: format
        });
        return withCB(cb, this.post(path, req).then(get('results')));
      } else {
        return this.query(q).then((function(_this) {
          return function(query) {
            return _this.doPagedRequest(query, path, page, format, cb);
          };
        })(this));
      }
    };

    Service.prototype.table = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsontable', cb);
    };

    Service.prototype.records = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'jsonobjects', cb);
    };

    Service.prototype.rows = function(q, page, cb) {
      return this.doPagedRequest(q, QUERY_RESULTS_PATH, page, 'json', cb);
    };

    Service.prototype.values = function(q, opts, cb) {
      var resp, _ref2;
      if (utils.isFunction(opts)) {
        _ref2 = [opts, cb], cb = _ref2[0], opts = _ref2[1];
      }
      resp = q == null ? error("No query term supplied") : (q.descriptors != null) || typeof q === 'string' ? this.pathValues(q, opts).then(map(get('value'))) : q.toXML != null ? q.views.length !== 1 ? error("Expected one column, got " + q.views.length) : this.rows(q, opts).then(map(get(0))) : this.query(q).then((function(_this) {
        return function(query) {
          return _this.values(query, opts);
        };
      })(this));
      return withCB(cb, resp);
    };

    Service.prototype.tableRows = function(q, page, cb) {
      return this.doPagedRequest(q, TABLE_ROW_PATH, page, 'json', cb);
    };

    Service.prototype.fetchTemplates = function(cb) {
      return withCB(cb, this.get(TEMPLATES_PATH).then(get('templates')));
    };

    Service.prototype.fetchLists = function(cb) {
      return this.findLists('', cb);
    };

    Service.prototype.findLists = function(name, cb) {
      if (name == null) {
        name = '';
      }
      if (cb == null) {
        cb = (function() {});
      }
      return this.fetchVersion().then((function(_this) {
        return function(v) {
          var fn;
          return withCB(cb, name && v < 13 ? error("Finding lists by name on the server requires version 13. This is only " + v) : (fn = function(ls) {
            var data, _k, _len2, _results;
            _results = [];
            for (_k = 0, _len2 = ls.length; _k < _len2; _k++) {
              data = ls[_k];
              _results.push(new List(data, _this));
            }
            return _results;
          }, _this.get(LISTS_PATH, {
            name: name
          }).then(get('lists')).then(fn)));
        };
      })(this));
    };

    Service.prototype.fetchList = function(name, cb) {
      return this.fetchVersion().then((function(_this) {
        return function(v) {
          return withCB(cb, v < 13 ? _this.findLists().then(getListFinder(name)) : _this.findLists(name).then(get(0)));
        };
      })(this));
    };

    Service.prototype.fetchListsContaining = function(opts, cb) {
      var fn;
      fn = (function(_this) {
        return function(xs) {
          var x, _k, _len2, _results;
          _results = [];
          for (_k = 0, _len2 = xs.length; _k < _len2; _k++) {
            x = xs[_k];
            _results.push(new List(x, _this));
          }
          return _results;
        };
      })(this);
      return withCB(cb, this.get(WITH_OBJ_PATH, opts).then(get('lists')).then(fn));
    };

    Service.prototype.combineLists = function(operation, options, cb) {
      var description, lists, name, req, tags, _ref2;
      _ref2 = merge({
        lists: [],
        tags: []
      }, options), name = _ref2.name, lists = _ref2.lists, tags = _ref2.tags, description = _ref2.description;
      req = {
        name: name,
        description: description
      };
      if (req.description == null) {
        req.description = "" + operation + " of " + (lists.join(', '));
      }
      req.tags = tags.join(';');
      req.lists = lists.join(';');
      return withCB(cb, this.get(LIST_OPERATION_PATHS[operation], req).then(LIST_PIPE(this)));
    };

    Service.prototype.merge = function() {
      return this.combineLists.apply(this, ['union'].concat(__slice.call(arguments)));
    };

    Service.prototype.intersect = function() {
      return this.combineLists.apply(this, ['intersection'].concat(__slice.call(arguments)));
    };

    Service.prototype.diff = function() {
      return this.combineLists.apply(this, ['difference'].concat(__slice.call(arguments)));
    };

    Service.prototype.complement = function(options, cb) {
      var defaultDesc, description, exclude, from, lists, name, references, req, tags;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      from = options.from, exclude = options.exclude, name = options.name, description = options.description, tags = options.tags;
      defaultDesc = function() {
        return "Relative complement of " + (lists.join(' and ')) + " in " + (references.join(' and '));
      };
      references = TO_NAMES(from);
      lists = TO_NAMES(exclude);
      if (name == null) {
        name = defaultDesc();
      }
      if (description == null) {
        description = defaultDesc();
      }
      if (tags == null) {
        tags = [];
      }
      req = {
        name: name,
        description: description,
        tags: tags,
        lists: lists,
        references: references
      };
      return withCB(cb, this.post(SUBTRACT_PATH, req).then(LIST_PIPE(this)));
    };

    Service.prototype.fetchWidgets = function(cb) {
      return REQUIRES_VERSION(this, 8, (function(_this) {
        return function() {
          return _get_or_fetch.call(_this, 'widgets', WIDGETS, WIDGETS_PATH, 'widgets', cb);
        };
      })(this));
    };

    toMapByName = utils.omap(function(w) {
      return [w.name, w];
    });

    Service.prototype.fetchWidgetMap = function(cb) {
      return REQUIRES_VERSION(this, 8, (function(_this) {
        return function() {
          return withCB(cb, (_this.__wmap__ != null ? _this.__wmap__ : _this.__wmap__ = _this.fetchWidgets().then(toMapByName)));
        };
      })(this));
    };

    Service.prototype.fetchModel = function(cb) {
      var ret;
      ret = _get_or_fetch.call(this, 'model', MODELS, MODEL_PATH, 'model').then(Model.load).then(set({
        service: this
      }));
      return withCB(cb, ret);
    };

    Service.prototype.fetchSummaryFields = function(cb) {
      return _get_or_fetch.call(this, 'summaryFields', SUMMARY_FIELDS, SUMMARYFIELDS_PATH, 'classes', cb);
    };

    Service.prototype.fetchVersion = function(cb) {
      return _get_or_fetch.call(this, 'version', VERSIONS, VERSION_PATH, 'version', cb);
    };

    Service.prototype.fetchClassKeys = function(cb) {
      return _get_or_fetch.call(this, 'classkeys', CLASSKEYS, CLASSKEY_PATH, 'classes', cb);
    };

    Service.prototype.fetchRelease = function(cb) {
      return _get_or_fetch.call(this, 'release', RELEASES, RELEASE_PATH, 'version', cb);
    };

    Service.prototype.query = function(options, cb) {
      var buildQuery;
      buildQuery = (function(_this) {
        return function(_arg) {
          var model, summaryFields;
          model = _arg[0], summaryFields = _arg[1];
          return new Query(options, _this, {
            model: model,
            summaryFields: summaryFields
          });
        };
      })(this);
      return withCB(cb, utils.parallel(this.fetchModel(), this.fetchSummaryFields()).then(buildQuery));
    };

    loadQ = function(service, name) {
      return function(q) {
        if (!q) {
          return error("No query found called " + name);
        }
        return service.query(q);
      };
    };

    checkNameParam = function(name) {
      if (name) {
        if ('string' === typeof name) {
          return success();
        } else {
          return error("Name must be a string");
        }
      } else {
        return error("Name not provided");
      }
    };

    Service.prototype.savedQuery = function(name, cb) {
      return REQUIRES_VERSION(this, 16, (function(_this) {
        return function() {
          return checkNameParam(name).then(function() {
            return withCB(cb, _this.get('user/queries', {
              filter: name
            }).then(function(r) {
              return r.queries[name];
            }).then(loadQ(_this, name)));
          });
        };
      })(this));
    };

    Service.prototype.templateQuery = function(name, cb) {
      return checkNameParam(name).then((function(_this) {
        return function() {
          return withCB(cb, _this.fetchTemplates().then(get(name)).then(set('type', 'TEMPLATE')).then(loadQ(_this, name)));
        };
      })(this));
    };

    Service.prototype.manageUserPreferences = function(method, data, cb) {
      return REQUIRES_VERSION(this, 11, (function(_this) {
        return function() {
          return withCB(cb, _this.makeRequest(method, PREF_PATH, data).then(get('preferences')));
        };
      })(this));
    };

    Service.prototype.resolveIds = function(opts, cb) {
      return REQUIRES_VERSION(this, 10, (function(_this) {
        return function() {
          var req;
          req = {
            type: 'POST',
            url: _this.root + ID_RESOLUTION_PATH,
            contentType: 'application/json',
            data: JSON.stringify(opts),
            dataType: 'json'
          };
          return withCB(cb, _this.doReq(req).then(get('uid')).then(IDResolutionJob.create(_this)));
        };
      })(this));
    };

    Service.prototype.resolutionJob = function(id) {
      return IDResolutionJob.create(this)(id);
    };

    Service.prototype.createList = function(opts, ids, cb) {
      var adjust, req;
      if (opts == null) {
        opts = {};
      }
      if (ids == null) {
        ids = '';
      }
      if (cb == null) {
        cb = function() {};
      }
      adjust = (function(_this) {
        return function(x) {
          return merge(x, {
            token: _this.token,
            tags: opts.tags || []
          });
        };
      })(this);
      req = {
        data: utils.isArray(ids) ? ids.map(function(x) {
          return "\"" + x + "\"";
        }).join("\n") : ids,
        dataType: 'json',
        url: "" + this.root + "lists?" + (to_query_string(adjust(opts))),
        type: 'POST',
        contentType: 'text/plain'
      };
      return withCB(cb, this.doReq(req).then(LIST_PIPE(this)));
    };

    getNewUserToken = function(resp) {
      return resp.user.temporaryToken;
    };

    Service.prototype.connectAs = function(token) {
      return Service.connect(merge(this, {
        token: token,
        noCache: !this.useCache
      }));
    };

    Service.prototype.register = function(name, password, cb) {
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          return withCB(cb, _this.post('users', {
            name: name,
            password: password
          }).then(getNewUserToken).then(_this.connectAs));
        };
      })(this));
    };

    FIVE_MIN = 5 * 60;

    Service.prototype.getDeregistrationToken = function(validity, cb) {
      if (validity == null) {
        validity = FIVE_MIN;
      }
      return REQUIRES_VERSION(this, 16, (function(_this) {
        return function() {
          var promise;
          promise = _this.token != null ? _this.post('user/deregistration', {
            validity: validity
          }).then(get('token')) : error("Not registered");
          return withCB(cb, promise);
        };
      })(this));
    };

    Service.prototype.deregister = function(token, cb) {
      return REQUIRES_VERSION(this, 16, (function(_this) {
        return function() {
          return withCB(cb, _this.makeRequest('DELETE', 'user', {
            deregistrationToken: token,
            format: 'xml'
          }));
        };
      })(this));
    };

    Service.prototype.login = function(name, password, cb) {
      return REQUIRES_VERSION(this, 9, (function(_this) {
        return function() {
          var auth;
          auth = "" + name + ":" + password;
          return withCB(cb, _this.logout().then(function(service) {
            return service.get('user/token', {
              auth: auth
            });
          })).then(get('token')).then(_this.connectAs);
        };
      })(this));
    };

    Service.prototype.logout = function(cb) {
      return withCB(cb, success(this.connectAs()));
    };

    return Service;

  })();

  Service.prototype.rowByRow = function() {
    var args, f, q;
    q = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    f = http.iterReq('POST', QUERY_RESULTS_PATH, 'json');
    if (q.toXML != null) {
      return f.apply(this, arguments);
    } else {
      return this.query(q).then((function(_this) {
        return function(query) {
          return _this.rowByRow.apply(_this, [query].concat(__slice.call(args)));
        };
      })(this));
    }
  };

  Service.prototype.eachRow = Service.prototype.rowByRow;

  Service.prototype.recordByRecord = function() {
    var args, f, q;
    q = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    f = http.iterReq('POST', QUERY_RESULTS_PATH, 'jsonobjects');
    if (q.toXML != null) {
      return f.apply(this, arguments);
    } else {
      return this.query(q).then((function(_this) {
        return function(query) {
          return _this.recordByRecord.apply(_this, [query].concat(__slice.call(args)));
        };
      })(this));
    }
  };

  Service.prototype.eachRecord = Service.prototype.recordByRecord;

  Service.prototype.union = Service.prototype.merge;

  Service.prototype.difference = Service.prototype.diff;

  Service.prototype.symmetricDifference = Service.prototype.diff;

  Service.prototype.relativeComplement = Service.prototype.complement;

  Service.prototype.subtract = Service.prototype.complement;

  Service.flushCaches = function() {
    MODELS = {};
    VERSIONS = {};
    RELEASES = {};
    CLASSKEYS = {};
    SUMMARY_FIELDS = {};
    return WIDGETS = {};
  };

  Service.connect = function(opts) {
    if ((opts != null ? opts.root : void 0) == null) {
      throw new Error("Invalid options provided: " + (JSON.stringify(opts)));
    }
    return new Service(opts);
  };

  exports.Service = Service;

  exports.Model = Model;

  exports.Query = Query;

  exports.utils = utils;

  exports.VERSION = version.VERSION;

  exports.imjs = version;

}).call(this);

},{"./http":3,"./id-resolution-job":4,"./lists":5,"./model":6,"./promise":8,"./query":9,"./user":14,"./util":15,"./version":16}],11:[function(_dereq_,module,exports){
(function (global){
(function() {
  var FakeDomParser;

  exports.DOMParser = global.DOMParser != null ? global.DOMParser : FakeDomParser = (function() {
    function FakeDomParser() {
      throw new Error("DOMParser is not available");
    }

    return FakeDomParser;

  })();

}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],12:[function(_dereq_,module,exports){
(function() {
  var HAS_CONSOLE, HAS_JSON, NOT_ENUM, hasDontEnumBug, hasOwnProperty, head, m, script, _fn, _i, _len, _ref;

  HAS_CONSOLE = typeof console !== 'undefined';

  HAS_JSON = typeof JSON !== 'undefined';

  NOT_ENUM = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'];

  if (!HAS_JSON) {
    script = document.createElement('script');
    script.src = 'http://cdn.intermine.org/js/json3/3.2.2/json3.min.js';
    script.type = 'text/javascript';
    head = document.getElementsByTagName('head')[0];
    head.appendChild(script);
  }

  if (Object.keys == null) {
    hasOwnProperty = Object.prototype.hasOwnProperty;
    hasDontEnumBug = !{
      toString: null
    }.propertyIsEnumerable("toString");
    Object.keys = function(o) {
      var keys, name, nonEnum, _i, _len;
      if (typeof o !== "object" && typeof o !== "" || o === null) {
        throw new TypeError("Object.keys called on a non-object");
      }
      keys = (function() {
        var _results;
        _results = [];
        for (name in o) {
          if (hasOwnProperty.call(o, name)) {
            _results.push(name);
          }
        }
        return _results;
      })();
      if (hasDontEnumBug) {
        for (_i = 0, _len = NOT_ENUM.length; _i < _len; _i++) {
          nonEnum = NOT_ENUM[_i];
          if (hasOwnProperty.call(o, nonEnum)) {
            keys.push(nonEnum);
          }
        }
      }
      return keys;
    };
  }

  if (Array.prototype.map == null) {
    Array.prototype.map = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        _results.push(f(x));
      }
      return _results;
    };
  }

  if (Array.prototype.filter == null) {
    Array.prototype.filter = function(f) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        x = this[_i];
        if (f(x)) {
          _results.push(x);
        }
      }
      return _results;
    };
  }

  if (Array.prototype.reduce == null) {
    Array.prototype.reduce = function(f, initValue) {
      var ret, x, xs, _i, _len;
      xs = this.slice();
      ret = arguments.length < 2 ? xs.pop() : initValue;
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        ret = f(ret, x);
      }
      return ret;
    };
  }

  if (Array.prototype.forEach == null) {
    Array.prototype.forEach = function(f, ctx) {
      var i, x, _i, _len, _results;
      if (!f) {
        throw new Error("No function provided");
      }
      _results = [];
      for (i = _i = 0, _len = this.length; _i < _len; i = ++_i) {
        x = this[i];
        _results.push(f.call(ctx != null ? ctx : this, x, i, this));
      }
      return _results;
    };
  }

  if (!HAS_CONSOLE) {
    this.console = {
      log: (function() {}),
      error: (function() {}),
      debug: (function() {})
    };
    if (typeof window !== "undefined" && window !== null) {
      window.console = this.console;
    }
  }

  if (console.log == null) {
    console.log = function() {};
  }

  if (console.error == null) {
    console.error = function() {};
  }

  if (console.debug == null) {
    console.debug = function() {};
  }

  if (console.log.apply == null) {
    console.log("Your console needs patching.");
    _ref = ['log', 'error', 'debug'];
    _fn = function(m) {
      var oldM;
      oldM = console[m];
      return console[m] = function(args) {
        return oldM(args);
      };
    };
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      m = _ref[_i];
      _fn(m);
    }
  }

}).call(this);

},{}],13:[function(_dereq_,module,exports){
(function() {
  var Promise, merge, properties,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  merge = function(src, dest) {
    var k, v, _results;
    _results = [];
    for (k in src) {
      v = src[k];
      _results.push(dest[k] = v);
    }
    return _results;
  };

  Promise = _dereq_('./promise');

  properties = ['attributes', 'references', 'collections'];

  exports.Table = (function() {
    function Table(opts, model) {
      var c, prop, _, _i, _len, _ref, _ref1;
      this.model = model;
      this.getDisplayName = __bind(this.getDisplayName, this);
      this.name = opts.name, this.tags = opts.tags, this.displayName = opts.displayName, this.attributes = opts.attributes, this.references = opts.references, this.collections = opts.collections;
      this.fields = {};
      this.__parents__ = (_ref = opts['extends']) != null ? _ref : [];
      for (_i = 0, _len = properties.length; _i < _len; _i++) {
        prop = properties[_i];
        if (this[prop] == null) {
          throw new Error("Bad model data: missing " + prop);
        }
        merge(this[prop], this.fields);
      }
      _ref1 = this.collections;
      for (_ in _ref1) {
        c = _ref1[_];
        c.isCollection = true;
      }
    }

    Table.prototype.toString = function() {
      var n, _;
      return "[Table name=" + this.name + ", fields=[" + ((function() {
        var _ref, _results;
        _ref = this.fields;
        _results = [];
        for (n in _ref) {
          _ = _ref[n];
          _results.push(n);
        }
        return _results;
      }).call(this)) + "]]";
    };

    Table.prototype.parents = function() {
      var _ref;
      return ((_ref = this.__parents__) != null ? _ref : []).slice();
    };

    Table.prototype.getDisplayName = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          if (_this.model != null) {
            return resolve(_this.model.makePath(_this.name).getDisplayName());
          } else {
            return reject(new Error('model not set - cannot make path'));
          }
        };
      })(this));
    };

    return Table;

  })();

}).call(this);

},{"./promise":8}],14:[function(_dereq_,module,exports){
(function() {
  var any, do_pref_req, error, get, isFunction, withCB, _ref,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ref = _dereq_('./util'), withCB = _ref.withCB, get = _ref.get, isFunction = _ref.isFunction, any = _ref.any, error = _ref.error;

  do_pref_req = function(user, data, method, cb) {
    return user.service.manageUserPreferences(method, data, cb).then(function(prefs) {
      return user.preferences = prefs;
    });
  };

  exports.User = (function() {
    function User(service, _arg) {
      this.service = service;
      this.username = _arg.username, this.preferences = _arg.preferences;
      this.refresh = __bind(this.refresh, this);
      this.clearPreferences = __bind(this.clearPreferences, this);
      this.clearPreference = __bind(this.clearPreference, this);
      this.setPreferences = __bind(this.setPreferences, this);
      this.setPreference = __bind(this.setPreference, this);
      this.hasPreferences = this.preferences != null;
      if (this.preferences == null) {
        this.preferences = {};
      }
    }

    User.prototype.setPreference = function(key, value, cb) {
      var data, _ref1;
      if (isFunction(value)) {
        _ref1 = [null, value], value = _ref1[0], cb = _ref1[1];
      }
      if (typeof key === 'string') {
        data = {};
        data[key] = value;
      } else if (value == null) {
        data = key;
      } else {
        return withCB(cb, error("Incorrect arguments to setPreference"));
      }
      return this.setPreferences(data, cb);
    };

    User.prototype.setPreferences = function(prefs, cb) {
      return do_pref_req(this, prefs, 'POST', cb);
    };

    User.prototype.clearPreference = function(key, cb) {
      return do_pref_req(this, {
        key: key
      }, 'DELETE', cb);
    };

    User.prototype.clearPreferences = function(cb) {
      return do_pref_req(this, {}, 'DELETE', cb);
    };

    User.prototype.refresh = function(cb) {
      return do_pref_req(this, {}, 'GET', cb);
    };

    User.prototype.createToken = function(type, message, cb) {
      var _ref1, _ref2;
      if (type == null) {
        type = 'day';
      }
      if ((cb == null) && any([type, message], isFunction)) {
        if (isFunction(type)) {
          _ref1 = [null, null, type], type = _ref1[0], message = _ref1[1], cb = _ref1[2];
        } else if (isFunction(message)) {
          _ref2 = [null, message], message = _ref2[0], cb = _ref2[1];
        }
      }
      return withCB(cb, this.service.post('user/tokens', {
        type: type,
        message: message
      }).then(get('token')));
    };

    User.prototype.fetchCurrentTokens = function(cb) {
      return withCB(cb, this.service.get('user/tokens').then(get('tokens')));
    };

    User.prototype.revokeAllTokens = function(cb) {
      return withCB(cb, this.service.makeRequest('DELETE', 'user/tokens'));
    };

    User.prototype.revokeToken = function(token, cb) {
      return withCB(cb, this.service.makeRequest('DELETE', "user/tokens/" + token));
    };

    return User;

  })();

}).call(this);

},{"./util":15}],15:[function(_dereq_,module,exports){
(function() {
  var Promise, REQUIRES, comp, curry, encode, entities, error, flatten, fold, id, invoke, invokeWith, isArray, merge, pairFold, qsFromList, root, success, thenFold, _ref,
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty;

  Promise = _dereq_('./promise');

  root = exports;

  root.defer = function() {
    var deferred;
    deferred = {};
    deferred.promise = new Promise(function(resolve, reject) {
      deferred.resolve = resolve;
      return deferred.reject = reject;
    });
    return deferred;
  };

  encode = function(x) {
    return encodeURIComponent(String(x));
  };

  qsFromList = function(pairs) {
    var pair;
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = pairs.length; _i < _len; _i++) {
        pair = pairs[_i];
        _results.push(pair.map(encode).join('='));
      }
      return _results;
    })()).join('&');
  };

  root.querystring = function(obj) {
    var k, p, pairs, subList, sv, v;
    if (!obj) {
      return '';
    }
    if (isArray(obj)) {
      pairs = obj.slice();
    } else {
      pairs = [];
      for (k in obj) {
        v = obj[k];
        if (isArray(v)) {
          subList = (function() {
            var _i, _len, _results;
            _results = [];
            for (_i = 0, _len = v.length; _i < _len; _i++) {
              sv = v[_i];
              _results.push([k, sv]);
            }
            return _results;
          })();
          pairs = pairs.concat(subList);
        } else {
          pairs.push([k, v]);
        }
      }
    }
    return qsFromList((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = pairs.length; _i < _len; _i++) {
        p = pairs[_i];
        if (p[1] != null) {
          _results.push(p);
        }
      }
      return _results;
    })());
  };

  root.curry = curry = function() {
    var args, f;
    f = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return function() {
      var rest;
      rest = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return f.apply(null, args.concat(rest));
    };
  };

  root.error = error = function(e) {
    return new Promise(function(_, reject) {
      return reject(new Error(e));
    });
  };

  root.success = success = function(x) {
    return new Promise(function(resolve, _) {
      return resolve(x);
    });
  };

  root.parallel = function() {
    var promises;
    promises = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (promises.length === 1 && (!promises[0].then) && promises[0].length) {
      return Promise.all(promises[0]);
    } else {
      return Promise.all(promises);
    }
  };

  root.withCB = function() {
    var f, fs, onErr, onSucc, p, _i, _j, _len;
    fs = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), p = arguments[_i++];
    for (_j = 0, _len = fs.length; _j < _len; _j++) {
      f = fs[_j];
      if (!(f != null)) {
        continue;
      }
      onSucc = curry(f, null);
      onErr = f;
      p.then(onSucc, onErr);
    }
    return p;
  };

  root.fold = fold = function(f) {
    return function(init, xs) {
      var k, ret, v;
      if (arguments.length === 1) {
        xs = (init != null ? init.slice() : void 0) || init;
        init = (xs != null ? xs.shift() : void 0) || {};
      }
      if (xs == null) {
        throw new Error("xs is null");
      }
      if (xs.reduce != null) {
        return xs.reduce(f, init);
      } else {
        ret = init;
        for (k in xs) {
          v = xs[k];
          ret = ret != null ? f(ret, k, v) : {
            k: v
          };
        }
        return ret;
      }
    };
  };

  root.take = function(n) {
    return function(xs) {
      if (n != null) {
        return xs.slice(0, +(n - 1) + 1 || 9e9);
      } else {
        return xs.slice();
      }
    };
  };

  root.filter = function(f) {
    return function(xs) {
      var x, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        if (f(x)) {
          _results.push(x);
        }
      }
      return _results;
    };
  };

  root.uniqBy = function(f, xs) {
    var k, keys, values, x, _i, _len;
    if (arguments.length === 1) {
      return curry(root.uniqBy, f);
    }
    keys = [];
    values = [];
    if (xs == null) {
      return values;
    }
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      k = f(x);
      if (__indexOf.call(keys, k) < 0) {
        keys.push(k);
        values.push(x);
      }
    }
    return values;
  };

  root.find = function(xs, f) {
    var x, _i, _len;
    if (arguments.length === 1) {
      f = xs;
      return function(xs) {
        return root.find(xs, f);
      };
    }
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (f(x)) {
        return x;
      }
    }
    return null;
  };

  isArray = (_ref = Array.isArray) != null ? _ref : function(xs) {
    return ((xs != null ? xs.splice : void 0) != null) && ((xs != null ? xs.push : void 0) != null) && ((xs != null ? xs.pop : void 0) != null) && ((xs != null ? xs.slice : void 0) != null);
  };

  root.isArray = isArray;

  root.isFunction = typeof /./ !== 'function' ? function(f) {
    return typeof f === 'function';
  } : function(f) {
    return (f != null) && (f.call != null) && (f.apply != null) && f.toString() === '[object Function]';
  };

  entities = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&apos;'
  };

  root.escape = function(str) {
    var code, i, ret, withEntities, _i, _ref1;
    if (str == null) {
      return '';
    }
    withEntities = String(str).replace(/[&<>"']/g, function(entity) {
      return entities[entity];
    });
    ret = [];
    for (i = _i = 0, _ref1 = withEntities.length; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
      code = withEntities.charCodeAt(i);
      if (code > 256) {
        ret.push("&#" + code + ";");
      } else {
        ret.push(withEntities.charAt(i));
      }
    }
    return ret.join('');
  };

  root.omap = function(f) {
    var merger;
    merger = fold(function(a, oldk, oldv) {
      var newk, newv, _ref1;
      _ref1 = f(oldk, oldv), newk = _ref1[0], newv = _ref1[1];
      if (isArray(newv)) {
        newv = newv.slice();
      }
      a[newk] = newv;
      return a;
    });
    return function(xs) {
      return merger({}, xs);
    };
  };

  root.copy = root.omap(function(k, v) {
    return [k, v];
  });

  root.partition = function(f) {
    return function(xs) {
      var divide;
      divide = fold(function(_arg, x) {
        var falses, trues;
        trues = _arg[0], falses = _arg[1];
        if (f(x)) {
          return [trues.concat([x]), falses];
        } else {
          return [trues, falses.concat([x])];
        }
      });
      return divide([[], []], xs);
    };
  };

  root.id = id = function(x) {
    return x;
  };

  root.concatMap = function(f) {
    return function(xs) {
      var fx, ret, x, _i, _len;
      ret = void 0;
      for (_i = 0, _len = xs.length; _i < _len; _i++) {
        x = xs[_i];
        fx = f(x);
        ret = ret === void 0 ? fx : typeof ret === 'number' ? ret + fx : ret.concat != null ? ret.concat(fx) : merge(ret, fx);
      }
      return ret;
    };
  };

  root.map = function(f) {
    return invoke('map', f);
  };

  comp = fold(function(f, g) {
    return function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return f(g.apply(null, args));
    };
  });

  root.compose = function() {
    var fs;
    fs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return comp(fs);
  };

  root.flatMap = root.concatMap;

  root.difference = function(xs, remove) {
    var x, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (__indexOf.call(remove, x) < 0) {
        _results.push(x);
      }
    }
    return _results;
  };

  root.stringList = function(x) {
    if (typeof x === 'string') {
      return [x];
    } else {
      return x;
    }
  };

  root.flatten = flatten = function() {
    var ret, x, xs, xx, _i, _j, _len, _len1, _ref1;
    xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    ret = [];
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (isArray(x)) {
        _ref1 = flatten.apply(null, x);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          xx = _ref1[_j];
          ret.push(xx);
        }
      } else {
        ret.push(x);
      }
    }
    return ret;
  };

  root.sum = root.concatMap(id);

  root.merge = merge = function() {
    var k, newObj, o, objs, v, _i, _len;
    objs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    newObj = {};
    for (_i = 0, _len = objs.length; _i < _len; _i++) {
      o = objs[_i];
      for (k in o) {
        if (!__hasProp.call(o, k)) continue;
        v = o[k];
        newObj[k] = v;
      }
    }
    return newObj;
  };

  root.any = function(xs, f) {
    var x, _i, _len;
    if (f == null) {
      f = id;
    }
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      if (f(x)) {
        return true;
      }
    }
    return false;
  };

  root.invoke = invoke = function() {
    var args, name;
    name = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return invokeWith(name, args);
  };

  root.invokeWith = invokeWith = function(name, args, ctx) {
    if (args == null) {
      args = [];
    }
    if (ctx == null) {
      ctx = null;
    }
    return function(o) {
      if (o == null) {
        throw new Error("Cannot call method \"" + name + "\" of null");
      }
      if (!o[name]) {
        throw new Error("Cannot call undefined method \"" + name + " of " + o);
      } else {
        return o[name].apply(ctx || o, args);
      }
    };
  };

  root.get = function(name) {
    return function(obj) {
      return obj[name];
    };
  };

  root.set = function(name, value) {
    return function(obj) {
      var k, v;
      if (arguments.length === 2) {
        obj[name] = value;
      } else {
        for (k in name) {
          if (!__hasProp.call(name, k)) continue;
          v = name[k];
          obj[k] = v;
        }
      }
      return obj;
    };
  };

  REQUIRES = function(required, got) {
    return "This service requires a service at version " + required + " or above. This one is at " + got;
  };

  root.REQUIRES_VERSION = function(s, n, f) {
    return s.fetchVersion().then(function(v) {
      if (v >= n) {
        return f();
      } else {
        return error(REQUIRES(n, v));
      }
    });
  };

  root.dejoin = function(q) {
    var parts, view, _i, _len, _ref1;
    _ref1 = q.views;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      view = _ref1[_i];
      parts = view.split('.');
      if (parts.length > 2) {
        q.addJoin(parts.slice(1, -1).join('.'));
      }
    }
    return q;
  };

  thenFold = fold(function(p, f) {
    return p.then(f);
  });

  root.sequence = function() {
    var fns;
    fns = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return thenFold(success(), fns);
  };

  pairFold = fold(function(o, _arg) {
    var k, v;
    k = _arg[0], v = _arg[1];
    if (o[k] != null) {
      throw new Error("Duplicate key: " + k);
    }
    o[k] = v;
    return o;
  });

  root.pairsToObj = function(pairs) {
    return pairFold({}, pairs);
  };

}).call(this);

},{"./promise":8}],16:[function(_dereq_,module,exports){
(function() {
  exports.VERSION = '3.13.0';

}).call(this);

},{}],17:[function(_dereq_,module,exports){
(function() {
  var DOMParser, sanitize;

  DOMParser = _dereq_('xmldom').DOMParser;

  sanitize = function(xml) {
    xml = xml.replace(/^\s*/g, '');
    xml = xml.replace(/\s$/g, '');
    if (xml.length === 0) {
      return xml;
    } else if (xml[xml.length - 1] !== '>') {
      return xml + '>';
    } else {
      return xml;
    }
  };

  exports.parse = function(xml) {
    var dom, parser;
    if (typeof xml !== 'string') {
      throw new Error("Expected a string - got " + xml);
    }
    xml = sanitize(xml);
    if (!xml) {
      throw new Error("Expected content - got empty string");
    }
    dom = (function() {
      try {
        parser = new DOMParser();
        return parser.parseFromString(xml, 'text/xml');
      } catch (_error) {}
    })();
    if ((!dom) || (!dom.documentElement) || dom.getElementsByTagName('parsererror').length) {
      throw new Error("Invalid XML: " + xml);
    }
    return dom;
  };

}).call(this);

},{"xmldom":11}],18:[function(_dereq_,module,exports){
(function (process,Buffer){


var Parser = _dereq_('jsonparse')
  , through = _dereq_('through')

/*

  the value of this.stack that creationix's jsonparse has is weird.

  it makes this code ugly, but his problem is way harder that mine,
  so i'll forgive him.

*/

exports.parse = function (path, map) {

  var parser = new Parser()
  var stream = through(function (chunk) {
    if('string' === typeof chunk)
      chunk = new Buffer(chunk)
    parser.write(chunk)
  },
  function (data) {
    if(data)
      stream.write(data)
    stream.queue(null)
  })

  if('string' === typeof path)
    path = path.split('.').map(function (e) {
      if (e === '*')
        return true
      else if (e === '') // '..'.split('.') returns an empty string
        return {recurse: true}
      else
        return e
    })


  var count = 0, _key
  if(!path || !path.length)
    path = null

  parser.onValue = function (value) {
    if (!this.root)
      stream.root = value

    if(! path) return

    var i = 0 // iterates on path
    var j  = 0 // iterates on stack
    while (i < path.length) {
      var key = path[i]
      var c
      j++

      if (key && !key.recurse) {
        c = (j === this.stack.length) ? this : this.stack[j]
        if (!c) return
        if (! check(key, c.key)) return
        i++
      } else {
        i++
        var nextKey = path[i]
        if (! nextKey) return
        while (true) {
          c = (j === this.stack.length) ? this : this.stack[j]
          if (!c) return
          if (check(nextKey, c.key)) { i++; break}
          j++
        }
      }
    }
    if (j !== this.stack.length) return

    count ++
    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])
    var data = this.value[this.key]
    if(null != data)
      if(null != (data = map ? map(data, actualPath) : data))
        stream.queue(data)
    delete this.value[this.key]
  }
  parser._onToken = parser.onToken;

  parser.onToken = function (token, value) {
    parser._onToken(token, value);
    if (this.stack.length === 0) {
      if (stream.root) {
        if(!path)
          stream.queue(stream.root)
        stream.emit('root', stream.root, count)
        count = 0;
        stream.root = null;
      }
    }
  }

  parser.onError = function (err) {
    stream.emit('error', err)
  }


  return stream
}

function check (x, y) {
  if ('string' === typeof x)
    return y == x
  else if (x && 'function' === typeof x.exec)
    return x.exec(y)
  else if ('boolean' === typeof x)
    return x
  else if ('function' === typeof x)
    return x(y)
  return false
}

exports.stringify = function (op, sep, cl, indent) {
  indent = indent || 0
  if (op === false){
    op = ''
    sep = '\n'
    cl = ''
  } else if (op == null) {

    op = '[\n'
    sep = '\n,\n'
    cl = '\n]\n'

  }

  //else, what ever you like

  var stream
    , first = true
    , anyData = false
  stream = through(function (data) {
    anyData = true
    var json = JSON.stringify(data, null, indent)
    if(first) { first = false ; stream.queue(op + json)}
    else stream.queue(sep + json)
  },
  function (data) {
    if(!anyData)
      stream.queue(op)
    stream.queue(cl)
    stream.queue(null)
  })

  return stream
}

exports.stringifyObject = function (op, sep, cl, indent) {
  indent = indent || 0
  if (op === false){
    op = ''
    sep = '\n'
    cl = ''
  } else if (op == null) {

    op = '{\n'
    sep = '\n,\n'
    cl = '\n}\n'

  }

  //else, what ever you like

  var first = true
    , anyData = false
  stream = through(function (data) {
    anyData = true
    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)
    if(first) { first = false ; this.queue(op + json)}
    else this.queue(sep + json)
  },
  function (data) {
    if(!anyData) this.queue(op)
    this.queue(cl)

    this.queue(null)
  })

  return stream
}

if(!module.parent && process.title !== 'browser') {
  process.stdin
    .pipe(exports.parse(process.argv[2]))
    .pipe(exports.stringify('[', ',\n', ']\n', 2))
    .pipe(process.stdout)
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"),_dereq_("buffer").Buffer)
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"buffer":23,"jsonparse":19,"through":56}],19:[function(_dereq_,module,exports){
(function (Buffer){
/*global Buffer*/
// Named constants with unique integer values
var C = {};
// Tokens
var LEFT_BRACE    = C.LEFT_BRACE    = 0x1;
var RIGHT_BRACE   = C.RIGHT_BRACE   = 0x2;
var LEFT_BRACKET  = C.LEFT_BRACKET  = 0x3;
var RIGHT_BRACKET = C.RIGHT_BRACKET = 0x4;
var COLON         = C.COLON         = 0x5;
var COMMA         = C.COMMA         = 0x6;
var TRUE          = C.TRUE          = 0x7;
var FALSE         = C.FALSE         = 0x8;
var NULL          = C.NULL          = 0x9;
var STRING        = C.STRING        = 0xa;
var NUMBER        = C.NUMBER        = 0xb;
// Tokenizer States
var START   = C.START   = 0x11;
var TRUE1   = C.TRUE1   = 0x21;
var TRUE2   = C.TRUE2   = 0x22;
var TRUE3   = C.TRUE3   = 0x23;
var FALSE1  = C.FALSE1  = 0x31;
var FALSE2  = C.FALSE2  = 0x32;
var FALSE3  = C.FALSE3  = 0x33;
var FALSE4  = C.FALSE4  = 0x34;
var NULL1   = C.NULL1   = 0x41;
var NULL2   = C.NULL3   = 0x42;
var NULL3   = C.NULL2   = 0x43;
var NUMBER1 = C.NUMBER1 = 0x51;
var NUMBER2 = C.NUMBER2 = 0x52;
var NUMBER3 = C.NUMBER3 = 0x53;
var NUMBER4 = C.NUMBER4 = 0x54;
var NUMBER5 = C.NUMBER5 = 0x55;
var NUMBER6 = C.NUMBER6 = 0x56;
var NUMBER7 = C.NUMBER7 = 0x57;
var NUMBER8 = C.NUMBER8 = 0x58;
var STRING1 = C.STRING1 = 0x61;
var STRING2 = C.STRING2 = 0x62;
var STRING3 = C.STRING3 = 0x63;
var STRING4 = C.STRING4 = 0x64;
var STRING5 = C.STRING5 = 0x65;
var STRING6 = C.STRING6 = 0x66;
// Parser States
var VALUE   = C.VALUE   = 0x71;
var KEY     = C.KEY     = 0x72;
// Parser Modes
var OBJECT  = C.OBJECT  = 0x81;
var ARRAY   = C.ARRAY   = 0x82;

// Slow code to string converter (only used when throwing syntax errors)
function toknam(code) {
  var keys = Object.keys(C);
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    if (C[key] === code) { return key; }
  }
  return code && ("0x" + code.toString(16));
}


function Parser() {
  this.tState = START;
  this.value = undefined;

  this.string = undefined; // string data
  this.unicode = undefined; // unicode escapes

  // For number parsing
  this.negative = undefined;
  this.magnatude = undefined;
  this.position = undefined;
  this.exponent = undefined;
  this.negativeExponent = undefined;
  
  this.key = undefined;
  this.mode = undefined;
  this.stack = [];
  this.state = VALUE;
  this.bytes_remaining = 0; // number of bytes remaining in multi byte utf8 char to read after split boundary
  this.bytes_in_sequence = 0; // bytes in multi byte utf8 char to read
  this.temp_buffs = { "2": new Buffer(2), "3": new Buffer(3), "4": new Buffer(4) }; // for rebuilding chars split before boundary is reached
}
var proto = Parser.prototype;
proto.charError = function (buffer, i) {
  this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(buffer[i])) + " at position " + i + " in state " + toknam(this.tState)));
};
proto.onError = function (err) { throw err; };
proto.write = function (buffer) {
  if (typeof buffer === "string") buffer = new Buffer(buffer);
  //process.stdout.write("Input: ");
  //console.dir(buffer.toString());
  var n;
  for (var i = 0, l = buffer.length; i < l; i++) {
    if (this.tState === START){
      n = buffer[i];
      if(n === 0x7b){ this.onToken(LEFT_BRACE, "{"); // {
      }else if(n === 0x7d){ this.onToken(RIGHT_BRACE, "}"); // }
      }else if(n === 0x5b){ this.onToken(LEFT_BRACKET, "["); // [
      }else if(n === 0x5d){ this.onToken(RIGHT_BRACKET, "]"); // ]
      }else if(n === 0x3a){ this.onToken(COLON, ":");  // :
      }else if(n === 0x2c){ this.onToken(COMMA, ","); // ,
      }else if(n === 0x74){ this.tState = TRUE1;  // t
      }else if(n === 0x66){ this.tState = FALSE1;  // f
      }else if(n === 0x6e){ this.tState = NULL1; // n
      }else if(n === 0x22){ this.string = ""; this.tState = STRING1; // "
      }else if(n === 0x2d){ this.negative = true; this.tState = NUMBER1; // -
      }else if(n === 0x30){ this.magnatude = 0; this.tState = NUMBER2; // 0
      }else{
        if (n > 0x30 && n < 0x40) { // 1-9
          this.magnatude = n - 0x30; this.tState = NUMBER3;
        } else if (n === 0x20 || n === 0x09 || n === 0x0a || n === 0x0d) {
          // whitespace
        } else { this.charError(buffer, i); }
      }
    }else if (this.tState === STRING1){ // After open quote
      n = buffer[i]; // get current byte from buffer
      // check for carry over of a multi byte char split between data chunks
      // & fill temp buffer it with start of this data chunk up to the boundary limit set in the last iteration
      if (this.bytes_remaining > 0) {
        for (var j = 0; j < this.bytes_remaining; j++) {
          this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + j] = buffer[j];
        }
        this.string += this.temp_buffs[this.bytes_in_sequence].toString();
        this.bytes_in_sequence = this.bytes_remaining = 0;
        i = i + j - 1;
      } else if (this.bytes_remaining === 0 && n >= 128) { // else if no remainder bytes carried over, parse multi byte (>=128) chars one at a time
        if ((n >= 194) && (n <= 223)) this.bytes_in_sequence = 2;
        if ((n >= 224) && (n <= 239)) this.bytes_in_sequence = 3;
        if ((n >= 240) && (n <= 244)) this.bytes_in_sequence = 4;
        if ((this.bytes_in_sequence + i) > buffer.length) { // if bytes needed to complete char fall outside buffer length, we have a boundary split
          for (var k = 0; k <= (buffer.length - 1 - i); k++) {
            this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k]; // fill temp buffer of correct size with bytes available in this chunk
          }
          this.bytes_remaining = (i + this.bytes_in_sequence) - buffer.length;
          i = buffer.length - 1;
        } else {
          this.string += buffer.slice(i, (i + this.bytes_in_sequence)).toString();
          i = i + this.bytes_in_sequence - 1;
        }
      } else if (n === 0x22) { this.tState = START; this.onToken(STRING, this.string); this.string = undefined; }
      else if (n === 0x5c) { this.tState = STRING2; }
      else if (n >= 0x20) { this.string += String.fromCharCode(n); }
      else { this.charError(buffer, i); }
    }else if (this.tState === STRING2){ // After backslash
      n = buffer[i];
      if(n === 0x22){ this.string += "\""; this.tState = STRING1;
      }else if(n === 0x5c){ this.string += "\\"; this.tState = STRING1; 
      }else if(n === 0x2f){ this.string += "\/"; this.tState = STRING1; 
      }else if(n === 0x62){ this.string += "\b"; this.tState = STRING1; 
      }else if(n === 0x66){ this.string += "\f"; this.tState = STRING1; 
      }else if(n === 0x6e){ this.string += "\n"; this.tState = STRING1; 
      }else if(n === 0x72){ this.string += "\r"; this.tState = STRING1; 
      }else if(n === 0x74){ this.string += "\t"; this.tState = STRING1; 
      }else if(n === 0x75){ this.unicode = ""; this.tState = STRING3;
      }else{ 
        this.charError(buffer, i); 
      }
    }else if (this.tState === STRING3 || this.tState === STRING4 || this.tState === STRING5 || this.tState === STRING6){ // unicode hex codes
      n = buffer[i];
      // 0-9 A-F a-f
      if ((n >= 0x30 && n < 0x40) || (n > 0x40 && n <= 0x46) || (n > 0x60 && n <= 0x66)) {
        this.unicode += String.fromCharCode(n);
        if (this.tState++ === STRING6) {
          this.string += String.fromCharCode(parseInt(this.unicode, 16));
          this.unicode = undefined;
          this.tState = STRING1; 
        }
      } else {
        this.charError(buffer, i);
      }
    }else if (this.tState === NUMBER1){ // after minus
      n = buffer[i];
      if (n === 0x30) { this.magnatude = 0; this.tState = NUMBER2; }
      else if (n > 0x30 && n < 0x40) { this.magnatude = n - 0x30; this.tState = NUMBER3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === NUMBER2){ // * After initial zero
      n = buffer[i];
      if(n === 0x2e){ // .
        this.position = 0.1; this.tState = NUMBER4;
      }else if(n === 0x65 ||  n === 0x45){ // e/E
        this.exponent = 0; this.tState = NUMBER6;
      }else{
        this.tState = START;
        this.onToken(NUMBER, 0);
        this.magnatude = undefined;
        this.negative = undefined;
        i--;
      }
    }else if (this.tState === NUMBER3){ // * After digit (before period)
      n = buffer[i];
      if(n === 0x2e){ // .
        this.position = 0.1; this.tState = NUMBER4;
      }else if(n === 0x65 || n === 0x45){ // e/E
        this.exponent = 0; this.tState = NUMBER6;
      }else{
        if (n >= 0x30 && n < 0x40) { this.magnatude = this.magnatude * 10 + n - 0x30; }
        else {
          this.tState = START; 
          if (this.negative) {
            this.magnatude = -this.magnatude;
            this.negative = undefined;
          }
          this.onToken(NUMBER, this.magnatude); 
          this.magnatude = undefined;
          i--;
        }
      }
    }else if (this.tState === NUMBER4){ // After period
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.magnatude += this.position * (n - 0x30);
        this.position /= 10;
        this.tState = NUMBER5; 
      } else { this.charError(buffer, i); }
    }else if (this.tState === NUMBER5){ // * After digit (after period)
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.magnatude += this.position * (n - 0x30);
        this.position /= 10;
      }
      else if (n === 0x65 || n === 0x45) { this.exponent = 0; this.tState = NUMBER6; } // E/e
      else {
        this.tState = START; 
        if (this.negative) {
          this.magnatude = -this.magnatude;
          this.negative = undefined;
        }
        this.onToken(NUMBER, this.negative ? -this.magnatude : this.magnatude); 
        this.magnatude = undefined;
        this.position = undefined;
        i--; 
      }
    }else if (this.tState === NUMBER6){ // After E
      n = buffer[i];
      if (n === 0x2b || n === 0x2d) { // +/-
        if (n === 0x2d) { this.negativeExponent = true; }
        this.tState = NUMBER7;
      }
      else if (n >= 0x30 && n < 0x40) {
        this.exponent = this.exponent * 10 + (n - 0x30);
        this.tState = NUMBER8;
      }
      else { this.charError(buffer, i); }  
    }else if (this.tState === NUMBER7){ // After +/-
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.exponent = this.exponent * 10 + (n - 0x30);
        this.tState = NUMBER8;
      }
      else { this.charError(buffer, i); }  
    }else if (this.tState === NUMBER8){ // * After digit (after +/-)
      n = buffer[i];
      if (n >= 0x30 && n < 0x40) { // 0-9
        this.exponent = this.exponent * 10 + (n - 0x30);
      }
      else {
        if (this.negativeExponent) {
          this.exponent = -this.exponent;
          this.negativeExponent = undefined;
        }
        this.magnatude *= Math.pow(10, this.exponent);
        this.exponent = undefined;
        if (this.negative) { 
          this.magnatude = -this.magnatude;
          this.negative = undefined;
        }
        this.tState = START;
        this.onToken(NUMBER, this.magnatude);
        this.magnatude = undefined;
        i--; 
      } 
    }else if (this.tState === TRUE1){ // r
      if (buffer[i] === 0x72) { this.tState = TRUE2; }
      else { this.charError(buffer, i); }
    }else if (this.tState === TRUE2){ // u
      if (buffer[i] === 0x75) { this.tState = TRUE3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === TRUE3){ // e
      if (buffer[i] === 0x65) { this.tState = START; this.onToken(TRUE, true); }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE1){ // a
      if (buffer[i] === 0x61) { this.tState = FALSE2; }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE2){ // l
      if (buffer[i] === 0x6c) { this.tState = FALSE3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE3){ // s
      if (buffer[i] === 0x73) { this.tState = FALSE4; }
      else { this.charError(buffer, i); }
    }else if (this.tState === FALSE4){ // e
      if (buffer[i] === 0x65) { this.tState = START; this.onToken(FALSE, false); }
      else { this.charError(buffer, i); }
    }else if (this.tState === NULL1){ // u
      if (buffer[i] === 0x75) { this.tState = NULL2; }
      else { this.charError(buffer, i); }
    }else if (this.tState === NULL2){ // l
      if (buffer[i] === 0x6c) { this.tState = NULL3; }
      else { this.charError(buffer, i); }
    }else if (this.tState === NULL3){ // l
      if (buffer[i] === 0x6c) { this.tState = START; this.onToken(NULL, null); }
      else { this.charError(buffer, i); }
    }
  }
};
proto.onToken = function (token, value) {
  // Override this to get events
};

proto.parseError = function (token, value) {
  this.onError(new Error("Unexpected " + toknam(token) + (value ? ("(" + JSON.stringify(value) + ")") : "") + " in state " + toknam(this.state)));
};
proto.onError = function (err) { throw err; };
proto.push = function () {
  this.stack.push({value: this.value, key: this.key, mode: this.mode});
};
proto.pop = function () {
  var value = this.value;
  var parent = this.stack.pop();
  this.value = parent.value;
  this.key = parent.key;
  this.mode = parent.mode;
  this.emit(value);
  if (!this.mode) { this.state = VALUE; }
};
proto.emit = function (value) {
  if (this.mode) { this.state = COMMA; }
  this.onValue(value);
};
proto.onValue = function (value) {
  // Override me
};  
proto.onToken = function (token, value) {
  //console.log("OnToken: state=%s token=%s %s", toknam(this.state), toknam(token), value?JSON.stringify(value):"");
  if(this.state === VALUE){
    if(token === STRING || token === NUMBER || token === TRUE || token === FALSE || token === NULL){
      if (this.value) {
        this.value[this.key] = value;
      }
      this.emit(value);  
    }else if(token === LEFT_BRACE){
      this.push();
      if (this.value) {
        this.value = this.value[this.key] = {};
      } else {
        this.value = {};
      }
      this.key = undefined;
      this.state = KEY;
      this.mode = OBJECT;
    }else if(token === LEFT_BRACKET){
      this.push();
      if (this.value) {
        this.value = this.value[this.key] = [];
      } else {
        this.value = [];
      }
      this.key = 0;
      this.mode = ARRAY;
      this.state = VALUE;
    }else if(token === RIGHT_BRACE){
      if (this.mode === OBJECT) {
        this.pop();
      } else {
        this.parseError(token, value);
      }
    }else if(token === RIGHT_BRACKET){
      if (this.mode === ARRAY) {
        this.pop();
      } else {
        this.parseError(token, value);
      }
    }else{
      this.parseError(token, value);
    }
  }else if(this.state === KEY){
    if (token === STRING) {
      this.key = value;
      this.state = COLON;
    } else if (token === RIGHT_BRACE) {
      this.pop();
    } else {
      this.parseError(token, value);
    }
  }else if(this.state === COLON){
    if (token === COLON) { this.state = VALUE; }
    else { this.parseError(token, value); }
  }else if(this.state === COMMA){
    if (token === COMMA) { 
      if (this.mode === ARRAY) { this.key++; this.state = VALUE; }
      else if (this.mode === OBJECT) { this.state = KEY; }

    } else if (token === RIGHT_BRACKET && this.mode === ARRAY || token === RIGHT_BRACE && this.mode === OBJECT) {
      this.pop();
    } else {
      this.parseError(token, value);
    }
  }else{
    this.parseError(token, value);
  }
};

module.exports = Parser;

}).call(this,_dereq_("buffer").Buffer)
},{"buffer":23}],20:[function(_dereq_,module,exports){
/**
 * Standalone extraction of Backbone.Events, no external dependency required.
 * Degrades nicely when Backone/underscore are already available in the current
 * global context.
 *
 * Note that docs suggest to use underscore's `_.extend()` method to add Events
 * support to some given object. A `mixin()` method has been added to the Events
 * prototype to avoid using underscore for that sole purpose:
 *
 *     var myEventEmitter = BackboneEvents.mixin({});
 *
 * Or for a function constructor:
 *
 *     function MyConstructor(){}
 *     MyConstructor.prototype.foo = function(){}
 *     BackboneEvents.mixin(MyConstructor.prototype);
 *
 * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * (c) 2013 Nicolas Perriault
 */
/* global exports:true, define, module */
(function() {
  var root = this,
      breaker = {},
      nativeForEach = Array.prototype.forEach,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      slice = Array.prototype.slice,
      idCounter = 0;

  // Returns a partial implementation matching the minimal API subset required
  // by Backbone.Events
  function miniscore() {
    return {
      keys: Object.keys || function (obj) {
        if (typeof obj !== "object" && typeof obj !== "function" || obj === null) {
          throw new TypeError("keys() called on a non-object");
        }
        var key, keys = [];
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            keys[keys.length] = key;
          }
        }
        return keys;
      },

      uniqueId: function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      },

      has: function(obj, key) {
        return hasOwnProperty.call(obj, key);
      },

      each: function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, l = obj.length; i < l; i++) {
            if (iterator.call(context, obj[i], i, obj) === breaker) return;
          }
        } else {
          for (var key in obj) {
            if (this.has(obj, key)) {
              if (iterator.call(context, obj[key], key, obj) === breaker) return;
            }
          }
        }
      },

      once: function(func) {
        var ran = false, memo;
        return function() {
          if (ran) return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      }
    };
  }

  var _ = miniscore(), Events;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Mixin utility
  Events.mixin = function(proto) {
    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo',
                   'listenToOnce', 'bind', 'unbind'];
    _.each(exports, function(name) {
      proto[name] = this[name];
    }, this);
    return proto;
  };

  // Export Events as BackboneEvents depending on current context
  if (typeof define === "function") {
    define(function() {
      return Events;
    });
  } else if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Events;
    }
    exports.BackboneEvents = Events;
  } else {
    root.BackboneEvents = Events;
  }
})(this);

},{}],21:[function(_dereq_,module,exports){
module.exports = _dereq_('./backbone-events-standalone');

},{"./backbone-events-standalone":20}],22:[function(_dereq_,module,exports){
(function (process,global){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE
 * @version   2.0.1
 */

(function() {
    "use strict";

    function $$utils$$objectOrFunction(x) {
      return typeof x === 'function' || (typeof x === 'object' && x !== null);
    }

    function $$utils$$isFunction(x) {
      return typeof x === 'function';
    }

    function $$utils$$isMaybeThenable(x) {
      return typeof x === 'object' && x !== null;
    }

    var $$utils$$_isArray;

    if (!Array.isArray) {
      $$utils$$_isArray = function (x) {
        return Object.prototype.toString.call(x) === '[object Array]';
      };
    } else {
      $$utils$$_isArray = Array.isArray;
    }

    var $$utils$$isArray = $$utils$$_isArray;
    var $$utils$$now = Date.now || function() { return new Date().getTime(); };
    function $$utils$$F() { }

    var $$utils$$o_create = (Object.create || function (o) {
      if (arguments.length > 1) {
        throw new Error('Second argument not supported');
      }
      if (typeof o !== 'object') {
        throw new TypeError('Argument must be an object');
      }
      $$utils$$F.prototype = o;
      return new $$utils$$F();
    });

    var $$asap$$len = 0;

    var $$asap$$default = function asap(callback, arg) {
      $$asap$$queue[$$asap$$len] = callback;
      $$asap$$queue[$$asap$$len + 1] = arg;
      $$asap$$len += 2;
      if ($$asap$$len === 2) {
        // If len is 1, that means that we need to schedule an async flush.
        // If additional callbacks are queued before the queue is flushed, they
        // will be processed by this flush that we are scheduling.
        $$asap$$scheduleFlush();
      }
    };

    var $$asap$$browserGlobal = (typeof window !== 'undefined') ? window : {};
    var $$asap$$BrowserMutationObserver = $$asap$$browserGlobal.MutationObserver || $$asap$$browserGlobal.WebKitMutationObserver;

    // test for web worker but not in IE10
    var $$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&
      typeof importScripts !== 'undefined' &&
      typeof MessageChannel !== 'undefined';

    // node
    function $$asap$$useNextTick() {
      return function() {
        process.nextTick($$asap$$flush);
      };
    }

    function $$asap$$useMutationObserver() {
      var iterations = 0;
      var observer = new $$asap$$BrowserMutationObserver($$asap$$flush);
      var node = document.createTextNode('');
      observer.observe(node, { characterData: true });

      return function() {
        node.data = (iterations = ++iterations % 2);
      };
    }

    // web worker
    function $$asap$$useMessageChannel() {
      var channel = new MessageChannel();
      channel.port1.onmessage = $$asap$$flush;
      return function () {
        channel.port2.postMessage(0);
      };
    }

    function $$asap$$useSetTimeout() {
      return function() {
        setTimeout($$asap$$flush, 1);
      };
    }

    var $$asap$$queue = new Array(1000);

    function $$asap$$flush() {
      for (var i = 0; i < $$asap$$len; i+=2) {
        var callback = $$asap$$queue[i];
        var arg = $$asap$$queue[i+1];

        callback(arg);

        $$asap$$queue[i] = undefined;
        $$asap$$queue[i+1] = undefined;
      }

      $$asap$$len = 0;
    }

    var $$asap$$scheduleFlush;

    // Decide what async method to use to triggering processing of queued callbacks:
    if (typeof process !== 'undefined' && {}.toString.call(process) === '[object process]') {
      $$asap$$scheduleFlush = $$asap$$useNextTick();
    } else if ($$asap$$BrowserMutationObserver) {
      $$asap$$scheduleFlush = $$asap$$useMutationObserver();
    } else if ($$asap$$isWorker) {
      $$asap$$scheduleFlush = $$asap$$useMessageChannel();
    } else {
      $$asap$$scheduleFlush = $$asap$$useSetTimeout();
    }

    function $$$internal$$noop() {}
    var $$$internal$$PENDING   = void 0;
    var $$$internal$$FULFILLED = 1;
    var $$$internal$$REJECTED  = 2;
    var $$$internal$$GET_THEN_ERROR = new $$$internal$$ErrorObject();

    function $$$internal$$selfFullfillment() {
      return new TypeError("You cannot resolve a promise with itself");
    }

    function $$$internal$$cannotReturnOwn() {
      return new TypeError('A promises callback cannot return that same promise.')
    }

    function $$$internal$$getThen(promise) {
      try {
        return promise.then;
      } catch(error) {
        $$$internal$$GET_THEN_ERROR.error = error;
        return $$$internal$$GET_THEN_ERROR;
      }
    }

    function $$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {
      try {
        then.call(value, fulfillmentHandler, rejectionHandler);
      } catch(e) {
        return e;
      }
    }

    function $$$internal$$handleForeignThenable(promise, thenable, then) {
       $$asap$$default(function(promise) {
        var sealed = false;
        var error = $$$internal$$tryThen(then, thenable, function(value) {
          if (sealed) { return; }
          sealed = true;
          if (thenable !== value) {
            $$$internal$$resolve(promise, value);
          } else {
            $$$internal$$fulfill(promise, value);
          }
        }, function(reason) {
          if (sealed) { return; }
          sealed = true;

          $$$internal$$reject(promise, reason);
        }, 'Settle: ' + (promise._label || ' unknown promise'));

        if (!sealed && error) {
          sealed = true;
          $$$internal$$reject(promise, error);
        }
      }, promise);
    }

    function $$$internal$$handleOwnThenable(promise, thenable) {
      if (thenable._state === $$$internal$$FULFILLED) {
        $$$internal$$fulfill(promise, thenable._result);
      } else if (promise._state === $$$internal$$REJECTED) {
        $$$internal$$reject(promise, thenable._result);
      } else {
        $$$internal$$subscribe(thenable, undefined, function(value) {
          $$$internal$$resolve(promise, value);
        }, function(reason) {
          $$$internal$$reject(promise, reason);
        });
      }
    }

    function $$$internal$$handleMaybeThenable(promise, maybeThenable) {
      if (maybeThenable.constructor === promise.constructor) {
        $$$internal$$handleOwnThenable(promise, maybeThenable);
      } else {
        var then = $$$internal$$getThen(maybeThenable);

        if (then === $$$internal$$GET_THEN_ERROR) {
          $$$internal$$reject(promise, $$$internal$$GET_THEN_ERROR.error);
        } else if (then === undefined) {
          $$$internal$$fulfill(promise, maybeThenable);
        } else if ($$utils$$isFunction(then)) {
          $$$internal$$handleForeignThenable(promise, maybeThenable, then);
        } else {
          $$$internal$$fulfill(promise, maybeThenable);
        }
      }
    }

    function $$$internal$$resolve(promise, value) {
      if (promise === value) {
        $$$internal$$reject(promise, $$$internal$$selfFullfillment());
      } else if ($$utils$$objectOrFunction(value)) {
        $$$internal$$handleMaybeThenable(promise, value);
      } else {
        $$$internal$$fulfill(promise, value);
      }
    }

    function $$$internal$$publishRejection(promise) {
      if (promise._onerror) {
        promise._onerror(promise._result);
      }

      $$$internal$$publish(promise);
    }

    function $$$internal$$fulfill(promise, value) {
      if (promise._state !== $$$internal$$PENDING) { return; }

      promise._result = value;
      promise._state = $$$internal$$FULFILLED;

      if (promise._subscribers.length === 0) {
      } else {
        $$asap$$default($$$internal$$publish, promise);
      }
    }

    function $$$internal$$reject(promise, reason) {
      if (promise._state !== $$$internal$$PENDING) { return; }
      promise._state = $$$internal$$REJECTED;
      promise._result = reason;

      $$asap$$default($$$internal$$publishRejection, promise);
    }

    function $$$internal$$subscribe(parent, child, onFulfillment, onRejection) {
      var subscribers = parent._subscribers;
      var length = subscribers.length;

      parent._onerror = null;

      subscribers[length] = child;
      subscribers[length + $$$internal$$FULFILLED] = onFulfillment;
      subscribers[length + $$$internal$$REJECTED]  = onRejection;

      if (length === 0 && parent._state) {
        $$asap$$default($$$internal$$publish, parent);
      }
    }

    function $$$internal$$publish(promise) {
      var subscribers = promise._subscribers;
      var settled = promise._state;

      if (subscribers.length === 0) { return; }

      var child, callback, detail = promise._result;

      for (var i = 0; i < subscribers.length; i += 3) {
        child = subscribers[i];
        callback = subscribers[i + settled];

        if (child) {
          $$$internal$$invokeCallback(settled, child, callback, detail);
        } else {
          callback(detail);
        }
      }

      promise._subscribers.length = 0;
    }

    function $$$internal$$ErrorObject() {
      this.error = null;
    }

    var $$$internal$$TRY_CATCH_ERROR = new $$$internal$$ErrorObject();

    function $$$internal$$tryCatch(callback, detail) {
      try {
        return callback(detail);
      } catch(e) {
        $$$internal$$TRY_CATCH_ERROR.error = e;
        return $$$internal$$TRY_CATCH_ERROR;
      }
    }

    function $$$internal$$invokeCallback(settled, promise, callback, detail) {
      var hasCallback = $$utils$$isFunction(callback),
          value, error, succeeded, failed;

      if (hasCallback) {
        value = $$$internal$$tryCatch(callback, detail);

        if (value === $$$internal$$TRY_CATCH_ERROR) {
          failed = true;
          error = value.error;
          value = null;
        } else {
          succeeded = true;
        }

        if (promise === value) {
          $$$internal$$reject(promise, $$$internal$$cannotReturnOwn());
          return;
        }

      } else {
        value = detail;
        succeeded = true;
      }

      if (promise._state !== $$$internal$$PENDING) {
        // noop
      } else if (hasCallback && succeeded) {
        $$$internal$$resolve(promise, value);
      } else if (failed) {
        $$$internal$$reject(promise, error);
      } else if (settled === $$$internal$$FULFILLED) {
        $$$internal$$fulfill(promise, value);
      } else if (settled === $$$internal$$REJECTED) {
        $$$internal$$reject(promise, value);
      }
    }

    function $$$internal$$initializePromise(promise, resolver) {
      try {
        resolver(function resolvePromise(value){
          $$$internal$$resolve(promise, value);
        }, function rejectPromise(reason) {
          $$$internal$$reject(promise, reason);
        });
      } catch(e) {
        $$$internal$$reject(promise, e);
      }
    }

    function $$$enumerator$$makeSettledResult(state, position, value) {
      if (state === $$$internal$$FULFILLED) {
        return {
          state: 'fulfilled',
          value: value
        };
      } else {
        return {
          state: 'rejected',
          reason: value
        };
      }
    }

    function $$$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {
      this._instanceConstructor = Constructor;
      this.promise = new Constructor($$$internal$$noop, label);
      this._abortOnReject = abortOnReject;

      if (this._validateInput(input)) {
        this._input     = input;
        this.length     = input.length;
        this._remaining = input.length;

        this._init();

        if (this.length === 0) {
          $$$internal$$fulfill(this.promise, this._result);
        } else {
          this.length = this.length || 0;
          this._enumerate();
          if (this._remaining === 0) {
            $$$internal$$fulfill(this.promise, this._result);
          }
        }
      } else {
        $$$internal$$reject(this.promise, this._validationError());
      }
    }

    $$$enumerator$$Enumerator.prototype._validateInput = function(input) {
      return $$utils$$isArray(input);
    };

    $$$enumerator$$Enumerator.prototype._validationError = function() {
      return new Error('Array Methods must be provided an Array');
    };

    $$$enumerator$$Enumerator.prototype._init = function() {
      this._result = new Array(this.length);
    };

    var $$$enumerator$$default = $$$enumerator$$Enumerator;

    $$$enumerator$$Enumerator.prototype._enumerate = function() {
      var length  = this.length;
      var promise = this.promise;
      var input   = this._input;

      for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {
        this._eachEntry(input[i], i);
      }
    };

    $$$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {
      var c = this._instanceConstructor;
      if ($$utils$$isMaybeThenable(entry)) {
        if (entry.constructor === c && entry._state !== $$$internal$$PENDING) {
          entry._onerror = null;
          this._settledAt(entry._state, i, entry._result);
        } else {
          this._willSettleAt(c.resolve(entry), i);
        }
      } else {
        this._remaining--;
        this._result[i] = this._makeResult($$$internal$$FULFILLED, i, entry);
      }
    };

    $$$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {
      var promise = this.promise;

      if (promise._state === $$$internal$$PENDING) {
        this._remaining--;

        if (this._abortOnReject && state === $$$internal$$REJECTED) {
          $$$internal$$reject(promise, value);
        } else {
          this._result[i] = this._makeResult(state, i, value);
        }
      }

      if (this._remaining === 0) {
        $$$internal$$fulfill(promise, this._result);
      }
    };

    $$$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {
      return value;
    };

    $$$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {
      var enumerator = this;

      $$$internal$$subscribe(promise, undefined, function(value) {
        enumerator._settledAt($$$internal$$FULFILLED, i, value);
      }, function(reason) {
        enumerator._settledAt($$$internal$$REJECTED, i, reason);
      });
    };

    var $$promise$all$$default = function all(entries, label) {
      return new $$$enumerator$$default(this, entries, true /* abort on reject */, label).promise;
    };

    var $$promise$race$$default = function race(entries, label) {
      /*jshint validthis:true */
      var Constructor = this;

      var promise = new Constructor($$$internal$$noop, label);

      if (!$$utils$$isArray(entries)) {
        $$$internal$$reject(promise, new TypeError('You must pass an array to race.'));
        return promise;
      }

      var length = entries.length;

      function onFulfillment(value) {
        $$$internal$$resolve(promise, value);
      }

      function onRejection(reason) {
        $$$internal$$reject(promise, reason);
      }

      for (var i = 0; promise._state === $$$internal$$PENDING && i < length; i++) {
        $$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);
      }

      return promise;
    };

    var $$promise$resolve$$default = function resolve(object, label) {
      /*jshint validthis:true */
      var Constructor = this;

      if (object && typeof object === 'object' && object.constructor === Constructor) {
        return object;
      }

      var promise = new Constructor($$$internal$$noop, label);
      $$$internal$$resolve(promise, object);
      return promise;
    };

    var $$promise$reject$$default = function reject(reason, label) {
      /*jshint validthis:true */
      var Constructor = this;
      var promise = new Constructor($$$internal$$noop, label);
      $$$internal$$reject(promise, reason);
      return promise;
    };

    var $$es6$promise$promise$$counter = 0;

    function $$es6$promise$promise$$needsResolver() {
      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
    }

    function $$es6$promise$promise$$needsNew() {
      throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }

    var $$es6$promise$promise$$default = $$es6$promise$promise$$Promise;

    /**
      Promise objects represent the eventual result of an asynchronous operation. The
      primary way of interacting with a promise is through its `then` method, which
      registers callbacks to receive either a promise’s eventual value or the reason
      why the promise cannot be fulfilled.

      Terminology
      -----------

      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
      - `thenable` is an object or function that defines a `then` method.
      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
      - `exception` is a value that is thrown using the throw statement.
      - `reason` is a value that indicates why a promise was rejected.
      - `settled` the final resting state of a promise, fulfilled or rejected.

      A promise can be in one of three states: pending, fulfilled, or rejected.

      Promises that are fulfilled have a fulfillment value and are in the fulfilled
      state.  Promises that are rejected have a rejection reason and are in the
      rejected state.  A fulfillment value is never a thenable.

      Promises can also be said to *resolve* a value.  If this value is also a
      promise, then the original promise's settled state will match the value's
      settled state.  So a promise that *resolves* a promise that rejects will
      itself reject, and a promise that *resolves* a promise that fulfills will
      itself fulfill.


      Basic Usage:
      ------------

      ```js
      var promise = new Promise(function(resolve, reject) {
        // on success
        resolve(value);

        // on failure
        reject(reason);
      });

      promise.then(function(value) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Advanced Usage:
      ---------------

      Promises shine when abstracting away asynchronous interactions such as
      `XMLHttpRequest`s.

      ```js
      function getJSON(url) {
        return new Promise(function(resolve, reject){
          var xhr = new XMLHttpRequest();

          xhr.open('GET', url);
          xhr.onreadystatechange = handler;
          xhr.responseType = 'json';
          xhr.setRequestHeader('Accept', 'application/json');
          xhr.send();

          function handler() {
            if (this.readyState === this.DONE) {
              if (this.status === 200) {
                resolve(this.response);
              } else {
                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
              }
            }
          };
        });
      }

      getJSON('/posts.json').then(function(json) {
        // on fulfillment
      }, function(reason) {
        // on rejection
      });
      ```

      Unlike callbacks, promises are great composable primitives.

      ```js
      Promise.all([
        getJSON('/posts'),
        getJSON('/comments')
      ]).then(function(values){
        values[0] // => postsJSON
        values[1] // => commentsJSON

        return values;
      });
      ```

      @class Promise
      @param {function} resolver
      Useful for tooling.
      @constructor
    */
    function $$es6$promise$promise$$Promise(resolver) {
      this._id = $$es6$promise$promise$$counter++;
      this._state = undefined;
      this._result = undefined;
      this._subscribers = [];

      if ($$$internal$$noop !== resolver) {
        if (!$$utils$$isFunction(resolver)) {
          $$es6$promise$promise$$needsResolver();
        }

        if (!(this instanceof $$es6$promise$promise$$Promise)) {
          $$es6$promise$promise$$needsNew();
        }

        $$$internal$$initializePromise(this, resolver);
      }
    }

    $$es6$promise$promise$$Promise.all = $$promise$all$$default;
    $$es6$promise$promise$$Promise.race = $$promise$race$$default;
    $$es6$promise$promise$$Promise.resolve = $$promise$resolve$$default;
    $$es6$promise$promise$$Promise.reject = $$promise$reject$$default;

    $$es6$promise$promise$$Promise.prototype = {
      constructor: $$es6$promise$promise$$Promise,

    /**
      The primary way of interacting with a promise is through its `then` method,
      which registers callbacks to receive either a promise's eventual value or the
      reason why the promise cannot be fulfilled.

      ```js
      findUser().then(function(user){
        // user is available
      }, function(reason){
        // user is unavailable, and you are given the reason why
      });
      ```

      Chaining
      --------

      The return value of `then` is itself a promise.  This second, 'downstream'
      promise is resolved with the return value of the first promise's fulfillment
      or rejection handler, or rejected if the handler throws an exception.

      ```js
      findUser().then(function (user) {
        return user.name;
      }, function (reason) {
        return 'default name';
      }).then(function (userName) {
        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
        // will be `'default name'`
      });

      findUser().then(function (user) {
        throw new Error('Found user, but still unhappy');
      }, function (reason) {
        throw new Error('`findUser` rejected and we're unhappy');
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
      });
      ```
      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.

      ```js
      findUser().then(function (user) {
        throw new PedagogicalException('Upstream error');
      }).then(function (value) {
        // never reached
      }).then(function (value) {
        // never reached
      }, function (reason) {
        // The `PedgagocialException` is propagated all the way down to here
      });
      ```

      Assimilation
      ------------

      Sometimes the value you want to propagate to a downstream promise can only be
      retrieved asynchronously. This can be achieved by returning a promise in the
      fulfillment or rejection handler. The downstream promise will then be pending
      until the returned promise is settled. This is called *assimilation*.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // The user's comments are now available
      });
      ```

      If the assimliated promise rejects, then the downstream promise will also reject.

      ```js
      findUser().then(function (user) {
        return findCommentsByAuthor(user);
      }).then(function (comments) {
        // If `findCommentsByAuthor` fulfills, we'll have the value here
      }, function (reason) {
        // If `findCommentsByAuthor` rejects, we'll have the reason here
      });
      ```

      Simple Example
      --------------

      Synchronous Example

      ```javascript
      var result;

      try {
        result = findResult();
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js
      findResult(function(result, err){
        if (err) {
          // failure
        } else {
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findResult().then(function(result){
        // success
      }, function(reason){
        // failure
      });
      ```

      Advanced Example
      --------------

      Synchronous Example

      ```javascript
      var author, books;

      try {
        author = findAuthor();
        books  = findBooksByAuthor(author);
        // success
      } catch(reason) {
        // failure
      }
      ```

      Errback Example

      ```js

      function foundBooks(books) {

      }

      function failure(reason) {

      }

      findAuthor(function(author, err){
        if (err) {
          failure(err);
          // failure
        } else {
          try {
            findBoooksByAuthor(author, function(books, err) {
              if (err) {
                failure(err);
              } else {
                try {
                  foundBooks(books);
                } catch(reason) {
                  failure(reason);
                }
              }
            });
          } catch(error) {
            failure(err);
          }
          // success
        }
      });
      ```

      Promise Example;

      ```javascript
      findAuthor().
        then(findBooksByAuthor).
        then(function(books){
          // found books
      }).catch(function(reason){
        // something went wrong
      });
      ```

      @method then
      @param {Function} onFulfilled
      @param {Function} onRejected
      Useful for tooling.
      @return {Promise}
    */
      then: function(onFulfillment, onRejection) {
        var parent = this;
        var state = parent._state;

        if (state === $$$internal$$FULFILLED && !onFulfillment || state === $$$internal$$REJECTED && !onRejection) {
          return this;
        }

        var child = new this.constructor($$$internal$$noop);
        var result = parent._result;

        if (state) {
          var callback = arguments[state - 1];
          $$asap$$default(function(){
            $$$internal$$invokeCallback(state, child, callback, result);
          });
        } else {
          $$$internal$$subscribe(parent, child, onFulfillment, onRejection);
        }

        return child;
      },

    /**
      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
      as the catch block of a try/catch statement.

      ```js
      function findAuthor(){
        throw new Error('couldn't find that author');
      }

      // synchronous
      try {
        findAuthor();
      } catch(reason) {
        // something went wrong
      }

      // async with promises
      findAuthor().catch(function(reason){
        // something went wrong
      });
      ```

      @method catch
      @param {Function} onRejection
      Useful for tooling.
      @return {Promise}
    */
      'catch': function(onRejection) {
        return this.then(null, onRejection);
      }
    };

    var $$es6$promise$polyfill$$default = function polyfill() {
      var local;

      if (typeof global !== 'undefined') {
        local = global;
      } else if (typeof window !== 'undefined' && window.document) {
        local = window;
      } else {
        local = self;
      }

      var es6PromiseSupport =
        "Promise" in local &&
        // Some of these methods are missing from
        // Firefox/Chrome experimental implementations
        "resolve" in local.Promise &&
        "reject" in local.Promise &&
        "all" in local.Promise &&
        "race" in local.Promise &&
        // Older version of the spec had a resolver object
        // as the arg rather than a function
        (function() {
          var resolve;
          new local.Promise(function(r) { resolve = r; });
          return $$utils$$isFunction(resolve);
        }());

      if (!es6PromiseSupport) {
        local.Promise = $$es6$promise$promise$$default;
      }
    };

    var es6$promise$umd$$ES6Promise = {
      'Promise': $$es6$promise$promise$$default,
      'polyfill': $$es6$promise$polyfill$$default
    };

    /* global define:true module:true window: true */
    if (typeof define === 'function' && define['amd']) {
      define(function() { return es6$promise$umd$$ES6Promise; });
    } else if (typeof module !== 'undefined' && module['exports']) {
      module['exports'] = es6$promise$umd$$ES6Promise;
    } else if (typeof this !== 'undefined') {
      this['ES6Promise'] = es6$promise$umd$$ES6Promise;
    }
}).call(this);
}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55}],23:[function(_dereq_,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = _dereq_('base64-js')
var ieee754 = _dereq_('ieee754')
var isArray = _dereq_('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":24,"ieee754":25,"is-array":26}],24:[function(_dereq_,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],25:[function(_dereq_,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],26:[function(_dereq_,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],27:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],28:[function(_dereq_,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],29:[function(_dereq_,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],30:[function(_dereq_,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],31:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],32:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],33:[function(_dereq_,module,exports){
'use strict';

exports.decode = exports.parse = _dereq_('./decode');
exports.encode = exports.stringify = _dereq_('./encode');

},{"./decode":31,"./encode":32}],34:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":35}],35:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Readable = _dereq_('./_stream_readable');
var Writable = _dereq_('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./_stream_readable":37,"./_stream_writable":39,"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"core-util-is":40,"inherits":28}],36:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = _dereq_('./_stream_transform');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":38,"core-util-is":40,"inherits":28}],37:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = _dereq_('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = _dereq_('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = _dereq_('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = _dereq_('stream');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = _dereq_('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = _dereq_('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"buffer":23,"core-util-is":40,"events":27,"inherits":28,"isarray":29,"stream":45,"string_decoder/":46}],38:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = _dereq_('./_stream_duplex');

/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":35,"core-util-is":40,"inherits":28}],39:[function(_dereq_,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = _dereq_('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = _dereq_('core-util-is');
util.inherits = _dereq_('inherits');
/*</replacement>*/

var Stream = _dereq_('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = _dereq_('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"./_stream_duplex":35,"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"buffer":23,"core-util-is":40,"inherits":28,"stream":45}],40:[function(_dereq_,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,_dereq_("buffer").Buffer)
},{"buffer":23}],41:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":36}],42:[function(_dereq_,module,exports){
var Stream = _dereq_('stream'); // hack to fix a circular dependency issue when used with browserify
exports = module.exports = _dereq_('./lib/_stream_readable.js');
exports.Stream = Stream;
exports.Readable = exports;
exports.Writable = _dereq_('./lib/_stream_writable.js');
exports.Duplex = _dereq_('./lib/_stream_duplex.js');
exports.Transform = _dereq_('./lib/_stream_transform.js');
exports.PassThrough = _dereq_('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":35,"./lib/_stream_passthrough.js":36,"./lib/_stream_readable.js":37,"./lib/_stream_transform.js":38,"./lib/_stream_writable.js":39,"stream":45}],43:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":38}],44:[function(_dereq_,module,exports){
module.exports = _dereq_("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":39}],45:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = _dereq_('events').EventEmitter;
var inherits = _dereq_('inherits');

inherits(Stream, EE);
Stream.Readable = _dereq_('readable-stream/readable.js');
Stream.Writable = _dereq_('readable-stream/writable.js');
Stream.Duplex = _dereq_('readable-stream/duplex.js');
Stream.Transform = _dereq_('readable-stream/transform.js');
Stream.PassThrough = _dereq_('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":27,"inherits":28,"readable-stream/duplex.js":34,"readable-stream/passthrough.js":41,"readable-stream/readable.js":42,"readable-stream/transform.js":43,"readable-stream/writable.js":44}],46:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = _dereq_('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":23}],47:[function(_dereq_,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = _dereq_('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = _dereq_('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":30,"querystring":33}],48:[function(_dereq_,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],49:[function(_dereq_,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = _dereq_('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = _dereq_('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":48,"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"inherits":28}],50:[function(_dereq_,module,exports){
var http = module.exports;
var EventEmitter = _dereq_('events').EventEmitter;
var Request = _dereq_('./lib/request');
var url = _dereq_('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }

    if (!params.protocol) {
        if (params.scheme) {
            params.protocol = params.scheme + ':';
        } else {
            params.protocol = window.location.protocol;
        }
    }

    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

http.STATUS_CODES = {
    100 : 'Continue',
    101 : 'Switching Protocols',
    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
    200 : 'OK',
    201 : 'Created',
    202 : 'Accepted',
    203 : 'Non-Authoritative Information',
    204 : 'No Content',
    205 : 'Reset Content',
    206 : 'Partial Content',
    207 : 'Multi-Status',               // RFC 4918
    300 : 'Multiple Choices',
    301 : 'Moved Permanently',
    302 : 'Moved Temporarily',
    303 : 'See Other',
    304 : 'Not Modified',
    305 : 'Use Proxy',
    307 : 'Temporary Redirect',
    400 : 'Bad Request',
    401 : 'Unauthorized',
    402 : 'Payment Required',
    403 : 'Forbidden',
    404 : 'Not Found',
    405 : 'Method Not Allowed',
    406 : 'Not Acceptable',
    407 : 'Proxy Authentication Required',
    408 : 'Request Time-out',
    409 : 'Conflict',
    410 : 'Gone',
    411 : 'Length Required',
    412 : 'Precondition Failed',
    413 : 'Request Entity Too Large',
    414 : 'Request-URI Too Large',
    415 : 'Unsupported Media Type',
    416 : 'Requested Range Not Satisfiable',
    417 : 'Expectation Failed',
    418 : 'I\'m a teapot',              // RFC 2324
    422 : 'Unprocessable Entity',       // RFC 4918
    423 : 'Locked',                     // RFC 4918
    424 : 'Failed Dependency',          // RFC 4918
    425 : 'Unordered Collection',       // RFC 4918
    426 : 'Upgrade Required',           // RFC 2817
    428 : 'Precondition Required',      // RFC 6585
    429 : 'Too Many Requests',          // RFC 6585
    431 : 'Request Header Fields Too Large',// RFC 6585
    500 : 'Internal Server Error',
    501 : 'Not Implemented',
    502 : 'Bad Gateway',
    503 : 'Service Unavailable',
    504 : 'Gateway Time-out',
    505 : 'HTTP Version Not Supported',
    506 : 'Variant Also Negotiates',    // RFC 2295
    507 : 'Insufficient Storage',       // RFC 4918
    509 : 'Bandwidth Limit Exceeded',
    510 : 'Not Extended',               // RFC 2774
    511 : 'Network Authentication Required' // RFC 6585
};
},{"./lib/request":51,"events":27,"url":47}],51:[function(_dereq_,module,exports){
var Stream = _dereq_('stream');
var Response = _dereq_('./response');
var Base64 = _dereq_('Base64');
var inherits = _dereq_('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.protocol || 'http:') + '//'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    if (typeof params.withCredentials === 'undefined') {
        params.withCredentials = true;
    }

    try { xhr.withCredentials = params.withCredentials }
    catch (e) {}
    
    if (params.responseType) try { xhr.responseType = params.responseType }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );

    xhr.onerror = function(event) {
        self.emit('error', new Error('Network error'));
    };

    self._headers = {};
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            self.setHeader(key, value);
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });

    res.on('error', function (err) {
        self.emit('error', err);
    });
    
    xhr.onreadystatechange = function () {
        // Fix for IE9 bug
        // SCRIPT575: Could not complete the operation due to error c00c023f
        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
        if (xhr.__aborted) return;
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    this._headers[key.toLowerCase()] = value
};

Request.prototype.getHeader = function (key) {
    return this._headers[key.toLowerCase()]
};

Request.prototype.removeHeader = function (key) {
    delete this._headers[key.toLowerCase()]
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);

    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = this._headers[key];
        if (isArray(value)) {
            for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
            }
        }
        else this.xhr.setRequestHeader(key, value)
    }

    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else if (isXHR2Compatible(this.body[0])) {
        this.xhr.send(this.body[0]);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

var isXHR2Compatible = function (obj) {
    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
};

},{"./response":52,"Base64":53,"inherits":54,"stream":45}],52:[function(_dereq_,module,exports){
var Stream = _dereq_('stream');
var util = _dereq_('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":45,"util":49}],53:[function(_dereq_,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],54:[function(_dereq_,module,exports){
module.exports=_dereq_(28)
},{"/home/alex/projects/javascript/imjs/node_modules/grunt-browserify/node_modules/browserify/node_modules/inherits/inherits_browser.js":28}],55:[function(_dereq_,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.once = noop;
process.off = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],56:[function(_dereq_,module,exports){
(function (process){
var Stream = _dereq_('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data == null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this,_dereq_("/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js"))
},{"/home/alex/projects/javascript/imjs/node_modules/insert-module-globals/node_modules/process/browser.js":55,"stream":45}]},{},[2])(2)
});
})(window.intermine);
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],7:[function(require,module,exports){
var cymine = {
  toNodesAndEdges : function(records, parentNode){
    var d = {
      nodes : [],
      edges : []
    };

    for (var i in records) {
      var thisNode, row = records[i];
      thisNode = this.recordToNode(row);

      if(row.interactions) {
        //recursively make the interactions into nodes,
        //because node entities are nested at two levels.
        d = this.mergeObjects(d, this.toNodesAndEdges(row.interactions, thisNode));
      } else {
        //if it doesn't have an interaction list, it probably *is* an interaction
        //and thus needs to be an edge
        d.edges.push(this.interactionToEdge(parentNode, thisNode));

      }
      d.nodes.push(thisNode);

    }

    return d;
  },
  recordToNode : function (obj) {
    var ret;
    ret = obj.gene2 ? obj.gene2 : obj;
    return {
      data : {
        details : this.addDetails(obj),
        label   : this.nameNode(obj),
        class   : ret.class,
        symbol  : ret.symbol,
        id : ret.objectId.toString() //cytoscape needs strings, not ints
      }
    }
  },
  addDetails : function(obj) {
    return obj.details ? obj.details[0] : {};
  },
  nameNode : function(obj) {
    if (obj.gene2 && obj.gene2.symbol) {
      return obj.gene2.symbol;
    } else if (obj.symbol) {
      return obj.symbol;
    } else if (obj.details) {
      return obj.details[0].name;
    } else {
      return "NAME MISSING"
    }
  },
  interactionToEdge : function(node, node2) {
    //todo: we almost certainly want to add more complexity to the return object
    return {
      data : {
        source : node.data.id,
        target : node2.data.id
      }
    };
  },
  /**
  * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
  * @param obj1
  * @param obj2
  * @returns obj3 a new object based on obj1 and obj2
  */

  //TODO: make sure we handle edge cases better, e.g. duplicate values.
  mergeObjects : function(obj1,obj2){
    var obj3 = {};
    for (var attrname in obj1) { obj3[attrname] = obj1[attrname]; }
    for (var attrname in obj2) { obj3[attrname] = obj2[attrname]; }
    return obj3;
  }

};

module.exports = cymine;

},{}],8:[function(require,module,exports){
var cymine = require('./cymine'),
cytoscape = require('./../bower_components/cytoscape/dist/cytoscape'),
imjs = require('./../bower_components/imjs/js/im.js'),
nodeDataDisplay = require('./nodeDataDisplay');

//Todo: generify query.
var cy, humanmine = new imjs.Service({root: 'www.humanmine.org/humanmine'}),
query = {
  "name": "Gene_Interactions",
  "title": "Gene --> Interactions",
  "description": "Show all interactions for a given gene.",
  "constraintLogic": "A and B",
  "from": "Gene",
  "select": [
    "symbol",
    "interactions.gene2.symbol",
    "interactions.details.name",
    "interactions.details.role1",
    "interactions.details.role2",
    "interactions.details.type",
    "interactions.details.experiment.interactionDetectionMethods.name",
    "interactions.details.experiment.publication.pubMedId",
    "interactions.details.relationshipType.name",
    "interactions.details.dataSets.name"
  ],
  "orderBy": [
    {
      "path": "symbol",
      "direction": "ASC"
    }
  ],
  "where": [
    {
      "path": "Gene",
      "op": "LOOKUP",
      "value": "PPARG",
      "extraValue": "H. sapiens",
      "code": "A",
      "editable": true,
      "switched": "LOCKED",
      "switchable": false
    }
  ]
};

humanmine.records(query).then(function(response) {
  if (response) {
    try {

      var graph = {};
        graph.data = cymine.toNodesAndEdges(response),
        graph.targetElem = document.getElementById('cy'),
        graph.statusBar = graph.targetElem.querySelector('.status');

      console.debug('response:', response, 'graph data', graph.data);

      cy = cytoscape({
        container: graph.targetElem,
        layout: { name: 'cose'},
        style: cytoscape.stylesheet()
    .selector('node')
      .css({
        'content': 'data(label)'
      })
    .selector(':selected')
      .css({
        'background-color': 'black',
        'line-color': 'black',
        'target-arrow-color': 'black',
        'source-arrow-color': 'black',
        'text-outline-color': 'black'
      }),
        elements: graph.data,
        ready: function(){
          window.cy = this;
          graph.statusBar.remove();
        }
      });

      cy.on('tap', 'node', function(){
        nodeDataDisplay.display(this.data());
      });


    } catch(e) {console.error(e);}
  } else {
    //todo make sure error handling works
    graph.statusBar.class = "status no-results";
  }
});

},{"./../bower_components/cytoscape/dist/cytoscape":5,"./../bower_components/imjs/js/im.js":6,"./cymine":7,"./nodeDataDisplay":9}],9:[function(require,module,exports){
var nodeInfo = {
  display : function(node) {
    this.targetElem = document.getElementById('nodeDetails'),
    console.log(node);
    this.node = node;
    this.setTitle();
    this.listProperties();
  },
  setTitle : function () {
    var title = nodeInfo.targetElem.querySelector('.nodeTitle');
    title.innerHTML = this.node.label;
  },
  listProperties : function() {
    //todo: make this more sane
    var display = this.expandPropertyVals(this.node);
    nodeInfo.targetElem.querySelector('.nodeInfo').innerHTML = display;
  },
  addProperty : function(prop, key) {
    return '<b> ' + key + '</b>: ' + prop[key] + "<br />";
  },
  expandPropertyVals : function(obj) {
    var display = "";
    for (var prop in obj) {
      if(typeof obj[prop] === "object") {
        display += this.addProperty(this.expandPropertyVals(obj[prop]), prop);
        console.log('object:', obj[prop], 'prop:', prop);
      } else{
        display += this.addProperty(obj, prop);
      }
    }
    return display;
  }
};

module.exports = nodeInfo;

},{}]},{},[8])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy5udm0vdmVyc2lvbnMvbm9kZS92MC4xMi43L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsIi4uLy4uLy4uLy5udm0vdmVyc2lvbnMvbm9kZS92MC4xMi43L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbGliL19lbXB0eS5qcyIsIi4uLy4uLy4uLy5udm0vdmVyc2lvbnMvbm9kZS92MC4xMi43L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL29zLWJyb3dzZXJpZnkvYnJvd3Nlci5qcyIsIi4uLy4uLy4uLy5udm0vdmVyc2lvbnMvbm9kZS92MC4xMi43L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIi4uLy4uLy4uLy5udm0vdmVyc2lvbnMvbm9kZS92MC4xMi43L2xpYi9ub2RlX21vZHVsZXMvd2F0Y2hpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIi4uL2Jvd2VyX2NvbXBvbmVudHMvY3l0b3NjYXBlL2Rpc3QvY3l0b3NjYXBlLmpzIiwiLi4vYm93ZXJfY29tcG9uZW50cy9pbWpzL2pzL2ltLmpzIiwiY3ltaW5lLmpzIiwibWFpbi5qcyIsIm5vZGVEYXRhRGlzcGxheS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeGt6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1L1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsbnVsbCwiZXhwb3J0cy5lbmRpYW5uZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0xFJyB9O1xuXG5leHBvcnRzLmhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ob3N0bmFtZVxuICAgIH1cbiAgICBlbHNlIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubG9hZGF2ZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudXB0aW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG5leHBvcnRzLmZyZWVtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLnRvdGFsbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy5jcHVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Jyb3dzZXInIH07XG5cbmV4cG9ydHMucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VzXG49IGV4cG9ydHMuZ2V0TmV0d29ya0ludGVyZmFjZXNcbj0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge30gfTtcblxuZXhwb3J0cy5hcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2phdmFzY3JpcHQnIH07XG5cbmV4cG9ydHMucGxhdGZvcm0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnYnJvd3NlcicgfTtcblxuZXhwb3J0cy50bXBkaXIgPSBleHBvcnRzLnRtcERpciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJy90bXAnO1xufTtcblxuZXhwb3J0cy5FT0wgPSAnXFxuJztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiFcbiAqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEN5dG9zY2FwZS5qcyAyLjQuNC5cbiAqIFxuICogQ3l0b3NjYXBlLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnkgaXRcbiAqIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZVxuICogU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnlcbiAqIGxhdGVyIHZlcnNpb24uXG4gKiBcbiAqIEN5dG9zY2FwZS5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLCBidXQgV0lUSE9VVFxuICogQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2YgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1NcbiAqIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gU2VlIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmVcbiAqIGRldGFpbHMuXG4gKiBcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhbG9uZyB3aXRoXG4gKiBDeXRvc2NhcGUuanMuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiAqL1xuIFxuXG4vLyB0aGlzIGlzIHB1dCBhcyBhIGdsb2JhbCB2YXIgaW4gdGhlIGJyb3dzZXJcbi8vIG9yIGl0J3MganVzdCBhIGdsb2JhbCB0byB0aGlzIG1vZHVsZSBpZiBjb21tb25qc1xuXG52YXIgY3l0b3NjYXBlO1xuXG4oZnVuY3Rpb24od2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHRoZSBvYmplY3QgaXRlc2VsZiBpcyBhIGZ1bmN0aW9uIHRoYXQgaW5pdCdzIGFuIGluc3RhbmNlIG9mIGN5dG9zY2FwZVxuXG4gIHZhciAkJCA9IGN5dG9zY2FwZSA9IGZ1bmN0aW9uKCl7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIHJldHVybiBjeXRvc2NhcGUuaW5pdC5hcHBseShjeXRvc2NhcGUsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgJCQudmVyc2lvbiA9ICcyLjQuNCc7XG4gIFxuICAvLyBhbGxvdyBmdW5jdGlvbmFsIGFjY2VzcyB0byBjeXRvc2NhcGUuanNcbiAgLy8gZS5nLiB2YXIgY3l0byA9ICQuY3l0b3NjYXBlKHsgc2VsZWN0b3I6IFwiI2Zvb1wiLCAuLi4gfSk7XG4gIC8vICAgICAgdmFyIG5vZGVzID0gY3l0by5ub2RlcygpO1xuICAkJC5pbml0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICBcbiAgICAvLyBpZiBubyBvcHRpb25zIHNwZWNpZmllZCwgdXNlIGRlZmF1bHRcbiAgICBpZiggb3B0aW9ucyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGluc3RhbmNlXG4gICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KCBvcHRpb25zICkgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuQ29yZSggb3B0aW9ucyApO1xuICAgIH0gXG4gICAgXG4gICAgLy8gYWxsb3cgZm9yIHJlZ2lzdHJhdGlvbiBvZiBleHRlbnNpb25zXG4gICAgLy8gZS5nLiAkLmN5dG9zY2FwZSgncmVuZGVyZXInLCAnc3ZnJywgU3ZnUmVuZGVyZXIpO1xuICAgIC8vIGUuZy4gJC5jeXRvc2NhcGUoJ3JlbmRlcmVyJywgJ3N2ZycsICdub2Rlc2hhcGUnLCAnZWxsaXBzZScsIFN2Z0VsbGlwc2VOb2RlU2hhcGUpO1xuICAgIC8vIGUuZy4gJC5jeXRvc2NhcGUoJ2NvcmUnLCAnZG9Tb21ldGhpbmcnLCBmdW5jdGlvbigpeyAvKiBkb1NvbWV0aGluZyBjb2RlICovIH0pO1xuICAgIC8vIGUuZy4gJC5jeXRvc2NhcGUoJ2NvbGxlY3Rpb24nLCAnZG9Tb21ldGhpbmcnLCBmdW5jdGlvbigpeyAvKiBkb1NvbWV0aGluZyBjb2RlICovIH0pO1xuICAgIGVsc2UgaWYoICQkLmlzLnN0cmluZyggb3B0aW9ucyApICkge1xuICAgICAgcmV0dXJuICQkLmV4dGVuc2lvbi5hcHBseSgkJC5leHRlbnNpb24sIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9O1xuXG4gIC8vIGRlZmluZSB0aGUgZnVuY3Rpb24gbmFtZXNwYWNlIGhlcmUsIHNpbmNlIGl0IGhhcyBtZW1iZXJzIGluIG1hbnkgcGxhY2VzXG4gICQkLmZuID0ge307XG5cbiAgaWYoIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICl7IC8vIGV4cG9zZSBhcyBhIGNvbW1vbmpzIG1vZHVsZVxuICAgIG1vZHVsZS5leHBvcnRzID0gY3l0b3NjYXBlO1xuICB9XG5cbiAgaWYoIHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQgKXsgLy8gZXhwb3NlIGFzIGFuIGFtZC9yZXF1aXJlanMgbW9kdWxlXG4gICAgZGVmaW5lKCdjeXRvc2NhcGUnLCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGN5dG9zY2FwZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSBhbHdheXMgcmVnaXN0ZXIgaW4gdGhlIHdpbmRvdyBqdXN0IGluIGNhc2UgKGUuZy4gdy8gZGVyYnlqcylcbiAgaWYoIHdpbmRvdyApe1xuICAgIHdpbmRvdy5jeXRvc2NhcGUgPSBjeXRvc2NhcGU7XG4gIH1cbiAgXG59KSggdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cbi8vIGV4dHJhIHNldCB0byBgdGhpc2AgaXMgbmVjZXNzYXJ5IGZvciBtZXRlb3JcbnRoaXMuY3l0b3NjYXBlID0gY3l0b3NjYXBlO1xuXG4vLyBpbnRlcm5hbCwgbWluaW1hbCBQcm9taXNlIGltcGwgcy50LiBhcGlzIGNhbiByZXR1cm4gcHJvbWlzZXMgaW4gb2xkIGVudnNcbi8vIGJhc2VkIG9uIHRoZW5hYmxlIChodHRwOi8vZ2l0aHViLmNvbS9yc2UvdGhlbmFibGUpXG5cbi8vIE5COiB5b3UgbXVzdCB1c2UgYG5ldyAkJC5Qcm9taXNlYCwgYmVjYXVzZSB5b3UgbWF5IGhhdmUgbmF0aXZlIHByb21pc2VzIHRoYXQgZG9uJ3QgYXV0b25ldyBmb3IgeW91XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAvKiAgcHJvbWlzZSBzdGF0ZXMgW1Byb21pc2VzL0ErIDIuMV0gICovXG4gIHZhciBTVEFURV9QRU5ESU5HICAgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMV0gICovXG4gIHZhciBTVEFURV9GVUxGSUxMRUQgPSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMl0gICovXG4gIHZhciBTVEFURV9SRUpFQ1RFRCAgPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuM10gICovXG5cbiAgLyogIHByb21pc2Ugb2JqZWN0IGNvbnN0cnVjdG9yICAqL1xuICB2YXIgYXBpID0gZnVuY3Rpb24gKGV4ZWN1dG9yKSB7XG4gICAgLyogIG9wdGlvbmFsbHkgc3VwcG9ydCBub24tY29uc3RydWN0b3IvcGxhaW4tZnVuY3Rpb24gY2FsbCAgKi9cbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgYXBpKSlcbiAgICAgIHJldHVybiBuZXcgYXBpKGV4ZWN1dG9yKTtcblxuICAgIC8qICBpbml0aWFsaXplIG9iamVjdCAgKi9cbiAgICB0aGlzLmlkICAgICAgICAgICA9IFwiVGhlbmFibGUvMS4wLjdcIjtcbiAgICB0aGlzLnN0YXRlICAgICAgICA9IFNUQVRFX1BFTkRJTkc7IC8qICBpbml0aWFsIHN0YXRlICAqL1xuICAgIHRoaXMuZnVsZmlsbFZhbHVlID0gdW5kZWZpbmVkOyAgICAgLyogIGluaXRpYWwgdmFsdWUgICovICAgICAvKiAgW1Byb21pc2VzL0ErIDEuMywgMi4xLjIuMl0gICovXG4gICAgdGhpcy5yZWplY3RSZWFzb24gPSB1bmRlZmluZWQ7ICAgICAvKiAgaW5pdGlhbCByZWFzb24gKi8gICAgIC8qICBbUHJvbWlzZXMvQSsgMS41LCAyLjEuMy4yXSAgKi9cbiAgICB0aGlzLm9uRnVsZmlsbGVkICA9IFtdOyAgICAgICAgICAgIC8qICBpbml0aWFsIGhhbmRsZXJzICAqL1xuICAgIHRoaXMub25SZWplY3RlZCAgID0gW107ICAgICAgICAgICAgLyogIGluaXRpYWwgaGFuZGxlcnMgICovXG5cbiAgICAvKiAgcHJvdmlkZSBvcHRpb25hbCBpbmZvcm1hdGlvbi1oaWRpbmcgcHJveHkgICovXG4gICAgdGhpcy5wcm94eSA9IHtcbiAgICAgIHRoZW46IHRoaXMudGhlbi5iaW5kKHRoaXMpXG4gICAgfTtcblxuICAgIC8qICBzdXBwb3J0IG9wdGlvbmFsIGV4ZWN1dG9yIGZ1bmN0aW9uICAqL1xuICAgIGlmICh0eXBlb2YgZXhlY3V0b3IgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIGV4ZWN1dG9yLmNhbGwodGhpcywgdGhpcy5mdWxmaWxsLmJpbmQodGhpcyksIHRoaXMucmVqZWN0LmJpbmQodGhpcykpO1xuICB9O1xuXG4gIC8qICBwcm9taXNlIEFQSSBtZXRob2RzICAqL1xuICBhcGkucHJvdG90eXBlID0ge1xuICAgIC8qICBwcm9taXNlIHJlc29sdmluZyBtZXRob2RzICAqL1xuICAgIGZ1bGZpbGw6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZGVsaXZlcih0aGlzLCBTVEFURV9GVUxGSUxMRUQsIFwiZnVsZmlsbFZhbHVlXCIsIHZhbHVlKTsgfSxcbiAgICByZWplY3Q6ICBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIGRlbGl2ZXIodGhpcywgU1RBVEVfUkVKRUNURUQsICBcInJlamVjdFJlYXNvblwiLCB2YWx1ZSk7IH0sXG5cbiAgICAvKiAgXCJUaGUgdGhlbiBNZXRob2RcIiBbUHJvbWlzZXMvQSsgMS4xLCAxLjIsIDIuMl0gICovXG4gICAgdGhlbjogZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICB2YXIgY3VyciA9IHRoaXM7XG4gICAgICB2YXIgbmV4dCA9IG5ldyBhcGkoKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43XSAgKi9cbiAgICAgIGN1cnIub25GdWxmaWxsZWQucHVzaChcbiAgICAgICAgcmVzb2x2ZXIob25GdWxmaWxsZWQsIG5leHQsIFwiZnVsZmlsbFwiKSk7ICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIvMi4yLjZdICAqL1xuICAgICAgY3Vyci5vblJlamVjdGVkLnB1c2goXG4gICAgICAgIHJlc29sdmVyKG9uUmVqZWN0ZWQsICBuZXh0LCBcInJlamVjdFwiICkpOyAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4zLzIuMi42XSAgKi9cbiAgICAgIGV4ZWN1dGUoY3Vycik7XG4gICAgICByZXR1cm4gbmV4dC5wcm94eTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LCAzLjNdICAqL1xuICAgIH1cbiAgfTtcblxuICAvKiAgZGVsaXZlciBhbiBhY3Rpb24gICovXG4gIHZhciBkZWxpdmVyID0gZnVuY3Rpb24gKGN1cnIsIHN0YXRlLCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9QRU5ESU5HKSB7XG4gICAgICBjdXJyLnN0YXRlID0gc3RhdGU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMS4yLjEsIDIuMS4zLjFdICAqL1xuICAgICAgY3VycltuYW1lXSA9IHZhbHVlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjEuMi4yLCAyLjEuMy4yXSAgKi9cbiAgICAgIGV4ZWN1dGUoY3Vycik7XG4gICAgfVxuICAgIHJldHVybiBjdXJyO1xuICB9O1xuXG4gIC8qICBleGVjdXRlIGFsbCBoYW5kbGVycyAgKi9cbiAgdmFyIGV4ZWN1dGUgPSBmdW5jdGlvbiAoY3Vycikge1xuICAgIGlmIChjdXJyLnN0YXRlID09PSBTVEFURV9GVUxGSUxMRUQpXG4gICAgICBleGVjdXRlX2hhbmRsZXJzKGN1cnIsIFwib25GdWxmaWxsZWRcIiwgY3Vyci5mdWxmaWxsVmFsdWUpO1xuICAgIGVsc2UgaWYgKGN1cnIuc3RhdGUgPT09IFNUQVRFX1JFSkVDVEVEKVxuICAgICAgZXhlY3V0ZV9oYW5kbGVycyhjdXJyLCBcIm9uUmVqZWN0ZWRcIiwgIGN1cnIucmVqZWN0UmVhc29uKTtcbiAgfTtcblxuICAvKiAgZXhlY3V0ZSBwYXJ0aWN1bGFyIHNldCBvZiBoYW5kbGVycyAgKi9cbiAgdmFyIGV4ZWN1dGVfaGFuZGxlcnMgPSBmdW5jdGlvbiAoY3VyciwgbmFtZSwgdmFsdWUpIHtcbiAgICAvKiBnbG9iYWwgcHJvY2VzczogdHJ1ZSAqL1xuICAgIC8qIGdsb2JhbCBzZXRJbW1lZGlhdGU6IHRydWUgKi9cbiAgICAvKiBnbG9iYWwgc2V0VGltZW91dDogdHJ1ZSAqL1xuXG4gICAgLyogIHNob3J0LWNpcmN1aXQgcHJvY2Vzc2luZyAgKi9cbiAgICBpZiAoY3VycltuYW1lXS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG5cbiAgICAvKiAgaXRlcmF0ZSBvdmVyIGFsbCBoYW5kbGVycywgZXhhY3RseSBvbmNlICAqL1xuICAgIHZhciBoYW5kbGVycyA9IGN1cnJbbmFtZV07XG4gICAgY3VycltuYW1lXSA9IFtdOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjIuMywgMi4yLjMuM10gICovXG4gICAgdmFyIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXJzLmxlbmd0aDsgaSsrKVxuICAgICAgICBoYW5kbGVyc1tpXSh2YWx1ZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4yLjVdICAqL1xuICAgIH07XG5cbiAgICAvKiAgZXhlY3V0ZSBwcm9jZWR1cmUgYXN5bmNocm9ub3VzbHkgICovICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNCwgMy4xXSAgKi9cbiAgICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHByb2Nlc3MubmV4dFRpY2sgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuYyk7XG4gICAgZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgc2V0SW1tZWRpYXRlKGZ1bmMpO1xuICAgIGVsc2VcbiAgICAgIHNldFRpbWVvdXQoZnVuYywgMCk7XG4gIH07XG5cbiAgLyogIGdlbmVyYXRlIGEgcmVzb2x2ZXIgZnVuY3Rpb24gICovXG4gIHZhciByZXNvbHZlciA9IGZ1bmN0aW9uIChjYiwgbmV4dCwgbWV0aG9kKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiBjYiAhPT0gXCJmdW5jdGlvblwiKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi4xLCAyLjIuNy4zLCAyLjIuNy40XSAgKi9cbiAgICAgICAgbmV4dFttZXRob2RdLmNhbGwobmV4dCwgdmFsdWUpOyAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjMsIDIuMi43LjRdICAqL1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHRyeSB7IHJlc3VsdCA9IGNiKHZhbHVlKTsgfSAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuMi4xLCAyLjIuMy4xLCAyLjIuNSwgMy4yXSAgKi9cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICBuZXh0LnJlamVjdChlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjIuNy4yXSAgKi9cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShuZXh0LCByZXN1bHQpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMi43LjFdICAqL1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLyogIFwiUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVwiICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zXSAgKi9cbiAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgeCkge1xuICAgIC8qICBzYW5pdHkgY2hlY2sgYXJndW1lbnRzICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4xXSAgKi9cbiAgICBpZiAocHJvbWlzZSA9PT0geCB8fCBwcm9taXNlLnByb3h5ID09PSB4KSB7XG4gICAgICBwcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFwiY2Fubm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLyogIHN1cmdpY2FsbHkgY2hlY2sgZm9yIGEgXCJ0aGVuXCIgbWV0aG9kXG4gICAgICAobWFpbmx5IHRvIGp1c3QgY2FsbCB0aGUgXCJnZXR0ZXJcIiBvZiBcInRoZW5cIiBvbmx5IG9uY2UpICAqL1xuICAgIHZhciB0aGVuO1xuICAgIGlmICgodHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbCkgfHwgdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdHJ5IHsgdGhlbiA9IHgudGhlbjsgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4xLCAzLjVdICAqL1xuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjJdICAqL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogIGhhbmRsZSBvd24gVGhlbmFibGVzICAgIFtQcm9taXNlcy9BKyAyLjMuMl1cbiAgICAgIGFuZCBzaW1pbGFyIFwidGhlbmFibGVzXCIgW1Byb21pc2VzL0ErIDIuMy4zXSAgKi9cbiAgICBpZiAodHlwZW9mIHRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICAvKiAgY2FsbCByZXRyaWV2ZWQgXCJ0aGVuXCIgbWV0aG9kICovICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zXSAgKi9cbiAgICAgICAgdGhlbi5jYWxsKHgsXG4gICAgICAgICAgLyogIHJlc29sdmVQcm9taXNlICAqLyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4xXSAgKi9cbiAgICAgICAgICBmdW5jdGlvbiAoeSkge1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkKSByZXR1cm47IHJlc29sdmVkID0gdHJ1ZTsgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjNdICAqL1xuICAgICAgICAgICAgaWYgKHkgPT09IHgpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAzLjZdICAqL1xuICAgICAgICAgICAgICBwcm9taXNlLnJlamVjdChuZXcgVHlwZUVycm9yKFwiY2lyY3VsYXIgdGhlbmFibGUgY2hhaW5cIikpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICByZXNvbHZlKHByb21pc2UsIHkpO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICAvKiAgcmVqZWN0UHJvbWlzZSAgKi8gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjJdICAqL1xuICAgICAgICAgIGZ1bmN0aW9uIChyKSB7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHJldHVybjsgcmVzb2x2ZWQgPSB0cnVlOyAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy4zLjMuM10gICovXG4gICAgICAgICAgICBwcm9taXNlLnJlamVjdChyKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIXJlc29sdmVkKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICBbUHJvbWlzZXMvQSsgMi4zLjMuMy4zXSAgKi9cbiAgICAgICAgICBwcm9taXNlLnJlamVjdChlKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogIFtQcm9taXNlcy9BKyAyLjMuMy4zLjRdICAqL1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qICBoYW5kbGUgb3RoZXIgdmFsdWVzICAqL1xuICAgIHByb21pc2UuZnVsZmlsbCh4KTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiAgW1Byb21pc2VzL0ErIDIuMy40LCAyLjMuMy40XSAgKi9cbiAgfTtcblxuICAvLyB1c2UgbmF0aXZlIHByb21pc2VzIHdoZXJlIHBvc3NpYmxlXG4gICQkLlByb21pc2UgPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyBhcGkgOiBQcm9taXNlO1xuXG4gIC8vIHNvIHdlIGFsd2F5cyBoYXZlIFByb21pc2UuYWxsKClcbiAgJCQuUHJvbWlzZS5hbGwgPSAkJC5Qcm9taXNlLmFsbCB8fCBmdW5jdGlvbiggcHMgKXtcbiAgICByZXR1cm4gbmV3ICQkLlByb21pc2UoZnVuY3Rpb24oIHJlc29sdmVBbGwsIHJlamVjdEFsbCApe1xuICAgICAgdmFyIHZhbHMgPSBuZXcgQXJyYXkoIHBzLmxlbmd0aCApO1xuICAgICAgdmFyIGRvbmVDb3VudCA9IDA7XG5cbiAgICAgIHZhciBmdWxmaWxsID0gZnVuY3Rpb24oIGksIHZhbCApe1xuICAgICAgICB2YWxzW2ldID0gdmFsO1xuICAgICAgICBkb25lQ291bnQrKztcblxuICAgICAgICBpZiggZG9uZUNvdW50ID09PSBwcy5sZW5ndGggKXtcbiAgICAgICAgICByZXNvbHZlQWxsKCB2YWxzICk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgKGZ1bmN0aW9uKCBpICl7XG4gICAgICAgICAgdmFyIHAgPSBwc1tpXTtcbiAgICAgICAgICB2YXIgaXNQcm9taXNlID0gcC50aGVuICE9IG51bGw7XG5cbiAgICAgICAgICBpZiggaXNQcm9taXNlICl7XG4gICAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24oIHZhbCApe1xuICAgICAgICAgICAgICBmdWxmaWxsKCBpLCB2YWwgKTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uKCBlcnIgKXtcbiAgICAgICAgICAgICAgcmVqZWN0QWxsKCBlcnIgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gcDtcbiAgICAgICAgICAgIGZ1bGZpbGwoIGksIHZhbCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoIGkgKTtcbiAgICAgIH1cblxuICAgIH0pO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG4vLyB0eXBlIHRlc3RpbmcgdXRpbGl0eSBmdW5jdGlvbnNcblxuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciB0eXBlb2ZzdHIgPSB0eXBlb2YgJyc7XG4gIHZhciB0eXBlb2ZvYmogPSB0eXBlb2Yge307XG4gIHZhciB0eXBlb2ZmbiA9IHR5cGVvZiBmdW5jdGlvbigpe307XG5cbiAgJCQuaXMgPSB7XG4gICAgZGVmaW5lZDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbDsgLy8gbm90IHVuZGVmaW5lZCBvciBudWxsXG4gICAgfSxcblxuICAgIHN0cmluZzogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09IHR5cGVvZnN0cjtcbiAgICB9LFxuICAgIFxuICAgIGZuOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZmZuO1xuICAgIH0sXG4gICAgXG4gICAgYXJyYXk6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSA/IEFycmF5LmlzQXJyYXkob2JqKSA6IG9iaiAhPSBudWxsICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5O1xuICAgIH0sXG4gICAgXG4gICAgcGxhaW5PYmplY3Q6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mb2JqICYmICEkJC5pcy5hcnJheShvYmopICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0O1xuICAgIH0sXG5cbiAgICBvYmplY3Q6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gdHlwZW9mb2JqO1xuICAgIH0sXG4gICAgXG4gICAgbnVtYmVyOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09IHR5cGVvZiAxICYmICFpc05hTihvYmopO1xuICAgIH0sXG5cbiAgICBpbnRlZ2VyOiBmdW5jdGlvbiggb2JqICl7XG4gICAgICByZXR1cm4gJCQuaXMubnVtYmVyKG9iaikgJiYgTWF0aC5mbG9vcihvYmopID09PSBvYmo7XG4gICAgfSxcbiAgICBcbiAgICBjb2xvcjogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2YgJycgJiYgJC5Db2xvcihvYmopLnRvU3RyaW5nKCkgIT09ICcnO1xuICAgIH0sXG4gICAgXG4gICAgYm9vbDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiB0eXBlb2Ygb2JqID09PSB0eXBlb2YgdHJ1ZTtcbiAgICB9LFxuICAgIFxuICAgIGVsZW1lbnRPckNvbGxlY3Rpb246IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gJCQuaXMuZWxlbWVudChvYmopIHx8ICQkLmlzLmNvbGxlY3Rpb24ob2JqKTtcbiAgICB9LFxuICAgIFxuICAgIGVsZW1lbnQ6IGZ1bmN0aW9uKG9iail7XG4gICAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgJCQuRWxlbWVudCAmJiBvYmouX3ByaXZhdGUuc2luZ2xlO1xuICAgIH0sXG4gICAgXG4gICAgY29sbGVjdGlvbjogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5Db2xsZWN0aW9uICYmICFvYmouX3ByaXZhdGUuc2luZ2xlO1xuICAgIH0sXG4gICAgXG4gICAgY29yZTogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5Db3JlO1xuICAgIH0sXG5cbiAgICBzdHlsZTogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5TdHlsZTtcbiAgICB9LFxuXG4gICAgc3R5bGVzaGVldDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5TdHlsZXNoZWV0O1xuICAgIH0sXG5cbiAgICBldmVudDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiAkJC5FdmVudDtcbiAgICB9LFxuXG4gICAgdGhyZWFkOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLlRocmVhZDtcbiAgICB9LFxuXG4gICAgZmFicmljOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mICQkLkZhYnJpYztcbiAgICB9LFxuXG4gICAgZW1wdHlTdHJpbmc6IGZ1bmN0aW9uKG9iail7XG4gICAgICBpZiggIW9iaiApeyAvLyBudWxsIGlzIGVtcHR5XG4gICAgICAgIHJldHVybiB0cnVlOyBcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKG9iaikgKXtcbiAgICAgICAgaWYoIG9iaiA9PT0gJycgfHwgb2JqLm1hdGNoKC9eXFxzKyQvKSApe1xuICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBlbXB0eSBzdHJpbmcgaXMgZW1wdHlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZmFsc2U7IC8vIG90aGVyd2lzZSwgd2UgZG9uJ3Qga25vdyB3aGF0IHdlJ3ZlIGdvdFxuICAgIH0sXG4gICAgXG4gICAgbm9uZW1wdHlTdHJpbmc6IGZ1bmN0aW9uKG9iail7XG4gICAgICBpZiggb2JqICYmICQkLmlzLnN0cmluZyhvYmopICYmIG9iaiAhPT0gJycgJiYgIW9iai5tYXRjaCgvXlxccyskLykgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZG9tRWxlbWVudDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIGlmKCB0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICd1bmRlZmluZWQnICl7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gd2UncmUgbm90IGluIGEgYnJvd3NlciBzbyBpdCBkb2Vzbid0IG1hdHRlclxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBib3VuZGluZ0JveDogZnVuY3Rpb24ob2JqKXtcbiAgICAgIHJldHVybiAkJC5pcy5wbGFpbk9iamVjdChvYmopICYmIFxuICAgICAgICAkJC5pcy5udW1iZXIob2JqLngxKSAmJiAkJC5pcy5udW1iZXIob2JqLngyKSAmJlxuICAgICAgICAkJC5pcy5udW1iZXIob2JqLnkxKSAmJiAkJC5pcy5udW1iZXIob2JqLnkyKVxuICAgICAgO1xuICAgIH0sXG5cbiAgICBwcm9taXNlOiBmdW5jdGlvbihvYmope1xuICAgICAgcmV0dXJuICQkLmlzLm9iamVjdChvYmopICYmICQkLmlzLmZuKG9iai50aGVuKTtcbiAgICB9LFxuXG4gICAgdG91Y2g6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gd2luZG93ICYmICggKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdykgfHwgd2luZG93LkRvY3VtZW50VG91Y2ggJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoICk7XG4gICAgfSxcblxuICAgIGdlY2tvOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCcgfHwgKCdNb3pBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpO1xuICAgIH0sXG5cbiAgICB3ZWJraXQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIHdlYmtpdFVSTCAhPT0gJ3VuZGVmaW5lZCcgfHwgKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpO1xuICAgIH0sXG5cbiAgICBjaHJvbWl1bTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2YgY2hyb21lICE9PSAndW5kZWZpbmVkJztcbiAgICB9LFxuXG4gICAga2h0bWw6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gbmF2aWdhdG9yLnZlbmRvci5tYXRjaCgva2RlL2kpOyAvLyBUT0RPIHByb2JhYmx5IGEgYmV0dGVyIHdheSB0byBkZXRlY3QgdGhpcy4uLlxuICAgIH0sXG5cbiAgICBraHRtbEV0YzogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiAkJC5pcy5raHRtbCgpIHx8ICQkLmlzLndlYmtpdCgpIHx8ICQkLmlzLmNocm9taXVtKCk7XG4gICAgfSxcblxuICAgIHRyaWRlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgcmV0dXJuIHR5cGVvZiBBY3RpdmVYT2JqZWN0ICE9PSAndW5kZWZpbmVkJyB8fCAvKkBjY19vbiFAKi9mYWxzZTtcbiAgICB9LFxuXG4gICAgd2luZG93czogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvV2luL2kpO1xuICAgIH0sXG5cbiAgICBtYWM6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL01hYy9pKTtcbiAgICB9LFxuXG4gICAgbGludXg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24ubWF0Y2goL0xpbnV4L2kpO1xuICAgIH0sXG5cbiAgICB1bml4OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5hcHBWZXJzaW9uLm1hdGNoKC9YMTEvaSk7XG4gICAgfVxuICB9OyAgXG4gIFxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cbjsoZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIHV0aWxpdHkgZnVuY3Rpb25zIG9ubHkgZm9yIGludGVybmFsIHVzZVxuXG4gICQkLnV0aWwgPSB7XG5cbiAgICAvLyB0aGUganF1ZXJ5IGV4dGVuZCgpIGZ1bmN0aW9uXG4gICAgLy8gTkI6IG1vZGlmaWVkIHRvIHVzZSAkJC5pcyBldGMgc2luY2Ugd2UgY2FuJ3QgdXNlIGpxdWVyeSBmdW5jdGlvbnNcbiAgICBleHRlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9wdGlvbnMsIG5hbWUsIHNyYywgY29weSwgY29weUlzQXJyYXksIGNsb25lLFxuICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG4gICAgICAgIGkgPSAxLFxuICAgICAgICBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBkZWVwID0gZmFsc2U7XG5cbiAgICAgIC8vIEhhbmRsZSBhIGRlZXAgY29weSBzaXR1YXRpb25cbiAgICAgIGlmICggdHlwZW9mIHRhcmdldCA9PT0gJ2Jvb2xlYW4nICkge1xuICAgICAgICBkZWVwID0gdGFyZ2V0O1xuICAgICAgICB0YXJnZXQgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgICAgIC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcbiAgICAgICAgaSA9IDI7XG4gICAgICB9XG5cbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuICAgICAgaWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSAnb2JqZWN0JyAmJiAhJCQuaXMuZm4odGFyZ2V0KSApIHtcbiAgICAgICAgdGFyZ2V0ID0ge307XG4gICAgICB9XG5cbiAgICAgIC8vIGV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuICAgICAgaWYgKCBsZW5ndGggPT09IGkgKSB7XG4gICAgICAgIHRhcmdldCA9IHRoaXM7XG4gICAgICAgIC0taTtcbiAgICAgIH1cblxuICAgICAgZm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgaWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuICAgICAgICAgIC8vIEV4dGVuZCB0aGUgYmFzZSBvYmplY3RcbiAgICAgICAgICBmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG4gICAgICAgICAgICBzcmMgPSB0YXJnZXRbIG5hbWUgXTtcbiAgICAgICAgICAgIGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgbmV2ZXItZW5kaW5nIGxvb3BcbiAgICAgICAgICAgIGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG4gICAgICAgICAgICBpZiAoIGRlZXAgJiYgY29weSAmJiAoICQkLmlzLnBsYWluT2JqZWN0KGNvcHkpIHx8IChjb3B5SXNBcnJheSA9ICQkLmlzLmFycmF5KGNvcHkpKSApICkge1xuICAgICAgICAgICAgICBpZiAoIGNvcHlJc0FycmF5ICkge1xuICAgICAgICAgICAgICAgIGNvcHlJc0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgJCQuaXMuYXJyYXkoc3JjKSA/IHNyYyA6IFtdO1xuXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvbmUgPSBzcmMgJiYgJCQuaXMucGxhaW5PYmplY3Qoc3JjKSA/IHNyYyA6IHt9O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG4gICAgICAgICAgICAgIHRhcmdldFsgbmFtZSBdID0gJCQudXRpbC5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cbiAgICAgICAgICAgIC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICAgICAgdGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9LFxuXG4gICAgLy8gcmVxdWlyZSB0aGF0IHB1bGxzIGluIG1vZHVsZSBmcm9tIGNvbW1vbmpzLCBhbWQsIG9yIHdpbmRvdyAoZmFsbGluZyBiYWNrIHVudGlsIGZvdW5kKVxuICAgIHJlcXVpcmU6IGZ1bmN0aW9uKCBuYW1lLCBjYWxsYmFjaywgb3B0aW9ucyApe1xuICAgICAgdmFyIHJldDtcbiAgICAgIG9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7XG4gICAgICAgIG1zZ0lmTm90Rm91bmQ6IHRydWVcbiAgICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgdmFyIGZ1bGZpbCA9IGZ1bmN0aW9uKCByZXQgKXtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKCByZXQgKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBjaGVja1dpbmRvdyA9IGZ1bmN0aW9uKCBuZXh0ICl7XG4gICAgICAgIGlmKCB3aW5kb3cgKXsgLy8gZGV0ZWN0ZWQgYnJvd3Nlci93aW5kb3cgZW52XG4gICAgICAgICAgcmV0ID0gd2luZG93WyBuYW1lIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiggcmV0ICE9PSB1bmRlZmluZWQgKXsgZnVsZmlsKHJldCk7IH1cbiAgICAgICAgaWYoIG5leHQgKXsgbmV4dCgpOyB9XG4gICAgICB9O1xuICAgICAgdmFyIG9uQ2hlY2tXaW5kb3dEb25lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoICFkb25lICl7XG4gICAgICAgICAgY2hlY2tDb21tb25Kcyggb25DaGVja0NvbW1vbkpzRG9uZSApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY2hlY2tDb21tb25KcyA9IGZ1bmN0aW9uKCBuZXh0ICl7XG4gICAgICAgIGlmKCB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cyAmJiByZXF1aXJlICl7IC8vIGRldGVjdGVkIGNvbW1vbmpzIGVudlxuICAgICAgICAgIHJldCA9IHJlcXVpcmUoIG5hbWUgKTsgLy8gcmVndWxhciByZXF1aXJlXG4gICAgICAgIH1cblxuICAgICAgICBpZiggcmV0ICE9PSB1bmRlZmluZWQgKXsgZnVsZmlsKHJldCk7IH1cbiAgICAgICAgaWYoIG5leHQgKXsgbmV4dCgpOyB9XG4gICAgICB9O1xuICAgICAgdmFyIG9uQ2hlY2tDb21tb25Kc0RvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggIWRvbmUgKXtcbiAgICAgICAgICBjaGVja0FtZCggb25DaGVja0FtZERvbmUgKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGNoZWNrQW1kID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICAgICAgaWYoIHR5cGVvZiBkZWZpbmUgIT09ICd1bmRlZmluZWQnICYmIGRlZmluZS5hbWQgJiYgcmVxdWlyZSApeyAvLyBkZXRlY3RlZCBhbWQgZW52IHcvIGRlZmluZWQgbW9kdWxlXG4gICAgICAgICAgcmVxdWlyZShbIG5hbWUgXSwgZnVuY3Rpb24oIG5hbWVJbXBsICl7XG4gICAgICAgICAgICByZXQgPSBuYW1lSW1wbDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIHJldCAhPT0gdW5kZWZpbmVkICl7IGZ1bGZpbChyZXQpOyB9XG4gICAgICAgICAgICBpZiggbmV4dCApeyBuZXh0KCk7IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBvbkNoZWNrQW1kRG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCAhZG9uZSAmJiBvcHRpb25zLm1zZ0lmTm90Rm91bmQgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdDeXRvc2NhcGUuanMgdHJpZWQgdG8gcHVsbCBpbiBkZXBlbmRlbmN5IGAnICsgbmFtZSArICdgIGJ1dCBubyBtb2R1bGUgKGkuZS4gQ29tbW9uSlMsIEFNRCwgb3Igd2luZG93KSB3YXMgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8ga2ljayBvZmYgMXN0IGNoZWNrOiB3aW5kb3dcbiAgICAgIGNoZWNrV2luZG93KCBvbkNoZWNrV2luZG93RG9uZSApO1xuXG4gICAgfSxcblxuICAgIC8vIG11bHRpcGxlIHJlcXVpcmVzIGluIG9uZSBjYWxsYmFja1xuICAgIHJlcXVpcmVzOiBmdW5jdGlvbiggbmFtZXMsIGNhbGxiYWNrICl7XG4gICAgICB2YXIgaW1wbHMgPSBbXTtcbiAgICAgIHZhciBnb3RJbXBsID0gW107XG5cbiAgICAgIHZhciBjaGVja0RvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrICl7IC8vIGNoZWNrIGhhdmUgYWxsIGltcGxzXG4gICAgICAgICAgaWYoICFnb3RJbXBsW2ldICl7IHJldHVybjsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBhbGwgZ290IGFsbCBpbXBscyA9PiBkb25lXG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KCBjYWxsYmFjaywgaW1wbHMgKTsgXG4gICAgICB9O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrICl7IChmdW5jdGlvbigpeyAvLyB3L3Njb3BlXG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIHZhciBpbmRleCA9IGk7XG5cbiAgICAgICAgJCQudXRpbC5yZXF1aXJlKG5hbWUsIGZ1bmN0aW9uKGltcGwpe1xuICAgICAgICAgIGltcGxzW2luZGV4XSA9IGltcGw7XG4gICAgICAgICAgZ290SW1wbFtpbmRleF0gPSB0cnVlO1xuXG4gICAgICAgICAgY2hlY2tEb25lKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSkoKTsgfVxuICAgIH0sXG5cbiAgICAvLyBwb3J0ZWQgbG9kYXNoIHRocm90dGxlIGZ1bmN0aW9uXG4gICAgdGhyb3R0bGU6IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgICAgIGlmIChvcHRpb25zID09PSBmYWxzZSkge1xuICAgICAgICBsZWFkaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKCQkLmlzLnBsYWluT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIGxlYWRpbmcgPSAnbGVhZGluZycgaW4gb3B0aW9ucyA/IG9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLmxlYWRpbmcgPSBsZWFkaW5nO1xuICAgICAgb3B0aW9ucy5tYXhXYWl0ID0gd2FpdDtcbiAgICAgIG9wdGlvbnMudHJhaWxpbmcgPSB0cmFpbGluZztcblxuICAgICAgcmV0dXJuICQkLnV0aWwuZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIG5vdzogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiArbmV3IERhdGUoKTtcbiAgICB9LFxuXG4gICAgLy8gcG9ydGVkIGxvZGFzaCBkZWJvdW5jZSBmdW5jdGlvblxuICAgIGRlYm91bmNlOiBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXJncyxcbiAgICAgICAgICBtYXhUaW1lb3V0SWQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHN0YW1wLFxuICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgdGltZW91dElkLFxuICAgICAgICAgIHRyYWlsaW5nQ2FsbCxcbiAgICAgICAgICBsYXN0Q2FsbGVkID0gMCxcbiAgICAgICAgICBtYXhXYWl0ID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAoISQkLmlzLmZuKGZ1bmMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdhaXQgPSBNYXRoLm1heCgwLCB3YWl0KSB8fCAwO1xuICAgICAgaWYgKG9wdGlvbnMgPT09IHRydWUpIHtcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFpbGluZyA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICgkJC5pcy5wbGFpbk9iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xuICAgICAgICBtYXhXYWl0ID0gJ21heFdhaXQnIGluIG9wdGlvbnMgJiYgKE1hdGgubWF4KHdhaXQsIG9wdGlvbnMubWF4V2FpdCkgfHwgMCk7XG4gICAgICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIGRlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbWFpbmluZyA9IHdhaXQgLSAoJCQudXRpbC5ub3coKSAtIHN0YW1wKTtcbiAgICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgICAgaWYgKG1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KG1heFRpbWVvdXRJZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0NhbGxlZCA9IHRyYWlsaW5nQ2FsbDtcbiAgICAgICAgICBtYXhUaW1lb3V0SWQgPSB0aW1lb3V0SWQgPSB0cmFpbGluZ0NhbGwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gJCQudXRpbC5ub3coKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzQXJnID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgbWF4RGVsYXllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4VGltZW91dElkID0gdGltZW91dElkID0gdHJhaWxpbmdDYWxsID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodHJhaWxpbmcgfHwgKG1heFdhaXQgIT09IHdhaXQpKSB7XG4gICAgICAgICAgbGFzdENhbGxlZCA9ICQkLnV0aWwubm93KCk7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICBpZiAoIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICBhcmdzID0gdGhpc0FyZyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN0YW1wID0gJCQudXRpbC5ub3coKTtcbiAgICAgICAgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRyYWlsaW5nICYmICh0aW1lb3V0SWQgfHwgIWxlYWRpbmcpO1xuXG4gICAgICAgIGlmIChtYXhXYWl0ID09PSBmYWxzZSkge1xuICAgICAgICAgIHZhciBsZWFkaW5nQ2FsbCA9IGxlYWRpbmcgJiYgIXRpbWVvdXRJZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW1heFRpbWVvdXRJZCAmJiAhbGVhZGluZykge1xuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVtYWluaW5nID0gbWF4V2FpdCAtIChzdGFtcCAtIGxhc3RDYWxsZWQpLFxuICAgICAgICAgICAgICBpc0NhbGxlZCA9IHJlbWFpbmluZyA8PSAwO1xuXG4gICAgICAgICAgaWYgKGlzQ2FsbGVkKSB7XG4gICAgICAgICAgICBpZiAobWF4VGltZW91dElkKSB7XG4gICAgICAgICAgICAgIG1heFRpbWVvdXRJZCA9IGNsZWFyVGltZW91dChtYXhUaW1lb3V0SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoIW1heFRpbWVvdXRJZCkge1xuICAgICAgICAgICAgbWF4VGltZW91dElkID0gc2V0VGltZW91dChtYXhEZWxheWVkLCByZW1haW5pbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgdGltZW91dElkKSB7XG4gICAgICAgICAgdGltZW91dElkID0gY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCAmJiB3YWl0ICE9PSBtYXhXYWl0KSB7XG4gICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChkZWxheWVkLCB3YWl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVhZGluZ0NhbGwpIHtcbiAgICAgICAgICBpc0NhbGxlZCA9IHRydWU7XG4gICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDYWxsZWQgJiYgIXRpbWVvdXRJZCAmJiAhbWF4VGltZW91dElkKSB7XG4gICAgICAgICAgYXJncyA9IHRoaXNBcmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBlcnJvcjogZnVuY3Rpb24oIG1zZyApe1xuICAgICAgaWYoIGNvbnNvbGUgKXtcbiAgICAgICAgaWYoIGNvbnNvbGUuZXJyb3IgKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTtcbiAgICAgICAgfSBlbHNlIGlmKCBjb25zb2xlLmxvZyApe1xuICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KCBjb25zb2xlLCBhcmd1bWVudHMgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBtc2c7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG1zZztcbiAgICAgIH1cbiAgICB9LCAgICBcblxuICAgIGNsb25lOiBmdW5jdGlvbiggb2JqICl7XG4gICAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAoIG9iai5oYXNPd25Qcm9wZXJ0eShpKSApIHsgLy8gVE9ETyBpcyB0aGlzIGhhc093blByb3BlcnR5KCkgY2FsbCBuZWNlc3NhcnkgZm9yIG91ciB1c2U/XG4gICAgICAgICAgdGFyZ2V0W2ldID0gb2JqW2ldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH0sXG5cbiAgICAvLyBnZXRzIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcmd1bWVudFxuICAgIGNvcHk6IGZ1bmN0aW9uKCBvYmogKXtcbiAgICAgIGlmKCBvYmogPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSBpZiggJCQuaXMuYXJyYXkob2JqKSApe1xuICAgICAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gICAgICB9IGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG9iaikgKXtcbiAgICAgICAgcmV0dXJuICQkLnV0aWwuY2xvbmUoIG9iaiApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIC8vIG1ha2VzIGEgZnVsbCBiYiAoeDEsIHkxLCB4MiwgeTIsIHcsIGgpIGZyb20gaW1wbGljaXQgcGFyYW1zXG4gICAgbWFrZUJvdW5kaW5nQm94OiBmdW5jdGlvbiggYmIgKXtcbiAgICAgIGlmKCBiYi54MSAhPSBudWxsICYmIGJiLnkxICE9IG51bGwgKXtcbiAgICAgICAgaWYoIGJiLngyICE9IG51bGwgJiYgYmIueTIgIT0gbnVsbCAmJiBiYi54MiA+PSBiYi54MSAmJiBiYi55MiA+PSBiYi55MSApe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MTogYmIueDEsXG4gICAgICAgICAgICB5MTogYmIueTEsXG4gICAgICAgICAgICB4MjogYmIueDIsXG4gICAgICAgICAgICB5MjogYmIueTIsXG4gICAgICAgICAgICB3OiBiYi54MiAtIGJiLngxLFxuICAgICAgICAgICAgaDogYmIueTIgLSBiYi55MVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiggYmIudyAhPSBudWxsICYmIGJiLmggIT0gbnVsbCAmJiBiYi53ID49IDAgJiYgYmIuaCA+PSAwICl7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgxOiBiYi54MSxcbiAgICAgICAgICAgIHkxOiBiYi55MSxcbiAgICAgICAgICAgIHgyOiBiYi54MSArIGJiLncsXG4gICAgICAgICAgICB5MjogYmIueTEgKyBiYi5oLFxuICAgICAgICAgICAgdzogYmIudyxcbiAgICAgICAgICAgIGg6IGJiLmhcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IFxuICAgIH0sXG5cbiAgICAvLyBoYXMgYW55dGhpbmcgYmVlbiBzZXQgaW4gdGhlIG1hcFxuICAgIG1hcEVtcHR5OiBmdW5jdGlvbiggbWFwICl7XG4gICAgICB2YXIgZW1wdHkgPSB0cnVlO1xuXG4gICAgICBpZiggbWFwICE9IG51bGwgKXtcbiAgICAgICAgZm9yKHZhciBpIGluIG1hcCl7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGVtcHR5O1xuICAgIH0sXG5cbiAgICAvLyBwdXNoZXMgdG8gdGhlIGFycmF5IGF0IHRoZSBlbmQgb2YgYSBtYXAgKG1hcCBtYXkgbm90IGJlIGJ1aWx0KVxuICAgIHB1c2hNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgYXJyYXkgPSAkJC51dGlsLmdldE1hcChvcHRpb25zKTtcblxuICAgICAgaWYoIGFycmF5ID09IG51bGwgKXsgLy8gaWYgZW1wdHksIHB1dCBpbml0aWFsIGFycmF5XG4gICAgICAgICQkLnV0aWwuc2V0TWFwKCAkLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAgIHZhbHVlOiBbIG9wdGlvbnMudmFsdWUgXVxuICAgICAgICB9KSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXkucHVzaCggb3B0aW9ucy52YWx1ZSApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBzZXRzIHRoZSB2YWx1ZSBpbiBhIG1hcCAobWFwIG1heSBub3QgYmUgYnVpbHQpXG4gICAgc2V0TWFwOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgICAgdmFyIGtleTtcbiAgICAgIHZhciBrZXlzID0gb3B0aW9ucy5rZXlzO1xuICAgICAgdmFyIGwgPSBrZXlzLmxlbmd0aDtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKyl7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdCgga2V5ICkgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdUcmllZCB0byBzZXQgbWFwIHdpdGggb2JqZWN0IGtleScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGkgPCBrZXlzLmxlbmd0aCAtIDEgKXtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBleHRlbmQgdGhlIG1hcCBpZiBuZWNlc3NhcnlcbiAgICAgICAgICBpZiggb2JqW2tleV0gPT0gbnVsbCApe1xuICAgICAgICAgICAgb2JqW2tleV0gPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZVxuICAgICAgICAgIG9ialtrZXldID0gb3B0aW9ucy52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgLy8gZ2V0cyB0aGUgdmFsdWUgaW4gYSBtYXAgZXZlbiBpZiBpdCdzIG5vdCBidWlsdCBpbiBwbGFjZXNcbiAgICBnZXRNYXA6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgb2JqID0gb3B0aW9ucy5tYXA7XG4gICAgICB2YXIga2V5cyA9IG9wdGlvbnMua2V5cztcbiAgICAgIHZhciBsID0ga2V5cy5sZW5ndGg7XG4gICAgICBcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspe1xuICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgICBpZiggJCQuaXMucGxhaW5PYmplY3QoIGtleSApICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignVHJpZWQgdG8gZ2V0IG1hcCB3aXRoIG9iamVjdCBrZXknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9iaiA9IG9ialtrZXldO1xuICAgICAgICBcbiAgICAgICAgaWYoIG9iaiA9PSBudWxsICl7XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG5cbiAgICAvLyBkZWxldGVzIHRoZSBlbnRyeSBpbiB0aGUgbWFwXG4gICAgZGVsZXRlTWFwOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIG9iaiA9IG9wdGlvbnMubWFwO1xuICAgICAgdmFyIGtleXMgPSBvcHRpb25zLmtleXM7XG4gICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgdmFyIGtlZXBDaGlsZHJlbiA9IG9wdGlvbnMua2VlcENoaWxkcmVuO1xuICAgICAgXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKXtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KCBrZXkgKSApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1RyaWVkIHRvIGRlbGV0ZSBtYXAgd2l0aCBvYmplY3Qga2V5Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdEtleSA9IGkgPT09IG9wdGlvbnMua2V5cy5sZW5ndGggLSAxO1xuICAgICAgICBpZiggbGFzdEtleSApe1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBrZWVwQ2hpbGRyZW4gKXsgLy8gdGhlbiBvbmx5IGRlbGV0ZSBjaGlsZCBmaWVsZHMgbm90IGluIGtlZXBDaGlsZHJlblxuICAgICAgICAgICAgZm9yKCB2YXIgY2hpbGQgaW4gb2JqICl7XG4gICAgICAgICAgICAgIGlmKCAha2VlcENoaWxkcmVuW2NoaWxkXSApe1xuICAgICAgICAgICAgICAgIG9ialtjaGlsZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqID0gb2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIGNhcGl0YWxpemU6IGZ1bmN0aW9uKHN0cil7XG4gICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoc3RyKSApe1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgICB9LFxuXG4gICAgY2FtZWwyZGFzaDogZnVuY3Rpb24oIHN0ciApe1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgY2ggPSBzdHJbaV07XG4gICAgICAgIHZhciBjaExvd2VyQ2FzZSA9IGNoLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBpc1VwcGVyQ2FzZSA9IGNoICE9PSBjaExvd2VyQ2FzZTtcblxuICAgICAgICBpZiggaXNVcHBlckNhc2UgKXtcbiAgICAgICAgICByZXQucHVzaCggJy0nICk7XG4gICAgICAgICAgcmV0LnB1c2goIGNoTG93ZXJDYXNlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0LnB1c2goIGNoICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5vVXBwZXJDYXNlcyA9IHJldC5sZW5ndGggPT09IHN0ci5sZW5ndGg7XG4gICAgICBpZiggbm9VcHBlckNhc2VzICl7IHJldHVybiBzdHI7IH0gLy8gY2hlYXBlciB0aGFuIC5qb2luKClcblxuICAgICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgZGFzaDJjYW1lbDogZnVuY3Rpb24oIHN0ciApe1xuICAgICAgdmFyIHJldCA9IFtdO1xuICAgICAgdmFyIG5leHRJc1VwcGVyID0gZmFsc2U7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjaCA9IHN0cltpXTtcbiAgICAgICAgdmFyIGlzRGFzaCA9IGNoID09PSAnLSc7XG5cbiAgICAgICAgaWYoIGlzRGFzaCApe1xuICAgICAgICAgIG5leHRJc1VwcGVyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiggbmV4dElzVXBwZXIgKXtcbiAgICAgICAgICAgIHJldC5wdXNoKCBjaC50b1VwcGVyQ2FzZSgpICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldC5wdXNoKCBjaCApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHRJc1VwcGVyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gc3RyaXAgc3BhY2VzIGZyb20gYmVnaW5uaW5nIG9mIHN0cmluZyBhbmQgZW5kIG9mIHN0cmluZ1xuICAgIHRyaW06IGZ1bmN0aW9uKCBzdHIgKXtcbiAgICAgIHZhciBmaXJzdCwgbGFzdDtcblxuICAgICAgLy8gZmluZCBmaXJzdCBub24tc3BhY2UgY2hhclxuICAgICAgZm9yKCBmaXJzdCA9IDA7IGZpcnN0IDwgc3RyLmxlbmd0aCAmJiBzdHJbZmlyc3RdID09PSAnICc7IGZpcnN0KysgKXt9XG5cbiAgICAgIC8vIGZpbmQgbGFzdCBub24tc3BhY2UgY2hhclxuICAgICAgZm9yKCBsYXN0ID0gc3RyLmxlbmd0aCAtIDE7IGxhc3QgPiBmaXJzdCAmJiBzdHJbbGFzdF0gPT09ICcgJzsgbGFzdC0tICl7fVxuXG4gICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhmaXJzdCwgbGFzdCArIDEpO1xuICAgIH0sXG5cbiAgICAvLyBnZXQgW3IsIGcsIGJdIGZyb20gI2FiYyBvciAjYWFiYmNjXG4gICAgaGV4MnR1cGxlOiBmdW5jdGlvbiggaGV4ICl7XG4gICAgICBpZiggIShoZXgubGVuZ3RoID09PSA0IHx8IGhleC5sZW5ndGggPT09IDcpIHx8IGhleFswXSAhPT0gXCIjXCIgKXsgcmV0dXJuOyB9XG5cbiAgICAgIHZhciBzaG9ydEhleCA9IGhleC5sZW5ndGggPT09IDQ7XG4gICAgICB2YXIgciwgZywgYjtcbiAgICAgIHZhciBiYXNlID0gMTY7XG5cbiAgICAgIGlmKCBzaG9ydEhleCApe1xuICAgICAgICByID0gcGFyc2VJbnQoIGhleFsxXSArIGhleFsxXSwgYmFzZSApO1xuICAgICAgICBnID0gcGFyc2VJbnQoIGhleFsyXSArIGhleFsyXSwgYmFzZSApO1xuICAgICAgICBiID0gcGFyc2VJbnQoIGhleFszXSArIGhleFszXSwgYmFzZSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHBhcnNlSW50KCBoZXhbMV0gKyBoZXhbMl0sIGJhc2UgKTtcbiAgICAgICAgZyA9IHBhcnNlSW50KCBoZXhbM10gKyBoZXhbNF0sIGJhc2UgKTtcbiAgICAgICAgYiA9IHBhcnNlSW50KCBoZXhbNV0gKyBoZXhbNl0sIGJhc2UgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgICB9LFxuXG4gICAgLy8gZ2V0IFtyLCBnLCBiLCBhXSBmcm9tIGhzbCgwLCAwLCAwKSBvciBoc2xhKDAsIDAsIDAsIDApXG4gICAgaHNsMnR1cGxlOiBmdW5jdGlvbiggaHNsICl7XG4gICAgICB2YXIgcmV0O1xuICAgICAgdmFyIGgsIHMsIGwsIGEsIHIsIGcsIGI7XG4gICAgICBmdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpe1xuICAgICAgICBpZih0IDwgMCkgdCArPSAxO1xuICAgICAgICBpZih0ID4gMSkgdCAtPSAxO1xuICAgICAgICBpZih0IDwgMS82KSByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICAgICAgaWYodCA8IDEvMikgcmV0dXJuIHE7XG4gICAgICAgIGlmKHQgPCAyLzMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyLzMgLSB0KSAqIDY7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbSA9IG5ldyBSZWdFeHAoXCJeXCIgKyAkJC51dGlsLnJlZ2V4LmhzbGEgKyBcIiRcIikuZXhlYyhoc2wpO1xuICAgICAgaWYoIG0gKXtcblxuICAgICAgICAvLyBnZXQgaHVlXG4gICAgICAgIGggPSBwYXJzZUludCggbVsxXSApOyBcbiAgICAgICAgaWYoIGggPCAwICl7XG4gICAgICAgICAgaCA9ICggMzYwIC0gKC0xKmggJSAzNjApICkgJSAzNjA7XG4gICAgICAgIH0gZWxzZSBpZiggaCA+IDM2MCApe1xuICAgICAgICAgIGggPSBoICUgMzYwO1xuICAgICAgICB9XG4gICAgICAgIGggLz0gMzYwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgICAgcyA9IHBhcnNlRmxvYXQoIG1bMl0gKTtcbiAgICAgICAgaWYoIHMgPCAwIHx8IHMgPiAxMDAgKXsgcmV0dXJuOyB9IC8vIHNhdHVyYXRpb24gaXMgWzAsIDEwMF1cbiAgICAgICAgcyA9IHMvMTAwOyAvLyBub3JtYWxpc2Ugb24gWzAsIDFdXG5cbiAgICAgICAgbCA9IHBhcnNlRmxvYXQoIG1bM10gKTtcbiAgICAgICAgaWYoIGwgPCAwIHx8IGwgPiAxMDAgKXsgcmV0dXJuOyB9IC8vIGxpZ2h0bmVzcyBpcyBbMCwgMTAwXVxuICAgICAgICBsID0gbC8xMDA7IC8vIG5vcm1hbGlzZSBvbiBbMCwgMV1cblxuICAgICAgICBhID0gbVs0XTtcbiAgICAgICAgaWYoIGEgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIGEgPSBwYXJzZUZsb2F0KCBhICk7XG5cbiAgICAgICAgICBpZiggYSA8IDAgfHwgYSA+IDEgKXsgcmV0dXJuOyB9IC8vIGFscGhhIGlzIFswLCAxXVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm93LCBjb252ZXJ0IHRvIHJnYlxuICAgICAgICAvLyBjb2RlIGZyb20gaHR0cDovL21qaWphY2tzb24uY29tLzIwMDgvMDIvcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jb252ZXJzaW9uLWFsZ29yaXRobXMtaW4tamF2YXNjcmlwdFxuICAgICAgICBpZiggcyA9PT0gMCApe1xuICAgICAgICAgIHIgPSBnID0gYiA9IE1hdGgucm91bmQobCAqIDI1NSk7IC8vIGFjaHJvbWF0aWNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcSA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHM7XG4gICAgICAgICAgdmFyIHAgPSAyICogbCAtIHE7XG4gICAgICAgICAgciA9IE1hdGgucm91bmQoIDI1NSAqIGh1ZTJyZ2IocCwgcSwgaCArIDEvMykgKTtcbiAgICAgICAgICBnID0gTWF0aC5yb3VuZCggMjU1ICogaHVlMnJnYihwLCBxLCBoKSApO1xuICAgICAgICAgIGIgPSBNYXRoLnJvdW5kKCAyNTUgKiBodWUycmdiKHAsIHEsIGggLSAxLzMpICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXQgPSBbciwgZywgYiwgYV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8vIGdldCBbciwgZywgYiwgYV0gZnJvbSByZ2IoMCwgMCwgMCkgb3IgcmdiYSgwLCAwLCAwLCAwKVxuICAgIHJnYjJ0dXBsZTogZnVuY3Rpb24oIHJnYiApe1xuICAgICAgdmFyIHJldDtcblxuICAgICAgdmFyIG0gPSBuZXcgUmVnRXhwKFwiXlwiICsgJCQudXRpbC5yZWdleC5yZ2JhICsgXCIkXCIpLmV4ZWMocmdiKTtcbiAgICAgIGlmKCBtICl7XG4gICAgICAgIHJldCA9IFtdO1xuXG4gICAgICAgIHZhciBpc1BjdCA9IFtdO1xuICAgICAgICBmb3IoIHZhciBpID0gMTsgaSA8PSAzOyBpKysgKXtcbiAgICAgICAgICB2YXIgY2hhbm5lbCA9IG1baV07XG5cbiAgICAgICAgICBpZiggY2hhbm5lbFsgY2hhbm5lbC5sZW5ndGggLSAxIF0gPT09IFwiJVwiICl7XG4gICAgICAgICAgICBpc1BjdFtpXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYW5uZWwgPSBwYXJzZUZsb2F0KCBjaGFubmVsICk7XG5cbiAgICAgICAgICBpZiggaXNQY3RbaV0gKXtcbiAgICAgICAgICAgIGNoYW5uZWwgPSBjaGFubmVsLzEwMCAqIDI1NTsgLy8gbm9ybWFsaXNlIHRvIFswLCAyNTVdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGNoYW5uZWwgPCAwIHx8IGNoYW5uZWwgPiAyNTUgKXsgcmV0dXJuOyB9IC8vIGludmFsaWQgY2hhbm5lbCB2YWx1ZVxuXG4gICAgICAgICAgcmV0LnB1c2goIE1hdGguZmxvb3IoY2hhbm5lbCkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdExlYXN0T25lSXNQY3QgPSBpc1BjdFsxXSB8fCBpc1BjdFsyXSB8fCBpc1BjdFszXTtcbiAgICAgICAgdmFyIGFsbEFyZVBjdCA9IGlzUGN0WzFdICYmIGlzUGN0WzJdICYmIGlzUGN0WzNdO1xuICAgICAgICBpZiggYXRMZWFzdE9uZUlzUGN0ICYmICFhbGxBcmVQY3QgKXsgcmV0dXJuOyB9IC8vIG11c3QgYWxsIGJlIHBlcmNlbnQgdmFsdWVzIGlmIG9uZSBpc1xuXG4gICAgICAgIHZhciBhbHBoYSA9IG1bNF07XG4gICAgICAgIGlmKCBhbHBoYSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgYWxwaGEgPSBwYXJzZUZsb2F0KCBhbHBoYSApO1xuXG4gICAgICAgICAgaWYoIGFscGhhIDwgMCB8fCBhbHBoYSA+IDEgKXsgcmV0dXJuOyB9IC8vIGludmFsaWQgYWxwaGEgdmFsdWVcblxuICAgICAgICAgIHJldC5wdXNoKCBhbHBoYSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIGNvbG9ybmFtZTJ0dXBsZTogZnVuY3Rpb24oIGNvbG9yICl7XG4gICAgICByZXR1cm4gJCQudXRpbC5jb2xvcnNbIGNvbG9yLnRvTG93ZXJDYXNlKCkgXTtcbiAgICB9LFxuXG4gICAgY29sb3IydHVwbGU6IGZ1bmN0aW9uKCBjb2xvciApe1xuICAgICAgcmV0dXJuICggJCQuaXMuYXJyYXkoY29sb3IpID8gY29sb3IgOiBudWxsICkgXG4gICAgICAgIHx8ICQkLnV0aWwuY29sb3JuYW1lMnR1cGxlKGNvbG9yKVxuICAgICAgICB8fCAkJC51dGlsLmhleDJ0dXBsZShjb2xvcilcbiAgICAgICAgfHwgJCQudXRpbC5yZ2IydHVwbGUoY29sb3IpXG4gICAgICAgIHx8ICQkLnV0aWwuaHNsMnR1cGxlKGNvbG9yKTtcbiAgICB9LFxuXG4gICAgdHVwbGUyaGV4OiBmdW5jdGlvbiggdHVwbGUgKXtcbiAgICAgIHZhciByID0gdHVwbGVbMF07XG4gICAgICB2YXIgZyA9IHR1cGxlWzFdO1xuICAgICAgdmFyIGIgPSB0dXBsZVsyXTtcblxuICAgICAgZnVuY3Rpb24gY2gyaGV4KCBjaCApe1xuICAgICAgICB2YXIgaGV4ID0gY2gudG9TdHJpbmcoMTYpO1xuXG4gICAgICAgIGlmKCBoZXgubGVuZ3RoID09PSAxICl7XG4gICAgICAgICAgaGV4ID0gJzAnICsgaGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhleDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcjJyArIGNoMmhleChyKSArIGNoMmhleChnKSArIGNoMmhleChiKTtcbiAgICB9LFxuXG4gICAgY29sb3JzOiB7XG4gICAgICAvLyBzcGVjaWFsIGNvbG91ciBuYW1lc1xuICAgICAgdHJhbnNwYXJlbnQ6ICAgICAgWzAsMCwwLDBdLCAvLyBOQiBhbHBoYSA9PT0gMFxuXG4gICAgICAvLyByZWd1bGFyIGNvbG91cnNcbiAgICAgIGFsaWNlYmx1ZTogICAgICAgIFsyNDAsMjQ4LDI1NV0sXG4gICAgICBhbnRpcXVld2hpdGU6ICAgICAgWzI1MCwyMzUsMjE1XSxcbiAgICAgIGFxdWE6ICAgICAgICAgIFswLDI1NSwyNTVdLFxuICAgICAgYXF1YW1hcmluZTogICAgICAgIFsxMjcsMjU1LDIxMl0sXG4gICAgICBhenVyZTogICAgICAgICAgWzI0MCwyNTUsMjU1XSxcbiAgICAgIGJlaWdlOiAgICAgICAgICBbMjQ1LDI0NSwyMjBdLFxuICAgICAgYmlzcXVlOiAgICAgICAgICBbMjU1LDIyOCwxOTZdLFxuICAgICAgYmxhY2s6ICAgICAgICAgIFswLDAsMF0sXG4gICAgICBibGFuY2hlZGFsbW9uZDogICAgICBbMjU1LDIzNSwyMDVdLFxuICAgICAgYmx1ZTogICAgICAgICAgWzAsMCwyNTVdLFxuICAgICAgYmx1ZXZpb2xldDogICAgICAgIFsxMzgsNDMsMjI2XSxcbiAgICAgIGJyb3duOiAgICAgICAgICBbMTY1LDQyLDQyXSxcbiAgICAgIGJ1cmx5d29vZDogICAgICAgIFsyMjIsMTg0LDEzNV0sXG4gICAgICBjYWRldGJsdWU6ICAgICAgICBbOTUsMTU4LDE2MF0sXG4gICAgICBjaGFydHJldXNlOiAgICAgICAgWzEyNywyNTUsMF0sXG4gICAgICBjaG9jb2xhdGU6ICAgICAgICBbMjEwLDEwNSwzMF0sXG4gICAgICBjb3JhbDogICAgICAgICAgWzI1NSwxMjcsODBdLFxuICAgICAgY29ybmZsb3dlcmJsdWU6ICAgICAgWzEwMCwxNDksMjM3XSxcbiAgICAgIGNvcm5zaWxrOiAgICAgICAgWzI1NSwyNDgsMjIwXSxcbiAgICAgIGNyaW1zb246ICAgICAgICBbMjIwLDIwLDYwXSxcbiAgICAgIGN5YW46ICAgICAgICAgIFswLDI1NSwyNTVdLFxuICAgICAgZGFya2JsdWU6ICAgICAgICBbMCwwLDEzOV0sXG4gICAgICBkYXJrY3lhbjogICAgICAgIFswLDEzOSwxMzldLFxuICAgICAgZGFya2dvbGRlbnJvZDogICAgICBbMTg0LDEzNCwxMV0sXG4gICAgICBkYXJrZ3JheTogICAgICAgIFsxNjksMTY5LDE2OV0sXG4gICAgICBkYXJrZ3JlZW46ICAgICAgICBbMCwxMDAsMF0sXG4gICAgICBkYXJrZ3JleTogICAgICAgIFsxNjksMTY5LDE2OV0sXG4gICAgICBkYXJra2hha2k6ICAgICAgICBbMTg5LDE4MywxMDddLFxuICAgICAgZGFya21hZ2VudGE6ICAgICAgWzEzOSwwLDEzOV0sXG4gICAgICBkYXJrb2xpdmVncmVlbjogICAgICBbODUsMTA3LDQ3XSxcbiAgICAgIGRhcmtvcmFuZ2U6ICAgICAgICBbMjU1LDE0MCwwXSxcbiAgICAgIGRhcmtvcmNoaWQ6ICAgICAgICBbMTUzLDUwLDIwNF0sXG4gICAgICBkYXJrcmVkOiAgICAgICAgWzEzOSwwLDBdLFxuICAgICAgZGFya3NhbG1vbjogICAgICAgIFsyMzMsMTUwLDEyMl0sXG4gICAgICBkYXJrc2VhZ3JlZW46ICAgICAgWzE0MywxODgsMTQzXSxcbiAgICAgIGRhcmtzbGF0ZWJsdWU6ICAgICAgWzcyLDYxLDEzOV0sXG4gICAgICBkYXJrc2xhdGVncmF5OiAgICAgIFs0Nyw3OSw3OV0sXG4gICAgICBkYXJrc2xhdGVncmV5OiAgICAgIFs0Nyw3OSw3OV0sXG4gICAgICBkYXJrdHVycXVvaXNlOiAgICAgIFswLDIwNiwyMDldLFxuICAgICAgZGFya3Zpb2xldDogICAgICAgIFsxNDgsMCwyMTFdLFxuICAgICAgZGVlcHBpbms6ICAgICAgICBbMjU1LDIwLDE0N10sXG4gICAgICBkZWVwc2t5Ymx1ZTogICAgICBbMCwxOTEsMjU1XSxcbiAgICAgIGRpbWdyYXk6ICAgICAgICBbMTA1LDEwNSwxMDVdLFxuICAgICAgZGltZ3JleTogICAgICAgIFsxMDUsMTA1LDEwNV0sXG4gICAgICBkb2RnZXJibHVlOiAgICAgICAgWzMwLDE0NCwyNTVdLFxuICAgICAgZmlyZWJyaWNrOiAgICAgICAgWzE3OCwzNCwzNF0sXG4gICAgICBmbG9yYWx3aGl0ZTogICAgICBbMjU1LDI1MCwyNDBdLFxuICAgICAgZm9yZXN0Z3JlZW46ICAgICAgWzM0LDEzOSwzNF0sXG4gICAgICBmdWNoc2lhOiAgICAgICAgWzI1NSwwLDI1NV0sXG4gICAgICBnYWluc2Jvcm86ICAgICAgICBbMjIwLDIyMCwyMjBdLFxuICAgICAgZ2hvc3R3aGl0ZTogICAgICAgIFsyNDgsMjQ4LDI1NV0sXG4gICAgICBnb2xkOiAgICAgICAgICBbMjU1LDIxNSwwXSxcbiAgICAgIGdvbGRlbnJvZDogICAgICAgIFsyMTgsMTY1LDMyXSxcbiAgICAgIGdyYXk6ICAgICAgICAgIFsxMjgsMTI4LDEyOF0sXG4gICAgICBncmV5OiAgICAgICAgICBbMTI4LDEyOCwxMjhdLFxuICAgICAgZ3JlZW46ICAgICAgICAgIFswLDEyOCwwXSxcbiAgICAgIGdyZWVueWVsbG93OiAgICAgIFsxNzMsMjU1LDQ3XSxcbiAgICAgIGhvbmV5ZGV3OiAgICAgICAgWzI0MCwyNTUsMjQwXSxcbiAgICAgIGhvdHBpbms6ICAgICAgICBbMjU1LDEwNSwxODBdLFxuICAgICAgaW5kaWFucmVkOiAgICAgICAgWzIwNSw5Miw5Ml0sXG4gICAgICBpbmRpZ286ICAgICAgICAgIFs3NSwwLDEzMF0sXG4gICAgICBpdm9yeTogICAgICAgICAgWzI1NSwyNTUsMjQwXSxcbiAgICAgIGtoYWtpOiAgICAgICAgICBbMjQwLDIzMCwxNDBdLFxuICAgICAgbGF2ZW5kZXI6ICAgICAgICBbMjMwLDIzMCwyNTBdLFxuICAgICAgbGF2ZW5kZXJibHVzaDogICAgICBbMjU1LDI0MCwyNDVdLFxuICAgICAgbGF3bmdyZWVuOiAgICAgICAgWzEyNCwyNTIsMF0sXG4gICAgICBsZW1vbmNoaWZmb246ICAgICAgWzI1NSwyNTAsMjA1XSxcbiAgICAgIGxpZ2h0Ymx1ZTogICAgICAgIFsxNzMsMjE2LDIzMF0sXG4gICAgICBsaWdodGNvcmFsOiAgICAgICAgWzI0MCwxMjgsMTI4XSxcbiAgICAgIGxpZ2h0Y3lhbjogICAgICAgIFsyMjQsMjU1LDI1NV0sXG4gICAgICBsaWdodGdvbGRlbnJvZHllbGxvdzogIFsyNTAsMjUwLDIxMF0sXG4gICAgICBsaWdodGdyYXk6ICAgICAgICBbMjExLDIxMSwyMTFdLFxuICAgICAgbGlnaHRncmVlbjogICAgICAgIFsxNDQsMjM4LDE0NF0sXG4gICAgICBsaWdodGdyZXk6ICAgICAgICBbMjExLDIxMSwyMTFdLFxuICAgICAgbGlnaHRwaW5rOiAgICAgICAgWzI1NSwxODIsMTkzXSxcbiAgICAgIGxpZ2h0c2FsbW9uOiAgICAgIFsyNTUsMTYwLDEyMl0sXG4gICAgICBsaWdodHNlYWdyZWVuOiAgICAgIFszMiwxNzgsMTcwXSxcbiAgICAgIGxpZ2h0c2t5Ymx1ZTogICAgICBbMTM1LDIwNiwyNTBdLFxuICAgICAgbGlnaHRzbGF0ZWdyYXk6ICAgICAgWzExOSwxMzYsMTUzXSxcbiAgICAgIGxpZ2h0c2xhdGVncmV5OiAgICAgIFsxMTksMTM2LDE1M10sXG4gICAgICBsaWdodHN0ZWVsYmx1ZTogICAgICBbMTc2LDE5NiwyMjJdLFxuICAgICAgbGlnaHR5ZWxsb3c6ICAgICAgWzI1NSwyNTUsMjI0XSxcbiAgICAgIGxpbWU6ICAgICAgICAgIFswLDI1NSwwXSxcbiAgICAgIGxpbWVncmVlbjogICAgICAgIFs1MCwyMDUsNTBdLFxuICAgICAgbGluZW46ICAgICAgICAgIFsyNTAsMjQwLDIzMF0sXG4gICAgICBtYWdlbnRhOiAgICAgICAgWzI1NSwwLDI1NV0sXG4gICAgICBtYXJvb246ICAgICAgICAgIFsxMjgsMCwwXSxcbiAgICAgIG1lZGl1bWFxdWFtYXJpbmU6ICAgIFsxMDIsMjA1LDE3MF0sXG4gICAgICBtZWRpdW1ibHVlOiAgICAgICAgWzAsMCwyMDVdLFxuICAgICAgbWVkaXVtb3JjaGlkOiAgICAgIFsxODYsODUsMjExXSxcbiAgICAgIG1lZGl1bXB1cnBsZTogICAgICBbMTQ3LDExMiwyMTldLFxuICAgICAgbWVkaXVtc2VhZ3JlZW46ICAgICAgWzYwLDE3OSwxMTNdLFxuICAgICAgbWVkaXVtc2xhdGVibHVlOiAgICBbMTIzLDEwNCwyMzhdLFxuICAgICAgbWVkaXVtc3ByaW5nZ3JlZW46ICAgIFswLDI1MCwxNTRdLFxuICAgICAgbWVkaXVtdHVycXVvaXNlOiAgICBbNzIsMjA5LDIwNF0sXG4gICAgICBtZWRpdW12aW9sZXRyZWQ6ICAgIFsxOTksMjEsMTMzXSxcbiAgICAgIG1pZG5pZ2h0Ymx1ZTogICAgICBbMjUsMjUsMTEyXSxcbiAgICAgIG1pbnRjcmVhbTogICAgICAgIFsyNDUsMjU1LDI1MF0sXG4gICAgICBtaXN0eXJvc2U6ICAgICAgICBbMjU1LDIyOCwyMjVdLFxuICAgICAgbW9jY2FzaW46ICAgICAgICBbMjU1LDIyOCwxODFdLFxuICAgICAgbmF2YWpvd2hpdGU6ICAgICAgWzI1NSwyMjIsMTczXSxcbiAgICAgIG5hdnk6ICAgICAgICAgIFswLDAsMTI4XSxcbiAgICAgIG9sZGxhY2U6ICAgICAgICBbMjUzLDI0NSwyMzBdLFxuICAgICAgb2xpdmU6ICAgICAgICAgIFsxMjgsMTI4LDBdLFxuICAgICAgb2xpdmVkcmFiOiAgICAgICAgWzEwNywxNDIsMzVdLFxuICAgICAgb3JhbmdlOiAgICAgICAgICBbMjU1LDE2NSwwXSxcbiAgICAgIG9yYW5nZXJlZDogICAgICAgIFsyNTUsNjksMF0sXG4gICAgICBvcmNoaWQ6ICAgICAgICAgIFsyMTgsMTEyLDIxNF0sXG4gICAgICBwYWxlZ29sZGVucm9kOiAgICAgIFsyMzgsMjMyLDE3MF0sXG4gICAgICBwYWxlZ3JlZW46ICAgICAgICBbMTUyLDI1MSwxNTJdLFxuICAgICAgcGFsZXR1cnF1b2lzZTogICAgICBbMTc1LDIzOCwyMzhdLFxuICAgICAgcGFsZXZpb2xldHJlZDogICAgICBbMjE5LDExMiwxNDddLFxuICAgICAgcGFwYXlhd2hpcDogICAgICAgIFsyNTUsMjM5LDIxM10sXG4gICAgICBwZWFjaHB1ZmY6ICAgICAgICBbMjU1LDIxOCwxODVdLFxuICAgICAgcGVydTogICAgICAgICAgWzIwNSwxMzMsNjNdLFxuICAgICAgcGluazogICAgICAgICAgWzI1NSwxOTIsMjAzXSxcbiAgICAgIHBsdW06ICAgICAgICAgIFsyMjEsMTYwLDIyMV0sXG4gICAgICBwb3dkZXJibHVlOiAgICAgICAgWzE3NiwyMjQsMjMwXSxcbiAgICAgIHB1cnBsZTogICAgICAgICAgWzEyOCwwLDEyOF0sXG4gICAgICByZWQ6ICAgICAgICAgIFsyNTUsMCwwXSxcbiAgICAgIHJvc3licm93bjogICAgICAgIFsxODgsMTQzLDE0M10sXG4gICAgICByb3lhbGJsdWU6ICAgICAgICBbNjUsMTA1LDIyNV0sXG4gICAgICBzYWRkbGVicm93bjogICAgICBbMTM5LDY5LDE5XSxcbiAgICAgIHNhbG1vbjogICAgICAgICAgWzI1MCwxMjgsMTE0XSxcbiAgICAgIHNhbmR5YnJvd246ICAgICAgICBbMjQ0LDE2NCw5Nl0sXG4gICAgICBzZWFncmVlbjogICAgICAgIFs0NiwxMzksODddLFxuICAgICAgc2Vhc2hlbGw6ICAgICAgICBbMjU1LDI0NSwyMzhdLFxuICAgICAgc2llbm5hOiAgICAgICAgICBbMTYwLDgyLDQ1XSxcbiAgICAgIHNpbHZlcjogICAgICAgICAgWzE5MiwxOTIsMTkyXSxcbiAgICAgIHNreWJsdWU6ICAgICAgICBbMTM1LDIwNiwyMzVdLFxuICAgICAgc2xhdGVibHVlOiAgICAgICAgWzEwNiw5MCwyMDVdLFxuICAgICAgc2xhdGVncmF5OiAgICAgICAgWzExMiwxMjgsMTQ0XSxcbiAgICAgIHNsYXRlZ3JleTogICAgICAgIFsxMTIsMTI4LDE0NF0sXG4gICAgICBzbm93OiAgICAgICAgICBbMjU1LDI1MCwyNTBdLFxuICAgICAgc3ByaW5nZ3JlZW46ICAgICAgWzAsMjU1LDEyN10sXG4gICAgICBzdGVlbGJsdWU6ICAgICAgICBbNzAsMTMwLDE4MF0sXG4gICAgICB0YW46ICAgICAgICAgIFsyMTAsMTgwLDE0MF0sXG4gICAgICB0ZWFsOiAgICAgICAgICBbMCwxMjgsMTI4XSxcbiAgICAgIHRoaXN0bGU6ICAgICAgICBbMjE2LDE5MSwyMTZdLFxuICAgICAgdG9tYXRvOiAgICAgICAgICBbMjU1LDk5LDcxXSxcbiAgICAgIHR1cnF1b2lzZTogICAgICAgIFs2NCwyMjQsMjA4XSxcbiAgICAgIHZpb2xldDogICAgICAgICAgWzIzOCwxMzAsMjM4XSxcbiAgICAgIHdoZWF0OiAgICAgICAgICBbMjQ1LDIyMiwxNzldLFxuICAgICAgd2hpdGU6ICAgICAgICAgIFsyNTUsMjU1LDI1NV0sXG4gICAgICB3aGl0ZXNtb2tlOiAgICAgICAgWzI0NSwyNDUsMjQ1XSxcbiAgICAgIHllbGxvdzogICAgICAgICAgWzI1NSwyNTUsMF0sXG4gICAgICB5ZWxsb3dncmVlbjogICAgICBbMTU0LDIwNSw1MF1cbiAgICB9XG4gICAgICBcbiAgfTtcblxuICAkJC51dGlsLnJlZ2V4ID0ge307XG4gIFxuICAkJC51dGlsLnJlZ2V4Lm51bWJlciA9IFwiKD86Wy1dP1xcXFxkKlxcXFwuXFxcXGQrfFstXT9cXFxcZCt8Wy1dP1xcXFxkKlxcXFwuXFxcXGQrW2VFXVxcXFxkKylcIjtcbiAgXG4gICQkLnV0aWwucmVnZXgucmdiYSA9IFwicmdiW2FdP1xcXFwoKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0/KVxcXFxzKixcXFxccyooXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXT8pXFxcXHMqLFxcXFxzKihcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdPykoPzpcXFxccyosXFxcXHMqKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpKT9cXFxcKVwiO1xuICAkJC51dGlsLnJlZ2V4LnJnYmFOb0JhY2tSZWZzID0gXCJyZ2JbYV0/XFxcXCgoPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdPylcXFxccyosXFxcXHMqKD86XCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXT8pXFxcXHMqLFxcXFxzKig/OlwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCJbJV0/KSg/OlxcXFxzKixcXFxccyooPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiKSk/XFxcXClcIjtcbiAgXG4gICQkLnV0aWwucmVnZXguaHNsYSA9IFwiaHNsW2FdP1xcXFwoKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpXFxcXHMqLFxcXFxzKihcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdKVxcXFxzKixcXFxccyooXCIrICQkLnV0aWwucmVnZXgubnVtYmVyICtcIlslXSkoPzpcXFxccyosXFxcXHMqKFwiKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArXCIpKT9cXFxcKVwiO1xuICAkJC51dGlsLnJlZ2V4LmhzbGFOb0JhY2tSZWZzID0gXCJoc2xbYV0/XFxcXCgoPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiKVxcXFxzKixcXFxccyooPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdKVxcXFxzKixcXFxccyooPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiWyVdKSg/OlxcXFxzKixcXFxccyooPzpcIisgJCQudXRpbC5yZWdleC5udW1iZXIgK1wiKSk/XFxcXClcIjtcbiAgXG4gICQkLnV0aWwucmVnZXguaGV4MyA9IFwiXFxcXCNbMC05YS1mQS1GXXszfVwiO1xuICAkJC51dGlsLnJlZ2V4LmhleDYgPSBcIlxcXFwjWzAtOWEtZkEtRl17Nn1cIjtcblxuICB2YXIgcmFmID0gIXdpbmRvdyA/IG51bGwgOiAoIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCAgXG4gICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lICk7XG5cbiAgcmFmID0gcmFmIHx8IGZ1bmN0aW9uKGZuKXsgaWYoZm4peyBzZXRUaW1lb3V0KGZuLCAxMDAwLzYwKTsgfSB9O1xuXG4gICQkLnV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oZm4pe1xuICAgIHJhZiggZm4gKTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQubWF0aCA9IHt9O1xuICBcbiAgJCQubWF0aC5zaWdudW0gPSBmdW5jdGlvbih4KXtcbiAgICBpZiggeCA+IDAgKXtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiggeCA8IDAgKXtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuXG4gICQkLm1hdGguZGlzdGFuY2UgPSBmdW5jdGlvbiggcDEsIHAyICl7XG4gICAgdmFyIGR4ID0gcDIueCAtIHAxLng7XG4gICAgdmFyIGR5ID0gcDIueSAtIHAxLnk7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KCBkeCpkeCArIGR5KmR5ICk7XG4gIH07XG5cbiAgLy8gZnJvbSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0LDqXppZXJfY3VydmUjUXVhZHJhdGljX2N1cnZlc1xuICAkJC5tYXRoLnFiZXppZXJBdCA9IGZ1bmN0aW9uKHAwLCBwMSwgcDIsIHQpe1xuICAgIHJldHVybiAoMSAtIHQpKigxIC0gdCkqcDAgKyAyKigxIC0gdCkqdCpwMSArIHQqdCpwMjtcbiAgfTtcblxuICAkJC5tYXRoLnFiZXppZXJQdEF0ID0gZnVuY3Rpb24ocDAsIHAxLCBwMiwgdCl7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6ICQkLm1hdGgucWJlemllckF0KCBwMC54LCBwMS54LCBwMi54LCB0ICksXG4gICAgICB5OiAkJC5tYXRoLnFiZXppZXJBdCggcDAueSwgcDEueSwgcDIueSwgdCApXG4gICAgfTtcbiAgfTtcblxuICAkJC5tYXRoLmJvdW5kaW5nQm94ZXNJbnRlcnNlY3QgPSBmdW5jdGlvbiggYmIxLCBiYjIgKXtcbiAgICAvLyBjYXNlOiBvbmUgYmIgdG8gcmlnaHQgb2Ygb3RoZXJcbiAgICBpZiggYmIxLngxID4gYmIyLngyICl7IHJldHVybiBmYWxzZTsgfVxuICAgIGlmKCBiYjIueDEgPiBiYjEueDIgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBjYXNlOiBvbmUgYmIgdG8gbGVmdCBvZiBvdGhlclxuICAgIGlmKCBiYjEueDIgPCBiYjIueDEgKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYoIGJiMi54MiA8IGJiMS54MSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIGNhc2U6IG9uZSBiYiBhYm92ZSBvdGhlclxuICAgIGlmKCBiYjEueTIgPCBiYjIueTEgKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYoIGJiMi55MiA8IGJiMS55MSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIGNhc2U6IG9uZSBiYiBiZWxvdyBvdGhlclxuICAgIGlmKCBiYjEueTEgPiBiYjIueTIgKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgaWYoIGJiMi55MSA+IGJiMS55MiApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIG90aGVyd2lzZSwgbXVzdCBoYXZlIHNvbWUgb3ZlcmxhcFxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gICQkLm1hdGguaW5Cb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCBiYiwgeCwgeSApe1xuICAgIHJldHVybiBiYi54MSA8PSB4ICYmIHggPD0gYmIueDIgJiYgYmIueTEgPD0geSAmJiB5IDw9IGJiLnkyO1xuICB9O1xuXG4gICQkLm1hdGgucG9pbnRJbkJvdW5kaW5nQm94ID0gZnVuY3Rpb24oIGJiLCBwdCApe1xuICAgIHJldHVybiB0aGlzLmluQm91bmRpbmdCb3goIGJiLCBwdC54LCBwdC55ICk7XG4gIH07XG5cbiAgJCQubWF0aC5yb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUgPSBmdW5jdGlvbihcbiAgICB4LCB5LCBub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgICBcbiAgICB2YXIgY29ybmVyUmFkaXVzID0gdGhpcy5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBcbiAgICB2YXIgaGFsZldpZHRoID0gd2lkdGggLyAyO1xuICAgIHZhciBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICBcbiAgICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggc3RyYWlnaHQgbGluZSBzZWdtZW50c1xuICAgIHZhciBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgIFxuICAgIC8vIFRvcCBzZWdtZW50LCBsZWZ0IHRvIHJpZ2h0XG4gICAge1xuICAgICAgdmFyIHRvcFN0YXJ0WCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzIC0gcGFkZGluZztcbiAgICAgIHZhciB0b3BTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgLSBwYWRkaW5nO1xuICAgICAgdmFyIHRvcEVuZFggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgICB2YXIgdG9wRW5kWSA9IHRvcFN0YXJ0WTtcbiAgICAgIFxuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgdG9wU3RhcnRYLCB0b3BTdGFydFksIHRvcEVuZFgsIHRvcEVuZFksIGZhbHNlKTtcbiAgICAgIFxuICAgICAgaWYgKHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gUmlnaHQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICAgIHtcbiAgICAgIHZhciByaWdodFN0YXJ0WCA9IG5vZGVYICsgaGFsZldpZHRoICsgcGFkZGluZztcbiAgICAgIHZhciByaWdodFN0YXJ0WSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgICB2YXIgcmlnaHRFbmRYID0gcmlnaHRTdGFydFg7XG4gICAgICB2YXIgcmlnaHRFbmRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICAgIFxuICAgICAgc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluaXRlTGluZXNJbnRlcnNlY3QoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgcmlnaHRTdGFydFgsIHJpZ2h0U3RhcnRZLCByaWdodEVuZFgsIHJpZ2h0RW5kWSwgZmFsc2UpO1xuICAgICAgXG4gICAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBCb3R0b20gc2VnbWVudCwgbGVmdCB0byByaWdodFxuICAgIHtcbiAgICAgIHZhciBib3R0b21TdGFydFggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cyAtIHBhZGRpbmc7XG4gICAgICB2YXIgYm90dG9tU3RhcnRZID0gbm9kZVkgKyBoYWxmSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgIHZhciBib3R0b21FbmRYID0gbm9kZVggKyBoYWxmV2lkdGggLSBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nO1xuICAgICAgdmFyIGJvdHRvbUVuZFkgPSBib3R0b21TdGFydFk7XG4gICAgICBcbiAgICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgICB4LCB5LCBub2RlWCwgbm9kZVksIGJvdHRvbVN0YXJ0WCwgYm90dG9tU3RhcnRZLCBib3R0b21FbmRYLCBib3R0b21FbmRZLCBmYWxzZSk7XG4gICAgICBcbiAgICAgIGlmIChzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIExlZnQgc2VnbWVudCwgdG9wIHRvIGJvdHRvbVxuICAgIHtcbiAgICAgIHZhciBsZWZ0U3RhcnRYID0gbm9kZVggLSBoYWxmV2lkdGggLSBwYWRkaW5nO1xuICAgICAgdmFyIGxlZnRTdGFydFkgPSBub2RlWSAtIGhhbGZIZWlnaHQgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgICAgdmFyIGxlZnRFbmRYID0gbGVmdFN0YXJ0WDtcbiAgICAgIHZhciBsZWZ0RW5kWSA9IG5vZGVZICsgaGFsZkhlaWdodCAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgICBcbiAgICAgIHN0cmFpZ2h0TGluZUludGVyc2VjdGlvbnMgPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgICB4LCB5LCBub2RlWCwgbm9kZVksIGxlZnRTdGFydFgsIGxlZnRTdGFydFksIGxlZnRFbmRYLCBsZWZ0RW5kWSwgZmFsc2UpO1xuICAgICAgXG4gICAgICBpZiAoc3RyYWlnaHRMaW5lSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiBzdHJhaWdodExpbmVJbnRlcnNlY3Rpb25zO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpbnRlcnNlY3Rpb25zIHdpdGggYXJjIHNlZ21lbnRzXG4gICAgdmFyIGFyY0ludGVyc2VjdGlvbnM7XG4gICAgXG4gICAgLy8gVG9wIExlZnRcbiAgICB7XG4gICAgICB2YXIgdG9wTGVmdENlbnRlclggPSBub2RlWCAtIGhhbGZXaWR0aCArIGNvcm5lclJhZGl1cztcbiAgICAgIHZhciB0b3BMZWZ0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgXG4gICAgICAgIHRvcExlZnRDZW50ZXJYLCB0b3BMZWZ0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdIDw9IHRvcExlZnRDZW50ZXJYXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wTGVmdENlbnRlclkpIHtcbiAgICAgICAgcmV0dXJuIFthcmNJbnRlcnNlY3Rpb25zWzBdLCBhcmNJbnRlcnNlY3Rpb25zWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gVG9wIFJpZ2h0XG4gICAge1xuICAgICAgdmFyIHRvcFJpZ2h0Q2VudGVyWCA9IG5vZGVYICsgaGFsZldpZHRoIC0gY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIHRvcFJpZ2h0Q2VudGVyWSA9IG5vZGVZIC0gaGFsZkhlaWdodCArIGNvcm5lclJhZGl1cztcbiAgICAgIGFyY0ludGVyc2VjdGlvbnMgPSB0aGlzLmludGVyc2VjdExpbmVDaXJjbGUoXG4gICAgICAgIHgsIHksIG5vZGVYLCBub2RlWSwgXG4gICAgICAgIHRvcFJpZ2h0Q2VudGVyWCwgdG9wUmlnaHRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPj0gdG9wUmlnaHRDZW50ZXJYXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMV0gPD0gdG9wUmlnaHRDZW50ZXJZKSB7XG4gICAgICAgIHJldHVybiBbYXJjSW50ZXJzZWN0aW9uc1swXSwgYXJjSW50ZXJzZWN0aW9uc1sxXV07XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEJvdHRvbSBSaWdodFxuICAgIHtcbiAgICAgIHZhciBib3R0b21SaWdodENlbnRlclggPSBub2RlWCArIGhhbGZXaWR0aCAtIGNvcm5lclJhZGl1cztcbiAgICAgIHZhciBib3R0b21SaWdodENlbnRlclkgPSBub2RlWSArIGhhbGZIZWlnaHQgLSBjb3JuZXJSYWRpdXM7XG4gICAgICBhcmNJbnRlcnNlY3Rpb25zID0gdGhpcy5pbnRlcnNlY3RMaW5lQ2lyY2xlKFxuICAgICAgICB4LCB5LCBub2RlWCwgbm9kZVksIFxuICAgICAgICBib3R0b21SaWdodENlbnRlclgsIGJvdHRvbVJpZ2h0Q2VudGVyWSwgY29ybmVyUmFkaXVzICsgcGFkZGluZyk7XG4gICAgICBcbiAgICAgIC8vIEVuc3VyZSB0aGUgaW50ZXJzZWN0aW9uIGlzIG9uIHRoZSBkZXNpcmVkIHF1YXJ0ZXIgb2YgdGhlIGNpcmNsZVxuICAgICAgaWYgKGFyY0ludGVyc2VjdGlvbnMubGVuZ3RoID4gMFxuICAgICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzBdID49IGJvdHRvbVJpZ2h0Q2VudGVyWFxuICAgICAgICAmJiBhcmNJbnRlcnNlY3Rpb25zWzFdID49IGJvdHRvbVJpZ2h0Q2VudGVyWSkge1xuICAgICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBCb3R0b20gTGVmdFxuICAgIHtcbiAgICAgIHZhciBib3R0b21MZWZ0Q2VudGVyWCA9IG5vZGVYIC0gaGFsZldpZHRoICsgY29ybmVyUmFkaXVzO1xuICAgICAgdmFyIGJvdHRvbUxlZnRDZW50ZXJZID0gbm9kZVkgKyBoYWxmSGVpZ2h0IC0gY29ybmVyUmFkaXVzO1xuICAgICAgYXJjSW50ZXJzZWN0aW9ucyA9IHRoaXMuaW50ZXJzZWN0TGluZUNpcmNsZShcbiAgICAgICAgeCwgeSwgbm9kZVgsIG5vZGVZLCBcbiAgICAgICAgYm90dG9tTGVmdENlbnRlclgsIGJvdHRvbUxlZnRDZW50ZXJZLCBjb3JuZXJSYWRpdXMgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgLy8gRW5zdXJlIHRoZSBpbnRlcnNlY3Rpb24gaXMgb24gdGhlIGRlc2lyZWQgcXVhcnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICBpZiAoYXJjSW50ZXJzZWN0aW9ucy5sZW5ndGggPiAwXG4gICAgICAgICYmIGFyY0ludGVyc2VjdGlvbnNbMF0gPD0gYm90dG9tTGVmdENlbnRlclhcbiAgICAgICAgJiYgYXJjSW50ZXJzZWN0aW9uc1sxXSA+PSBib3R0b21MZWZ0Q2VudGVyWSkge1xuICAgICAgICByZXR1cm4gW2FyY0ludGVyc2VjdGlvbnNbMF0sIGFyY0ludGVyc2VjdGlvbnNbMV1dO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbXTsgLy8gaWYgbm90aGluZ1xuICB9O1xuICBcbiAgJCQubWF0aC5yb3VuZFJlY3RhbmdsZUludGVyc2VjdEJveCA9IGZ1bmN0aW9uKFxuICAgIGJveFgxLCBib3hZMSwgYm94WDIsIGJveFkyLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBwYWRkaW5nKSB7XG4gICAgXG4gICAgLy8gV2UgaGF2ZSB0aGUgZm9sbG93aW5nIHNocGFlXG4gICAgXG4gICAgLy8gICAgX19fX19cbiAgICAvLyAgX3wgICAgIHxfXG4gICAgLy8gfCAgICAgICAgIHxcbiAgICAvLyB8XyAgICAgICBffFxuICAgIC8vICAgfF9fX19ffFxuICAgIC8vXG4gICAgLy8gV2l0aCBhIHF1YXJ0ZXIgY2lyY2xlIGF0IGVhY2ggY29ybmVyLlxuICAgIFxuICAgIHZhciBjb3JuZXJSYWRpdXMgPSB0aGlzLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIHZhciBoQm94VG9wTGVmdFggPSBjZW50ZXJYIC0gd2lkdGggLyAyIC0gcGFkZGluZztcbiAgICB2YXIgaEJveFRvcExlZnRZID0gY2VudGVyWSAtIGhlaWdodCAvIDIgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciBoQm94Qm90dG9tUmlnaHRYID0gY2VudGVyWCArIHdpZHRoIC8gMiArIHBhZGRpbmc7XG4gICAgdmFyIGhCb3hCb3R0b21SaWdodFkgPSBjZW50ZXJZICsgaGVpZ2h0IC8gMiAtIGNvcm5lclJhZGl1cyArIHBhZGRpbmc7XG4gICAgXG4gICAgdmFyIHZCb3hUb3BMZWZ0WCA9IGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMgLSBwYWRkaW5nO1xuICAgIHZhciB2Qm94VG9wTGVmdFkgPSBjZW50ZXJZIC0gaGVpZ2h0IC8gMiAtIHBhZGRpbmc7XG4gICAgdmFyIHZCb3hCb3R0b21SaWdodFggPSBjZW50ZXJYICsgd2lkdGggLyAyIC0gY29ybmVyUmFkaXVzICsgcGFkZGluZztcbiAgICB2YXIgdkJveEJvdHRvbVJpZ2h0WSA9IGNlbnRlclkgKyBoZWlnaHQgLyAyICsgcGFkZGluZztcbiAgICBcbiAgICAvLyBDaGVjayBpZiB0aGUgYm94IGlzIG91dCBvZiBib3VuZHNcbiAgICB2YXIgYm94TWluWCA9IE1hdGgubWluKGJveFgxLCBib3hYMik7XG4gICAgdmFyIGJveE1heFggPSBNYXRoLm1heChib3hYMSwgYm94WDIpO1xuICAgIHZhciBib3hNaW5ZID0gTWF0aC5taW4oYm94WTEsIGJveFkyKTtcbiAgICB2YXIgYm94TWF4WSA9IE1hdGgubWF4KGJveFkxLCBib3hZMik7XG4gICAgXG4gICAgaWYgKGJveE1heFggPCBoQm94VG9wTGVmdFgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGJveE1pblggPiBoQm94Qm90dG9tUmlnaHRYKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmIChib3hNYXhZIDwgdkJveFRvcExlZnRZKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChib3hNaW5ZID4gdkJveEJvdHRvbVJpZ2h0WSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhbiBoQm94IHBvaW50IGlzIGluIGdpdmVuIGJveFxuICAgIGlmIChoQm94VG9wTGVmdFggPj0gYm94TWluWCAmJiBoQm94VG9wTGVmdFggPD0gYm94TWF4WFxuICAgICAgICAmJiBoQm94VG9wTGVmdFkgPj0gYm94TWluWSAmJiBoQm94VG9wTGVmdFkgPD0gYm94TWF4WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChoQm94Qm90dG9tUmlnaHRYID49IGJveE1pblggJiYgaEJveEJvdHRvbVJpZ2h0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIGhCb3hUb3BMZWZ0WSA+PSBib3hNaW5ZICYmIGhCb3hUb3BMZWZ0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGhCb3hCb3R0b21SaWdodFggPj0gYm94TWluWCAmJiBoQm94Qm90dG9tUmlnaHRYIDw9IGJveE1heFhcbiAgICAgICAgJiYgaEJveEJvdHRvbVJpZ2h0WSA+PSBib3hNaW5ZICYmIGhCb3hCb3R0b21SaWdodFkgPD0gYm94TWF4WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmIChoQm94VG9wTGVmdFggPj0gYm94TWluWCAmJiBoQm94VG9wTGVmdFggPD0gYm94TWF4WFxuICAgICAgICAmJiBoQm94Qm90dG9tUmlnaHRZID49IGJveE1pblkgJiYgaEJveEJvdHRvbVJpZ2h0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYSBnaXZlbiBwb2ludCBib3ggaXMgaW4gdGhlIGhCb3hcbiAgICBpZiAoYm94TWluWCA+PSBoQm94VG9wTGVmdFggJiYgYm94TWluWCA8PSBoQm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNaW5ZID49IGhCb3hUb3BMZWZ0WSAmJiBib3hNaW5ZIDw9IGhCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWF4WCA+PSBoQm94VG9wTGVmdFggJiYgYm94TWF4WCA8PSBoQm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNaW5ZID49IGhCb3hUb3BMZWZ0WSAmJiBib3hNaW5ZIDw9IGhCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWF4WCA+PSBoQm94VG9wTGVmdFggJiYgYm94TWF4WCA8PSBoQm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNYXhZID49IGhCb3hUb3BMZWZ0WSAmJiBib3hNYXhZIDw9IGhCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWluWCA+PSBoQm94VG9wTGVmdFggJiYgYm94TWluWCA8PSBoQm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNYXhZID49IGhCb3hUb3BMZWZ0WSAmJiBib3hNYXhZIDw9IGhCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhbiB2Qm94IHBvaW50IGlzIGluIGdpdmVuIGJveFxuICAgIGlmICh2Qm94VG9wTGVmdFggPj0gYm94TWluWCAmJiB2Qm94VG9wTGVmdFggPD0gYm94TWF4WFxuICAgICAgICAmJiB2Qm94VG9wTGVmdFkgPj0gYm94TWluWSAmJiB2Qm94VG9wTGVmdFkgPD0gYm94TWF4WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh2Qm94Qm90dG9tUmlnaHRYID49IGJveE1pblggJiYgdkJveEJvdHRvbVJpZ2h0WCA8PSBib3hNYXhYXG4gICAgICAgICYmIHZCb3hUb3BMZWZ0WSA+PSBib3hNaW5ZICYmIHZCb3hUb3BMZWZ0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHZCb3hCb3R0b21SaWdodFggPj0gYm94TWluWCAmJiB2Qm94Qm90dG9tUmlnaHRYIDw9IGJveE1heFhcbiAgICAgICAgJiYgdkJveEJvdHRvbVJpZ2h0WSA+PSBib3hNaW5ZICYmIHZCb3hCb3R0b21SaWdodFkgPD0gYm94TWF4WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh2Qm94VG9wTGVmdFggPj0gYm94TWluWCAmJiB2Qm94VG9wTGVmdFggPD0gYm94TWF4WFxuICAgICAgICAmJiB2Qm94Qm90dG9tUmlnaHRZID49IGJveE1pblkgJiYgdkJveEJvdHRvbVJpZ2h0WSA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgYSBnaXZlbiBwb2ludCBib3ggaXMgaW4gdGhlIHZCb3hcbiAgICBpZiAoYm94TWluWCA+PSB2Qm94VG9wTGVmdFggJiYgYm94TWluWCA8PSB2Qm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNaW5ZID49IHZCb3hUb3BMZWZ0WSAmJiBib3hNaW5ZIDw9IHZCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWF4WCA+PSB2Qm94VG9wTGVmdFggJiYgYm94TWF4WCA8PSB2Qm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNaW5ZID49IHZCb3hUb3BMZWZ0WSAmJiBib3hNaW5ZIDw9IHZCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWF4WCA+PSB2Qm94VG9wTGVmdFggJiYgYm94TWF4WCA8PSB2Qm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNYXhZID49IHZCb3hUb3BMZWZ0WSAmJiBib3hNYXhZIDw9IHZCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoYm94TWluWCA+PSB2Qm94VG9wTGVmdFggJiYgYm94TWluWCA8PSB2Qm94Qm90dG9tUmlnaHRYXG4gICAgICAmJiBib3hNYXhZID49IHZCb3hUb3BMZWZ0WSAmJiBib3hNYXhZIDw9IHZCb3hCb3R0b21SaWdodFkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBMYXN0bHksIGNoZWNrIGlmIG9uZSBvZiB0aGUgZWxsaXBzZXMgY29pbmNpZGUgd2l0aCB0aGUgYm94XG4gICAgXG4gICAgaWYgKHRoaXMuYm94SW50ZXJzZWN0RWxsaXBzZShib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCB2Qm94VG9wTGVmdFggKyBwYWRkaW5nLCBoQm94VG9wTGVmdFkgKyBwYWRkaW5nKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh0aGlzLmJveEludGVyc2VjdEVsbGlwc2UoYm94TWluWCwgYm94TWluWSwgYm94TWF4WCwgYm94TWF4WSwgcGFkZGluZyxcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMiwgdkJveEJvdHRvbVJpZ2h0WCAtIHBhZGRpbmcsIGhCb3hUb3BMZWZ0WSArIHBhZGRpbmcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuYm94SW50ZXJzZWN0RWxsaXBzZShib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCB2Qm94Qm90dG9tUmlnaHRYIC0gcGFkZGluZywgaEJveEJvdHRvbVJpZ2h0WSAtIHBhZGRpbmcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRoaXMuYm94SW50ZXJzZWN0RWxsaXBzZShib3hNaW5YLCBib3hNaW5ZLCBib3hNYXhYLCBib3hNYXhZLCBwYWRkaW5nLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCB2Qm94VG9wTGVmdFggKyBwYWRkaW5nLCBoQm94Qm90dG9tUmlnaHRZIC0gcGFkZGluZykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIFxuICAvLyBATyBBcHByb3hpbWF0ZSBjb2xsaXNpb24gZnVuY3Rpb25zXG4gICQkLm1hdGguY2hlY2tJbkJvdW5kaW5nQ2lyY2xlID0gZnVuY3Rpb24oXG4gICAgeCwgeSwgZmFydGhlc3RQb2ludFNxRGlzdGFuY2UsIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICBcbiAgICB4ID0gKHggLSBjZW50ZXJYKSAvICh3aWR0aCArIHBhZGRpbmcpO1xuICAgIHkgPSAoeSAtIGNlbnRlclkpIC8gKGhlaWdodCArIHBhZGRpbmcpO1xuICAgIFxuICAgIHJldHVybiAoeCAqIHggKyB5ICogeSkgPD0gZmFydGhlc3RQb2ludFNxRGlzdGFuY2U7XG4gIH07XG4gIFxuICAkJC5tYXRoLmJveEluQmV6aWVyVmljaW5pdHkgPSBmdW5jdGlvbihcbiAgICB4MWJveCwgeTFib3gsIHgyYm94LCB5MmJveCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlKSB7XG4gICAgXG4gICAgLy8gUmV0dXJuIHZhbHVlczpcbiAgICAvLyAwIC0gY3VydmUgaXMgbm90IGluIGJveFxuICAgIC8vIDEgLSBjdXJ2ZSBtYXkgYmUgaW4gYm94OyBuZWVkcyBwcmVjaXNlIGNoZWNrXG4gICAgLy8gMiAtIGN1cnZlIGlzIGluIGJveFxuICAgIFxuICAgIC8vIG1pZHBvaW50XG4gICAgdmFyIG1pZFggPSAwLjI1ICogeDEgKyAwLjUgKiB4MiArIDAuMjUgKiB4MztcbiAgICB2YXIgbWlkWSA9IDAuMjUgKiB5MSArIDAuNSAqIHkyICsgMC4yNSAqIHkzO1xuXG4gICAgdmFyIGJveE1pblggPSBNYXRoLm1pbih4MWJveCwgeDJib3gpIC0gdG9sZXJhbmNlO1xuICAgIHZhciBib3hNaW5ZID0gTWF0aC5taW4oeTFib3gsIHkyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWF4WCA9IE1hdGgubWF4KHgxYm94LCB4MmJveCkgKyB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFkgPSBNYXRoLm1heCh5MWJveCwgeTJib3gpICsgdG9sZXJhbmNlO1xuICAgIFxuICAgIGlmICh4MSA+PSBib3hNaW5YICYmIHgxIDw9IGJveE1heFggJiYgeTEgPj0gYm94TWluWSAmJiB5MSA8PSBib3hNYXhZKSB7IC8vICh4MSwgeTEpIGluIGJveFxuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICh4MyA+PSBib3hNaW5YICYmIHgzIDw9IGJveE1heFggJiYgeTMgPj0gYm94TWluWSAmJiB5MyA8PSBib3hNYXhZKSB7IC8vICh4MywgeTMpIGluIGJveFxuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChtaWRYID49IGJveE1pblggJiYgbWlkWCA8PSBib3hNYXhYICYmIG1pZFkgPj0gYm94TWluWSAmJiBtaWRZIDw9IGJveE1heFkpIHsgLy8gKG1pZFgsIG1pZFkpIGluIGJveFxuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmICh4MiA+PSBib3hNaW5YICYmIHgyIDw9IGJveE1heFggJiYgeTIgPj0gYm94TWluWSAmJiB5MiA8PSBib3hNYXhZKSB7IC8vIGN0cmwgcHQgaW4gYm94XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGN1cnZlTWluWCA9IE1hdGgubWluKHgxLCBtaWRYLCB4Myk7XG4gICAgdmFyIGN1cnZlTWluWSA9IE1hdGgubWluKHkxLCBtaWRZLCB5Myk7XG4gICAgdmFyIGN1cnZlTWF4WCA9IE1hdGgubWF4KHgxLCBtaWRYLCB4Myk7XG4gICAgdmFyIGN1cnZlTWF4WSA9IE1hdGgubWF4KHkxLCBtaWRZLCB5Myk7XG4gICAgXG4gICAgLypcbiAgICBjb25zb2xlLmxvZyhjdXJ2ZU1pblggKyBcIiwgXCIgKyBjdXJ2ZU1pblkgKyBcIiwgXCIgKyBjdXJ2ZU1heFggXG4gICAgICArIFwiLCBcIiArIGN1cnZlTWF4WSk7XG4gICAgaWYgKGN1cnZlTWluWCA9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwidW5kZWZpbmVkIGN1cnZlTWluWDogXCIgKyB4MSArIFwiLCBcIiArIHgyICsgXCIsIFwiICsgeDMpO1xuICAgIH1cbiAgICAqL1xuICAgIFxuICAgIGlmIChjdXJ2ZU1pblggPiBib3hNYXhYXG4gICAgICB8fCBjdXJ2ZU1heFggPCBib3hNaW5YXG4gICAgICB8fCBjdXJ2ZU1pblkgPiBib3hNYXhZXG4gICAgICB8fCBjdXJ2ZU1heFkgPCBib3hNaW5ZKSB7XG4gICAgICBcbiAgICAgIHJldHVybiAwOyAgXG4gICAgfVxuICAgIFxuICAgIHJldHVybiAxO1xuICB9O1xuXG4gICQkLm1hdGguY2hlY2tCZXppZXJJbkJveCA9IGZ1bmN0aW9uKFxuICAgIHgxYm94LCB5MWJveCwgeDJib3gsIHkyYm94LCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB0b2xlcmFuY2UpIHtcblxuICAgIGZ1bmN0aW9uIHNhbXBsZUluQm94KHQpe1xuICAgICAgdmFyIHggPSAkJC5tYXRoLnFiZXppZXJBdCh4MSwgeDIsIHgzLCB0KTtcbiAgICAgIHZhciB5ID0gJCQubWF0aC5xYmV6aWVyQXQoeTEsIHkyLCB5MywgdCk7XG5cbiAgICAgIHJldHVybiB4MWJveCA8PSB4ICYmIHggPD0geDJib3hcbiAgICAgICAgJiYgeTFib3ggPD0geSAmJiB5IDw9IHkyYm94XG4gICAgICA7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgdCA9IDA7IHQgPD0gMTsgdCArPSAwLjI1ICl7XG4gICAgICBpZiggIXNhbXBsZUluQm94KHQpICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbiAgXG4gICQkLm1hdGguY2hlY2tTdHJhaWdodEVkZ2VJbkJveCA9IGZ1bmN0aW9uKFxuICAgIHgxYm94LCB5MWJveCwgeDJib3gsIHkyYm94LCB4MSwgeTEsIHgyLCB5MiwgdG9sZXJhbmNlKSB7XG5cbiAgICByZXR1cm4geDFib3ggPD0geDEgJiYgeDEgPD0geDJib3hcbiAgICAgICYmIHgxYm94IDw9IHgyICYmIHgyIDw9IHgyYm94XG4gICAgICAmJiB5MWJveCA8PSB5MSAmJiB5MSA8PSB5MmJveFxuICAgICAgJiYgeTFib3ggPD0geTIgJiYgeTIgPD0geTJib3hcbiAgICA7XG4gIH07XG5cbiAgJCQubWF0aC5jaGVja1N0cmFpZ2h0RWRnZUNyb3NzZXNCb3ggPSBmdW5jdGlvbihcbiAgICB4MWJveCwgeTFib3gsIHgyYm94LCB5MmJveCwgeDEsIHkxLCB4MiwgeTIsIHRvbGVyYW5jZSkge1xuICAgIFxuICAgLy9jb25zb2xlLmxvZyhhcmd1bWVudHMpO1xuICAgIFxuICAgIHZhciBib3hNaW5YID0gTWF0aC5taW4oeDFib3gsIHgyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWluWSA9IE1hdGgubWluKHkxYm94LCB5MmJveCkgLSB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFggPSBNYXRoLm1heCh4MWJveCwgeDJib3gpICsgdG9sZXJhbmNlO1xuICAgIHZhciBib3hNYXhZID0gTWF0aC5tYXgoeTFib3gsIHkyYm94KSArIHRvbGVyYW5jZTtcbiAgICBcbiAgICAvLyBDaGVjayBsZWZ0ICsgcmlnaHQgYm91bmRzXG4gICAgdmFyIGFYID0geDIgLSB4MTtcbiAgICB2YXIgYlggPSB4MTtcbiAgICB2YXIgeVZhbHVlO1xuICAgIFxuICAgIC8vIFRvcCBhbmQgYm90dG9tXG4gICAgdmFyIGFZID0geTIgLSB5MTtcbiAgICB2YXIgYlkgPSB5MTtcbiAgICB2YXIgeFZhbHVlO1xuICAgIFxuICAgIGlmIChNYXRoLmFicyhhWCkgPCAwLjAwMDEpIHtcbiAgICAgIHJldHVybiAoeDEgPj0gYm94TWluWCAmJiB4MSA8PSBib3hNYXhYXG4gICAgICAgICYmIE1hdGgubWluKHkxLCB5MikgPD0gYm94TWluWVxuICAgICAgICAmJiBNYXRoLm1heCh5MSwgeTIpID49IGJveE1heFkpOyAgXG4gICAgfVxuICAgIFxuICAgIHZhciB0TGVmdCA9IChib3hNaW5YIC0gYlgpIC8gYVg7XG4gICAgaWYgKHRMZWZ0ID4gMCAmJiB0TGVmdCA8PSAxKSB7XG4gICAgICB5VmFsdWUgPSBhWSAqIHRMZWZ0ICsgYlk7XG4gICAgICBpZiAoeVZhbHVlID49IGJveE1pblkgJiYgeVZhbHVlIDw9IGJveE1heFkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IFxuICAgIH1cbiAgICBcbiAgICB2YXIgdFJpZ2h0ID0gKGJveE1heFggLSBiWCkgLyBhWDtcbiAgICBpZiAodFJpZ2h0ID4gMCAmJiB0UmlnaHQgPD0gMSkge1xuICAgICAgeVZhbHVlID0gYVkgKiB0UmlnaHQgKyBiWTtcbiAgICAgIGlmICh5VmFsdWUgPj0gYm94TWluWSAmJiB5VmFsdWUgPD0gYm94TWF4WSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gXG4gICAgfVxuICAgIFxuICAgIHZhciB0VG9wID0gKGJveE1pblkgLSBiWSkgLyBhWTtcbiAgICBpZiAodFRvcCA+IDAgJiYgdFRvcCA8PSAxKSB7XG4gICAgICB4VmFsdWUgPSBhWCAqIHRUb3AgKyBiWDtcbiAgICAgIGlmICh4VmFsdWUgPj0gYm94TWluWCAmJiB4VmFsdWUgPD0gYm94TWF4WCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gXG4gICAgfVxuICAgIFxuICAgIHZhciB0Qm90dG9tID0gKGJveE1heFkgLSBiWSkgLyBhWTtcbiAgICBpZiAodEJvdHRvbSA+IDAgJiYgdEJvdHRvbSA8PSAxKSB7XG4gICAgICB4VmFsdWUgPSBhWCAqIHRCb3R0b20gKyBiWDtcbiAgICAgIGlmICh4VmFsdWUgPj0gYm94TWluWCAmJiB4VmFsdWUgPD0gYm94TWF4WCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gICQkLm1hdGguY2hlY2tCZXppZXJDcm9zc2VzQm94ID0gZnVuY3Rpb24oXG4gICAgeDFib3gsIHkxYm94LCB4MmJveCwgeTJib3gsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIHRvbGVyYW5jZSkge1xuICAgIFxuICAgIHZhciBib3hNaW5YID0gTWF0aC5taW4oeDFib3gsIHgyYm94KSAtIHRvbGVyYW5jZTtcbiAgICB2YXIgYm94TWluWSA9IE1hdGgubWluKHkxYm94LCB5MmJveCkgLSB0b2xlcmFuY2U7XG4gICAgdmFyIGJveE1heFggPSBNYXRoLm1heCh4MWJveCwgeDJib3gpICsgdG9sZXJhbmNlO1xuICAgIHZhciBib3hNYXhZID0gTWF0aC5tYXgoeTFib3gsIHkyYm94KSArIHRvbGVyYW5jZTtcbiAgICBcbiAgICBpZiAoeDEgPj0gYm94TWluWCAmJiB4MSA8PSBib3hNYXhYICYmIHkxID49IGJveE1pblkgJiYgeTEgPD0gYm94TWF4WSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICh4MyA+PSBib3hNaW5YICYmIHgzIDw9IGJveE1heFggJiYgeTMgPj0gYm94TWluWSAmJiB5MyA8PSBib3hNYXhZKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGFYID0geDEgLSAyICogeDIgKyB4MztcbiAgICB2YXIgYlggPSAtMiAqIHgxICsgMiAqIHgyO1xuICAgIHZhciBjWCA9IHgxO1xuXG4gICAgdmFyIHhJbnRlcnZhbHMgPSBbXTtcbiAgICBcbiAgICBpZiAoTWF0aC5hYnMoYVgpIDwgMC4wMDAxKSB7XG4gICAgICB2YXIgbGVmdFBhcmFtID0gKGJveE1pblggLSB4MSkgLyBiWDtcbiAgICAgIHZhciByaWdodFBhcmFtID0gKGJveE1heFggLSB4MSkgLyBiWDtcbiAgICAgIFxuICAgICAgeEludGVydmFscy5wdXNoKGxlZnRQYXJhbSwgcmlnaHRQYXJhbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZpbmQgd2hlbiB4IGNvb3JkaW5hdGUgb2YgdGhlIGN1cnZlIGNyb3NzZXMgdGhlIGxlZnQgc2lkZSBvZiB0aGUgYm94XG4gICAgICB2YXIgZGlzY3JpbWluYW50WDEgPSBiWCAqIGJYIC0gNCAqIGFYICogKGNYIC0gYm94TWluWCk7XG4gICAgICB2YXIgdFgxLCB0WDI7XG4gICAgICBpZiAoZGlzY3JpbWluYW50WDEgPiAwKSB7XG4gICAgICAgIHZhciBzcXJ0ID0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudFgxKTtcbiAgICAgICAgdFgxID0gKC1iWCArIHNxcnQpIC8gKDIgKiBhWCk7XG4gICAgICAgIHRYMiA9ICgtYlggLSBzcXJ0KSAvICgyICogYVgpO1xuICAgICAgICBcbiAgICAgICAgeEludGVydmFscy5wdXNoKHRYMSwgdFgyKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGRpc2NyaW1pbmFudFgyID0gYlggKiBiWCAtIDQgKiBhWCAqIChjWCAtIGJveE1heFgpO1xuICAgICAgdmFyIHRYMywgdFg0O1xuICAgICAgaWYgKGRpc2NyaW1pbmFudFgyID4gMCkge1xuICAgICAgICB2YXIgc3FydCA9IE1hdGguc3FydChkaXNjcmltaW5hbnRYMik7XG4gICAgICAgIHRYMyA9ICgtYlggKyBzcXJ0KSAvICgyICogYVgpO1xuICAgICAgICB0WDQgPSAoLWJYIC0gc3FydCkgLyAoMiAqIGFYKTtcbiAgICAgICAgXG4gICAgICAgIHhJbnRlcnZhbHMucHVzaCh0WDMsIHRYNCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHhJbnRlcnZhbHMuc29ydChmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSk7XG4gICAgXG4gICAgdmFyIGFZID0geTEgLSAyICogeTIgKyB5MztcbiAgICB2YXIgYlkgPSAtMiAqIHkxICsgMiAqIHkyO1xuICAgIHZhciBjWSA9IHkxO1xuICAgIFxuICAgIHZhciB5SW50ZXJ2YWxzID0gW107XG4gICAgXG4gICAgaWYgKE1hdGguYWJzKGFZKSA8IDAuMDAwMSkge1xuICAgICAgdmFyIHRvcFBhcmFtID0gKGJveE1pblkgLSB5MSkgLyBiWTtcbiAgICAgIHZhciBib3R0b21QYXJhbSA9IChib3hNYXhZIC0geTEpIC8gYlk7XG4gICAgICBcbiAgICAgIHlJbnRlcnZhbHMucHVzaCh0b3BQYXJhbSwgYm90dG9tUGFyYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGlzY3JpbWluYW50WTEgPSBiWSAqIGJZIC0gNCAqIGFZICogKGNZIC0gYm94TWluWSk7XG4gICAgICBcbiAgICAgIHZhciB0WTEsIHRZMjtcbiAgICAgIGlmIChkaXNjcmltaW5hbnRZMSA+IDApIHtcbiAgICAgICAgdmFyIHNxcnQgPSBNYXRoLnNxcnQoZGlzY3JpbWluYW50WTEpO1xuICAgICAgICB0WTEgPSAoLWJZICsgc3FydCkgLyAoMiAqIGFZKTtcbiAgICAgICAgdFkyID0gKC1iWSAtIHNxcnQpIC8gKDIgKiBhWSk7XG4gICAgICAgIFxuICAgICAgICB5SW50ZXJ2YWxzLnB1c2godFkxLCB0WTIpO1xuICAgICAgfVxuICBcbiAgICAgIHZhciBkaXNjcmltaW5hbnRZMiA9IGJZICogYlkgLSA0ICogYVkgKiAoY1kgLSBib3hNYXhZKTtcbiAgICAgIFxuICAgICAgdmFyIHRZMywgdFk0O1xuICAgICAgaWYgKGRpc2NyaW1pbmFudFkyID4gMCkge1xuICAgICAgICB2YXIgc3FydCA9IE1hdGguc3FydChkaXNjcmltaW5hbnRZMik7XG4gICAgICAgIHRZMyA9ICgtYlkgKyBzcXJ0KSAvICgyICogYVkpO1xuICAgICAgICB0WTQgPSAoLWJZIC0gc3FydCkgLyAoMiAqIGFZKTtcbiAgICAgICAgXG4gICAgICAgIHlJbnRlcnZhbHMucHVzaCh0WTMsIHRZNCk7XG4gICAgICB9XG4gICAgfVxuICAgICAgICBcbiAgICB5SW50ZXJ2YWxzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHhJbnRlcnZhbHMubGVuZ3RoOyBpbmRleCArPSAyKSB7XG4gICAgICBmb3IgKHZhciB5SW5kZXggPSAxOyB5SW5kZXggPCB5SW50ZXJ2YWxzLmxlbmd0aDsgeUluZGV4ICs9IDIpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZXJlIGV4aXN0cyB2YWx1ZXMgZm9yIHRoZSBCZXppZXIgY3VydmVcbiAgICAgICAgLy8gcGFyYW1ldGVyIGJldHdlZW4gMCBhbmQgMSB3aGVyZSBib3RoIHRoZSBjdXJ2ZSdzXG4gICAgICAgIC8vIHggYW5kIHkgY29vcmRpbmF0ZXMgYXJlIHdpdGhpbiB0aGUgYm91bmRzIHNwZWNpZmllZCBieSB0aGUgYm94XG4gICAgICAgIGlmICh4SW50ZXJ2YWxzW2luZGV4XSA8IHlJbnRlcnZhbHNbeUluZGV4XVxuICAgICAgICAgICYmIHlJbnRlcnZhbHNbeUluZGV4XSA+PSAwLjBcbiAgICAgICAgICAmJiB4SW50ZXJ2YWxzW2luZGV4XSA8PSAxLjBcbiAgICAgICAgICAmJiB4SW50ZXJ2YWxzW2luZGV4ICsgMV0gPiB5SW50ZXJ2YWxzW3lJbmRleCAtIDFdXG4gICAgICAgICAgJiYgeUludGVydmFsc1t5SW5kZXggLSAxXSA8PSAxLjBcbiAgICAgICAgICAmJiB4SW50ZXJ2YWxzW2luZGV4ICsgMV0gPj0gMC4wKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBcbiAgJCQubWF0aC5pbkxpbmVWaWNpbml0eSA9IGZ1bmN0aW9uKHgsIHksIGx4MSwgbHkxLCBseDIsIGx5MiwgdG9sZXJhbmNlKXtcbiAgICB2YXIgdCA9IHRvbGVyYW5jZTtcblxuICAgIHZhciB4MSA9IE1hdGgubWluKGx4MSwgbHgyKTtcbiAgICB2YXIgeDIgPSBNYXRoLm1heChseDEsIGx4Mik7XG4gICAgdmFyIHkxID0gTWF0aC5taW4obHkxLCBseTIpO1xuICAgIHZhciB5MiA9IE1hdGgubWF4KGx5MSwgbHkyKTtcblxuICAgIHJldHVybiB4MSAtIHQgPD0geCAmJiB4IDw9IHgyICsgdFxuICAgICAgJiYgeTEgLSB0IDw9IHkgJiYgeSA8PSB5MiArIHQ7XG4gIH07XG5cbiAgJCQubWF0aC5pbkJlemllclZpY2luaXR5ID0gZnVuY3Rpb24oXG4gICAgeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdG9sZXJhbmNlU3F1YXJlZCkge1xuXG4gICAgdmFyIGJiID0ge1xuICAgICAgeDE6IE1hdGgubWluKCB4MSwgeDMsIHgyICksXG4gICAgICB4MjogTWF0aC5tYXgoIHgxLCB4MywgeDIgKSxcbiAgICAgIHkxOiBNYXRoLm1pbiggeTEsIHkzLCB5MiApLFxuICAgICAgeTI6IE1hdGgubWF4KCB5MSwgeTMsIHkyIClcbiAgICB9O1xuXG4gICAgLy8gaWYgb3V0c2lkZSB0aGUgcm91Z2ggYm91bmRpbmcgYm94IGZvciB0aGUgYmV6aWVyLCB0aGVuIGl0IGNhbid0IGJlIGEgaGl0XG4gICAgaWYoIHggPCBiYi54MSB8fCB4ID4gYmIueDIgfHwgeSA8IGJiLnkxIHx8IHkgPiBiYi55MiApe1xuICAgICAgLy8gY29uc29sZS5sb2coJ2JlemllciBvdXQgb2Ygcm91Z2ggYmInKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnZG8gbW9yZSBleHBlbnNpdmUgY2hlY2snKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICB9O1xuICBcbiAgJCQubWF0aC5zb2x2ZUN1YmljID0gZnVuY3Rpb24oYSwgYiwgYywgZCwgcmVzdWx0KSB7XG4gICAgXG4gICAgLy8gU29sdmVzIGEgY3ViaWMgZnVuY3Rpb24sIHJldHVybnMgcm9vdCBpbiBmb3JtIFtyMSwgaTEsIHIyLCBpMiwgcjMsIGkzXSwgd2hlcmVcbiAgICAvLyByIGlzIHRoZSByZWFsIGNvbXBvbmVudCwgaSBpcyB0aGUgaW1hZ2luYXJ5IGNvbXBvbmVudFxuXG4gICAgLy8gQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIENhcmRhbm8gbWV0aG9kIGZyb20gdGhlIHllYXIgMTU0NVxuICAgIC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ3ViaWNfZnVuY3Rpb24jVGhlX25hdHVyZV9vZl90aGVfcm9vdHNcblxuICAgIGIgLz0gYTtcbiAgICBjIC89IGE7XG4gICAgZCAvPSBhO1xuICAgIFxuICAgIHZhciBkaXNjcmltaW5hbnQsIHEsIHIsIGR1bTEsIHMsIHQsIHRlcm0xLCByMTM7XG5cbiAgICBxID0gKDMuMCAqIGMgLSAoYiAqIGIpKSAvIDkuMDtcbiAgICByID0gLSgyNy4wICogZCkgKyBiICogKDkuMCAqIGMgLSAyLjAgKiAoYiAqIGIpKTtcbiAgICByIC89IDU0LjA7XG4gICAgXG4gICAgZGlzY3JpbWluYW50ID0gcSAqIHEgKiBxICsgciAqIHI7XG4gICAgcmVzdWx0WzFdID0gMDtcbiAgICB0ZXJtMSA9IChiIC8gMy4wKTtcbiAgICBcbiAgICBpZiAoZGlzY3JpbWluYW50ID4gMCkge1xuICAgICAgcyA9IHIgKyBNYXRoLnNxcnQoZGlzY3JpbWluYW50KTtcbiAgICAgIHMgPSAoKHMgPCAwKSA/IC1NYXRoLnBvdygtcywgKDEuMCAvIDMuMCkpIDogTWF0aC5wb3cocywgKDEuMCAvIDMuMCkpKTtcbiAgICAgIHQgPSByIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCk7XG4gICAgICB0ID0gKCh0IDwgMCkgPyAtTWF0aC5wb3coLXQsICgxLjAgLyAzLjApKSA6IE1hdGgucG93KHQsICgxLjAgLyAzLjApKSk7XG4gICAgICByZXN1bHRbMF0gPSAtdGVybTEgKyBzICsgdDtcbiAgICAgIHRlcm0xICs9IChzICsgdCkgLyAyLjA7XG4gICAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtdGVybTE7XG4gICAgICB0ZXJtMSA9IE1hdGguc3FydCgzLjApICogKC10ICsgcykgLyAyO1xuICAgICAgcmVzdWx0WzNdID0gdGVybTE7XG4gICAgICByZXN1bHRbNV0gPSAtdGVybTE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHJlc3VsdFs1XSA9IHJlc3VsdFszXSA9IDA7XG4gICAgXG4gICAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xuICAgICAgcjEzID0gKChyIDwgMCkgPyAtTWF0aC5wb3coLXIsICgxLjAgLyAzLjApKSA6IE1hdGgucG93KHIsICgxLjAgLyAzLjApKSk7XG4gICAgICByZXN1bHRbMF0gPSAtdGVybTEgKyAyLjAgKiByMTM7XG4gICAgICByZXN1bHRbNF0gPSByZXN1bHRbMl0gPSAtKHIxMyArIHRlcm0xKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgcSA9IC1xO1xuICAgIGR1bTEgPSBxICogcSAqIHE7XG4gICAgZHVtMSA9IE1hdGguYWNvcyhyIC8gTWF0aC5zcXJ0KGR1bTEpKTtcbiAgICByMTMgPSAyLjAgKiBNYXRoLnNxcnQocSk7XG4gICAgcmVzdWx0WzBdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoZHVtMSAvIDMuMCk7XG4gICAgcmVzdWx0WzJdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyAyLjAgKiBNYXRoLlBJKSAvIDMuMCk7XG4gICAgcmVzdWx0WzRdID0gLXRlcm0xICsgcjEzICogTWF0aC5jb3MoKGR1bTEgKyA0LjAgKiBNYXRoLlBJKSAvIDMuMCk7XG4gICAgXG4gICAgcmV0dXJuO1xuICB9O1xuXG4gICQkLm1hdGguc3FEaXN0YW5jZVRvUXVhZHJhdGljQmV6aWVyID0gZnVuY3Rpb24oXG4gICAgeCwgeSwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIFxuICAgIC8vIEZpbmQgbWluaW11bSBkaXN0YW5jZSBieSB1c2luZyB0aGUgbWluaW11bSBvZiB0aGUgZGlzdGFuY2UgXG4gICAgLy8gZnVuY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnQgYW5kIHRoZSBjdXJ2ZVxuICAgIFxuICAgIC8vIFRoaXMgZ2l2ZXMgdGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgcmVzdWx0aW5nIGN1YmljIGVxdWF0aW9uXG4gICAgLy8gd2hvc2Ugcm9vdHMgdGVsbCB1cyB3aGVyZSBhIHBvc3NpYmxlIG1pbmltdW0gaXNcbiAgICAvLyAoQ29lZmZpY2llbnRzIGFyZSBkaXZpZGVkIGJ5IDQpXG4gICAgXG4gICAgdmFyIGEgPSAxLjAgKiB4MSp4MSAtIDQqeDEqeDIgKyAyKngxKngzICsgNCp4Mip4MiAtIDQqeDIqeDMgKyB4Myp4M1xuICAgICAgKyB5MSp5MSAtIDQqeTEqeTIgKyAyKnkxKnkzICsgNCp5Mip5MiAtIDQqeTIqeTMgKyB5Myp5MztcbiAgICBcbiAgICB2YXIgYiA9IDEuMCAqIDkqeDEqeDIgLSAzKngxKngxIC0gMyp4MSp4MyAtIDYqeDIqeDIgKyAzKngyKngzXG4gICAgICArIDkqeTEqeTIgLSAzKnkxKnkxIC0gMyp5MSp5MyAtIDYqeTIqeTIgKyAzKnkyKnkzO1xuICAgIFxuICAgIHZhciBjID0gMS4wICogMyp4MSp4MSAtIDYqeDEqeDIgKyB4MSp4MyAtIHgxKnggKyAyKngyKngyICsgMip4Mip4IC0geDMqeFxuICAgICAgKyAzKnkxKnkxIC0gNip5MSp5MiArIHkxKnkzIC0geTEqeSArIDIqeTIqeTIgKyAyKnkyKnkgLSB5Myp5O1xuICAgICAgXG4gICAgdmFyIGQgPSAxLjAgKiB4MSp4MiAtIHgxKngxICsgeDEqeCAtIHgyKnhcbiAgICAgICsgeTEqeTIgLSB5MSp5MSArIHkxKnkgLSB5Mip5O1xuICAgIFxuICAgIC8vIGRlYnVnKFwiY29lZmZpY2llbnRzOiBcIiArIGEgLyBhICsgXCIsIFwiICsgYiAvIGEgKyBcIiwgXCIgKyBjIC8gYSArIFwiLCBcIiArIGQgLyBhKTtcbiAgICBcbiAgICB2YXIgcm9vdHMgPSBbXTtcbiAgICBcbiAgICAvLyBVc2UgdGhlIGN1YmljIHNvbHZpbmcgYWxnb3JpdGhtXG4gICAgdGhpcy5zb2x2ZUN1YmljKGEsIGIsIGMsIGQsIHJvb3RzKTtcbiAgICBcbiAgICB2YXIgemVyb1RocmVzaG9sZCA9IDAuMDAwMDAwMTtcbiAgICBcbiAgICB2YXIgcGFyYW1zID0gW107XG4gICAgXG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IDY7IGluZGV4ICs9IDIpIHtcbiAgICAgIGlmIChNYXRoLmFicyhyb290c1tpbmRleCArIDFdKSA8IHplcm9UaHJlc2hvbGRcbiAgICAgICAgICAmJiByb290c1tpbmRleF0gPj0gMFxuICAgICAgICAgICYmIHJvb3RzW2luZGV4XSA8PSAxLjApIHtcbiAgICAgICAgcGFyYW1zLnB1c2gocm9vdHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcGFyYW1zLnB1c2goMS4wKTtcbiAgICBwYXJhbXMucHVzaCgwLjApO1xuICAgIFxuICAgIHZhciBtaW5EaXN0YW5jZVNxdWFyZWQgPSAtMTtcbiAgICB2YXIgY2xvc2VzdFBhcmFtO1xuICAgIFxuICAgIHZhciBjdXJYLCBjdXJZLCBkaXN0U3F1YXJlZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgICAgY3VyWCA9IE1hdGgucG93KDEuMCAtIHBhcmFtc1tpXSwgMi4wKSAqIHgxXG4gICAgICAgICsgMi4wICogKDEgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeDJcbiAgICAgICAgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB4MztcbiAgICAgICAgXG4gICAgICBjdXJZID0gTWF0aC5wb3coMSAtIHBhcmFtc1tpXSwgMi4wKSAqIHkxXG4gICAgICAgICsgMiAqICgxLjAgLSBwYXJhbXNbaV0pICogcGFyYW1zW2ldICogeTJcbiAgICAgICAgKyBwYXJhbXNbaV0gKiBwYXJhbXNbaV0gKiB5MztcbiAgICAgICAgXG4gICAgICBkaXN0U3F1YXJlZCA9IE1hdGgucG93KGN1clggLSB4LCAyKSArIE1hdGgucG93KGN1clkgLSB5LCAyKTtcbiAgICAgIC8vIGRlYnVnKCdkaXN0YW5jZSBmb3IgcGFyYW0gJyArIHBhcmFtc1tpXSArIFwiOiBcIiArIE1hdGguc3FydChkaXN0U3F1YXJlZCkpO1xuICAgICAgaWYgKG1pbkRpc3RhbmNlU3F1YXJlZCA+PSAwKSB7XG4gICAgICAgIGlmIChkaXN0U3F1YXJlZCA8IG1pbkRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlU3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuICAgICAgICAgIGNsb3Nlc3RQYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWluRGlzdGFuY2VTcXVhcmVkID0gZGlzdFNxdWFyZWQ7XG4gICAgICAgIGNsb3Nlc3RQYXJhbSA9IHBhcmFtc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLypcbiAgICBkZWJ1Z1N0YXRzLmNsaWNrWCA9IHg7XG4gICAgZGVidWdTdGF0cy5jbGlja1kgPSB5O1xuICAgIFxuICAgIGRlYnVnU3RhdHMuY2xvc2VzdFggPSBNYXRoLnBvdygxLjAgLSBjbG9zZXN0UGFyYW0sIDIuMCkgKiB4MVxuICAgICAgICArIDIuMCAqICgxLjAgLSBjbG9zZXN0UGFyYW0pICogY2xvc2VzdFBhcmFtICogeDJcbiAgICAgICAgKyBjbG9zZXN0UGFyYW0gKiBjbG9zZXN0UGFyYW0gKiB4MztcbiAgICAgICAgXG4gICAgZGVidWdTdGF0cy5jbG9zZXN0WSA9IE1hdGgucG93KDEuMCAtIGNsb3Nlc3RQYXJhbSwgMi4wKSAqIHkxXG4gICAgICAgICsgMi4wICogKDEuMCAtIGNsb3Nlc3RQYXJhbSkgKiBjbG9zZXN0UGFyYW0gKiB5MlxuICAgICAgICArIGNsb3Nlc3RQYXJhbSAqIGNsb3Nlc3RQYXJhbSAqIHkzO1xuICAgICovXG4gICAgXG4gICAgLy8gZGVidWcoXCJnaXZlbjogXCIgXG4gICAgLy8gICArIFwiKCBcIiArIHggKyBcIiwgXCIgKyB5ICsgXCIpLCBcIiBcbiAgICAvLyAgICsgXCIoIFwiICsgeDEgKyBcIiwgXCIgKyB5MSArIFwiKSwgXCIgXG4gICAgLy8gICArIFwiKCBcIiArIHgyICsgXCIsIFwiICsgeTIgKyBcIiksIFwiXG4gICAgLy8gICArIFwiKCBcIiArIHgzICsgXCIsIFwiICsgeTMgKyBcIilcIik7XG4gICAgXG4gICAgXG4gICAgLy8gZGVidWcoXCJyb290czogXCIgKyByb290cyk7XG4gICAgLy8gZGVidWcoXCJwYXJhbXM6IFwiICsgcGFyYW1zKTtcbiAgICAvLyBkZWJ1ZyhcImNsb3Nlc3QgcGFyYW06IFwiICsgY2xvc2VzdFBhcmFtKTtcbiAgICByZXR1cm4gbWluRGlzdGFuY2VTcXVhcmVkO1xuICB9O1xuICBcbiAgJCQubWF0aC5zcURpc3RhbmNlVG9GaW5pdGVMaW5lID0gZnVuY3Rpb24oeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgb2Zmc2V0ID0gW3ggLSB4MSwgeSAtIHkxXTtcbiAgICB2YXIgbGluZSA9IFt4MiAtIHgxLCB5MiAtIHkxXTtcbiAgICBcbiAgICB2YXIgbGluZVNxID0gbGluZVswXSAqIGxpbmVbMF0gKyBsaW5lWzFdICogbGluZVsxXTtcbiAgICB2YXIgaHlwU3EgPSBvZmZzZXRbMF0gKiBvZmZzZXRbMF0gKyBvZmZzZXRbMV0gKiBvZmZzZXRbMV07XG4gICAgXG4gICAgdmFyIGRvdFByb2R1Y3QgPSBvZmZzZXRbMF0gKiBsaW5lWzBdICsgb2Zmc2V0WzFdICogbGluZVsxXTtcbiAgICB2YXIgYWRqU3EgPSBkb3RQcm9kdWN0ICogZG90UHJvZHVjdCAvIGxpbmVTcTtcbiAgICBcbiAgICBpZiAoZG90UHJvZHVjdCA8IDApIHtcbiAgICAgIHJldHVybiBoeXBTcTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGFkalNxID4gbGluZVNxKSB7XG4gICAgICByZXR1cm4gKHggLSB4MikgKiAoeCAtIHgyKSArICh5IC0geTIpICogKHkgLSB5Mik7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBoeXBTcSAtIGFkalNxO1xuICB9O1xuXG4gICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uID0gZnVuY3Rpb24oXG4gICAgeCwgeSwgYmFzZVBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG5cbiAgICAvL3ZhciBkaXJlY3Rpb24gPSBhcmd1bWVudHNbNl07XG4gICAgdmFyIHRyYW5zZm9ybWVkUG9pbnRzID0gbmV3IEFycmF5KGJhc2VQb2ludHMubGVuZ3RoKTtcblxuICAgIC8vIEdpdmVzIG5lZ2F0aXZlIGFuZ2xlXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKGRpcmVjdGlvblsxXSAvIChNYXRoLnNxcnQoZGlyZWN0aW9uWzBdICogZGlyZWN0aW9uWzBdIFxuICAgICAgKyBkaXJlY3Rpb25bMV0gKiBkaXJlY3Rpb25bMV0pKSk7XG4gICAgXG4gICAgaWYgKGRpcmVjdGlvblswXSA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gICAgICAgIFxuICAgIHZhciBjb3MgPSBNYXRoLmNvcygtYW5nbGUpO1xuICAgIHZhciBzaW4gPSBNYXRoLnNpbigtYW5nbGUpO1xuICAgIFxuLy8gICAgY29uc29sZS5sb2coXCJiYXNlOiBcIiArIGJhc2VQb2ludHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPSBcbiAgICAgICAgd2lkdGggLyAyICogKGJhc2VQb2ludHNbaSAqIDJdICogY29zXG4gICAgICAgICAgLSBiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBzaW4pO1xuICAgICAgXG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdID0gXG4gICAgICAgIGhlaWdodCAvIDIgKiAoYmFzZVBvaW50c1tpICogMiArIDFdICogY29zIFxuICAgICAgICAgICsgYmFzZVBvaW50c1tpICogMl0gKiBzaW4pO1xuXG4gICAgICB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gKz0gY2VudGVyWDtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gKz0gY2VudGVyWTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHBvaW50cztcbiAgICBcbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSB0aGlzLmV4cGFuZFBvbHlnb24oXG4gICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzLFxuICAgICAgICAtcGFkZGluZyk7XG4gICAgICBcbiAgICAgIHBvaW50cyA9IHRoaXMuam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIH1cbiAgICBcbiAgICB2YXIgeDEsIHkxLCB4MiwgeTI7XG4gICAgdmFyIHkzO1xuICAgIFxuICAgIC8vIEludGVyc2VjdCB3aXRoIHZlcnRpY2FsIGxpbmUgdGhyb3VnaCAoeCwgeSlcbiAgICB2YXIgdXAgPSAwO1xuICAgIHZhciBkb3duID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIFxuICAgICAgeDEgPSBwb2ludHNbaSAqIDJdO1xuICAgICAgeTEgPSBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIFxuICAgICAgaWYgKGkgKyAxIDwgcG9pbnRzLmxlbmd0aCAvIDIpIHtcbiAgICAgICAgeDIgPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgICB5MiA9IHBvaW50c1soaSArIDEpICogMiArIDFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeDIgPSBwb2ludHNbKGkgKyAxIC0gcG9pbnRzLmxlbmd0aCAvIDIpICogMl07XG4gICAgICAgIHkyID0gcG9pbnRzWyhpICsgMSAtIHBvaW50cy5sZW5ndGggLyAyKSAqIDIgKyAxXTtcbiAgICAgIH1cbiAgICAgIFxuLy8qICAgICAgY29uc29sZS5sb2coXCJsaW5lIGZyb20gKFwiICsgeDEgKyBcIiwgXCIgKyB5MSArIFwiKSB0byAoXCIgKyB4MiArIFwiLCBcIiArIHkyICsgXCIpXCIpO1xuXG4vLyYgICAgICBjb25zb2xlLmxvZyh4MSwgeCwgeDIpO1xuXG4gICAgICBpZiAoeDEgPT0geCAmJiB4MiA9PSB4KSB7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIGlmICgoeDEgPj0geCAmJiB4ID49IHgyKVxuICAgICAgICB8fCAoeDEgPD0geCAmJiB4IDw9IHgyKSkge1xuICAgICAgICBcbiAgICAgICAgeTMgPSAoeCAtIHgxKSAvICh4MiAtIHgxKSAqICh5MiAtIHkxKSArIHkxO1xuICAgICAgICBcbiAgICAgICAgaWYgKHkzID4geSkge1xuICAgICAgICAgIHVwKys7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh5MyA8IHkpIHtcbiAgICAgICAgICBkb3duKys7XG4gICAgICAgIH1cbiAgICAgICAgXG4vLyogICAgICAgIGNvbnNvbGUubG9nKHkzLCB5KTtcbiAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuLy8qICAgICAgICBjb25zb2xlLmxvZygnMjInKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gICAgXG4vLyogICAgY29uc29sZS5sb2coXCJ1cDogXCIgKyB1cCArIFwiLCBkb3duOiBcIiArIGRvd24pO1xuICAgIFxuICAgIGlmICh1cCAlIDIgPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9O1xuXG4gICQkLm1hdGguam9pbkxpbmVzID0gZnVuY3Rpb24obGluZVNldCkge1xuICAgIFxuICAgIHZhciB2ZXJ0aWNlcyA9IG5ldyBBcnJheShsaW5lU2V0Lmxlbmd0aCAvIDIpO1xuICAgIFxuICAgIHZhciBjdXJyZW50TGluZVN0YXJ0WCwgY3VycmVudExpbmVTdGFydFksIGN1cnJlbnRMaW5lRW5kWCwgY3VycmVudExpbmVFbmRZO1xuICAgIHZhciBuZXh0TGluZVN0YXJ0WCwgbmV4dExpbmVTdGFydFksIG5leHRMaW5lRW5kWCwgbmV4dExpbmVFbmRZO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZVNldC5sZW5ndGggLyA0OyBpKyspIHtcbiAgICAgIGN1cnJlbnRMaW5lU3RhcnRYID0gbGluZVNldFtpICogNF07XG4gICAgICBjdXJyZW50TGluZVN0YXJ0WSA9IGxpbmVTZXRbaSAqIDQgKyAxXTtcbiAgICAgIGN1cnJlbnRMaW5lRW5kWCA9IGxpbmVTZXRbaSAqIDQgKyAyXTtcbiAgICAgIGN1cnJlbnRMaW5lRW5kWSA9IGxpbmVTZXRbaSAqIDQgKyAzXTtcbiAgICAgIFxuICAgICAgaWYgKGkgPCBsaW5lU2V0Lmxlbmd0aCAvIDQgLSAxKSB7XG4gICAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFsoaSArIDEpICogNF07XG4gICAgICAgIG5leHRMaW5lU3RhcnRZID0gbGluZVNldFsoaSArIDEpICogNCArIDFdO1xuICAgICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WyhpICsgMSkgKiA0ICsgMl07XG4gICAgICAgIG5leHRMaW5lRW5kWSA9IGxpbmVTZXRbKGkgKyAxKSAqIDQgKyAzXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRMaW5lU3RhcnRYID0gbGluZVNldFswXTtcbiAgICAgICAgbmV4dExpbmVTdGFydFkgPSBsaW5lU2V0WzFdO1xuICAgICAgICBuZXh0TGluZUVuZFggPSBsaW5lU2V0WzJdO1xuICAgICAgICBuZXh0TGluZUVuZFkgPSBsaW5lU2V0WzNdO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgaW50ZXJzZWN0aW9uID0gdGhpcy5maW5pdGVMaW5lc0ludGVyc2VjdChcbiAgICAgICAgY3VycmVudExpbmVTdGFydFgsIGN1cnJlbnRMaW5lU3RhcnRZLFxuICAgICAgICBjdXJyZW50TGluZUVuZFgsIGN1cnJlbnRMaW5lRW5kWSxcbiAgICAgICAgbmV4dExpbmVTdGFydFgsIG5leHRMaW5lU3RhcnRZLFxuICAgICAgICBuZXh0TGluZUVuZFgsIG5leHRMaW5lRW5kWSxcbiAgICAgICAgdHJ1ZSk7XG4gICAgICBcbiAgICAgIHZlcnRpY2VzW2kgKiAyXSA9IGludGVyc2VjdGlvblswXTtcbiAgICAgIHZlcnRpY2VzW2kgKiAyICsgMV0gPSBpbnRlcnNlY3Rpb25bMV07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB2ZXJ0aWNlcztcbiAgfTtcblxuICAkJC5tYXRoLmV4cGFuZFBvbHlnb24gPSBmdW5jdGlvbihwb2ludHMsIHBhZCkge1xuICAgIFxuICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCAqIDIpO1xuICAgIFxuICAgIHZhciBjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZLCBuZXh0UG9pbnRYLCBuZXh0UG9pbnRZO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgY3VycmVudFBvaW50WCA9IHBvaW50c1tpICogMl07XG4gICAgICBjdXJyZW50UG9pbnRZID0gcG9pbnRzW2kgKiAyICsgMV07XG4gICAgICBcbiAgICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgIG5leHRQb2ludFggPSBwb2ludHNbKGkgKyAxKSAqIDJdO1xuICAgICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0UG9pbnRYID0gcG9pbnRzWzBdO1xuICAgICAgICBuZXh0UG9pbnRZID0gcG9pbnRzWzFdO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDdXJyZW50IGxpbmU6IFtjdXJyZW50UG9pbnRYLCBjdXJyZW50UG9pbnRZXSB0byBbbmV4dFBvaW50WCwgbmV4dFBvaW50WV1cbiAgICAgIFxuICAgICAgLy8gQXNzdW1lIENDVyBwb2x5Z29uIHdpbmRpbmdcbiAgICAgIFxuICAgICAgdmFyIG9mZnNldFggPSAobmV4dFBvaW50WSAtIGN1cnJlbnRQb2ludFkpO1xuICAgICAgdmFyIG9mZnNldFkgPSAtKG5leHRQb2ludFggLSBjdXJyZW50UG9pbnRYKTtcbiAgICAgIFxuICAgICAgLy8gTm9ybWFsaXplXG4gICAgICB2YXIgb2Zmc2V0TGVuZ3RoID0gTWF0aC5zcXJ0KG9mZnNldFggKiBvZmZzZXRYICsgb2Zmc2V0WSAqIG9mZnNldFkpO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRPZmZzZXRYID0gb2Zmc2V0WCAvIG9mZnNldExlbmd0aDtcbiAgICAgIHZhciBub3JtYWxpemVkT2Zmc2V0WSA9IG9mZnNldFkgLyBvZmZzZXRMZW5ndGg7XG4gICAgICBcbiAgICAgIGV4cGFuZGVkTGluZVNldFtpICogNF0gPSBjdXJyZW50UG9pbnRYICsgbm9ybWFsaXplZE9mZnNldFggKiBwYWQ7XG4gICAgICBleHBhbmRlZExpbmVTZXRbaSAqIDQgKyAxXSA9IGN1cnJlbnRQb2ludFkgKyBub3JtYWxpemVkT2Zmc2V0WSAqIHBhZDtcbiAgICAgIGV4cGFuZGVkTGluZVNldFtpICogNCArIDJdID0gbmV4dFBvaW50WCArIG5vcm1hbGl6ZWRPZmZzZXRYICogcGFkO1xuICAgICAgZXhwYW5kZWRMaW5lU2V0W2kgKiA0ICsgM10gPSBuZXh0UG9pbnRZICsgbm9ybWFsaXplZE9mZnNldFkgKiBwYWQ7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBleHBhbmRlZExpbmVTZXQ7XG4gIH07XG5cbiAgJCQubWF0aC5pbnRlcnNlY3RMaW5lRWxsaXBzZSA9IGZ1bmN0aW9uKFxuICAgIHgsIHksIGNlbnRlclgsIGNlbnRlclksIGVsbGlwc2VXcmFkaXVzLCBlbGxpcHNlSHJhZGl1cykge1xuICAgIFxuICAgIHZhciBkaXNwWCA9IGNlbnRlclggLSB4O1xuICAgIHZhciBkaXNwWSA9IGNlbnRlclkgLSB5O1xuICAgIFxuICAgIGRpc3BYIC89IGVsbGlwc2VXcmFkaXVzO1xuICAgIGRpc3BZIC89IGVsbGlwc2VIcmFkaXVzO1xuICAgIFxuICAgIHZhciBsZW4gPSBNYXRoLnNxcnQoZGlzcFggKiBkaXNwWCArIGRpc3BZICogZGlzcFkpO1xuICAgIFxuICAgIHZhciBuZXdMZW5ndGggPSBsZW4gLSAxO1xuICAgIFxuICAgIGlmIChuZXdMZW5ndGggPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIHZhciBsZW5Qcm9wb3J0aW9uID0gbmV3TGVuZ3RoIC8gbGVuO1xuICAgIFxuICAgIHJldHVybiBbKGNlbnRlclggLSB4KSAqIGxlblByb3BvcnRpb24gKyB4LCAoY2VudGVyWSAtIHkpICogbGVuUHJvcG9ydGlvbiArIHldO1xuICB9O1xuICBcbiAgJCQubWF0aC5kb3RQcm9kdWN0ID0gZnVuY3Rpb24oXG4gICAgdmVjMSwgdmVjMikge1xuICAgIFxuICAgIGlmICh2ZWMxLmxlbmd0aCAhPSAyIHx8IHZlYzIubGVuZ3RoICE9IDIpIHtcbiAgICAgIHRocm93ICdkb3QgcHJvZHVjdDogYXJndW1lbnRzIGFyZSBub3QgdmVjdG9ycyc7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiAodmVjMVswXSAqIHZlYzJbMF0gKyB2ZWMxWzFdICogdmVjMlsxXSk7XG4gIH07XG4gIFxuICAvLyBSZXR1cm5zIGludGVyc2VjdGlvbnMgb2YgaW5jcmVhc2luZyBkaXN0YW5jZSBmcm9tIGxpbmUncyBzdGFydCBwb2ludFxuICAkJC5tYXRoLmludGVyc2VjdExpbmVDaXJjbGUgPSBmdW5jdGlvbihcbiAgICB4MSwgeTEsIHgyLCB5MiwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzKSB7XG4gICAgXG4gICAgLy8gQ2FsY3VsYXRlIGQsIGRpcmVjdGlvbiB2ZWN0b3Igb2YgbGluZVxuICAgIHZhciBkID0gW3gyIC0geDEsIHkyIC0geTFdOyAvLyBEaXJlY3Rpb24gdmVjdG9yIG9mIGxpbmVcbiAgICB2YXIgYyA9IFtjZW50ZXJYLCBjZW50ZXJZXTsgLy8gQ2VudGVyIG9mIGNpcmNsZVxuICAgIHZhciBmID0gW3gxIC0gY2VudGVyWCwgeTEgLSBjZW50ZXJZXTtcbiAgICBcbiAgICB2YXIgYSA9IGRbMF0gKiBkWzBdICsgZFsxXSAqIGRbMV07XG4gICAgdmFyIGIgPSAyICogKGZbMF0gKiBkWzBdICsgZlsxXSAqIGRbMV0pO1xuICAgIHZhciBjID0gKGZbMF0gKiBmWzBdICsgZlsxXSAqIGZbMV0pIC0gcmFkaXVzICogcmFkaXVzIDtcbiAgICBcbiAgICB2YXIgZGlzY3JpbWluYW50ID0gYipiLTQqYSpjO1xuICAgIFxuICAgIGlmIChkaXNjcmltaW5hbnQgPCAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIHZhciB0MSA9ICgtYiArIE1hdGguc3FydChkaXNjcmltaW5hbnQpKSAvICgyICogYSk7XG4gICAgdmFyIHQyID0gKC1iIC0gTWF0aC5zcXJ0KGRpc2NyaW1pbmFudCkpIC8gKDIgKiBhKTtcbiAgICBcbiAgICB2YXIgdE1pbiA9IE1hdGgubWluKHQxLCB0Mik7XG4gICAgdmFyIHRNYXggPSBNYXRoLm1heCh0MSwgdDIpO1xuICAgIHZhciBpblJhbmdlUGFyYW1zID0gW107XG4gICAgXG4gICAgaWYgKHRNaW4gPj0gMCAmJiB0TWluIDw9IDEpIHtcbiAgICAgIGluUmFuZ2VQYXJhbXMucHVzaCh0TWluKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHRNYXggPj0gMCAmJiB0TWF4IDw9IDEpIHtcbiAgICAgIGluUmFuZ2VQYXJhbXMucHVzaCh0TWF4KTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGluUmFuZ2VQYXJhbXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIFxuICAgIHZhciBuZWFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMF0gKiBkWzBdICsgeDE7XG4gICAgdmFyIG5lYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1swXSAqIGRbMV0gKyB5MTtcbiAgICBcbiAgICBpZiAoaW5SYW5nZVBhcmFtcy5sZW5ndGggPiAxKSB7XG4gICAgXG4gICAgICBpZiAoaW5SYW5nZVBhcmFtc1swXSA9PSBpblJhbmdlUGFyYW1zWzFdKSB7XG4gICAgICAgIHJldHVybiBbbmVhckludGVyc2VjdGlvblgsIG5lYXJJbnRlcnNlY3Rpb25ZXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgZmFySW50ZXJzZWN0aW9uWCA9IGluUmFuZ2VQYXJhbXNbMV0gKiBkWzBdICsgeDE7XG4gICAgICAgIHZhciBmYXJJbnRlcnNlY3Rpb25ZID0gaW5SYW5nZVBhcmFtc1sxXSAqIGRbMV0gKyB5MTtcbiAgICAgIFxuICAgICAgICByZXR1cm4gW25lYXJJbnRlcnNlY3Rpb25YLCBuZWFySW50ZXJzZWN0aW9uWSwgZmFySW50ZXJzZWN0aW9uWCwgZmFySW50ZXJzZWN0aW9uWV07XG4gICAgICB9XG4gICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtuZWFySW50ZXJzZWN0aW9uWCwgbmVhckludGVyc2VjdGlvblldO1xuICAgIH1cbiAgICBcbiAgfTtcbiAgXG4gICQkLm1hdGguZmluZENpcmNsZU5lYXJQb2ludCA9IGZ1bmN0aW9uKGNlbnRlclgsIGNlbnRlclksIFxuICAgIHJhZGl1cywgZmFyWCwgZmFyWSkge1xuICAgIFxuICAgIHZhciBkaXNwbGFjZW1lbnRYID0gZmFyWCAtIGNlbnRlclg7XG4gICAgdmFyIGRpc3BsYWNlbWVudFkgPSBmYXJZIC0gY2VudGVyWTtcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlzcGxhY2VtZW50WCAqIGRpc3BsYWNlbWVudFggXG4gICAgICArIGRpc3BsYWNlbWVudFkgKiBkaXNwbGFjZW1lbnRZKTtcbiAgICBcbiAgICB2YXIgdW5pdERpc3BsYWNlbWVudFggPSBkaXNwbGFjZW1lbnRYIC8gZGlzdGFuY2U7XG4gICAgdmFyIHVuaXREaXNwbGFjZW1lbnRZID0gZGlzcGxhY2VtZW50WSAvIGRpc3RhbmNlO1xuICAgIFxuICAgIHJldHVybiBbY2VudGVyWCArIHVuaXREaXNwbGFjZW1lbnRYICogcmFkaXVzLCBcbiAgICAgIGNlbnRlclkgKyB1bml0RGlzcGxhY2VtZW50WSAqIHJhZGl1c107XG4gIH07XG4gIFxuICAkJC5tYXRoLmZpbmRNYXhTcURpc3RhbmNlVG9PcmlnaW4gPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICB2YXIgbWF4U3FEaXN0YW5jZSA9IDAuMDAwMDAxO1xuICAgIHZhciBzcURpc3RhbmNlO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgXG4gICAgICBzcURpc3RhbmNlID0gcG9pbnRzW2kgKiAyXSAqIHBvaW50c1tpICogMl0gXG4gICAgICAgICsgcG9pbnRzW2kgKiAyICsgMV0gKiBwb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgIFxuICAgICAgaWYgKHNxRGlzdGFuY2UgPiBtYXhTcURpc3RhbmNlKSB7XG4gICAgICAgIG1heFNxRGlzdGFuY2UgPSBzcURpc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbWF4U3FEaXN0YW5jZTtcbiAgfTtcbiAgXG4gICQkLm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QgPSBmdW5jdGlvbihcbiAgICB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4NCwgeTQsIGluZmluaXRlTGluZXMpIHtcbiAgICBcbiAgICB2YXIgdWFfdCA9ICh4NCAtIHgzKSAqICh5MSAtIHkzKSAtICh5NCAtIHkzKSAqICh4MSAtIHgzKTtcbiAgICB2YXIgdWJfdCA9ICh4MiAtIHgxKSAqICh5MSAtIHkzKSAtICh5MiAtIHkxKSAqICh4MSAtIHgzKTtcbiAgICB2YXIgdV9iID0gKHk0IC0geTMpICogKHgyIC0geDEpIC0gKHg0IC0geDMpICogKHkyIC0geTEpO1xuXG4gICAgaWYgKHVfYiAhPT0gMCkge1xuICAgICAgdmFyIHVhID0gdWFfdCAvIHVfYjtcbiAgICAgIHZhciB1YiA9IHViX3QgLyB1X2I7XG4gICAgICBcbiAgICAgIGlmICgwIDw9IHVhICYmIHVhIDw9IDEgJiYgMCA8PSB1YiAmJiB1YiA8PSAxKSB7ICBcbiAgICAgICAgcmV0dXJuIFt4MSArIHVhICogKHgyIC0geDEpLCB5MSArIHVhICogKHkyIC0geTEpXTtcbiAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWluZmluaXRlTGluZXMpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFt4MSArIHVhICogKHgyIC0geDEpLCB5MSArIHVhICogKHkyIC0geTEpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodWFfdCA9PT0gMCB8fCB1Yl90ID09PSAwKSB7XG5cbiAgICAgICAgLy8gUGFyYWxsZWwsIGNvaW5jaWRlbnQgbGluZXMuIENoZWNrIGlmIG92ZXJsYXBcblxuICAgICAgICAvLyBDaGVjayBlbmRwb2ludCBvZiBzZWNvbmQgbGluZVxuICAgICAgICBpZiAoW3gxLCB4MiwgeDRdLnNvcnQoKVsxXSA9PT0geDQpIHtcbiAgICAgICAgICByZXR1cm4gW3g0LCB5NF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIHN0YXJ0IHBvaW50IG9mIHNlY29uZCBsaW5lXG4gICAgICAgIGlmIChbeDEsIHgyLCB4M10uc29ydCgpWzFdID09PSB4Mykge1xuICAgICAgICAgIHJldHVybiBbeDMsIHkzXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gRW5kcG9pbnQgb2YgZmlyc3QgbGluZVxuICAgICAgICBpZiAoW3gzLCB4NCwgeDJdLnNvcnQoKVsxXSA9PT0geDIpIHtcbiAgICAgICAgICByZXR1cm4gW3gyLCB5Ml07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICBcbiAgICAgICAgLy8gUGFyYWxsZWwsIG5vbi1jb2luY2lkZW50XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFxuICAvLyAoYm94TWluWCwgYm94TWluWSwgYm94TWF4WCwgYm94TWF4WSwgcGFkZGluZyxcbiAgLy8gICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCB2Qm94VG9wTGVmdFggKyBwYWRkaW5nLCBoQm94VG9wTGVmdFkgKyBwYWRkaW5nKSkge1xuICBcbiAgJCQubWF0aC5ib3hJbnRlcnNlY3RFbGxpcHNlID0gZnVuY3Rpb24oXG4gICAgeDEsIHkxLCB4MiwgeTIsIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICBcbiAgICBpZiAoeDIgPCB4MSkge1xuICAgICAgdmFyIG9sZFgxID0geDE7XG4gICAgICB4MSA9IHgyO1xuICAgICAgeDIgPSBvbGRYMTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHkyIDwgeTEpIHtcbiAgICAgIHZhciBvbGRZMSA9IHkxO1xuICAgICAgeTEgPSB5MjtcbiAgICAgIHkyID0gb2xkWTE7XG4gICAgfVxuICAgIFxuICAgIC8vIDQgb3J0aG8gZXh0cmVtZSBwb2ludHNcbiAgICB2YXIgd2VzdCA9IFtjZW50ZXJYIC0gd2lkdGggLyAyIC0gcGFkZGluZywgY2VudGVyWV07XG4gICAgdmFyIGVhc3QgPSBbY2VudGVyWCArIHdpZHRoIC8gMiArIHBhZGRpbmcsIGNlbnRlclldO1xuICAgIHZhciBub3J0aCA9IFtjZW50ZXJYLCBjZW50ZXJZIC0gaGVpZ2h0IC8gMiAtIHBhZGRpbmddO1xuICAgIHZhciBzb3V0aCA9IFtjZW50ZXJYLCBjZW50ZXJZICsgaGVpZ2h0IC8gMiArIHBhZGRpbmddO1xuICAgIFxuICAgIC8vIG91dCBvZiBib3VuZHM6IHJldHVybiBmYWxzZVxuICAgIGlmICh4MiA8IHdlc3RbMF0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgxID4gZWFzdFswXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTEgPiBzb3V0aFsxXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTIgPCBub3J0aFsxXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyAxIG9mIDQgb3J0aG8gZXh0cmVtZSBwb2ludHMgaW4gYm94OiByZXR1cm4gdHJ1ZVxuICAgIGlmICh4MSA8PSBlYXN0WzBdICYmIGVhc3RbMF0gPD0geDJcbiAgICAgICAgJiYgeTEgPD0gZWFzdFsxXSAmJiBlYXN0WzFdIDw9IHkyKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgxIDw9IHdlc3RbMF0gJiYgd2VzdFswXSA8PSB4MlxuICAgICAgICAmJiB5MSA8PSB3ZXN0WzFdICYmIHdlc3RbMV0gPD0geTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgPD0gbm9ydGhbMF0gJiYgbm9ydGhbMF0gPD0geDJcbiAgICAgICAgJiYgeTEgPD0gbm9ydGhbMV0gJiYgbm9ydGhbMV0gPD0geTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgPD0gc291dGhbMF0gJiYgc291dGhbMF0gPD0geDJcbiAgICAgICAgJiYgeTEgPD0gc291dGhbMV0gJiYgc291dGhbMV0gPD0geTIpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBib3ggY29ybmVyIGluIGVsbGlwc2U6IHJldHVybiB0cnVlICAgIFxuICAgIHgxID0gKHgxIC0gY2VudGVyWCkgLyAod2lkdGggLyAyICsgcGFkZGluZyk7XG4gICAgeDIgPSAoeDIgLSBjZW50ZXJYKSAvICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICBcbiAgICB5MSA9ICh5MSAtIGNlbnRlclkpIC8gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICB5MiA9ICh5MiAtIGNlbnRlclkpIC8gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICBcbiAgICBpZiAoeDEgKiB4MSArIHkxICogeTEgPD0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MiAqIHgyICsgeTEgKiB5MSA8PSAxKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHgyICogeDIgKyB5MiAqIHkyIDw9IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeDEgKiB4MSArIHkyICogeTIgPD0gMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gICQkLm1hdGguYm94SW50ZXJzZWN0UG9seWdvbiA9IGZ1bmN0aW9uKFxuICAgIHgxLCB5MSwgeDIsIHkyLCBiYXNlUG9pbnRzLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZLCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICBcbi8vICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cyk7XG4gICAgXG4gICAgaWYgKHgyIDwgeDEpIHtcbiAgICAgIHZhciBvbGRYMSA9IHgxO1xuICAgICAgeDEgPSB4MjtcbiAgICAgIHgyID0gb2xkWDE7XG4gICAgfVxuICAgIFxuICAgIGlmICh5MiA8IHkxKSB7XG4gICAgICB2YXIgb2xkWTEgPSB5MTtcbiAgICAgIHkxID0geTI7XG4gICAgICB5MiA9IG9sZFkxO1xuICAgIH1cbiAgICBcbiAgICB2YXIgdHJhbnNmb3JtZWRQb2ludHMgPSBuZXcgQXJyYXkoYmFzZVBvaW50cy5sZW5ndGgpO1xuICAgIFxuICAgIC8vIEdpdmVzIG5lZ2F0aXZlIG9mIGFuZ2xlXG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hc2luKGRpcmVjdGlvblsxXSAvIChNYXRoLnNxcnQoZGlyZWN0aW9uWzBdICogZGlyZWN0aW9uWzBdIFxuICAgICAgKyBkaXJlY3Rpb25bMV0gKiBkaXJlY3Rpb25bMV0pKSk7XG4gICAgXG4gICAgaWYgKGRpcmVjdGlvblswXSA8IDApIHtcbiAgICAgIGFuZ2xlID0gYW5nbGUgKyBNYXRoLlBJIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5nbGUgPSAtYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB9XG4gICAgXG4gICAgdmFyIGNvcyA9IE1hdGguY29zKC1hbmdsZSk7XG4gICAgdmFyIHNpbiA9IE1hdGguc2luKC1hbmdsZSk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IFxuICAgICAgICB3aWR0aCAvIDIgKiAoYmFzZVBvaW50c1tpICogMl0gKiBjb3NcbiAgICAgICAgICAtIGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIHNpbik7XG4gICAgICBcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyICsgMV0gPSBcbiAgICAgICAgaGVpZ2h0IC8gMiAqIChiYXNlUG9pbnRzW2kgKiAyICsgMV0gKiBjb3MgXG4gICAgICAgICAgKyBiYXNlUG9pbnRzW2kgKiAyXSAqIHNpbik7XG4gICAgICBcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSArPSBjZW50ZXJYO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSArPSBjZW50ZXJZO1xuICAgIH1cbiAgICBcbiAgICAvLyBBc3N1bWUgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoID4gMCwgYW5kIGNoZWNrIGlmIGludGVyc2VjdGlvbiBpcyBwb3NzaWJsZVxuICAgIHZhciBtaW5UcmFuc2Zvcm1lZFggPSB0cmFuc2Zvcm1lZFBvaW50c1swXTtcbiAgICB2YXIgbWF4VHJhbnNmb3JtZWRYID0gdHJhbnNmb3JtZWRQb2ludHNbMF07XG4gICAgdmFyIG1pblRyYW5zZm9ybWVkWSA9IHRyYW5zZm9ybWVkUG9pbnRzWzFdO1xuICAgIHZhciBtYXhUcmFuc2Zvcm1lZFkgPSB0cmFuc2Zvcm1lZFBvaW50c1sxXTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHRyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgaWYgKHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA+IG1heFRyYW5zZm9ybWVkWCkge1xuICAgICAgICBtYXhUcmFuc2Zvcm1lZFggPSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMl07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmICh0cmFuc2Zvcm1lZFBvaW50c1tpICogMl0gPCBtaW5UcmFuc2Zvcm1lZFgpIHtcbiAgICAgICAgbWluVHJhbnNmb3JtZWRYID0gdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA+IG1heFRyYW5zZm9ybWVkWSkge1xuICAgICAgICBtYXhUcmFuc2Zvcm1lZFkgPSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAodHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA8IG1pblRyYW5zZm9ybWVkWSkge1xuICAgICAgICBtaW5UcmFuc2Zvcm1lZFkgPSB0cmFuc2Zvcm1lZFBvaW50c1tpICogMiArIDFdO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBpZiAoeDIgPCBtaW5UcmFuc2Zvcm1lZFggLSBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIGlmICh4MSA+IG1heFRyYW5zZm9ybWVkWCArIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHkyIDwgbWluVHJhbnNmb3JtZWRZIC0gcGFkZGluZykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICBpZiAoeTEgPiBtYXhUcmFuc2Zvcm1lZFkgKyBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIC8vIENvbnRpbnVlIGNoZWNraW5nIHdpdGggcGFkZGluZy1jb3JyZWN0ZWQgcG9pbnRzXG4gICAgdmFyIHBvaW50cztcbiAgICBcbiAgICBpZiAocGFkZGluZyA+IDApIHtcbiAgICAgIHZhciBleHBhbmRlZExpbmVTZXQgPSAkJC5tYXRoLmV4cGFuZFBvbHlnb24oXG4gICAgICAgIHRyYW5zZm9ybWVkUG9pbnRzLFxuICAgICAgICAtcGFkZGluZyk7XG4gICAgICBcbiAgICAgIHBvaW50cyA9ICQkLm1hdGguam9pbkxpbmVzKGV4cGFuZGVkTGluZVNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBhIHBvaW50IGlzIGluIGJveFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICBpZiAoeDEgPD0gdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdXG4gICAgICAgICAgJiYgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDJdIDw9IHgyKSB7XG4gICAgICAgIFxuICAgICAgICBpZiAoeTEgPD0gdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXVxuICAgICAgICAgICAgJiYgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA8PSB5Mikge1xuICAgICAgICAgIFxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIFxuICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb25zIHdpdGggdGhlIHNlbGVjdGlvbiBib3hcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIFxuICAgICAgdmFyIGN1cnJlbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgIHZhciBjdXJyZW50WSA9IHBvaW50c1tpICogMiArIDFdO1xuICAgICAgdmFyIG5leHRYO1xuICAgICAgdmFyIG5leHRZO1xuICAgICAgXG4gICAgICBpZiAoaSA8IHBvaW50cy5sZW5ndGggLyAyIC0gMSkge1xuICAgICAgICBuZXh0WCA9IHBvaW50c1soaSArIDEpICogMl07XG4gICAgICAgIG5leHRZID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0WCA9IHBvaW50c1swXTtcbiAgICAgICAgbmV4dFkgPSBwb2ludHNbMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEludGVyc2VjdGlvbiB3aXRoIHRvcCBvZiBzZWxlY3Rpb24gYm94XG4gICAgICBpZiAoJCQubWF0aC5maW5pdGVMaW5lc0ludGVyc2VjdChjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WSwgeDEsIHkxLCB4MiwgeTEsIGZhbHNlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBJbnRlcnNlY3Rpb24gd2l0aCBib3R0b20gb2Ygc2VsZWN0aW9uIGJveFxuICAgICAgaWYgKCQkLm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QoY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFksIHgxLCB5MiwgeDIsIHkyLCBmYWxzZSkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSW50ZXJzZWN0aW9uIHdpdGggbGVmdCBzaWRlIG9mIHNlbGVjdGlvbiBib3hcbiAgICAgIGlmICgkJC5tYXRoLmZpbml0ZUxpbmVzSW50ZXJzZWN0KGN1cnJlbnRYLCBjdXJyZW50WSwgbmV4dFgsIG5leHRZLCB4MSwgeTEsIHgxLCB5MiwgZmFsc2UpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIEludGVyc2VjdGlvbiB3aXRoIHJpZ2h0IHNpZGUgb2Ygc2VsZWN0aW9uIGJveFxuICAgICAgaWYgKCQkLm1hdGguZmluaXRlTGluZXNJbnRlcnNlY3QoY3VycmVudFgsIGN1cnJlbnRZLCBuZXh0WCwgbmV4dFksIHgyLCB5MSwgeDIsIHkyLCBmYWxzZSkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKlxuICAgIC8vIENoZWNrIGlmIGJveCBjb3JuZXIgaW4gdGhlIHBvbHlnb25cbiAgICBpZiAoJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICB4MSwgeTEsIHBvaW50cywgMCwgMCwgMSwgMSwgMCwgZGlyZWN0aW9uKSkge1xuICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgeDEsIHkyLCBwb2ludHMsIDAsIDAsIDEsIDEsIDAsIGRpcmVjdGlvbikpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgIHgyLCB5MiwgcG9pbnRzLCAwLCAwLCAxLCAxLCAwLCBkaXJlY3Rpb24pKSB7XG4gICAgICAgXG4gICAgICByZXR1cm4gdHJ1ZTsgXG4gICAgfSBlbHNlIGlmICgkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgIHgyLCB5MSwgcG9pbnRzLCAwLCAwLCAxLCAxLCAwLCBkaXJlY3Rpb24pKSB7XG4gICAgICBcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAqL1xuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gICQkLm1hdGgucG9seWdvbkludGVyc2VjdExpbmUgPSBmdW5jdGlvbihcbiAgICB4LCB5LCBiYXNlUG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBwYWRkaW5nKSB7XG4gICAgXG4gICAgdmFyIGludGVyc2VjdGlvbnMgPSBbXTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uO1xuICAgIFxuICAgIHZhciB0cmFuc2Zvcm1lZFBvaW50cyA9IG5ldyBBcnJheShiYXNlUG9pbnRzLmxlbmd0aCk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybWVkUG9pbnRzW2kgKiAyXSA9IGJhc2VQb2ludHNbaSAqIDJdICogd2lkdGggKyBjZW50ZXJYO1xuICAgICAgdHJhbnNmb3JtZWRQb2ludHNbaSAqIDIgKyAxXSA9IGJhc2VQb2ludHNbaSAqIDIgKyAxXSAqIGhlaWdodCArIGNlbnRlclk7XG4gICAgfVxuICAgIFxuICAgIHZhciBwb2ludHM7XG4gICAgXG4gICAgaWYgKHBhZGRpbmcgPiAwKSB7XG4gICAgICB2YXIgZXhwYW5kZWRMaW5lU2V0ID0gJCQubWF0aC5leHBhbmRQb2x5Z29uKFxuICAgICAgICB0cmFuc2Zvcm1lZFBvaW50cyxcbiAgICAgICAgLXBhZGRpbmcpO1xuICAgICAgXG4gICAgICBwb2ludHMgPSAkJC5tYXRoLmpvaW5MaW5lcyhleHBhbmRlZExpbmVTZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludHMgPSB0cmFuc2Zvcm1lZFBvaW50cztcbiAgICB9XG4gICAgLy8gdmFyIHBvaW50cyA9IHRyYW5zZm9ybWVkUG9pbnRzO1xuICAgIFxuICAgIHZhciBjdXJyZW50WCwgY3VycmVudFksIG5leHRYLCBuZXh0WTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICBcbiAgICAgIGN1cnJlbnRYID0gcG9pbnRzW2kgKiAyXTtcbiAgICAgIGN1cnJlbnRZID0gcG9pbnRzW2kgKiAyICsgMV07XG5cbiAgICAgIGlmIChpIDwgcG9pbnRzLmxlbmd0aCAvIDIgLSAxKSB7XG4gICAgICAgIG5leHRYID0gcG9pbnRzWyhpICsgMSkgKiAyXTsgXG4gICAgICAgIG5leHRZID0gcG9pbnRzWyhpICsgMSkgKiAyICsgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0WCA9IHBvaW50c1swXTsgXG4gICAgICAgIG5leHRZID0gcG9pbnRzWzFdO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpbnRlcnNlY3Rpb24gPSB0aGlzLmZpbml0ZUxpbmVzSW50ZXJzZWN0KFxuICAgICAgICB4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLFxuICAgICAgICBjdXJyZW50WCwgY3VycmVudFksXG4gICAgICAgIG5leHRYLCBuZXh0WSk7XG4gICAgICBcbiAgICAgIGlmIChpbnRlcnNlY3Rpb24ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGludGVyc2VjdGlvbnMucHVzaChpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9O1xuICBcbiAgJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oXG4gICAgaW50ZXJzZWN0aW9uLCBvZmZzZXQsIGFtb3VudCkge1xuICAgIFxuICAgIHZhciBkaXNwID0gW2ludGVyc2VjdGlvblswXSAtIG9mZnNldFswXSwgaW50ZXJzZWN0aW9uWzFdIC0gb2Zmc2V0WzFdXTtcbiAgICBcbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5zcXJ0KGRpc3BbMF0gKiBkaXNwWzBdICsgZGlzcFsxXSAqIGRpc3BbMV0pO1xuICAgIFxuICAgIHZhciBsZW5SYXRpbyA9IChsZW5ndGggLSBhbW91bnQpIC8gbGVuZ3RoO1xuICAgIFxuICAgIGlmIChsZW5SYXRpbyA8IDApIHtcbiAgICAgIGxlblJhdGlvID0gMC4wMDAwMTtcbiAgICB9XG5cbiAgICByZXR1cm4gW29mZnNldFswXSArIGxlblJhdGlvICogZGlzcFswXSwgb2Zmc2V0WzFdICsgbGVuUmF0aW8gKiBkaXNwWzFdXTtcbiAgfTtcblxuICAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSA9IGZ1bmN0aW9uKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgICB2YXIgcG9pbnRzID0gJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpO1xuICAgIHBvaW50cyA9ICQkLm1hdGguZml0UG9seWdvblRvU3F1YXJlKHBvaW50cyk7XG5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9O1xuXG4gICQkLm1hdGguZml0UG9seWdvblRvU3F1YXJlID0gZnVuY3Rpb24ocG9pbnRzKXtcbiAgICB2YXIgeCwgeTtcbiAgICB2YXIgc2lkZXMgPSBwb2ludHMubGVuZ3RoLzI7XG4gICAgdmFyIG1pblggPSBJbmZpbml0eSwgbWluWSA9IEluZmluaXR5LCBtYXhYID0gLUluZmluaXR5LCBtYXhZID0gLUluZmluaXR5O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKSB7XG4gICAgICB4ID0gcG9pbnRzWzIgKiBpXTtcbiAgICAgIHkgPSBwb2ludHNbMiAqIGkgKyAxXTtcblxuICAgICAgbWluWCA9IE1hdGgubWluKCBtaW5YLCB4ICk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgoIG1heFgsIHggKTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbiggbWluWSwgeSApO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KCBtYXhZLCB5ICk7XG4gICAgfVxuICAgIFxuICAgIC8vIHN0cmV0Y2ggZmFjdG9yc1xuICAgIHZhciBzeCA9IDIgLyAobWF4WCAtIG1pblgpO1xuICAgIHZhciBzeSA9IDIgLyAobWF4WSAtIG1pblkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKXtcbiAgICAgIHggPSBwb2ludHNbMiAqIGldID0gcG9pbnRzWzIgKiBpXSAqIHN4O1xuICAgICAgeSA9IHBvaW50c1syICogaSArIDFdID0gcG9pbnRzWzIgKiBpICsgMV0gKiBzeTtcblxuICAgICAgbWluWCA9IE1hdGgubWluKCBtaW5YLCB4ICk7XG4gICAgICBtYXhYID0gTWF0aC5tYXgoIG1heFgsIHggKTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbiggbWluWSwgeSApO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KCBtYXhZLCB5ICk7XG4gICAgfVxuXG4gICAgaWYoIG1pblkgPCAtMSApe1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKXtcbiAgICAgICAgeSA9IHBvaW50c1syICogaSArIDFdID0gcG9pbnRzWzIgKiBpICsgMV0gKyAoLTEgLW1pblkpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9O1xuXG4gICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50cyA9IGZ1bmN0aW9uKHNpZGVzLCByb3RhdGlvblJhZGlhbnMpIHtcbiAgICBcbiAgICB2YXIgaW5jcmVtZW50ID0gMS4wIC8gc2lkZXMgKiAyICogTWF0aC5QSTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNpZGVzICUgMiA9PT0gMCA/IFxuICAgICAgTWF0aC5QSSAvIDIuMCArIGluY3JlbWVudCAvIDIuMCA6IE1hdGguUEkgLyAyLjA7XG4vLyAgICBjb25zb2xlLmxvZyhub2RlU2hhcGVzWydzcXVhcmUnXSk7XG4gICAgc3RhcnRBbmdsZSArPSByb3RhdGlvblJhZGlhbnM7XG4gICAgXG4gICAgdmFyIHBvaW50cyA9IG5ldyBBcnJheShzaWRlcyAqIDIpO1xuXG4gICAgdmFyIGN1cnJlbnRBbmdsZSwgeCwgeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspIHtcbiAgICAgIGN1cnJlbnRBbmdsZSA9IGkgKiBpbmNyZW1lbnQgKyBzdGFydEFuZ2xlO1xuICAgICAgXG4gICAgICB4ID0gcG9pbnRzWzIgKiBpXSA9IE1hdGguY29zKGN1cnJlbnRBbmdsZSk7Ly8gKiAoMSArIGkvMik7XG4gICAgICB5ID0gcG9pbnRzWzIgKiBpICsgMV0gPSBNYXRoLnNpbigtY3VycmVudEFuZ2xlKTsvLyAgKiAoMSArIGkvMik7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBwb2ludHM7XG4gIH07XG5cbiAgJCQubWF0aC5nZXRSb3VuZFJlY3RhbmdsZVJhZGl1cyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBcbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgcmFkaXVzLCB1bmxlc3MgaGFsZiBvZiB3aWR0aCBvciBoZWlnaHQgaXMgc21hbGxlciB0aGFuIGRlZmF1bHRcbiAgICByZXR1cm4gTWF0aC5taW4od2lkdGggLyA0LCBoZWlnaHQgLyA0LCA4KTtcbiAgfTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAvLyByZWdpc3RlcmVkIGV4dGVuc2lvbnMgdG8gY3l0b3NjYXBlLCBpbmRleGVkIGJ5IG5hbWVcbiAgdmFyIGV4dGVuc2lvbnMgPSB7fTtcbiAgJCQuZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnM7XG4gIFxuICAvLyByZWdpc3RlcmVkIG1vZHVsZXMgZm9yIGV4dGVuc2lvbnMsIGluZGV4ZWQgYnkgbmFtZVxuICB2YXIgbW9kdWxlcyA9IHt9O1xuICAkJC5tb2R1bGVzID0gbW9kdWxlcztcbiAgXG4gIGZ1bmN0aW9uIHNldEV4dGVuc2lvbih0eXBlLCBuYW1lLCByZWdpc3RyYW50KXtcbiAgICB2YXIgaW1wbCA9IHt9O1xuICAgIGltcGxbbmFtZV0gPSByZWdpc3RyYW50O1xuICAgIFxuICAgIHN3aXRjaCggdHlwZSApe1xuICAgIGNhc2UgJ2NvcmUnOlxuICAgIGNhc2UgJ2NvbGxlY3Rpb24nOlxuICAgICAgJCQuZm5bdHlwZV0oIGltcGwgKTtcbiAgICB9XG4gICAgXG4gICAgLy8gZmlsbCBpbiBtaXNzaW5nIGxheW91dCBmdW5jdGlvbnMgaW4gdGhlIHByb3RvdHlwZVxuICAgIGlmKCB0eXBlID09PSAnbGF5b3V0JyApe1xuICAgICAgdmFyIGxheW91dFByb3RvID0gcmVnaXN0cmFudC5wcm90b3R5cGU7XG4gICAgICB2YXIgb3B0TGF5b3V0Rm5zID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgb3B0TGF5b3V0Rm5zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBmbk5hbWUgPSBvcHRMYXlvdXRGbnNbaV07XG5cbiAgICAgICAgbGF5b3V0UHJvdG9bZm5OYW1lXSA9IGxheW91dFByb3RvW2ZuTmFtZV0gfHwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH07XG4gICAgICB9XG5cbiAgICAgIC8vIGVpdGhlciAuc3RhcnQoKSBvciAucnVuKCkgaXMgZGVmaW5lZCwgc28gYXV0b2dlbiB0aGUgb3RoZXJcbiAgICAgIGlmKCBsYXlvdXRQcm90by5zdGFydCAmJiAhbGF5b3V0UHJvdG8ucnVuICl7XG4gICAgICAgIGxheW91dFByb3RvLnJ1biA9IGZ1bmN0aW9uKCl7IHRoaXMuc3RhcnQoKTsgcmV0dXJuIHRoaXM7IH07XG4gICAgICB9IGVsc2UgaWYoICFsYXlvdXRQcm90by5zdGFydCAmJiBsYXlvdXRQcm90by5ydW4gKXtcbiAgICAgICAgbGF5b3V0UHJvdG8uc3RhcnQgPSBmdW5jdGlvbigpeyB0aGlzLnJ1bigpOyByZXR1cm4gdGhpczsgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoICFsYXlvdXRQcm90by5zdG9wICl7XG4gICAgICAgIGxheW91dFByb3RvLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgICAgICAgIHZhciBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBvcHRzICYmIG9wdHMuYW5pbWF0ZSApe1xuICAgICAgICAgICAgb3B0cy5lbGVzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGxheW91dFByb3RvLm9uID0gJCQuZGVmaW5lLm9uKHsgbGF5b3V0OiB0cnVlIH0pO1xuICAgICAgbGF5b3V0UHJvdG8ub25lID0gJCQuZGVmaW5lLm9uKHsgbGF5b3V0OiB0cnVlLCB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pO1xuICAgICAgbGF5b3V0UHJvdG8ub25jZSA9ICQkLmRlZmluZS5vbih7IGxheW91dDogdHJ1ZSwgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogdHJ1ZSB9KTtcbiAgICAgIGxheW91dFByb3RvLm9mZiA9ICQkLmRlZmluZS5vZmYoeyBsYXlvdXQ6IHRydWUgfSk7XG4gICAgICBsYXlvdXRQcm90by50cmlnZ2VyID0gJCQuZGVmaW5lLnRyaWdnZXIoeyBsYXlvdXQ6IHRydWUgfSk7XG5cbiAgICAgICQkLmRlZmluZS5ldmVudEFsaWFzZXNPbiggbGF5b3V0UHJvdG8gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJCQudXRpbC5zZXRNYXAoe1xuICAgICAgbWFwOiBleHRlbnNpb25zLFxuICAgICAga2V5czogWyB0eXBlLCBuYW1lIF0sXG4gICAgICB2YWx1ZTogcmVnaXN0cmFudFxuICAgIH0pO1xuICB9XG4gIFxuICBmdW5jdGlvbiBnZXRFeHRlbnNpb24odHlwZSwgbmFtZSl7XG4gICAgcmV0dXJuICQkLnV0aWwuZ2V0TWFwKHtcbiAgICAgIG1hcDogZXh0ZW5zaW9ucyxcbiAgICAgIGtleXM6IFsgdHlwZSwgbmFtZSBdXG4gICAgfSk7XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIHNldE1vZHVsZSh0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lLCByZWdpc3RyYW50KXtcbiAgICByZXR1cm4gJCQudXRpbC5zZXRNYXAoe1xuICAgICAgbWFwOiBtb2R1bGVzLFxuICAgICAga2V5czogWyB0eXBlLCBuYW1lLCBtb2R1bGVUeXBlLCBtb2R1bGVOYW1lIF0sXG4gICAgICB2YWx1ZTogcmVnaXN0cmFudFxuICAgIH0pO1xuICB9XG4gIFxuICBmdW5jdGlvbiBnZXRNb2R1bGUodHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSl7XG4gICAgcmV0dXJuICQkLnV0aWwuZ2V0TWFwKHtcbiAgICAgIG1hcDogbW9kdWxlcyxcbiAgICAgIGtleXM6IFsgdHlwZSwgbmFtZSwgbW9kdWxlVHlwZSwgbW9kdWxlTmFtZSBdXG4gICAgfSk7XG4gIH1cbiAgXG4gICQkLmV4dGVuc2lvbiA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gZS5nLiAkJC5leHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycpXG4gICAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT0gMiApe1xuICAgICAgcmV0dXJuIGdldEV4dGVuc2lvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBcbiAgICAvLyBlLmcuICQkLmV4dGVuc2lvbigncmVuZGVyZXInLCAnc3ZnJywgeyAuLi4gfSlcbiAgICBlbHNlIGlmKCBhcmd1bWVudHMubGVuZ3RoID09IDMgKXtcbiAgICAgIHJldHVybiBzZXRFeHRlbnNpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgXG4gICAgLy8gZS5nLiAkJC5leHRlbnNpb24oJ3JlbmRlcmVyJywgJ3N2ZycsICdub2RlU2hhcGUnLCAnZWxsaXBzZScpXG4gICAgZWxzZSBpZiggYXJndW1lbnRzLmxlbmd0aCA9PSA0ICl7XG4gICAgICByZXR1cm4gZ2V0TW9kdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIFxuICAgIC8vIGUuZy4gJCQuZXh0ZW5zaW9uKCdyZW5kZXJlcicsICdzdmcnLCAnbm9kZVNoYXBlJywgJ2VsbGlwc2UnLCB7IC4uLiB9KVxuICAgIGVsc2UgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT0gNSApe1xuICAgICAgcmV0dXJuIHNldE1vZHVsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICBcbiAgICBlbHNlIHtcbiAgICAgICQkLnV0aWwuZXJyb3IoJ0ludmFsaWQgZXh0ZW5zaW9uIGFjY2VzcyBzeW50YXgnKTtcbiAgICB9XG4gIFxuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkLCAkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIGlmKCAhJCApeyByZXR1cm47IH0gLy8gbm8ganF1ZXJ5ID0+IGRvbid0IG5lZWQgdGhpc1xuXG4gIHZhciBjeVJlZyA9IGZ1bmN0aW9uKCAkZWxlICl7XG4gICAgdmFyIGQgPSAkZWxlWzBdLl9jeXJlZyA9ICRlbGVbMF0uX2N5cmVnIHx8IHt9O1xuXG4gICAgcmV0dXJuIGQ7XG4gIH07XG5cbiAgLy8gYWxsb3cgY2FsbHMgb24gYSBqUXVlcnkgc2VsZWN0b3IgYnkgcHJveHlpbmcgY2FsbHMgdG8gJC5jeXRvc2NhcGVcbiAgLy8gZS5nLiAkKFwiI2Zvb1wiKS5jeXRvc2NhcGUob3B0aW9ucykgPT4gJC5jeXRvc2NhcGUob3B0aW9ucykgb24gI2Zvb1xuICAkLmZuLmN5dG9zY2FwZSA9IGZ1bmN0aW9uKG9wdHMpe1xuICAgIHZhciAkdGhpcyA9ICQodGhpcyk7XG5cbiAgICAvLyBnZXQgb2JqZWN0XG4gICAgaWYoIG9wdHMgPT09ICdnZXQnICl7XG4gICAgICByZXR1cm4gY3lSZWcoICR0aGlzICkuY3k7XG4gICAgfVxuICAgIFxuICAgIC8vIGJpbmQgdG8gcmVhZHlcbiAgICBlbHNlIGlmKCAkJC5pcy5mbihvcHRzKSApe1xuXG4gICAgICB2YXIgcmVhZHkgPSBvcHRzO1xuICAgICAgdmFyIGN5ID0gY3lSZWcoICR0aGlzICkuY3k7XG4gICAgICBcbiAgICAgIGlmKCBjeSAmJiBjeS5pc1JlYWR5KCkgKXsgLy8gYWxyZWFkeSByZWFkeSBzbyBqdXN0IHRyaWdnZXIgbm93XG4gICAgICAgIGN5LnRyaWdnZXIoJ3JlYWR5JywgW10sIHJlYWR5KTtcblxuICAgICAgfSBlbHNlIHsgLy8gbm90IHlldCByZWFkeSwgc28gYWRkIHRvIHJlYWRpZXMgbGlzdFxuICAgICAgICB2YXIgZGF0YSA9IGN5UmVnKCAkdGhpcyApO1xuICAgICAgICB2YXIgcmVhZGllcyA9IGRhdGEucmVhZGllcyA9IGRhdGEucmVhZGllcyB8fCBbXTtcblxuICAgICAgICByZWFkaWVzLnB1c2goIHJlYWR5ICk7XG4gICAgICB9IFxuICAgICAgXG4gICAgfVxuICAgIFxuICAgIC8vIHByb3h5IHRvIGNyZWF0ZSBpbnN0YW5jZVxuICAgIGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG9wdHMpICl7XG4gICAgICByZXR1cm4gJHRoaXMuZWFjaChmdW5jdGlvbigpe1xuICAgICAgICB2YXIgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBvcHRzLCB7XG4gICAgICAgICAgY29udGFpbmVyOiAkKHRoaXMpWzBdXG4gICAgICAgIH0pO1xuICAgICAgXG4gICAgICAgIGN5dG9zY2FwZShvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIGFsbG93IGFjY2VzcyB0byB0aGUgZ2xvYmFsIGN5dG9zY2FwZSBvYmplY3QgdW5kZXIganF1ZXJ5IGZvciBsZWdhY3kgcmVhc29uc1xuICAkLmN5dG9zY2FwZSA9IGN5dG9zY2FwZTtcbiAgXG4gIC8vIHVzZSBzaG9ydCBhbGlhcyAoY3kpIGlmIG5vdCBhbHJlYWR5IGRlZmluZWRcbiAgaWYoICQuZm4uY3kgPT0gbnVsbCAmJiAkLmN5ID09IG51bGwgKXtcbiAgICAkLmZuLmN5ID0gJC5mbi5jeXRvc2NhcGU7XG4gICAgJC5jeSA9ICQuY3l0b3NjYXBlO1xuICB9XG4gIFxufSkodHlwZW9mIGpRdWVyeSAhPT0gJ3VuZGVmaW5lZCcgPyBqUXVlcnkgOiBudWxsICwgY3l0b3NjYXBlKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIHNoYW1lbGVzc2x5IHRha2VuIGZyb20galF1ZXJ5XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L2Jsb2IvbWFzdGVyL3NyYy9ldmVudC5qc1xuXG4gICQkLkV2ZW50ID0gZnVuY3Rpb24oIHNyYywgcHJvcHMgKSB7XG4gICAgLy8gQWxsb3cgaW5zdGFudGlhdGlvbiB3aXRob3V0IHRoZSAnbmV3JyBrZXl3b3JkXG4gICAgaWYgKCAhKHRoaXMgaW5zdGFuY2VvZiAkJC5FdmVudCkgKSB7XG4gICAgICByZXR1cm4gbmV3ICQkLkV2ZW50KCBzcmMsIHByb3BzICk7XG4gICAgfVxuXG4gICAgLy8gRXZlbnQgb2JqZWN0XG4gICAgaWYgKCBzcmMgJiYgc3JjLnR5cGUgKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG4gICAgICB0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuICAgICAgLy8gRXZlbnRzIGJ1YmJsaW5nIHVwIHRoZSBkb2N1bWVudCBtYXkgaGF2ZSBiZWVuIG1hcmtlZCBhcyBwcmV2ZW50ZWRcbiAgICAgIC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSAoIHNyYy5kZWZhdWx0UHJldmVudGVkICkgPyByZXR1cm5UcnVlIDogcmV0dXJuRmFsc2U7XG5cbiAgICAvLyBFdmVudCB0eXBlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHlwZSA9IHNyYztcbiAgICB9XG5cbiAgICAvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuICAgIGlmICggcHJvcHMgKSB7XG4gICAgICAvLyAkJC51dGlsLmV4dGVuZCggdGhpcywgcHJvcHMgKTtcblxuICAgICAgLy8gbW9yZSBlZmZpY2llbnQgdG8gbWFudWFsbHkgY29weSBmaWVsZHMgd2UgdXNlXG4gICAgICB0aGlzLnR5cGUgPSBwcm9wcy50eXBlICE9PSB1bmRlZmluZWQgPyBwcm9wcy50eXBlIDogdGhpcy50eXBlO1xuICAgICAgdGhpcy5jeSA9IHByb3BzLmN5O1xuICAgICAgdGhpcy5jeVRhcmdldCA9IHByb3BzLmN5VGFyZ2V0O1xuICAgICAgdGhpcy5jeVBvc2l0aW9uID0gcHJvcHMuY3lQb3NpdGlvbjtcbiAgICAgIHRoaXMuY3lSZW5kZXJlZFBvc2l0aW9uID0gcHJvcHMuY3lSZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgdGhpcy5uYW1lc3BhY2UgPSBwcm9wcy5uYW1lc3BhY2U7XG4gICAgICB0aGlzLmxheW91dCA9IHByb3BzLmxheW91dDtcbiAgICAgIHRoaXMuZGF0YSA9IHByb3BzLmRhdGE7XG4gICAgICB0aGlzLm1lc3NhZ2UgPSBwcm9wcy5tZXNzYWdlO1xuICAgIH1cblxuICAgIC8vIENyZWF0ZSBhIHRpbWVzdGFtcCBpZiBpbmNvbWluZyBldmVudCBkb2Vzbid0IGhhdmUgb25lXG4gICAgdGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCArbmV3IERhdGUoKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbiAgJCQuRXZlbnQucHJvdG90eXBlID0ge1xuICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICBpZiAoICFlICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHByZXZlbnREZWZhdWx0IGV4aXN0cyBydW4gaXQgb24gdGhlIG9yaWdpbmFsIGV2ZW50XG4gICAgICBpZiAoIGUucHJldmVudERlZmF1bHQgKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuICAgICAgdmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG4gICAgICBpZiAoICFlICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBpZiBzdG9wUHJvcGFnYXRpb24gZXhpc3RzIHJ1biBpdCBvbiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICAgIGlmICggZS5zdG9wUHJvcGFnYXRpb24gKSB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG4gICAgICB0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0sXG4gICAgaXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcbiAgICBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG4gICAgaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlXG4gIH07XG4gIFxuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyB1c2UgdGhpcyBtb2R1bGUgdG8gY2hlcnJ5IHBpY2sgZnVuY3Rpb25zIGludG8geW91ciBwcm90b3R5cGVcbiAgLy8gKHVzZWZ1bCBmb3IgZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIHRoZSBjb3JlIGFuZCBjb2xsZWN0aW9ucywgZm9yIGV4YW1wbGUpXG5cbiAgLy8gZS5nLlxuICAvLyAkJC5mbi5jb2xsZWN0aW9uKHtcbiAgLy8gICBmb286ICQkLmRlZmluZS5mb28oeyAvKiBwYXJhbXMuLi4gKi8gfSlcbiAgLy8gfSk7XG5cbiAgJCQuZGVmaW5lID0ge1xuXG4gICAgLy8gYWNjZXNzIGRhdGEgZmllbGRcbiAgICBkYXRhOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7IFxuICAgICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgICAgYWxsb3dTZXR0aW5nOiBmYWxzZSxcbiAgICAgICAgYWxsb3dHZXR0aW5nOiBmYWxzZSxcbiAgICAgICAgc2V0dGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgICBpbW11dGFibGVLZXlzOiB7fSwgLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICAgIHVwZGF0ZVN0eWxlOiBmYWxzZSxcbiAgICAgICAgb25TZXQ6IGZ1bmN0aW9uKCBzZWxmICl7fSxcbiAgICAgICAgY2FuU2V0OiBmdW5jdGlvbiggc2VsZiApeyByZXR1cm4gdHJ1ZTsgfVxuICAgICAgfTtcbiAgICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRhdGFJbXBsKCBuYW1lLCB2YWx1ZSApe1xuICAgICAgICB2YXIgcCA9IHBhcmFtcztcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgc2luZ2xlID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZlswXSA6IHNlbGY7XG5cbiAgICAgICAgLy8gLmRhdGEoJ2ZvbycsIC4uLilcbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyhuYW1lKSApeyAvLyBzZXQgb3IgZ2V0IHByb3BlcnR5XG5cbiAgICAgICAgICAvLyAuZGF0YSgnZm9vJylcbiAgICAgICAgICBpZiggcC5hbGxvd0dldHRpbmcgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCApeyAvLyBnZXRcblxuICAgICAgICAgICAgdmFyIHJldDtcbiAgICAgICAgICAgIGlmKCBzaW5nbGUgKXtcbiAgICAgICAgICAgICAgcmV0ID0gc2luZ2xlLl9wcml2YXRlWyBwLmZpZWxkIF1bIG5hbWUgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gLmRhdGEoJ2ZvbycsICdiYXInKVxuICAgICAgICAgIH0gZWxzZSBpZiggcC5hbGxvd1NldHRpbmcgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCApIHsgLy8gc2V0XG4gICAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzW25hbWVdO1xuICAgICAgICAgICAgaWYoIHZhbGlkICl7XG4gICAgICAgICAgICAgIGZvciggdmFyIGkgPSAwLCBsID0gYWxsLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICAgICAgICAgIGlmKCBwLmNhblNldCggYWxsW2ldICkgKXtcbiAgICAgICAgICAgICAgICAgIGFsbFtpXS5fcHJpdmF0ZVsgcC5maWVsZCBdWyBuYW1lIF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyB1cGRhdGUgbWFwcGVycyBpZiBhc2tlZFxuICAgICAgICAgICAgICBpZiggcC51cGRhdGVTdHlsZSApeyBzZWxmLnVwZGF0ZVN0eWxlKCk7IH1cblxuICAgICAgICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgICAgICAgIHAub25TZXQoIHNlbGYgKTtcblxuICAgICAgICAgICAgICBpZiggcC5zZXR0aW5nVHJpZ2dlcnNFdmVudCApe1xuICAgICAgICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLnNldHRpbmdFdmVudCApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIC5kYXRhKHsgJ2Zvbyc6ICdiYXInIH0pXG4gICAgICAgIH0gZWxzZSBpZiggcC5hbGxvd1NldHRpbmcgJiYgJCQuaXMucGxhaW5PYmplY3QobmFtZSkgKXsgLy8gZXh0ZW5kXG4gICAgICAgICAgdmFyIG9iaiA9IG5hbWU7XG4gICAgICAgICAgdmFyIGssIHY7XG5cbiAgICAgICAgICBmb3IoIGsgaW4gb2JqICl7XG4gICAgICAgICAgICB2ID0gb2JqWyBrIF07XG5cbiAgICAgICAgICAgIHZhciB2YWxpZCA9ICFwLmltbXV0YWJsZUtleXNba107XG4gICAgICAgICAgICBpZiggdmFsaWQgKXtcbiAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBhbGwubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICAgICAgICAgICAgaWYoIHAuY2FuU2V0KCBhbGxbaV0gKSApe1xuICAgICAgICAgICAgICAgICAgYWxsW2ldLl9wcml2YXRlWyBwLmZpZWxkIF1bIGsgXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIHVwZGF0ZSBtYXBwZXJzIGlmIGFza2VkXG4gICAgICAgICAgaWYoIHAudXBkYXRlU3R5bGUgKXsgc2VsZi51cGRhdGVTdHlsZSgpOyB9XG5cbiAgICAgICAgICAvLyBjYWxsIG9uU2V0IGNhbGxiYWNrXG4gICAgICAgICAgcC5vblNldCggc2VsZiApO1xuXG4gICAgICAgICAgaWYoIHAuc2V0dGluZ1RyaWdnZXJzRXZlbnQgKXtcbiAgICAgICAgICAgIHNlbGZbIHAudHJpZ2dlckZuTmFtZSBdKCBwLnNldHRpbmdFdmVudCApO1xuICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIC5kYXRhKGZ1bmN0aW9uKCl7IC4uLiB9KVxuICAgICAgICB9IGVsc2UgaWYoIHAuYWxsb3dCaW5kaW5nICYmICQkLmlzLmZuKG5hbWUpICl7IC8vIGJpbmQgdG8gZXZlbnRcbiAgICAgICAgICB2YXIgZm4gPSBuYW1lO1xuICAgICAgICAgIHNlbGYuYmluZCggcC5iaW5kaW5nRXZlbnQsIGZuICk7XG4gICAgICAgIFxuICAgICAgICAvLyAuZGF0YSgpXG4gICAgICAgIH0gZWxzZSBpZiggcC5hbGxvd0dldHRpbmcgJiYgbmFtZSA9PT0gdW5kZWZpbmVkICl7IC8vIGdldCB3aG9sZSBvYmplY3RcbiAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgIGlmKCBzaW5nbGUgKXtcbiAgICAgICAgICAgIHJldCA9IHNpbmdsZS5fcHJpdmF0ZVsgcC5maWVsZCBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluYWJpbGl0eVxuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9LCAvLyBkYXRhXG5cbiAgICAvLyByZW1vdmUgZGF0YSBmaWVsZFxuICAgIHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHsgXG4gICAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICAgIGV2ZW50OiAnZGF0YScsXG4gICAgICAgIHRyaWdnZXJGbk5hbWU6ICd0cmlnZ2VyJyxcbiAgICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZSxcbiAgICAgICAgaW1tdXRhYmxlS2V5czoge30gLy8ga2V5ID0+IHRydWUgaWYgaW1tdXRhYmxlXG4gICAgICB9O1xuICAgICAgcGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBwYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlRGF0YUltcGwoIG5hbWVzICl7XG4gICAgICAgIHZhciBwID0gcGFyYW1zO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIFxuICAgICAgICAvLyAucmVtb3ZlRGF0YSgnZm9vIGJhcicpXG4gICAgICAgIGlmKCAkJC5pcy5zdHJpbmcobmFtZXMpICl7IC8vIHRoZW4gZ2V0IHRoZSBsaXN0IG9mIGtleXMsIGFuZCBkZWxldGUgdGhlbVxuICAgICAgICAgIHZhciBrZXlzID0gbmFtZXMuc3BsaXQoL1xccysvKTtcbiAgICAgICAgICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBsOyBpKysgKXsgLy8gZGVsZXRlIGVhY2ggbm9uLWVtcHR5IGtleVxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiggJCQuaXMuZW1wdHlTdHJpbmcoa2V5KSApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICB2YXIgdmFsaWQgPSAhcC5pbW11dGFibGVLZXlzWyBrZXkgXTsgLy8gbm90IHZhbGlkIGlmIGltbXV0YWJsZVxuICAgICAgICAgICAgaWYoIHZhbGlkICl7XG4gICAgICAgICAgICAgIGZvciggdmFyIGlfYSA9IDAsIGxfYSA9IGFsbC5sZW5ndGg7IGlfYSA8IGxfYTsgaV9hKysgKXtcbiAgICAgICAgICAgICAgICBhbGxbIGlfYSBdLl9wcml2YXRlWyBwLmZpZWxkIF1bIGtleSBdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHAudHJpZ2dlckV2ZW50ICl7XG4gICAgICAgICAgICBzZWxmWyBwLnRyaWdnZXJGbk5hbWUgXSggcC5ldmVudCApO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyAucmVtb3ZlRGF0YSgpXG4gICAgICAgIH0gZWxzZSBpZiggbmFtZXMgPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIGRlbGV0ZSBhbGwga2V5c1xuXG4gICAgICAgICAgZm9yKCB2YXIgaV9hID0gMCwgbF9hID0gYWxsLmxlbmd0aDsgaV9hIDwgbF9hOyBpX2ErKyApe1xuICAgICAgICAgICAgdmFyIF9wcml2YXRlRmllbGRzID0gYWxsWyBpX2EgXS5fcHJpdmF0ZVsgcC5maWVsZCBdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IoIHZhciBrZXkgaW4gX3ByaXZhdGVGaWVsZHMgKXtcbiAgICAgICAgICAgICAgdmFyIHZhbGlkS2V5VG9EZWxldGUgPSAhcC5pbW11dGFibGVLZXlzWyBrZXkgXTtcblxuICAgICAgICAgICAgICBpZiggdmFsaWRLZXlUb0RlbGV0ZSApe1xuICAgICAgICAgICAgICAgIF9wcml2YXRlRmllbGRzWyBrZXkgXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBwLnRyaWdnZXJFdmVudCApe1xuICAgICAgICAgICAgc2VsZlsgcC50cmlnZ2VyRm5OYW1lIF0oIHAuZXZlbnQgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgIH07IC8vIGZ1bmN0aW9uXG4gICAgfSwgLy8gcmVtb3ZlRGF0YVxuXG4gICAgLy8gZXZlbnQgZnVuY3Rpb24gcmV1c2FibGUgc3R1ZmZcbiAgICBldmVudDoge1xuICAgICAgcmVnZXg6IC8oXFx3KykoXFwuXFx3Kyk/LywgLy8gcmVnZXggZm9yIG1hdGNoaW5nIGV2ZW50IHN0cmluZ3MgKGUuZy4gXCJjbGljay5uYW1lc3BhY2VcIilcbiAgICAgIG9wdGlvbmFsVHlwZVJlZ2V4OiAvKFxcdyspPyhcXC5cXHcrKT8vLFxuICAgICAgZmFsc2VDYWxsYmFjazogZnVuY3Rpb24oKXsgcmV0dXJuIGZhbHNlOyB9XG4gICAgfSxcblxuICAgIC8vIGV2ZW50IGJpbmRpbmdcbiAgICBvbjogZnVuY3Rpb24oIHBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICB1bmJpbmRTZWxmT25UcmlnZ2VyOiBmYWxzZSxcbiAgICAgICAgdW5iaW5kQWxsQmluZGVyc09uVHJpZ2dlcjogZmFsc2VcbiAgICAgIH07XG4gICAgICBwYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgICBcbiAgICAgIHJldHVybiBmdW5jdGlvbiBvbkltcGwoZXZlbnRzLCBzZWxlY3RvciwgZGF0YSwgY2FsbGJhY2spe1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxmSXNBcnJheUxpa2UgPSBzZWxmLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgYWxsID0gc2VsZklzQXJyYXlMaWtlID8gc2VsZiA6IFtzZWxmXTsgLy8gcHV0IGluIGFycmF5IGlmIG5vdCBhcnJheS1saWtlXG4gICAgICAgIHZhciBldmVudHNJc1N0cmluZyA9ICQkLmlzLnN0cmluZyhldmVudHMpO1xuICAgICAgICB2YXIgcCA9IHBhcmFtcztcblxuICAgICAgICBpZiggJCQuaXMucGxhaW5PYmplY3Qoc2VsZWN0b3IpICl7IC8vIHNlbGVjdG9yIGlzIGFjdHVhbGx5IGRhdGFcbiAgICAgICAgICBjYWxsYmFjayA9IGRhdGE7XG4gICAgICAgICAgZGF0YSA9IHNlbGVjdG9yO1xuICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYoICQkLmlzLmZuKHNlbGVjdG9yKSB8fCBzZWxlY3RvciA9PT0gZmFsc2UgKXsgLy8gc2VsZWN0b3IgaXMgYWN0dWFsbHkgY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgc2VsZWN0b3IgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggJCQuaXMuZm4oZGF0YSkgfHwgZGF0YSA9PT0gZmFsc2UgKXsgLy8gZGF0YSBpcyBhY3R1YWxseSBjYWxsYmFja1xuICAgICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgICBkYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXNuJ3QgYSBjYWxsYmFjaywgd2UgY2FuJ3QgcmVhbGx5IGRvIGFueXRoaW5nXG4gICAgICAgIC8vIChjYW4ndCBzcGVhayBmb3IgbWFwcGVkIGV2ZW50cyBhcmcgdmVyc2lvbilcbiAgICAgICAgaWYoICEoJCQuaXMuZm4oY2FsbGJhY2spIHx8IGNhbGxiYWNrID09PSBmYWxzZSkgJiYgZXZlbnRzSXNTdHJpbmcgKXtcbiAgICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBldmVudHNJc1N0cmluZyApeyAvLyB0aGVuIGNvbnZlcnQgdG8gbWFwXG4gICAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICAgIG1hcFsgZXZlbnRzIF0gPSBjYWxsYmFjaztcbiAgICAgICAgICBldmVudHMgPSBtYXA7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIHZhciBldnRzIGluIGV2ZW50cyApe1xuICAgICAgICAgIGNhbGxiYWNrID0gZXZlbnRzW2V2dHNdO1xuICAgICAgICAgIGlmKCBjYWxsYmFjayA9PT0gZmFsc2UgKXtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gJCQuZGVmaW5lLmV2ZW50LmZhbHNlQ2FsbGJhY2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICEkJC5pcy5mbihjYWxsYmFjaykgKXsgY29udGludWU7IH1cblxuICAgICAgICAgIGV2dHMgPSBldnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBldnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZXZ0c1tpXTtcbiAgICAgICAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhldnQpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaCggJCQuZGVmaW5lLmV2ZW50LnJlZ2V4ICk7IC8vIHR5cGVbLm5hbWVzcGFjZV1cblxuICAgICAgICAgICAgaWYoIG1hdGNoICl7XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssIC8vIGNhbGxiYWNrIHRvIHJ1blxuICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsIC8vIGV4dHJhIGRhdGEgaW4gZXZlbnRPYmouZGF0YVxuICAgICAgICAgICAgICAgIGRlbGVnYXRlZDogc2VsZWN0b3IgPyB0cnVlIDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGV2dCBpcyBkZWxlZ2F0ZWRcbiAgICAgICAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsIC8vIHRoZSBzZWxlY3RvciB0byBtYXRjaCBmb3IgZGVsZWdhdGVkIGV2ZW50c1xuICAgICAgICAgICAgICAgIHNlbE9iajogbmV3ICQkLlNlbGVjdG9yKHNlbGVjdG9yKSwgLy8gY2FjaGVkIHNlbGVjdG9yIG9iamVjdCB0byBzYXZlIHJlYnVpbGRpbmdcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLCAvLyB0aGUgZXZlbnQgdHlwZSAoZS5nLiAnY2xpY2snKVxuICAgICAgICAgICAgICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLCAvLyB0aGUgZXZlbnQgbmFtZXNwYWNlIChlLmcuIFwiLmZvb1wiKVxuICAgICAgICAgICAgICAgIHVuYmluZFNlbGZPblRyaWdnZXI6IHAudW5iaW5kU2VsZk9uVHJpZ2dlcixcbiAgICAgICAgICAgICAgICB1bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyOiBwLnVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXIsXG4gICAgICAgICAgICAgICAgYmluZGVyczogYWxsIC8vIHdobyBib3VuZCB0b2dldGhlclxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICAgICAgdmFyIF9wID0gYWxsW2pdLl9wcml2YXRlO1xuXG4gICAgICAgICAgICAgICAgX3AubGlzdGVuZXJzID0gX3AubGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICAgICAgICAgIF9wLmxpc3RlbmVycy5wdXNoKCBsaXN0ZW5lciApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBmb3IgZXZlbnRzIGFycmF5XG4gICAgICAgIH0gLy8gZm9yIGV2ZW50cyBtYXBcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgfTsgLy8gZnVuY3Rpb25cbiAgICB9LCAvLyBvblxuXG4gICAgZXZlbnRBbGlhc2VzT246IGZ1bmN0aW9uKCBwcm90byApe1xuICAgICAgdmFyIHAgPSBwcm90bztcblxuICAgICAgcC5hZGRMaXN0ZW5lciA9IHAubGlzdGVuID0gcC5iaW5kID0gcC5vbjtcbiAgICAgIHAucmVtb3ZlTGlzdGVuZXIgPSBwLnVubGlzdGVuID0gcC51bmJpbmQgPSBwLm9mZjtcbiAgICAgIHAuZW1pdCA9IHAudHJpZ2dlcjtcblxuICAgICAgLy8gdGhpcyBpcyBqdXN0IGEgd3JhcHBlciBhbGlhcyBvZiAub24oKVxuICAgICAgcC5wb24gPSBwLnByb21pc2VPbiA9IGZ1bmN0aW9uKCBldmVudHMsIHNlbGVjdG9yICl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAwICk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyAkJC5Qcm9taXNlKGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKXtcbiAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiggZSApe1xuICAgICAgICAgICAgc2VsZi5vZmYuYXBwbHkoIHNlbGYsIG9mZkFyZ3MgKTtcblxuICAgICAgICAgICAgcmVzb2x2ZSggZSApO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgb25BcmdzID0gYXJncy5jb25jYXQoWyBjYWxsYmFjayBdKTtcbiAgICAgICAgICB2YXIgb2ZmQXJncyA9IG9uQXJncy5jb25jYXQoW10pO1xuXG4gICAgICAgICAgc2VsZi5vbi5hcHBseSggc2VsZiwgb25BcmdzICk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9LFxuXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmZJbXBsKCBwYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIH07XG4gICAgICBwYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgICBcbiAgICAgIHJldHVybiBmdW5jdGlvbihldmVudHMsIHNlbGVjdG9yLCBjYWxsYmFjayl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIGV2ZW50c0lzU3RyaW5nID0gJCQuaXMuc3RyaW5nKGV2ZW50cyk7XG5cbiAgICAgICAgaWYoIGFyZ3VtZW50cy5sZW5ndGggPT09IDAgKXsgLy8gdGhlbiB1bmJpbmQgYWxsXG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgYWxsW2ldLl9wcml2YXRlLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzZWxmOyAvLyBtYWludGFpbiBjaGFpbmluZ1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICQkLmlzLmZuKHNlbGVjdG9yKSB8fCBzZWxlY3RvciA9PT0gZmFsc2UgKXsgLy8gc2VsZWN0b3IgaXMgYWN0dWFsbHkgY2FsbGJhY2tcbiAgICAgICAgICBjYWxsYmFjayA9IHNlbGVjdG9yO1xuICAgICAgICAgIHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGV2ZW50c0lzU3RyaW5nICl7IC8vIHRoZW4gY29udmVydCB0byBtYXBcbiAgICAgICAgICB2YXIgbWFwID0ge307XG4gICAgICAgICAgbWFwWyBldmVudHMgXSA9IGNhbGxiYWNrO1xuICAgICAgICAgIGV2ZW50cyA9IG1hcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciggdmFyIGV2dHMgaW4gZXZlbnRzICl7XG4gICAgICAgICAgY2FsbGJhY2sgPSBldmVudHNbZXZ0c107XG5cbiAgICAgICAgICBpZiggY2FsbGJhY2sgPT09IGZhbHNlICl7XG4gICAgICAgICAgICBjYWxsYmFjayA9ICQkLmRlZmluZS5ldmVudC5mYWxzZUNhbGxiYWNrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGV2dHMgPSBldnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgZm9yKCB2YXIgaCA9IDA7IGggPCBldnRzLmxlbmd0aDsgaCsrICl7XG4gICAgICAgICAgICB2YXIgZXZ0ID0gZXZ0c1toXTtcbiAgICAgICAgICAgIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhldnQpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGV2dC5tYXRjaCggJCQuZGVmaW5lLmV2ZW50Lm9wdGlvbmFsVHlwZVJlZ2V4ICk7IC8vIFt0eXBlXVsubmFtZXNwYWNlXVxuICAgICAgICAgICAgaWYoIG1hdGNoICl7XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gbWF0Y2hbMV0gPyBtYXRjaFsxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IG1hdGNoWzJdID8gbWF0Y2hbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKysgKXsgLy9cbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gYWxsW2ldLl9wcml2YXRlLmxpc3RlbmVycyA9IGFsbFtpXS5fcHJpdmF0ZS5saXN0ZW5lcnMgfHwgW107XG5cbiAgICAgICAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGxpc3RlbmVycy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2pdO1xuICAgICAgICAgICAgICAgICAgdmFyIG5zTWF0Y2hlcyA9ICFuYW1lc3BhY2UgfHwgbmFtZXNwYWNlID09PSBsaXN0ZW5lci5uYW1lc3BhY2U7XG4gICAgICAgICAgICAgICAgICB2YXIgdHlwZU1hdGNoZXMgPSAhdHlwZSB8fCBsaXN0ZW5lci50eXBlID09PSB0eXBlO1xuICAgICAgICAgICAgICAgICAgdmFyIGNiTWF0Y2hlcyA9ICFjYWxsYmFjayB8fCBjYWxsYmFjayA9PT0gbGlzdGVuZXIuY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJNYXRjaGVzID0gbnNNYXRjaGVzICYmIHR5cGVNYXRjaGVzICYmIGNiTWF0Y2hlcztcblxuICAgICAgICAgICAgICAgICAgLy8gZGVsZXRlIGxpc3RlbmVyIGlmIGl0IG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgIGlmKCBsaXN0ZW5lck1hdGNoZXMgKXtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZm9yIGxpc3RlbmVyc1xuICAgICAgICAgICAgICB9IC8vIGZvciBhbGxcbiAgICAgICAgICAgIH0gLy8gaWYgbWF0Y2hcbiAgICAgICAgICB9IC8vIGZvciBldmVudHMgYXJyYXlcblxuICAgICAgICB9IC8vIGZvciBldmVudHMgbWFwXG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2VsZjsgLy8gbWFpbnRhaW4gY2hhaW5pbmdcbiAgICAgIH07IC8vIGZ1bmN0aW9uXG4gICAgfSwgLy8gb2ZmXG5cbiAgICB0cmlnZ2VyOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgcGFyYW1zKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRyaWdnZXJJbXBsKGV2ZW50cywgZXh0cmFQYXJhbXMsIGZuVG9UcmlnZ2VyKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgZXZlbnRzSXNTdHJpbmcgPSAkJC5pcy5zdHJpbmcoZXZlbnRzKTtcbiAgICAgICAgdmFyIGV2ZW50c0lzT2JqZWN0ID0gJCQuaXMucGxhaW5PYmplY3QoZXZlbnRzKTtcbiAgICAgICAgdmFyIGV2ZW50c0lzRXZlbnQgPSAkJC5pcy5ldmVudChldmVudHMpO1xuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8ICggJCQuaXMuY29yZSh0aGlzKSA/IHRoaXMgOiBudWxsICk7XG4gICAgICAgIHZhciBoYXNDb21wb3VuZHMgPSBjeSA/IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKSA6IGZhbHNlO1xuXG4gICAgICAgIGlmKCBldmVudHNJc1N0cmluZyApeyAvLyB0aGVuIG1ha2UgYSBwbGFpbiBldmVudCBvYmplY3QgZm9yIGVhY2ggZXZlbnQgbmFtZVxuICAgICAgICAgIHZhciBldnRzID0gZXZlbnRzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgICAgZXZlbnRzID0gW107XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV2dHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBldnQgPSBldnRzW2ldO1xuICAgICAgICAgICAgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGV2dCkgKXsgY29udGludWU7IH1cblxuICAgICAgICAgICAgdmFyIG1hdGNoID0gZXZ0Lm1hdGNoKCAkJC5kZWZpbmUuZXZlbnQucmVnZXggKTsgLy8gdHlwZVsubmFtZXNwYWNlXVxuICAgICAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIHZhciBuYW1lc3BhY2UgPSBtYXRjaFsyXSA/IG1hdGNoWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBldmVudHMucHVzaCgge1xuICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZVxuICAgICAgICAgICAgfSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKCBldmVudHNJc09iamVjdCApeyAvLyBwdXQgaW4gbGVuZ3RoIDEgYXJyYXlcbiAgICAgICAgICB2YXIgZXZlbnRBcmdPYmogPSBldmVudHM7XG5cbiAgICAgICAgICBldmVudHMgPSBbIGV2ZW50QXJnT2JqIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiggZXh0cmFQYXJhbXMgKXtcbiAgICAgICAgICBpZiggISQkLmlzLmFycmF5KGV4dHJhUGFyYW1zKSApeyAvLyBtYWtlIHN1cmUgZXh0cmEgcGFyYW1zIGFyZSBpbiBhbiBhcnJheSBpZiBzcGVjaWZpZWRcbiAgICAgICAgICAgIGV4dHJhUGFyYW1zID0gWyBleHRyYVBhcmFtcyBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlLCB3ZSd2ZSBnb3Qgbm90aGluZ1xuICAgICAgICAgIGV4dHJhUGFyYW1zID0gW107XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKyApeyAvLyB0cmlnZ2VyIGVhY2ggZXZlbnQgaW4gb3JkZXJcbiAgICAgICAgICB2YXIgZXZ0T2JqID0gZXZlbnRzW2ldO1xuICAgICAgICAgIFxuICAgICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgYWxsLmxlbmd0aDsgaisrICl7IC8vIGZvciBlYWNoXG4gICAgICAgICAgICB2YXIgdHJpZ2dlcmVyID0gYWxsW2pdO1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRyaWdnZXJlci5fcHJpdmF0ZS5saXN0ZW5lcnMgPSB0cmlnZ2VyZXIuX3ByaXZhdGUubGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJlcklzRWxlbWVudCA9ICQkLmlzLmVsZW1lbnQodHJpZ2dlcmVyKTtcbiAgICAgICAgICAgIHZhciBidWJibGVVcCA9IHRyaWdnZXJlcklzRWxlbWVudCB8fCBwYXJhbXMubGF5b3V0O1xuXG4gICAgICAgICAgICAvLyBjcmVhdGUgdGhlIGV2ZW50IGZvciB0aGlzIGVsZW1lbnQgZnJvbSB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICB2YXIgZXZ0O1xuXG4gICAgICAgICAgICBpZiggZXZlbnRzSXNFdmVudCApeyAvLyB0aGVuIGp1c3QgZ2V0IHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgZXZ0ID0gZXZ0T2JqO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgZXZ0LmN5VGFyZ2V0ID0gZXZ0LmN5VGFyZ2V0IHx8IHRyaWdnZXJlcjtcbiAgICAgICAgICAgICAgZXZ0LmN5ID0gZXZ0LmN5IHx8IGN5O1xuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHdlIGhhdmUgdG8gbWFrZSBvbmVcbiAgICAgICAgICAgICAgZXZ0ID0gbmV3ICQkLkV2ZW50KCBldnRPYmosIHtcbiAgICAgICAgICAgICAgICBjeVRhcmdldDogdHJpZ2dlcmVyLFxuICAgICAgICAgICAgICAgIGN5OiBjeSxcbiAgICAgICAgICAgICAgICBuYW1lc3BhY2U6IGV2dE9iai5uYW1lc3BhY2VcbiAgICAgICAgICAgICAgfSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBhIGxheW91dCB3YXMgc3BlY2lmaWVkLCB0aGVuIHB1dCBpdCBpbiB0aGUgdHlwZWQgZXZlbnRcbiAgICAgICAgICAgIGlmKCBldnRPYmoubGF5b3V0ICl7XG4gICAgICAgICAgICAgIGV2dC5sYXlvdXQgPSBldnRPYmoubGF5b3V0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB0cmlnZ2VyZWQgYnkgbGF5b3V0LCBwdXQgaW4gZXZlbnRcbiAgICAgICAgICAgIGlmKCBwYXJhbXMubGF5b3V0ICl7XG4gICAgICAgICAgICAgIGV2dC5sYXlvdXQgPSB0cmlnZ2VyZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHJlbmRlcmVkIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBwYXNzZWQgcG9zaXRpb25cbiAgICAgICAgICAgIGlmKCBldnQuY3lQb3NpdGlvbiApe1xuICAgICAgICAgICAgICB2YXIgcG9zID0gZXZ0LmN5UG9zaXRpb247XG4gICAgICAgICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG5cbiAgICAgICAgICAgICAgZXZ0LmN5UmVuZGVyZWRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBwb3MueCAqIHpvb20gKyBwYW4ueCxcbiAgICAgICAgICAgICAgICB5OiBwb3MueSAqIHpvb20gKyBwYW4ueVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggZm5Ub1RyaWdnZXIgKXsgLy8gdGhlbiBvdmVycmlkZSB0aGUgbGlzdGVuZXJzIGxpc3Qgd2l0aCBqdXN0IHRoZSBvbmUgd2Ugc3BlY2lmaWVkXG4gICAgICAgICAgICAgIGxpc3RlbmVycyA9IFt7XG4gICAgICAgICAgICAgICAgbmFtZXNwYWNlOiBldnQubmFtZXNwYWNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IGV2dC50eXBlLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBmblRvVHJpZ2dlclxuICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBsaXN0ZW5lcnMubGVuZ3RoOyBrKysgKXsgLy8gY2hlY2sgZWFjaCBsaXN0ZW5lclxuICAgICAgICAgICAgICB2YXIgbGlzID0gbGlzdGVuZXJzW2tdO1xuICAgICAgICAgICAgICB2YXIgbnNNYXRjaGVzID0gIWxpcy5uYW1lc3BhY2UgfHwgbGlzLm5hbWVzcGFjZSA9PT0gZXZ0Lm5hbWVzcGFjZTtcbiAgICAgICAgICAgICAgdmFyIHR5cGVNYXRjaGVzID0gbGlzLnR5cGUgPT09IGV2dC50eXBlO1xuICAgICAgICAgICAgICB2YXIgdGFyZ2V0TWF0Y2hlcyA9IGxpcy5kZWxlZ2F0ZWQgPyAoIHRyaWdnZXJlciAhPT0gZXZ0LmN5VGFyZ2V0ICYmICQkLmlzLmVsZW1lbnQoZXZ0LmN5VGFyZ2V0KSAmJiBsaXMuc2VsT2JqLm1hdGNoZXMoZXZ0LmN5VGFyZ2V0KSApIDogKHRydWUpOyAvLyB3ZSdyZSBub3QgZ29pbmcgdG8gdmFsaWRhdGUgdGhlIGhpZXJhcmNoeTsgdGhhdCdzIHRvbyBleHBlbnNpdmVcbiAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyTWF0Y2hlcyA9IG5zTWF0Y2hlcyAmJiB0eXBlTWF0Y2hlcyAmJiB0YXJnZXRNYXRjaGVzO1xuXG4gICAgICAgICAgICAgIGlmKCBsaXN0ZW5lck1hdGNoZXMgKXsgLy8gdGhlbiB0cmlnZ2VyIGl0XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbIGV2dCBdO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdCggZXh0cmFQYXJhbXMgKTsgLy8gYWRkIGV4dHJhIHBhcmFtcyB0byBhcmdzIGxpc3RcblxuICAgICAgICAgICAgICAgIGlmKCBsaXMuZGF0YSApeyAvLyBhZGQgb24gZGF0YSBwbHVnZ2VkIGludG8gYmluZGluZ1xuICAgICAgICAgICAgICAgICAgZXZ0LmRhdGEgPSBsaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBvciBjbGVhciBpdCBpbiBjYXNlIHRoZSBldmVudCBvYmogaXMgcmV1c2VkXG4gICAgICAgICAgICAgICAgICBldnQuZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiggbGlzLnVuYmluZFNlbGZPblRyaWdnZXIgfHwgbGlzLnVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXIgKXsgLy8gdGhlbiByZW1vdmUgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaywgMSk7XG4gICAgICAgICAgICAgICAgICBrLS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIGxpcy51bmJpbmRBbGxCaW5kZXJzT25UcmlnZ2VyICl7IC8vIHRoZW4gZGVsZXRlIHRoZSBsaXN0ZW5lciBmb3IgYWxsIGJpbmRlcnNcbiAgICAgICAgICAgICAgICAgIHZhciBiaW5kZXJzID0gbGlzLmJpbmRlcnM7XG4gICAgICAgICAgICAgICAgICBmb3IoIHZhciBsID0gMDsgbCA8IGJpbmRlcnMubGVuZ3RoOyBsKysgKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlciA9IGJpbmRlcnNbbF07XG4gICAgICAgICAgICAgICAgICAgIGlmKCAhYmluZGVyIHx8IGJpbmRlciA9PT0gdHJpZ2dlcmVyICl7IGNvbnRpbnVlOyB9IC8vIGFscmVhZHkgaGFuZGxlZCB0cmlnZ2VyZXIgb3Igd2UgY2FuJ3QgaGFuZGxlIGl0XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlckxpc3RlbmVycyA9IGJpbmRlci5fcHJpdmF0ZS5saXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICAgIGZvciggdmFyIG0gPSAwOyBtIDwgYmluZGVyTGlzdGVuZXJzLmxlbmd0aDsgbSsrICl7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGJpbmRlckxpc3RlbmVyID0gYmluZGVyTGlzdGVuZXJzW21dO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYoIGJpbmRlckxpc3RlbmVyID09PSBsaXMgKXsgLy8gZGVsZXRlIGxpc3RlbmVyIGZyb20gbGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgYmluZGVyTGlzdGVuZXJzLnNwbGljZShtLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0tLTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBydW4gdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBsaXMuZGVsZWdhdGVkID8gZXZ0LmN5VGFyZ2V0IDogdHJpZ2dlcmVyO1xuICAgICAgICAgICAgICAgIHZhciByZXQgPSBsaXMuY2FsbGJhY2suYXBwbHkoIGNvbnRleHQsIGFyZ3MgKTtcblxuICAgICAgICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlIHx8IGV2dC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICl7XG4gICAgICAgICAgICAgICAgICAvLyB0aGVuIGRvbid0IGJ1YmJsZVxuICAgICAgICAgICAgICAgICAgYnViYmxlVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0dXJuaW5nIGZhbHNlIGlzIGEgc2hvcnRoYW5kIGZvciBzdG9wcGluZyBwcm9wYWdhdGlvbiBhbmQgcHJldmVudGluZyB0aGUgZGVmLiBhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gaWYgbGlzdGVuZXIgbWF0Y2hlc1xuICAgICAgICAgICAgfSAvLyBmb3IgZWFjaCBsaXN0ZW5lclxuXG4gICAgICAgICAgICAvLyBidWJibGUgdXAgZXZlbnQgZm9yIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiggYnViYmxlVXAgKXtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGhhc0NvbXBvdW5kcyA/IHRyaWdnZXJlci5fcHJpdmF0ZS5wYXJlbnQgOiBudWxsO1xuICAgICAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICE9IG51bGwgJiYgcGFyZW50Lmxlbmd0aCAhPT0gMDtcblxuICAgICAgICAgICAgICBpZiggaGFzUGFyZW50ICl7IC8vIHRoZW4gYnViYmxlIHVwIHRvIHBhcmVudFxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgICAgICAgICBwYXJlbnQudHJpZ2dlcihldnQpO1xuICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2UsIGJ1YmJsZSB1cCB0byB0aGUgY29yZVxuICAgICAgICAgICAgICAgIGN5LnRyaWdnZXIoZXZ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSAvLyBmb3IgZWFjaCBvZiBhbGxcbiAgICAgICAgfSAvLyBmb3IgZWFjaCBldmVudFxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG1haW50YWluIGNoYWluaW5nXG4gICAgICB9OyAvLyBmdW5jdGlvblxuICAgIH0sIC8vIHRyaWdnZXJcblxuXG4gICAgYW5pbWF0ZWQ6IGZ1bmN0aW9uKCBmblBhcmFtcyApe1xuICAgICAgdmFyIGRlZmF1bHRzID0ge307XG4gICAgICBmblBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgZm5QYXJhbXMpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gYW5pbWF0ZWRJbXBsKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgdmFyIGVsZSA9IGFsbFswXTtcblxuICAgICAgICBpZiggZWxlICl7XG4gICAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24uY3VycmVudC5sZW5ndGggPiAwO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sIC8vIGFuaW1hdGVkXG5cbiAgICBjbGVhclF1ZXVlOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgZm5QYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGZuUGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNsZWFyUXVldWVJbXBsKCl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgICAgZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5xdWV1ZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0sIC8vIGNsZWFyUXVldWVcblxuICAgIGRlbGF5OiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgZm5QYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGZuUGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlbGF5SW1wbCggdGltZSwgY29tcGxldGUgKXtcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgICB0aGlzLmFuaW1hdGUoe1xuICAgICAgICAgIGRlbGF5OiB0aW1lXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogdGltZSxcbiAgICAgICAgICBjb21wbGV0ZTogY29tcGxldGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9O1xuICAgIH0sIC8vIGRlbGF5XG5cbiAgICBhbmltYXRlOiBmdW5jdGlvbiggZm5QYXJhbXMgKXtcbiAgICAgIHZhciBkZWZhdWx0cyA9IHt9O1xuICAgICAgZm5QYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGZuUGFyYW1zKTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFuaW1hdGVJbXBsKCBwcm9wZXJ0aWVzLCBwYXJhbXMgKXtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZklzQXJyYXlMaWtlID0gc2VsZi5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFsbCA9IHNlbGZJc0FycmF5TGlrZSA/IHNlbGYgOiBbc2VsZl07IC8vIHB1dCBpbiBhcnJheSBpZiBub3QgYXJyYXktbGlrZVxuICAgICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5IHx8IHRoaXM7XG4gICAgICAgIHZhciBpc0NvcmUgPSAhc2VsZklzQXJyYXlMaWtlO1xuICAgICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcblxuICAgICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgICAgdmFyIGNhbGxUaW1lID0gK25ldyBEYXRlKCk7XG4gICAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgICAgIHZhciBxO1xuICAgICAgICBcbiAgICAgICAgaWYoIHBhcmFtcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiggcGFyYW1zLmR1cmF0aW9uID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBwYXJhbXMuZHVyYXRpb24gPSA0MDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN3aXRjaCggcGFyYW1zLmR1cmF0aW9uICl7XG4gICAgICAgIGNhc2UgJ3Nsb3cnOlxuICAgICAgICAgIHBhcmFtcy5kdXJhdGlvbiA9IDYwMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZmFzdCc6XG4gICAgICAgICAgcGFyYW1zLmR1cmF0aW9uID0gMjAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgcHJvcGVydGllc0VtcHR5ID0gdHJ1ZTtcbiAgICAgICAgaWYoIHByb3BlcnRpZXMgKXsgZm9yKCB2YXIgaSBpbiBwcm9wZXJ0aWVzICl7XG4gICAgICAgICAgcHJvcGVydGllc0VtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gfVxuXG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzRW1wdHkgKXtcbiAgICAgICAgICByZXR1cm4gdGhpczsgLy8gbm90aGluZyB0byBhbmltYXRlXG4gICAgICAgIH1cblxuICAgICAgICBpZiggcHJvcGVydGllcy5jc3MgJiYgaXNFbGVzICl7XG4gICAgICAgICAgcHJvcGVydGllcy5jc3MgPSBzdHlsZS5nZXRWYWx1ZVN0eWxlKCBwcm9wZXJ0aWVzLmNzcywgeyBhcnJheTogdHJ1ZSB9ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uICYmIGlzRWxlcyApe1xuICAgICAgICAgIHZhciBycG9zID0gcHJvcGVydGllcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgICAgICB2YXIgem9vbSA9IGN5Lnpvb20oKTtcblxuICAgICAgICAgIHByb3BlcnRpZXMucG9zaXRpb24gPSB7XG4gICAgICAgICAgICB4OiAoIHJwb3MueCAtIHBhbi54ICkgL3pvb20sXG4gICAgICAgICAgICB5OiAoIHJwb3MueSAtIHBhbi55ICkgL3pvb21cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3ZlcnJpZGUgcGFuIHcvIHBhbkJ5IGlmIHNldFxuICAgICAgICBpZiggcHJvcGVydGllcy5wYW5CeSAmJiBpc0NvcmUgKXtcbiAgICAgICAgICB2YXIgcGFuQnkgPSBwcm9wZXJ0aWVzLnBhbkJ5O1xuICAgICAgICAgIHZhciBjeVBhbiA9IGN5LnBhbigpO1xuXG4gICAgICAgICAgcHJvcGVydGllcy5wYW4gPSB7XG4gICAgICAgICAgICB4OiBjeVBhbi54ICsgcGFuQnkueCxcbiAgICAgICAgICAgIHk6IGN5UGFuLnkgKyBwYW5CeS55XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG92ZXJyaWRlIHBhbiB3LyBjZW50ZXIgaWYgc2V0XG4gICAgICAgIHZhciBjZW50ZXIgPSBwcm9wZXJ0aWVzLmNlbnRlciB8fCBwcm9wZXJ0aWVzLmNlbnRyZTtcbiAgICAgICAgaWYoIGNlbnRlciAmJiBpc0NvcmUgKXtcbiAgICAgICAgICB2YXIgY2VudGVyUGFuID0gY3kuZ2V0Q2VudGVyUGFuKCBjZW50ZXIuZWxlcywgcHJvcGVydGllcy56b29tICk7XG5cbiAgICAgICAgICBpZiggY2VudGVyUGFuICl7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGNlbnRlclBhbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBvdmVycmlkZSBwYW4gJiB6b29tIHcvIGZpdCBpZiBzZXRcbiAgICAgICAgaWYoIHByb3BlcnRpZXMuZml0ICYmIGlzQ29yZSApe1xuICAgICAgICAgIHZhciBmaXQgPSBwcm9wZXJ0aWVzLmZpdDtcbiAgICAgICAgICB2YXIgZml0VnAgPSBjeS5nZXRGaXRWaWV3cG9ydCggZml0LmVsZXMgfHwgZml0LmJvdW5kaW5nQm94LCBmaXQucGFkZGluZyApO1xuXG4gICAgICAgICAgaWYoIGZpdFZwICl7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnBhbiA9IGZpdFZwLnBhbjsgLy97IHg6IGZpdFZwLnBhbi54LCB5OiBmaXRWcC5wYW4ueSB9O1xuICAgICAgICAgICAgcHJvcGVydGllcy56b29tID0gZml0VnAuem9vbTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgICBcbiAgICAgICAgICBpZiggZWxlLmFuaW1hdGVkKCkgJiYgKHBhcmFtcy5xdWV1ZSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcy5xdWV1ZSkgKXtcbiAgICAgICAgICAgIHEgPSBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLnF1ZXVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBxID0gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHEucHVzaCh7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICAgICAgZHVyYXRpb246IHBhcmFtcy5kdXJhdGlvbixcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgY2FsbFRpbWU6IGNhbGxUaW1lXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaXNFbGVzICl7XG4gICAgICAgICAgY3kuYWRkVG9BbmltYXRpb25Qb29sKCB0aGlzICk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICAgIH07XG4gICAgfSwgLy8gYW5pbWF0ZVxuXG4gICAgc3RvcDogZnVuY3Rpb24oIGZuUGFyYW1zICl7XG4gICAgICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgICAgIGZuUGFyYW1zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBmblBhcmFtcyk7XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiBzdG9wSW1wbCggY2xlYXJRdWV1ZSwganVtcFRvRW5kICl7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHNlbGZJc0FycmF5TGlrZSA9IHNlbGYubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBhbGwgPSBzZWxmSXNBcnJheUxpa2UgPyBzZWxmIDogW3NlbGZdOyAvLyBwdXQgaW4gYXJyYXkgaWYgbm90IGFycmF5LWxpa2VcbiAgICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeSB8fCB0aGlzO1xuXG4gICAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGFsbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBhbGxbaV07XG4gICAgICAgICAgdmFyIGFuaXMgPSBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQ7XG5cbiAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGFuaXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBhbmlzW2pdOyAgICBcbiAgICAgICAgICAgIGlmKCBqdW1wVG9FbmQgKXtcbiAgICAgICAgICAgICAgLy8gbmV4dCBpdGVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbiBsb29wLCB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgIC8vIHdpbGwgZ28gc3RyYWlnaHQgdG8gdGhlIGVuZCBhbmQgYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICBhbmltYXRpb24uZHVyYXRpb24gPSAwOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gY2xlYXIgdGhlIHF1ZXVlIG9mIGZ1dHVyZSBhbmltYXRpb25zXG4gICAgICAgICAgaWYoIGNsZWFyUXVldWUgKXtcbiAgICAgICAgICAgIGVsZS5fcHJpdmF0ZS5hbmltYXRpb24ucXVldWUgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIWp1bXBUb0VuZCApe1xuICAgICAgICAgICAgZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5jdXJyZW50ID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIG5vdGlmeSAodGhlIGFuaW1hdGlvbiBsb29wIGRvZXNuJ3QgZG8gaXQgZm9yIHVzIG9uIGBzdG9wYClcbiAgICAgICAgY3kubm90aWZ5KHtcbiAgICAgICAgICBjb2xsZWN0aW9uOiB0aGlzLFxuICAgICAgICAgIHR5cGU6ICdkcmF3J1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfTtcbiAgICB9IC8vIHN0b3BcblxuICB9OyAvLyBkZWZpbmVcblxuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5zZWxlY3RvciA9IGZ1bmN0aW9uKG1hcCwgb3B0aW9ucyl7XG4gICAgZm9yKCB2YXIgbmFtZSBpbiBtYXAgKXtcbiAgICAgIHZhciBmbiA9IG1hcFtuYW1lXTtcbiAgICAgICQkLlNlbGVjdG9yLnByb3RvdHlwZVsgbmFtZSBdID0gZm47XG4gICAgfVxuICB9O1xuXG4gICQkLlNlbGVjdG9yID0gZnVuY3Rpb24ob25seVRoaXNHcm91cCwgc2VsZWN0b3Ipe1xuICAgIFxuICAgIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiAkJC5TZWxlY3RvcikgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuU2VsZWN0b3Iob25seVRoaXNHcm91cCwgc2VsZWN0b3IpO1xuICAgIH1cbiAgXG4gICAgaWYoIHNlbGVjdG9yID09PSB1bmRlZmluZWQgJiYgb25seVRoaXNHcm91cCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICBzZWxlY3RvciA9IG9ubHlUaGlzR3JvdXA7XG4gICAgICBvbmx5VGhpc0dyb3VwID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXG4gICAgc2VsZi5fcHJpdmF0ZSA9IHtcbiAgICAgIHNlbGVjdG9yVGV4dDogbnVsbCxcbiAgICAgIGludmFsaWQ6IHRydWVcbiAgICB9O1xuICAgIFxuICAgIGlmKCAhc2VsZWN0b3IgfHwgKCAkJC5pcy5zdHJpbmcoc2VsZWN0b3IpICYmIHNlbGVjdG9yLm1hdGNoKC9eXFxzKiQvKSApICl7XG4gICAgICBcbiAgICAgIGlmKCBvbmx5VGhpc0dyb3VwID09IG51bGwgKXtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIHNlbGYubGVuZ3RoID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgICAgICBzZWxmWzBdLmdyb3VwID0gb25seVRoaXNHcm91cDtcbiAgICAgICAgc2VsZi5sZW5ndGggPSAxO1xuICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICB9IGVsc2UgaWYoICQkLmlzLmVsZW1lbnQoIHNlbGVjdG9yICkgKXtcbiAgICAgIHZhciBjb2xsZWN0aW9uID0gbmV3ICQkLkNvbGxlY3Rpb24oc2VsZi5jeSgpLCBbIHNlbGVjdG9yIF0pO1xuICAgICAgXG4gICAgICBzZWxmWzBdID0gbmV3UXVlcnkoKTtcbiAgICAgIHNlbGZbMF0uY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICBzZWxmLmxlbmd0aCA9IDE7XG4gICAgICBcbiAgICB9IGVsc2UgaWYoICQkLmlzLmNvbGxlY3Rpb24oIHNlbGVjdG9yICkgKXtcbiAgICAgIHNlbGZbMF0gPSBuZXdRdWVyeSgpO1xuICAgICAgc2VsZlswXS5jb2xsZWN0aW9uID0gc2VsZWN0b3I7XG4gICAgICBzZWxmLmxlbmd0aCA9IDE7XG4gICAgICBcbiAgICB9IGVsc2UgaWYoICQkLmlzLmZuKCBzZWxlY3RvciApICkge1xuICAgICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7XG4gICAgICBzZWxmWzBdLmZpbHRlciA9IHNlbGVjdG9yO1xuICAgICAgc2VsZi5sZW5ndGggPSAxO1xuICAgICAgXG4gICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcoIHNlbGVjdG9yICkgKXtcblxuICAgICAgLy8gdGhlIGN1cnJlbnQgc3ViamVjdCBpbiB0aGUgcXVlcnlcbiAgICAgIHZhciBjdXJyZW50U3ViamVjdCA9IG51bGw7XG4gICAgICBcbiAgICAgIC8vIHN0b3JhZ2UgZm9yIHBhcnNlZCBxdWVyaWVzXG4gICAgICB2YXIgbmV3UXVlcnkgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNsYXNzZXM6IFtdLCBcbiAgICAgICAgICBjb2xvblNlbGVjdG9yczogW10sXG4gICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgZ3JvdXA6IG51bGwsXG4gICAgICAgICAgaWRzOiBbXSxcbiAgICAgICAgICBtZXRhOiBbXSxcblxuICAgICAgICAgIC8vIGZha2Ugc2VsZWN0b3JzXG4gICAgICAgICAgY29sbGVjdGlvbjogbnVsbCwgLy8gYSBjb2xsZWN0aW9uIHRvIG1hdGNoIGFnYWluc3RcbiAgICAgICAgICBmaWx0ZXI6IG51bGwsIC8vIGZpbHRlciBmdW5jdGlvblxuXG4gICAgICAgICAgLy8gdGhlc2UgYXJlIGRlZmluZWQgaW4gdGhlIHVwd2FyZCBkaXJlY3Rpb24gcmF0aGVyIHRoYW4gZG93biAoZS5nLiBjaGlsZClcbiAgICAgICAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gZ28gdXAgaW4gU2VsZWN0b3IuZmlsdGVyKClcbiAgICAgICAgICBwYXJlbnQ6IG51bGwsIC8vIHBhcmVudCBxdWVyeSBvYmpcbiAgICAgICAgICBhbmNlc3RvcjogbnVsbCwgLy8gYW5jZXN0b3IgcXVlcnkgb2JqXG4gICAgICAgICAgc3ViamVjdDogbnVsbCwgLy8gZGVmaW5lcyBzdWJqZWN0IGluIGNvbXBvdW5kIHF1ZXJ5IChzdWJqZWN0IHF1ZXJ5IG9iajsgcG9pbnRzIHRvIHNlbGYgaWYgc3ViamVjdClcblxuICAgICAgICAgIC8vIHVzZSB0aGVzZSBvbmx5IHdoZW4gc3ViamVjdCBoYXMgYmVlbiBkZWZpbmVkXG4gICAgICAgICAgY2hpbGQ6IG51bGwsXG4gICAgICAgICAgZGVzY2VuZGFudDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgLy8gdG9rZW5zIGluIHRoZSBxdWVyeSBsYW5ndWFnZVxuICAgICAgdmFyIHRva2VucyA9IHtcbiAgICAgICAgbWV0YUNoYXI6ICdbXFxcXCFcXFxcXCJcXFxcI1xcXFwkXFxcXCVcXFxcJlxcXFxcXCdcXFxcKFxcXFwpXFxcXCpcXFxcK1xcXFwsXFxcXC5cXFxcL1xcXFw6XFxcXDtcXFxcPFxcXFw9XFxcXD5cXFxcP1xcXFxAXFxcXFtcXFxcXVxcXFxeXFxcXGBcXFxce1xcXFx8XFxcXH1cXFxcfl0nLCAvLyBjaGFycyB3ZSBuZWVkIHRvIGVzY2FwZSBpbiB2YXIgbmFtZXMsIGV0Y1xuICAgICAgICBjb21wYXJhdG9yT3A6ICc9fFxcXFwhPXw+fD49fDx8PD18XFxcXCQ9fFxcXFxePXxcXFxcKj0nLCAvLyBiaW5hcnkgY29tcGFyaXNvbiBvcCAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycylcbiAgICAgICAgYm9vbE9wOiAnXFxcXD98XFxcXCF8XFxcXF4nLCAvLyBib29sZWFuICh1bmFyeSkgb3BlcmF0b3JzICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKVxuICAgICAgICBzdHJpbmc6ICdcIig/OlxcXFxcXFxcXCJ8W15cIl0pK1wiJyArICd8JyArIFwiJyg/OlxcXFxcXFxcJ3xbXiddKSsnXCIsIC8vIHN0cmluZyBsaXRlcmFscyAodXNlZCBpbiBkYXRhIHNlbGVjdG9ycykgLS0gZG91YmxlcXVvdGVzIHwgc2luZ2xlcXVvdGVzXG4gICAgICAgIG51bWJlcjogJCQudXRpbC5yZWdleC5udW1iZXIsIC8vIG51bWJlciBsaXRlcmFsICh1c2VkIGluIGRhdGEgc2VsZWN0b3JzKSAtLS0gZS5nLiAwLjEyMzQsIDEyMzQsIDEyZTEyM1xuICAgICAgICBtZXRhOiAnZGVncmVlfGluZGVncmVlfG91dGRlZ3JlZScsIC8vIGFsbG93ZWQgbWV0YWRhdGEgZmllbGRzIChpLmUuIGFsbG93ZWQgZnVuY3Rpb25zIHRvIHVzZSBmcm9tICQkLkNvbGxlY3Rpb24pXG4gICAgICAgIHNlcGFyYXRvcjogJ1xcXFxzKixcXFxccyonLCAvLyBxdWVyaWVzIGFyZSBzZXBhcmF0ZWQgYnkgY29tbWFzLCBlLmcuIGVkZ2VbZm9vID0gJ2JhciddLCBub2RlLnNvbWVDbGFzc1xuICAgICAgICBkZXNjZW5kYW50OiAnXFxcXHMrJyxcbiAgICAgICAgY2hpbGQ6ICdcXFxccys+XFxcXHMrJyxcbiAgICAgICAgc3ViamVjdDogJ1xcXFwkJ1xuICAgICAgfTtcbiAgICAgIHRva2Vucy52YXJpYWJsZSA9ICcoPzpbXFxcXHctXXwoPzpcXFxcXFxcXCcrIHRva2Vucy5tZXRhQ2hhciArJykpKyc7IC8vIGEgdmFyaWFibGUgbmFtZVxuICAgICAgdG9rZW5zLnZhbHVlID0gdG9rZW5zLnN0cmluZyArICd8JyArIHRva2Vucy5udW1iZXI7IC8vIGEgdmFsdWUgbGl0ZXJhbCwgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlclxuICAgICAgdG9rZW5zLmNsYXNzTmFtZSA9IHRva2Vucy52YXJpYWJsZTsgLy8gYSBjbGFzcyBuYW1lIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuICAgICAgdG9rZW5zLmlkID0gdG9rZW5zLnZhcmlhYmxlOyAvLyBhbiBlbGVtZW50IGlkIChmb2xsb3dzIHZhcmlhYmxlIGNvbnZlbnRpb25zKVxuXG4gICAgICAvLyB3aGVuIGEgdG9rZW4gbGlrZSBhIHZhcmlhYmxlIGhhcyBlc2NhcGVkIG1ldGEgY2hhcmFjdGVycywgd2UgbmVlZCB0byBjbGVhbiB0aGUgYmFja3NsYXNoZXMgb3V0XG4gICAgICAvLyBzbyB0aGF0IHZhbHVlcyBnZXQgY29tcGFyZWQgcHJvcGVybHkgaW4gU2VsZWN0b3IuZmlsdGVyKClcbiAgICAgIHZhciBjbGVhbk1ldGFDaGFycyA9IGZ1bmN0aW9uKHN0cil7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcXFxcXCgnICsgdG9rZW5zLm1ldGFDaGFyICsgJyknLCAnZycpLCBmdW5jdGlvbihtYXRjaCwgJDEsIG9mZnNldCwgb3JpZ2luYWwpe1xuICAgICAgICAgIHJldHVybiAkMTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICAvLyBhZGQgQCB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcbiAgICAgIHZhciBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgb3AgPSBvcHNbaV07XG4gICAgICAgIHRva2Vucy5jb21wYXJhdG9yT3AgKz0gJ3xAJyArIG9wO1xuICAgICAgfVxuXG4gICAgICAvLyBhZGQgISB2YXJpYW50cyB0byBjb21wYXJhdG9yT3BcbiAgICAgIHZhciBvcHMgPSB0b2tlbnMuY29tcGFyYXRvck9wLnNwbGl0KCd8Jyk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgb3AgPSBvcHNbaV07XG5cbiAgICAgICAgaWYoIG9wLmluZGV4T2YoJyEnKSA+PSAwICl7IGNvbnRpbnVlOyB9IC8vIHNraXAgb3BzIHRoYXQgZXhwbGljaXRseSBjb250YWluICFcbiAgICAgICAgaWYoIG9wID09PSAnPScgKXsgY29udGludWU7IH0gLy8gc2tpcCA9IGIvYyAhPSBpcyBleHBsaWNpdGx5IGRlZmluZWRcblxuICAgICAgICB0b2tlbnMuY29tcGFyYXRvck9wICs9ICd8XFxcXCEnICsgb3A7XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEU6IGFkZCBuZXcgZXhwcmVzc2lvbiBzeW50YXggaGVyZSB0byBoYXZlIGl0IHJlY29nbmlzZWQgYnkgdGhlIHBhcnNlcjtcbiAgICAgIC8vIC0gYSBxdWVyeSBjb250YWlucyBhbGwgYWRqYWNlbnQgKGkuZS4gbm8gc2VwYXJhdG9yIGluIGJldHdlZW4pIGV4cHJlc3Npb25zO1xuICAgICAgLy8gLSB0aGUgY3VycmVudCBxdWVyeSBpcyBzdG9yZWQgaW4gc2VsZltpXSAtLS0geW91IGNhbiB1c2UgdGhlIHJlZmVyZW5jZSB0byBgdGhpc2AgaW4gdGhlIHBvcHVsYXRlIGZ1bmN0aW9uO1xuICAgICAgLy8gLSB5b3UgbmVlZCB0byBjaGVjayB0aGUgcXVlcnkgb2JqZWN0cyBpbiBTZWxlY3Rvci5maWx0ZXIoKSBmb3IgaXQgYWN0dWFsbHkgZmlsdGVyIHByb3Blcmx5LCBidXQgdGhhdCdzIHByZXR0eSBzdHJhaWdodCBmb3J3YXJkXG4gICAgICAvLyAtIHdoZW4geW91IGFkZCBzb21ldGhpbmcgaGVyZSwgYWxzbyBhZGQgdG8gU2VsZWN0b3IudG9TdHJpbmcoKVxuICAgICAgdmFyIGV4cHJzID0ge1xuICAgICAgICBncm91cDoge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnKG5vZGV8ZWRnZXxcXFxcKiknLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggZ3JvdXAgKXtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSBncm91cCA9PSBcIipcIiA/IGdyb3VwIDogZ3JvdXAgKyAncyc7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICAvLyBOQjogaWYgb25lIGNvbG9uIHNlbGVjdG9yIGlzIGEgc3Vic3RyaW5nIG9mIGFub3RoZXIgZnJvbSBpdHMgc3RhcnQsIHBsYWNlIHRoZSBsb25nZXIgb25lIGZpcnN0XG4gICAgICAgICAgLy8gZS5nLiA6Zm9vYmFyfDpmb29cbiAgICAgICAgICByZWdleDogJyg6c2VsZWN0ZWR8OnVuc2VsZWN0ZWR8OmxvY2tlZHw6dW5sb2NrZWR8OnZpc2libGV8OmhpZGRlbnw6dHJhbnNwYXJlbnR8OmdyYWJiZWR8OmZyZWV8OnJlbW92ZWR8Omluc2lkZXw6Z3JhYmJhYmxlfDp1bmdyYWJiYWJsZXw6YW5pbWF0ZWR8OnVuYW5pbWF0ZWR8OnNlbGVjdGFibGV8OnVuc2VsZWN0YWJsZXw6b3JwaGFufDpub25vcnBoYW58OnBhcmVudHw6Y2hpbGR8Omxvb3B8OnNpbXBsZXw6YWN0aXZlfDppbmFjdGl2ZXw6dG91Y2h8OmJhY2tncm91bmRpbmd8Om5vbmJhY2tncm91bmRpbmcpJyxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oIHN0YXRlICl7XG4gICAgICAgICAgICB0aGlzLmNvbG9uU2VsZWN0b3JzLnB1c2goIHN0YXRlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICByZWdleDogJ1xcXFwjKCcrIHRva2Vucy5pZCArJyknLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggaWQgKXtcbiAgICAgICAgICAgIHRoaXMuaWRzLnB1c2goIGNsZWFuTWV0YUNoYXJzKGlkKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGNsYXNzTmFtZToge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnXFxcXC4oJysgdG9rZW5zLmNsYXNzTmFtZSArJyknLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggY2xhc3NOYW1lICl7XG4gICAgICAgICAgICB0aGlzLmNsYXNzZXMucHVzaCggY2xlYW5NZXRhQ2hhcnMoY2xhc3NOYW1lKSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIGRhdGFFeGlzdHM6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcrIHRva2Vucy52YXJpYWJsZSArJylcXFxccypcXFxcXScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCB2YXJpYWJsZSApe1xuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2goe1xuICAgICAgICAgICAgICBmaWVsZDogY2xlYW5NZXRhQ2hhcnModmFyaWFibGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICBkYXRhQ29tcGFyZToge1xuICAgICAgICAgIHF1ZXJ5OiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiAnXFxcXFtcXFxccyooJysgdG9rZW5zLnZhcmlhYmxlICsnKVxcXFxzKignKyB0b2tlbnMuY29tcGFyYXRvck9wICsnKVxcXFxzKignKyB0b2tlbnMudmFsdWUgKycpXFxcXHMqXFxcXF0nLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggdmFyaWFibGUsIGNvbXBhcmF0b3JPcCwgdmFsdWUgKXsgXG4gICAgICAgICAgICB2YXIgdmFsdWVJc1N0cmluZyA9IG5ldyBSZWdFeHAoJ14nICsgdG9rZW5zLnN0cmluZyArICckJykuZXhlYyh2YWx1ZSkgIT0gbnVsbDtcblxuICAgICAgICAgICAgaWYoIHZhbHVlSXNTdHJpbmcgKXtcbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSwgdmFsdWUubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XG4gICAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSksXG4gICAgICAgICAgICAgIG9wZXJhdG9yOiBjb21wYXJhdG9yT3AsXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgZGF0YUJvb2w6IHtcbiAgICAgICAgICBxdWVyeTogdHJ1ZSxcbiAgICAgICAgICByZWdleDogJ1xcXFxbXFxcXHMqKCcrIHRva2Vucy5ib29sT3AgKycpXFxcXHMqKCcrIHRva2Vucy52YXJpYWJsZSArJylcXFxccypcXFxcXScsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCBib29sT3AsIHZhcmlhYmxlICl7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XG4gICAgICAgICAgICAgIGZpZWxkOiBjbGVhbk1ldGFDaGFycyh2YXJpYWJsZSksXG4gICAgICAgICAgICAgIG9wZXJhdG9yOiBib29sT3BcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIG1ldGFDb21wYXJlOiB7XG4gICAgICAgICAgcXVlcnk6IHRydWUsXG4gICAgICAgICAgcmVnZXg6ICdcXFxcW1xcXFxbXFxcXHMqKCcrIHRva2Vucy5tZXRhICsnKVxcXFxzKignKyB0b2tlbnMuY29tcGFyYXRvck9wICsnKVxcXFxzKignKyB0b2tlbnMubnVtYmVyICsnKVxcXFxzKlxcXFxdXFxcXF0nLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbiggbWV0YSwgY29tcGFyYXRvck9wLCBudW1iZXIgKXtcbiAgICAgICAgICAgIHRoaXMubWV0YS5wdXNoKHtcbiAgICAgICAgICAgICAgZmllbGQ6IGNsZWFuTWV0YUNoYXJzKG1ldGEpLFxuICAgICAgICAgICAgICBvcGVyYXRvcjogY29tcGFyYXRvck9wLFxuICAgICAgICAgICAgICB2YWx1ZTogcGFyc2VGbG9hdChudW1iZXIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmV4dFF1ZXJ5OiB7XG4gICAgICAgICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiB0b2tlbnMuc2VwYXJhdG9yLFxuICAgICAgICAgIHBvcHVsYXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gZ28gb24gdG8gbmV4dCBxdWVyeVxuICAgICAgICAgICAgc2VsZlsrK2ldID0gbmV3UXVlcnkoKTtcbiAgICAgICAgICAgIGN1cnJlbnRTdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2hpbGQ6IHtcbiAgICAgICAgICBzZXBhcmF0b3I6IHRydWUsXG4gICAgICAgICAgcmVnZXg6IHRva2Vucy5jaGlsZCxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vIHRoaXMgcXVlcnkgaXMgdGhlIHBhcmVudCBvZiB0aGUgZm9sbG93aW5nIHF1ZXJ5XG4gICAgICAgICAgICB2YXIgY2hpbGRRdWVyeSA9IG5ld1F1ZXJ5KCk7XG4gICAgICAgICAgICBjaGlsZFF1ZXJ5LnBhcmVudCA9IHRoaXM7XG4gICAgICAgICAgICBjaGlsZFF1ZXJ5LnN1YmplY3QgPSBjdXJyZW50U3ViamVjdDtcblxuICAgICAgICAgICAgLy8gd2UncmUgbm93IHBvcHVsYXRpbmcgdGhlIGNoaWxkIHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgICAgICAgIHNlbGZbaV0gPSBjaGlsZFF1ZXJ5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBkZXNjZW5kYW50OiB7XG4gICAgICAgICAgc2VwYXJhdG9yOiB0cnVlLFxuICAgICAgICAgIHJlZ2V4OiB0b2tlbnMuZGVzY2VuZGFudCxcbiAgICAgICAgICBwb3B1bGF0ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vIHRoaXMgcXVlcnkgaXMgdGhlIGFuY2VzdG9yIG9mIHRoZSBmb2xsb3dpbmcgcXVlcnlcbiAgICAgICAgICAgIHZhciBkZXNjZW5kYW50UXVlcnkgPSBuZXdRdWVyeSgpO1xuICAgICAgICAgICAgZGVzY2VuZGFudFF1ZXJ5LmFuY2VzdG9yID0gdGhpcztcbiAgICAgICAgICAgIGRlc2NlbmRhbnRRdWVyeS5zdWJqZWN0ID0gY3VycmVudFN1YmplY3Q7XG5cbiAgICAgICAgICAgIC8vIHdlJ3JlIG5vdyBwb3B1bGF0aW5nIHRoZSBkZXNjZW5kYW50IHF1ZXJ5IHdpdGggZXhwcmVzc2lvbnMgdGhhdCBmb2xsb3dcbiAgICAgICAgICAgIHNlbGZbaV0gPSBkZXNjZW5kYW50UXVlcnk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN1YmplY3Q6IHtcbiAgICAgICAgICBtb2RpZmllcjogdHJ1ZSxcbiAgICAgICAgICByZWdleDogdG9rZW5zLnN1YmplY3QsXG4gICAgICAgICAgcG9wdWxhdGU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiggY3VycmVudFN1YmplY3QgIT0gbnVsbCAmJiB0aGlzLnN1YmplY3QgIT0gdGhpcyApe1xuICAgICAgICAgICAgICAkJC51dGlsLmVycm9yKCdSZWRlZmluaXRpb24gb2Ygc3ViamVjdCBpbiBzZWxlY3RvciBgJyArIHNlbGVjdG9yICsgJ2AnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50U3ViamVjdCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnN1YmplY3QgPSB0aGlzO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgaiA9IDA7XG4gICAgICBmb3IoIHZhciBuYW1lIGluIGV4cHJzICl7XG4gICAgICAgIGV4cHJzW2pdID0gZXhwcnNbbmFtZV07XG4gICAgICAgIGV4cHJzW2pdLm5hbWUgPSBuYW1lO1xuXG4gICAgICAgIGorKztcbiAgICAgIH1cbiAgICAgIGV4cHJzLmxlbmd0aCA9IGo7XG5cbiAgICAgIHNlbGYuX3ByaXZhdGUuc2VsZWN0b3JUZXh0ID0gc2VsZWN0b3I7XG4gICAgICB2YXIgcmVtYWluaW5nID0gc2VsZWN0b3I7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICBcbiAgICAgIC8vIG9mIGFsbCB0aGUgZXhwcmVzc2lvbnMsIGZpbmQgdGhlIGZpcnN0IG1hdGNoIGluIHRoZSByZW1haW5pbmcgdGV4dFxuICAgICAgdmFyIGNvbnN1bWVFeHByID0gZnVuY3Rpb24oIGV4cGVjdGF0aW9uICl7XG4gICAgICAgIHZhciBleHByO1xuICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgIHZhciBuYW1lO1xuICAgICAgICBcbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBleHBycy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlID0gZXhwcnNbal07XG4gICAgICAgICAgdmFyIG4gPSBlLm5hbWU7XG5cbiAgICAgICAgICAvLyBpZ25vcmUgdGhpcyBleHByZXNzaW9uIGlmIGl0IGRvZXNuJ3QgbWVldCB0aGUgZXhwZWN0YXRpb24gZnVuY3Rpb25cbiAgICAgICAgICBpZiggJCQuaXMuZm4oIGV4cGVjdGF0aW9uICkgJiYgIWV4cGVjdGF0aW9uKG4sIGUpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICB2YXIgbSA9IHJlbWFpbmluZy5tYXRjaChuZXcgUmVnRXhwKCAnXicgKyBlLnJlZ2V4ICkpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBtICE9IG51bGwgKXtcbiAgICAgICAgICAgIG1hdGNoID0gbTtcbiAgICAgICAgICAgIGV4cHIgPSBlO1xuICAgICAgICAgICAgbmFtZSA9IG47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjb25zdW1lZCA9IG1bMF07XG4gICAgICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKCBjb25zdW1lZC5sZW5ndGggKTsgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGJyZWFrOyAvLyB3ZSd2ZSBjb25zdW1lZCBvbmUgZXhwciwgc28gd2UgY2FuIHJldHVybiBub3dcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZXhwcjogZXhwcixcbiAgICAgICAgICBtYXRjaDogbWF0Y2gsXG4gICAgICAgICAgbmFtZTogbmFtZVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gY29uc3VtZSBhbGwgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICB2YXIgY29uc3VtZVdoaXRlc3BhY2UgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgbWF0Y2ggPSByZW1haW5pbmcubWF0Y2goL15cXHMrLyk7XG4gICAgICAgIFxuICAgICAgICBpZiggbWF0Y2ggKXtcbiAgICAgICAgICB2YXIgY29uc3VtZWQgPSBtYXRjaFswXTtcbiAgICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKCBjb25zdW1lZC5sZW5ndGggKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgc2VsZlswXSA9IG5ld1F1ZXJ5KCk7IC8vIGdldCBzdGFydGVkXG5cbiAgICAgIGNvbnN1bWVXaGl0ZXNwYWNlKCk7IC8vIGdldCByaWQgb2YgbGVhZGluZyB3aGl0ZXNwYWNlXG4gICAgICBmb3IoOzspeyAgICAgICAgXG4gICAgICAgIHZhciBjaGVjayA9IGNvbnN1bWVFeHByKCk7XG4gICAgICAgIFxuICAgICAgICBpZiggY2hlY2suZXhwciA9PSBudWxsICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignVGhlIHNlbGVjdG9yIGAnKyBzZWxlY3RvciArJ2BpcyBpbnZhbGlkJyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgZm9yKHZhciBqID0gMTsgaiA8IGNoZWNrLm1hdGNoLmxlbmd0aDsgaisrKXtcbiAgICAgICAgICAgIGFyZ3MucHVzaCggY2hlY2subWF0Y2hbal0gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gbGV0IHRoZSB0b2tlbiBwb3B1bGF0ZSB0aGUgc2VsZWN0b3Igb2JqZWN0IChpLmUuIGluIHNlbGZbaV0pXG4gICAgICAgICAgdmFyIHJldCA9IGNoZWNrLmV4cHIucG9wdWxhdGUuYXBwbHkoIHNlbGZbaV0sIGFyZ3MgKTtcblxuICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7IHJldHVybjsgfSAvLyBleGl0IGlmIHBvcHVsYXRpb24gZmFpbGVkXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIHdlJ3JlIGRvbmUgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBwYXJzZVxuICAgICAgICBpZiggcmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKSApe1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHNlbGYubGVuZ3RoID0gaSArIDE7XG5cbiAgICAgIC8vIGFkanVzdCByZWZlcmVuY2VzIGZvciBzdWJqZWN0XG4gICAgICBmb3IoaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKXtcbiAgICAgICAgdmFyIHF1ZXJ5ID0gc2VsZltqXTtcblxuICAgICAgICBpZiggcXVlcnkuc3ViamVjdCAhPSBudWxsICl7XG4gICAgICAgICAgLy8gZ28gdXAgdGhlIHRyZWUgdW50aWwgd2UgcmVhY2ggdGhlIHN1YmplY3RcbiAgICAgICAgICBmb3IoOzspe1xuICAgICAgICAgICAgaWYoIHF1ZXJ5LnN1YmplY3QgPT0gcXVlcnkgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiBzdWJqZWN0IGlzIHNlbGZcblxuICAgICAgICAgICAgaWYoIHF1ZXJ5LnBhcmVudCAhPSBudWxsICl7IC8vIHN3YXAgcGFyZW50L2NoaWxkIHJlZmVyZW5jZVxuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcXVlcnkucGFyZW50O1xuICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBxdWVyeTtcblxuICAgICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICBwYXJlbnQuY2hpbGQgPSBjaGlsZDtcblxuICAgICAgICAgICAgICBxdWVyeSA9IHBhcmVudDsgLy8gZ28gdXAgdGhlIHRyZWVcbiAgICAgICAgICAgIH0gZWxzZSBpZiggcXVlcnkuYW5jZXN0b3IgIT0gbnVsbCApeyAvLyBzd2FwIGFuY2VzdG9yL2Rlc2NlbmRhbnRcbiAgICAgICAgICAgICAgdmFyIGFuY2VzdG9yID0gcXVlcnkuYW5jZXN0b3I7XG4gICAgICAgICAgICAgIHZhciBkZXNjZW5kYW50ID0gcXVlcnk7XG5cbiAgICAgICAgICAgICAgZGVzY2VuZGFudC5hbmNlc3RvciA9IG51bGw7XG4gICAgICAgICAgICAgIGFuY2VzdG9yLmRlc2NlbmRhbnQgPSBkZXNjZW5kYW50O1xuXG4gICAgICAgICAgICAgIHF1ZXJ5ID0gYW5jZXN0b3I7IC8vIGdvIHVwIHRoZSB0cmVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAkJC51dGlsLmVycm9yKCdXaGVuIGFkanVzdGluZyByZWZlcmVuY2VzIGZvciB0aGUgc2VsZWN0b3IgYCcrIHF1ZXJ5ICsnYCwgbmVpdGhlciBwYXJlbnQgbm9yIGFuY2VzdG9yIHdhcyBmb3VuZCcpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIGZvclxuXG4gICAgICAgICAgc2VsZltqXSA9IHF1ZXJ5LnN1YmplY3Q7IC8vIHN1YmplY3Qgc2hvdWxkIGJlIHRoZSByb290IHF1ZXJ5XG4gICAgICAgIH0gLy8gaWZcbiAgICAgIH0gLy8gZm9yXG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBmb3IgZWFjaCBxdWVyeSB0aGF0IHRoZSBzdWJqZWN0IGdyb3VwIG1hdGNoZXMgdGhlIGltcGxpY2l0IGdyb3VwIGlmIGFueVxuICAgICAgaWYoIG9ubHlUaGlzR3JvdXAgIT0gbnVsbCApe1xuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyl7XG4gICAgICAgICAgaWYoIHNlbGZbal0uZ3JvdXAgIT0gbnVsbCAmJiBzZWxmW2pdLmdyb3VwICE9IG9ubHlUaGlzR3JvdXAgKXtcbiAgICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ0dyb3VwIGAnKyBzZWxmW2pdLmdyb3VwICsnYCBjb25mbGljdHMgd2l0aCBpbXBsaWNpdCBncm91cCBgJysgb25seVRoaXNHcm91cCArJ2AgaW4gc2VsZWN0b3IgYCcrIHNlbGVjdG9yICsnYCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGZbal0uZ3JvdXAgPSBvbmx5VGhpc0dyb3VwOyAvLyBzZXQgdG8gaW1wbGljaXQgZ3JvdXBcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfSBlbHNlIHtcbiAgICAgICQkLnV0aWwuZXJyb3IoJ0Egc2VsZWN0b3IgbXVzdCBiZSBjcmVhdGVkIGZyb20gYSBzdHJpbmc7IGZvdW5kICcgKyBzZWxlY3Rvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2VsZi5fcHJpdmF0ZS5pbnZhbGlkID0gZmFsc2U7XG4gICAgXG4gIH07XG5cbiAgJCQuc2VsZm4gPSAkJC5TZWxlY3Rvci5wcm90b3R5cGU7XG4gIFxuICAkJC5zZWxmbi5zaXplID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gIH07XG4gIFxuICAkJC5zZWxmbi5lcSA9IGZ1bmN0aW9uKGkpe1xuICAgIHJldHVybiB0aGlzW2ldO1xuICB9O1xuICBcbiAgLy8gZ2V0IGVsZW1lbnRzIGZyb20gdGhlIGNvcmUgYW5kIHRoZW4gZmlsdGVyIHRoZW1cbiAgJCQuc2VsZm4uZmluZCA9IGZ1bmN0aW9uKCl7XG4gICAgLy8gVE9ETyBpbXBsIGlmIHdlIGRlY2lkZSB0byB1c2UgYSBEQiBmb3Igc3RvcmluZyBlbGVtZW50c1xuICB9O1xuICBcbiAgdmFyIHF1ZXJ5TWF0Y2hlcyA9IGZ1bmN0aW9uKHF1ZXJ5LCBlbGVtZW50KXtcbiAgICAvLyBjaGVjayBncm91cFxuICAgIGlmKCBxdWVyeS5ncm91cCAhPSBudWxsICYmIHF1ZXJ5Lmdyb3VwICE9ICcqJyAmJiBxdWVyeS5ncm91cCAhPSBlbGVtZW50Ll9wcml2YXRlLmdyb3VwICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGN5ID0gZWxlbWVudC5jeSgpO1xuICAgIFxuICAgIC8vIGNoZWNrIGNvbG9uIHNlbGVjdG9yc1xuICAgIHZhciBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gdHJ1ZTtcbiAgICBmb3IodmFyIGsgPSAwOyBrIDwgcXVlcnkuY29sb25TZWxlY3RvcnMubGVuZ3RoOyBrKyspe1xuICAgICAgdmFyIHNlbCA9IHF1ZXJ5LmNvbG9uU2VsZWN0b3JzW2tdO1xuICAgICAgXG4gICAgICBzd2l0Y2goc2VsKXtcbiAgICAgIGNhc2UgJzpzZWxlY3RlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnNlbGVjdGVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnVuc2VsZWN0ZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuc2VsZWN0ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6c2VsZWN0YWJsZSc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnNlbGVjdGFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5zZWxlY3RhYmxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LnNlbGVjdGFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6bG9ja2VkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQubG9ja2VkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOnVubG9ja2VkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmxvY2tlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp2aXNpYmxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQudmlzaWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpoaWRkZW4nOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQudmlzaWJsZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp0cmFuc3BhcmVudCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LnRyYW5zcGFyZW50KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmdyYWJiZWQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5ncmFiYmVkKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmZyZWUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuZ3JhYmJlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpyZW1vdmVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQucmVtb3ZlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzppbnNpZGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQucmVtb3ZlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpncmFiYmFibGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5ncmFiYmFibGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5ncmFiYmFibGUnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gIWVsZW1lbnQuZ3JhYmJhYmxlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmFuaW1hdGVkJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuYW5pbWF0ZWQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6dW5hbmltYXRlZCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAhZWxlbWVudC5hbmltYXRlZCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpwYXJlbnQnOlxuICAgICAgICBhbGxDb2xvblNlbGVjdG9yc01hdGNoID0gZWxlbWVudC5pc05vZGUoKSAmJiBlbGVtZW50LmNoaWxkcmVuKCkubm9uZW1wdHkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6Y2hpbGQnOlxuICAgICAgY2FzZSAnOm5vbm9ycGhhbic6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSBlbGVtZW50LmlzTm9kZSgpICYmIGVsZW1lbnQucGFyZW50KCkubm9uZW1wdHkoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6b3JwaGFuJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuaXNOb2RlKCkgJiYgZWxlbWVudC5wYXJlbnQoKS5lbXB0eSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpsb29wJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuaXNFZGdlKCkgJiYgZWxlbWVudC5kYXRhKCdzb3VyY2UnKSA9PT0gZWxlbWVudC5kYXRhKCd0YXJnZXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6c2ltcGxlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuaXNFZGdlKCkgJiYgZWxlbWVudC5kYXRhKCdzb3VyY2UnKSAhPT0gZWxlbWVudC5kYXRhKCd0YXJnZXQnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICc6YWN0aXZlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuYWN0aXZlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnOmluYWN0aXZlJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmFjdGl2ZSgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzp0b3VjaCc6XG4gICAgICAgIGFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggPSAkJC5pcy50b3VjaCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpiYWNrZ3JvdW5kaW5nJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9IGVsZW1lbnQuYmFja2dyb3VuZGluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJzpub25iYWNrZ3JvdW5kaW5nJzpcbiAgICAgICAgYWxsQ29sb25TZWxlY3RvcnNNYXRjaCA9ICFlbGVtZW50LmJhY2tncm91bmRpbmcoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCAhYWxsQ29sb25TZWxlY3RvcnNNYXRjaCApIGJyZWFrO1xuICAgIH1cbiAgICBpZiggIWFsbENvbG9uU2VsZWN0b3JzTWF0Y2ggKSByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgLy8gY2hlY2sgaWRcbiAgICB2YXIgYWxsSWRzTWF0Y2ggPSB0cnVlO1xuICAgIGZvcih2YXIgayA9IDA7IGsgPCBxdWVyeS5pZHMubGVuZ3RoOyBrKyspe1xuICAgICAgdmFyIGlkID0gcXVlcnkuaWRzW2tdO1xuICAgICAgdmFyIGFjdHVhbElkID0gZWxlbWVudC5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgXG4gICAgICBhbGxJZHNNYXRjaCA9IGFsbElkc01hdGNoICYmIChpZCA9PSBhY3R1YWxJZCk7XG4gICAgICBcbiAgICAgIGlmKCAhYWxsSWRzTWF0Y2ggKSBicmVhaztcbiAgICB9XG4gICAgaWYoICFhbGxJZHNNYXRjaCApIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAvLyBjaGVjayBjbGFzc2VzXG4gICAgdmFyIGFsbENsYXNzZXNNYXRjaCA9IHRydWU7XG4gICAgZm9yKHZhciBrID0gMDsgayA8IHF1ZXJ5LmNsYXNzZXMubGVuZ3RoOyBrKyspe1xuICAgICAgdmFyIGNscyA9IHF1ZXJ5LmNsYXNzZXNba107XG4gICAgICBcbiAgICAgIGFsbENsYXNzZXNNYXRjaCA9IGFsbENsYXNzZXNNYXRjaCAmJiBlbGVtZW50Lmhhc0NsYXNzKGNscyk7XG4gICAgICBcbiAgICAgIGlmKCAhYWxsQ2xhc3Nlc01hdGNoICkgYnJlYWs7XG4gICAgfVxuICAgIGlmKCAhYWxsQ2xhc3Nlc01hdGNoICkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgIC8vIGdlbmVyaWMgY2hlY2tpbmcgZm9yIGRhdGEvbWV0YWRhdGFcbiAgICB2YXIgb3BlcmFuZHNNYXRjaCA9IGZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgICB2YXIgYWxsRGF0YU1hdGNoZXMgPSB0cnVlO1xuICAgICAgZm9yKHZhciBrID0gMDsgayA8IHF1ZXJ5W3BhcmFtcy5uYW1lXS5sZW5ndGg7IGsrKyl7XG4gICAgICAgIHZhciBkYXRhID0gcXVlcnlbcGFyYW1zLm5hbWVdW2tdO1xuICAgICAgICB2YXIgb3BlcmF0b3IgPSBkYXRhLm9wZXJhdG9yO1xuICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLnZhbHVlO1xuICAgICAgICB2YXIgZmllbGQgPSBkYXRhLmZpZWxkO1xuICAgICAgICB2YXIgbWF0Y2hlcztcbiAgICAgICAgXG4gICAgICAgIGlmKCBvcGVyYXRvciAhPSBudWxsICYmIHZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgZmllbGRWYWwgPSBwYXJhbXMuZmllbGRWYWx1ZShmaWVsZCk7XG4gICAgICAgICAgdmFyIGZpZWxkU3RyID0gISQkLmlzLnN0cmluZyhmaWVsZFZhbCkgJiYgISQkLmlzLm51bWJlcihmaWVsZFZhbCkgPyAnJyA6ICcnICsgZmllbGRWYWw7XG4gICAgICAgICAgdmFyIHZhbFN0ciA9ICcnICsgdmFsdWU7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIGlmKCBvcGVyYXRvci5pbmRleE9mKCdAJykgPj0gMCApe1xuICAgICAgICAgICAgZmllbGRTdHIgPSBmaWVsZFN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgdmFsU3RyID0gdmFsU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG9wZXJhdG9yID0gb3BlcmF0b3IucmVwbGFjZSgnQCcsICcnKTtcbiAgICAgICAgICAgIGNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5vdEV4cHIgPSBmYWxzZTtcbiAgICAgICAgICB2YXIgaGFuZGxlZE5vdEV4cHIgPSBmYWxzZTtcbiAgICAgICAgICBpZiggb3BlcmF0b3IuaW5kZXhPZignIScpID49IDAgKXtcbiAgICAgICAgICAgIG9wZXJhdG9yID0gb3BlcmF0b3IucmVwbGFjZSgnIScsICcnKTtcbiAgICAgICAgICAgIG5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICAvLyBpZiB3ZSdyZSBkb2luZyBhIGNhc2UgaW5zZW5zaXRpdmUgY29tcGFyaXNvbiwgdGhlbiB3ZSdyZSB1c2luZyBhIFNUUklORyBjb21wYXJpc29uXG4gICAgICAgICAgLy8gZXZlbiBpZiB3ZSdyZSBjb21wYXJpbmcgbnVtYmVyc1xuICAgICAgICAgIGlmKCBjYXNlSW5zZW5zaXRpdmUgKXtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmaWVsZFZhbCA9IGZpZWxkU3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3dpdGNoKG9wZXJhdG9yKXtcbiAgICAgICAgICBjYXNlICcqPSc6XG4gICAgICAgICAgICBtYXRjaGVzID0gZmllbGRTdHIuc2VhcmNoKHZhbFN0cikgPj0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJyQ9JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSBuZXcgUmVnRXhwKHZhbFN0ciArICckJykuZXhlYyhmaWVsZFN0cikgIT0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ149JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSBuZXcgUmVnRXhwKCdeJyArIHZhbFN0cikuZXhlYyhmaWVsZFN0cikgIT0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IGZpZWxkVmFsID09PSB2YWx1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJyE9JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSBmaWVsZFZhbCAhPT0gdmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSAhbm90RXhwciA/IGZpZWxkVmFsID4gdmFsdWUgOiBmaWVsZFZhbCA8PSB2YWx1ZTtcbiAgICAgICAgICAgIGhhbmRsZWROb3RFeHByID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJz49JzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSAhbm90RXhwciA/IGZpZWxkVmFsID49IHZhbHVlIDogZmllbGRWYWwgPCB2YWx1ZTtcbiAgICAgICAgICAgIGhhbmRsZWROb3RFeHByID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPCB2YWx1ZSA6IGZpZWxkVmFsID49IHZhbHVlO1xuICAgICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9ICFub3RFeHByID8gZmllbGRWYWwgPD0gdmFsdWUgOiBmaWVsZFZhbCA+IHZhbHVlO1xuICAgICAgICAgICAgaGFuZGxlZE5vdEV4cHIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIG9wZXJhdG9yICE9IG51bGwgKXtcbiAgICAgICAgICBzd2l0Y2gob3BlcmF0b3Ipe1xuICAgICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IHBhcmFtcy5maWVsZFRydXRoeShmaWVsZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICchJzpcbiAgICAgICAgICAgIG1hdGNoZXMgPSAhcGFyYW1zLmZpZWxkVHJ1dGh5KGZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ14nOlxuICAgICAgICAgICAgbWF0Y2hlcyA9IHBhcmFtcy5maWVsZFVuZGVmaW5lZChmaWVsZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7ICAgXG4gICAgICAgICAgbWF0Y2hlcyA9ICFwYXJhbXMuZmllbGRVbmRlZmluZWQoZmllbGQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG5vdEV4cHIgJiYgIWhhbmRsZWROb3RFeHByICl7XG4gICAgICAgICAgbWF0Y2hlcyA9ICFtYXRjaGVzO1xuICAgICAgICAgIGhhbmRsZWROb3RFeHByID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoICFtYXRjaGVzICl7XG4gICAgICAgICAgYWxsRGF0YU1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBmb3JcbiAgICAgIFxuICAgICAgcmV0dXJuIGFsbERhdGFNYXRjaGVzO1xuICAgIH07IC8vIG9wZXJhbmRzTWF0Y2hcbiAgICBcbiAgICAvLyBjaGVjayBkYXRhIG1hdGNoZXNcbiAgICB2YXIgYWxsRGF0YU1hdGNoZXMgPSBvcGVyYW5kc01hdGNoKHtcbiAgICAgIG5hbWU6ICdkYXRhJyxcbiAgICAgIGZpZWxkVmFsdWU6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuX3ByaXZhdGUuZGF0YVtmaWVsZF07XG4gICAgICB9LFxuICAgICAgZmllbGRSZWY6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgcmV0dXJuICdlbGVtZW50Ll9wcml2YXRlLmRhdGEuJyArIGZpZWxkO1xuICAgICAgfSxcbiAgICAgIGZpZWxkVW5kZWZpbmVkOiBmdW5jdGlvbihmaWVsZCl7XG4gICAgICAgIHJldHVybiBlbGVtZW50Ll9wcml2YXRlLmRhdGFbZmllbGRdID09PSB1bmRlZmluZWQ7XG4gICAgICB9LFxuICAgICAgZmllbGRUcnV0aHk6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgaWYoIGVsZW1lbnQuX3ByaXZhdGUuZGF0YVtmaWVsZF0gKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYoICFhbGxEYXRhTWF0Y2hlcyApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBjaGVjayBtZXRhZGF0YSBtYXRjaGVzXG4gICAgdmFyIGFsbE1ldGFNYXRjaGVzID0gb3BlcmFuZHNNYXRjaCh7XG4gICAgICBuYW1lOiAnbWV0YScsXG4gICAgICBmaWVsZFZhbHVlOiBmdW5jdGlvbihmaWVsZCl7XG4gICAgICAgIHJldHVybiBlbGVtZW50W2ZpZWxkXSgpO1xuICAgICAgfSxcbiAgICAgIGZpZWxkUmVmOiBmdW5jdGlvbihmaWVsZCl7XG4gICAgICAgIHJldHVybiAnZWxlbWVudC4nICsgZmllbGQgKyAnKCknO1xuICAgICAgfSxcbiAgICAgIGZpZWxkVW5kZWZpbmVkOiBmdW5jdGlvbihmaWVsZCl7XG4gICAgICAgIHJldHVybiBlbGVtZW50W2ZpZWxkXSgpID09IG51bGw7XG4gICAgICB9LFxuICAgICAgZmllbGRUcnV0aHk6IGZ1bmN0aW9uKGZpZWxkKXtcbiAgICAgICAgaWYoIGVsZW1lbnRbZmllbGRdKCkgKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgaWYoICFhbGxNZXRhTWF0Y2hlcyApe1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBcbiAgICAvLyBjaGVjayBjb2xsZWN0aW9uXG4gICAgaWYoIHF1ZXJ5LmNvbGxlY3Rpb24gIT0gbnVsbCApe1xuICAgICAgdmFyIG1hdGNoZXNBbnkgPSBxdWVyeS5jb2xsZWN0aW9uLl9wcml2YXRlLmlkc1sgZWxlbWVudC5pZCgpIF0gIT0gbnVsbDtcbiAgICAgIFxuICAgICAgaWYoICFtYXRjaGVzQW55ICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gY2hlY2sgZmlsdGVyIGZ1bmN0aW9uXG4gICAgaWYoIHF1ZXJ5LmZpbHRlciAhPSBudWxsICYmIGVsZW1lbnQuY29sbGVjdGlvbigpLmZpbHRlciggcXVlcnkuZmlsdGVyICkuc2l6ZSgpID09PSAwICl7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuXG4gICAgLy8gY2hlY2sgcGFyZW50L2NoaWxkIHJlbGF0aW9uc1xuICAgIHZhciBjb25maXJtUmVsYXRpb25zID0gZnVuY3Rpb24oIHF1ZXJ5LCBlbGVtZW50cyApe1xuICAgICAgaWYoIHF1ZXJ5ICE9IG51bGwgKXtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSBmYWxzZTtcblxuICAgICAgICBpZiggIWN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnRzID0gZWxlbWVudHMoKTsgLy8gbWFrZSBlbGVtZW50cyBmdW5jdGlvbmFsIHNvIHdlIHNhdmUgY3ljbGVzIGlmIHF1ZXJ5ID09IG51bGxcblxuICAgICAgICAvLyBxdWVyeSBtdXN0IG1hdGNoIGZvciBhdCBsZWFzdCBvbmUgZWxlbWVudCAobWF5IGJlIHJlY3Vyc2l2ZSlcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICBpZiggcXVlcnlNYXRjaGVzKCBxdWVyeSwgZWxlbWVudHNbaV0gKSApe1xuICAgICAgICAgICAgbWF0Y2hlcyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoISBjb25maXJtUmVsYXRpb25zKHF1ZXJ5LnBhcmVudCwgZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBlbGVtZW50LnBhcmVudCgpO1xuICAgIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCEgY29uZmlybVJlbGF0aW9ucyhxdWVyeS5hbmNlc3RvciwgZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBlbGVtZW50LnBhcmVudHMoKTtcbiAgICB9KSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIGlmICghIGNvbmZpcm1SZWxhdGlvbnMocXVlcnkuY2hpbGQsIGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbigpO1xuICAgIH0pICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgaWYgKCEgY29uZmlybVJlbGF0aW9ucyhxdWVyeS5kZXNjZW5kYW50LCBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZGVzY2VuZGFudHMoKTtcbiAgICB9KSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgIC8vIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCwgc28gd2UndmUgbWF0Y2hlZCBldmVyeXRoaW5nIGZvciB0aGlzIHF1ZXJ5XG4gICAgcmV0dXJuIHRydWU7XG4gIH07IC8vIHF1ZXJ5TWF0Y2hlc1xuXG4gIC8vIGZpbHRlciBhbiBleGlzdGluZyBjb2xsZWN0aW9uXG4gICQkLnNlbGZuLmZpbHRlciA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24pe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3kgPSBjb2xsZWN0aW9uLmN5KCk7XG4gICAgXG4gICAgLy8gZG9uJ3QgYm90aGVyIHRyeWluZyBpZiBpdCdzIGludmFsaWRcbiAgICBpZiggc2VsZi5fcHJpdmF0ZS5pbnZhbGlkICl7XG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5ICk7XG4gICAgfVxuICBcbiAgICB2YXIgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xuICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHNlbGYubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIgcXVlcnkgPSBzZWxmW2pdO1xuICAgICAgICBcbiAgICAgICAgaWYoIHF1ZXJ5TWF0Y2hlcyhxdWVyeSwgZWxlbWVudCkgKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBcbiAgICBpZiggc2VsZi5fcHJpdmF0ZS5zZWxlY3RvclRleHQgPT0gbnVsbCApe1xuICAgICAgc2VsZWN0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKCl7IHJldHVybiB0cnVlOyB9O1xuICAgIH1cbiAgICBcbiAgICB2YXIgZmlsdGVyZWRDb2xsZWN0aW9uID0gY29sbGVjdGlvbi5maWx0ZXIoIHNlbGVjdG9yRnVuY3Rpb24gKTtcbiAgICBcbiAgICByZXR1cm4gZmlsdGVyZWRDb2xsZWN0aW9uO1xuICB9OyAvLyBmaWx0ZXJcblxuICAvLyBkb2VzIHNlbGVjdG9yIG1hdGNoIGEgc2luZ2xlIGVsZW1lbnQ/XG4gICQkLnNlbGZuLm1hdGNoZXMgPSBmdW5jdGlvbihlbGUpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBcbiAgICAvLyBkb24ndCBib3RoZXIgdHJ5aW5nIGlmIGl0J3MgaW52YWxpZFxuICAgIGlmKCBzZWxmLl9wcml2YXRlLmludmFsaWQgKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIFxuICAgIGZvcih2YXIgaiA9IDA7IGogPCBzZWxmLmxlbmd0aDsgaisrKXtcbiAgICAgIHZhciBxdWVyeSA9IHNlbGZbal07XG4gICAgICBcbiAgICAgIGlmKCBxdWVyeU1hdGNoZXMocXVlcnksIGVsZSkgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYWxzZTtcbiAgfTsgLy8gZmlsdGVyXG4gIFxuICAvLyBpdGggcXVlcnkgdG8gc3RyaW5nXG4gICQkLnNlbGZuLnRvU3RyaW5nID0gJCQuc2VsZm4uc2VsZWN0b3IgPSBmdW5jdGlvbigpe1xuICAgIFxuICAgIHZhciBzdHIgPSAnJztcbiAgICBcbiAgICB2YXIgY2xlYW4gPSBmdW5jdGlvbihvYmosIGlzVmFsdWUpe1xuICAgICAgaWYoICQkLmlzLnN0cmluZyhvYmopICl7XG4gICAgICAgIHJldHVybiBpc1ZhbHVlID8gJ1wiJyArIG9iaiArICdcIicgOiBvYmo7XG4gICAgICB9IFxuICAgICAgcmV0dXJuICcnO1xuICAgIH07XG4gICAgXG4gICAgdmFyIHF1ZXJ5VG9TdHJpbmcgPSBmdW5jdGlvbihxdWVyeSl7XG4gICAgICB2YXIgc3RyID0gJyc7XG5cbiAgICAgIGlmKCBxdWVyeS5zdWJqZWN0ID09PSBxdWVyeSApe1xuICAgICAgICBzdHIgKz0gJyQnO1xuICAgICAgfVxuXG4gICAgICB2YXIgZ3JvdXAgPSBjbGVhbihxdWVyeS5ncm91cCk7XG4gICAgICBzdHIgKz0gZ3JvdXAuc3Vic3RyaW5nKDAsIGdyb3VwLmxlbmd0aCAtIDEpO1xuICAgICAgXG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgcXVlcnkuZGF0YS5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBkYXRhID0gcXVlcnkuZGF0YVtqXTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBkYXRhLnZhbHVlICl7XG4gICAgICAgICAgc3RyICs9ICdbJyArIGRhdGEuZmllbGQgKyBjbGVhbihkYXRhLm9wZXJhdG9yKSArIGNsZWFuKGRhdGEudmFsdWUsIHRydWUpICsgJ10nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciArPSAnWycgKyBjbGVhbihkYXRhLm9wZXJhdG9yKSArIGRhdGEuZmllbGQgKyAnXSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yKHZhciBqID0gMDsgaiA8IHF1ZXJ5Lm1ldGEubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIgbWV0YSA9IHF1ZXJ5Lm1ldGFbal07XG4gICAgICAgIHN0ciArPSAnW1snICsgbWV0YS5maWVsZCArIGNsZWFuKG1ldGEub3BlcmF0b3IpICsgY2xlYW4obWV0YS52YWx1ZSwgdHJ1ZSkgKyAnXV0nO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgcXVlcnkuY29sb25TZWxlY3RvcnMubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIgc2VsID0gcXVlcnkuY29sb25TZWxlY3RvcnNbaV07XG4gICAgICAgIHN0ciArPSBzZWw7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBxdWVyeS5pZHMubGVuZ3RoOyBqKyspe1xuICAgICAgICB2YXIgc2VsID0gJyMnICsgcXVlcnkuaWRzW2ldO1xuICAgICAgICBzdHIgKz0gc2VsO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmb3IodmFyIGogPSAwOyBqIDwgcXVlcnkuY2xhc3Nlcy5sZW5ndGg7IGorKyl7XG4gICAgICAgIHZhciBzZWwgPSAnLicgKyBxdWVyeS5jbGFzc2VzW2ldO1xuICAgICAgICBzdHIgKz0gc2VsO1xuICAgICAgfVxuXG4gICAgICBpZiggcXVlcnkucGFyZW50ICE9IG51bGwgKXtcbiAgICAgICAgc3RyID0gcXVlcnlUb1N0cmluZyggcXVlcnkucGFyZW50ICkgKyAnID4gJyArIHN0cjsgXG4gICAgICB9XG5cbiAgICAgIGlmKCBxdWVyeS5hbmNlc3RvciAhPSBudWxsICl7XG4gICAgICAgIHN0ciA9IHF1ZXJ5VG9TdHJpbmcoIHF1ZXJ5LmFuY2VzdG9yICkgKyAnICcgKyBzdHI7IFxuICAgICAgfVxuXG4gICAgICBpZiggcXVlcnkuY2hpbGQgIT0gbnVsbCApe1xuICAgICAgICBzdHIgKz0gJyA+ICcgKyBxdWVyeVRvU3RyaW5nKCBxdWVyeS5jaGlsZCApOyBcbiAgICAgIH1cblxuICAgICAgaWYoIHF1ZXJ5LmRlc2NlbmRhbnQgIT0gbnVsbCApe1xuICAgICAgICBzdHIgKz0gJyAnICsgcXVlcnlUb1N0cmluZyggcXVlcnkuZGVzY2VuZGFudCApOyBcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspe1xuICAgICAgdmFyIHF1ZXJ5ID0gdGhpc1tpXTtcbiAgICAgIFxuICAgICAgc3RyICs9IHF1ZXJ5VG9TdHJpbmcoIHF1ZXJ5ICk7XG4gICAgICBcbiAgICAgIGlmKCB0aGlzLmxlbmd0aCA+IDEgJiYgaSA8IHRoaXMubGVuZ3RoIC0gMSApe1xuICAgICAgICBzdHIgKz0gJywgJztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuU3R5bGUgPSBmdW5jdGlvbiggY3kgKXtcblxuICAgIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiAkJC5TdHlsZSkgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuU3R5bGUoY3kpO1xuICAgIH1cblxuICAgIGlmKCAhJCQuaXMuY29yZShjeSkgKXtcbiAgICAgICQkLnV0aWwuZXJyb3IoJ0Egc3R5bGUgbXVzdCBoYXZlIGEgY29yZSByZWZlcmVuY2UnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgY3k6IGN5LFxuICAgICAgY29yZVN0eWxlOiB7fSxcbiAgICAgIG5ld1N0eWxlOiB0cnVlXG4gICAgfTtcblxuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuYWRkRGVmYXVsdFN0eWxlc2hlZXQoKTtcbiAgfTtcblxuICAvLyBuaWNlLXRvLWhhdmUgYWxpYXNlc1xuICAkJC5zdHlsZSA9ICQkLlN0eWxlO1xuICAkJC5zdHlmbiA9ICQkLlN0eWxlLnByb3RvdHlwZTtcblxuICAvLyBkZWZpbmUgZnVuY3Rpb25zIGluIHRoZSBTdHlsZSBwcm90b3R5cGVcbiAgJCQuZm4uc3R5bGUgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBmbk5hbWUgaW4gZm5NYXAgKXtcbiAgICAgIHZhciBmbiA9IGZuTWFwWyBmbk5hbWUgXTtcbiAgICAgICQkLlN0eWxlLnByb3RvdHlwZSA9IGZuO1xuICAgIH1cbiAgfTtcblxuICAoZnVuY3Rpb24oKXtcbiAgICB2YXIgbnVtYmVyID0gJCQudXRpbC5yZWdleC5udW1iZXI7XG4gICAgdmFyIHJnYmEgPSAkJC51dGlsLnJlZ2V4LnJnYmFOb0JhY2tSZWZzO1xuICAgIHZhciBoc2xhID0gJCQudXRpbC5yZWdleC5oc2xhTm9CYWNrUmVmcztcbiAgICB2YXIgaGV4MyA9ICQkLnV0aWwucmVnZXguaGV4MztcbiAgICB2YXIgaGV4NiA9ICQkLnV0aWwucmVnZXguaGV4NjtcbiAgICB2YXIgZGF0YSA9IGZ1bmN0aW9uKCBwcmVmaXggKXsgcmV0dXJuICdeJyArIHByZWZpeCArICdcXFxccypcXFxcKFxcXFxzKihbXFxcXHdcXFxcLl0rKVxcXFxzKlxcXFwpJCc7IH07XG4gICAgdmFyIG1hcERhdGEgPSBmdW5jdGlvbiggcHJlZml4ICl7IHJldHVybiAnXicgKyBwcmVmaXggKyAnXFxcXHMqXFxcXCgoW1xcXFx3XFxcXC5dKylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccypcXFxcLFxcXFxzKignICsgbnVtYmVyICsgJylcXFxccyosXFxcXHMqKCcgKyBudW1iZXIgKyAnfFxcXFx3K3wnICsgcmdiYSArICd8JyArIGhzbGEgKyAnfCcgKyBoZXgzICsgJ3wnICsgaGV4NiArICcpXFxcXHMqXFxcXCxcXFxccyooJyArIG51bWJlciArICd8XFxcXHcrfCcgKyByZ2JhICsgJ3wnICsgaHNsYSArICd8JyArIGhleDMgKyAnfCcgKyBoZXg2ICsgJylcXFxcKSQnOyB9O1xuXG4gICAgLy8gZWFjaCB2aXN1YWwgc3R5bGUgcHJvcGVydHkgaGFzIGEgdHlwZSBhbmQgbmVlZHMgdG8gYmUgdmFsaWRhdGVkIGFjY29yZGluZyB0byBpdFxuICAgICQkLnN0eWxlLnR5cGVzID0ge1xuICAgICAgdGltZTogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgdW5pdHM6ICdzfG1zJywgaW1wbGljaXRVbml0czogJ21zJyB9LFxuICAgICAgcGVyY2VudDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgbWF4OiAxMDAsIHVuaXRzOiAnJScgfSxcbiAgICAgIHplcm9PbmVOdW1iZXI6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIG1heDogMSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICAgIG5PbmVPbmVOdW1iZXI6IHsgbnVtYmVyOiB0cnVlLCBtaW46IC0xLCBtYXg6IDEsIHVuaXRsZXNzOiB0cnVlIH0sXG4gICAgICBub25OZWdhdGl2ZUludDogeyBudW1iZXI6IHRydWUsIG1pbjogMCwgaW50ZWdlcjogdHJ1ZSwgdW5pdGxlc3M6IHRydWUgfSxcbiAgICAgIHBvc2l0aW9uOiB7IGVudW1zOiBbJ3BhcmVudCcsICdvcmlnaW4nXSB9LFxuICAgICAgYXV0b1NpemU6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGVudW1zOiBbJ2F1dG8nXSB9LFxuICAgICAgbnVtYmVyOiB7IG51bWJlcjogdHJ1ZSB9LFxuICAgICAgc2l6ZTogeyBudW1iZXI6IHRydWUsIG1pbjogMCB9LFxuICAgICAgYmdTaXplOiB7IG51bWJlcjogdHJ1ZSwgbWluOiAwLCBhbGxvd1BlcmNlbnQ6IHRydWUgfSxcbiAgICAgIGJnV0g6IHsgbnVtYmVyOiB0cnVlLCBtaW46IDAsIGFsbG93UGVyY2VudDogdHJ1ZSwgZW51bXM6IFsnYXV0byddIH0sXG4gICAgICBiZ1BvczogeyBudW1iZXI6IHRydWUsIGFsbG93UGVyY2VudDogdHJ1ZSB9LFxuICAgICAgYmdSZXBlYXQ6IHsgZW51bXM6IFsncmVwZWF0JywgJ3JlcGVhdC14JywgJ3JlcGVhdC15JywgJ25vLXJlcGVhdCddIH0sXG4gICAgICBiZ0ZpdDogeyBlbnVtczogWydub25lJywgJ2NvbnRhaW4nLCAnY292ZXInXSB9LFxuICAgICAgYmdDbGlwOiB7IGVudW1zOiBbJ25vbmUnLCAnbm9kZSddIH0sXG4gICAgICBjb2xvcjogeyBjb2xvcjogdHJ1ZSB9LFxuICAgICAgbGluZVN0eWxlOiB7IGVudW1zOiBbJ3NvbGlkJywgJ2RvdHRlZCcsICdkYXNoZWQnXSB9LFxuICAgICAgYm9yZGVyU3R5bGU6IHsgZW51bXM6IFsnc29saWQnLCAnZG90dGVkJywgJ2Rhc2hlZCcsICdkb3VibGUnXSB9LFxuICAgICAgY3VydmVTdHlsZTogeyBlbnVtczogWydiZXppZXInLCAndW5idW5kbGVkLWJlemllcicsICdoYXlzdGFjayddIH0sXG4gICAgICBmb250RmFtaWx5OiB7IHJlZ2V4OiAnXihbXFxcXHctIFxcXFxcIl0rKD86XFxcXHMqLFxcXFxzKltcXFxcdy0gXFxcXFwiXSspKikkJyB9LFxuICAgICAgZm9udFZhcmlhbnQ6IHsgZW51bXM6IFsnc21hbGwtY2FwcycsICdub3JtYWwnXSB9LFxuICAgICAgZm9udFN0eWxlOiB7IGVudW1zOiBbJ2l0YWxpYycsICdub3JtYWwnLCAnb2JsaXF1ZSddIH0sXG4gICAgICBmb250V2VpZ2h0OiB7IGVudW1zOiBbJ25vcm1hbCcsICdib2xkJywgJ2JvbGRlcicsICdsaWdodGVyJywgJzEwMCcsICcyMDAnLCAnMzAwJywgJzQwMCcsICc1MDAnLCAnNjAwJywgJzgwMCcsICc5MDAnLCAxMDAsIDIwMCwgMzAwLCA0MDAsIDUwMCwgNjAwLCA3MDAsIDgwMCwgOTAwXSB9LFxuICAgICAgdGV4dERlY29yYXRpb246IHsgZW51bXM6IFsnbm9uZScsICd1bmRlcmxpbmUnLCAnb3ZlcmxpbmUnLCAnbGluZS10aHJvdWdoJ10gfSxcbiAgICAgIHRleHRUcmFuc2Zvcm06IHsgZW51bXM6IFsnbm9uZScsICd1cHBlcmNhc2UnLCAnbG93ZXJjYXNlJ10gfSxcbiAgICAgIHRleHRXcmFwOiB7IGVudW1zOiBbJ25vbmUnLCAnd3JhcCddIH0sXG4gICAgICB0ZXh0QmFja2dyb3VuZFNoYXBlOiB7IGVudW1zOiBbJ3JlY3RhbmdsZScsICdyb3VuZHJlY3RhbmdsZSddfSxcbiAgICAgIG5vZGVTaGFwZTogeyBlbnVtczogWydyZWN0YW5nbGUnLCAncm91bmRyZWN0YW5nbGUnLCAnZWxsaXBzZScsICd0cmlhbmdsZScsICdzcXVhcmUnLCAncGVudGFnb24nLCAnaGV4YWdvbicsICdoZXB0YWdvbicsICdvY3RhZ29uJywgJ3N0YXInLCAnZGlhbW9uZCcsICd2ZWUnLCAncmhvbWJvaWQnXSB9LFxuICAgICAgY29tcG91bmRJbmNsdWRlTGFiZWxzOiB7IGVudW1zOiBbJ2luY2x1ZGUnLCAnZXhjbHVkZSddIH0sXG4gICAgICBhcnJvd1NoYXBlOiB7IGVudW1zOiBbJ3RlZScsICd0cmlhbmdsZScsICd0cmlhbmdsZS10ZWUnLCAndHJpYW5nbGUtYmFja2N1cnZlJywgJ2hhbGYtdHJpYW5nbGUtb3ZlcnNob3QnLCAnc3F1YXJlJywgJ2NpcmNsZScsICdkaWFtb25kJywgJ25vbmUnXSB9LFxuICAgICAgYXJyb3dGaWxsOiB7IGVudW1zOiBbJ2ZpbGxlZCcsICdob2xsb3cnXSB9LFxuICAgICAgZGlzcGxheTogeyBlbnVtczogWydlbGVtZW50JywgJ25vbmUnXSB9LFxuICAgICAgdmlzaWJpbGl0eTogeyBlbnVtczogWydoaWRkZW4nLCAndmlzaWJsZSddIH0sXG4gICAgICB2YWxpZ246IHsgZW51bXM6IFsndG9wJywgJ2NlbnRlcicsICdib3R0b20nXSB9LFxuICAgICAgaGFsaWduOiB7IGVudW1zOiBbJ2xlZnQnLCAnY2VudGVyJywgJ3JpZ2h0J10gfSxcbiAgICAgIHRleHQ6IHsgc3RyaW5nOiB0cnVlIH0sXG4gICAgICBkYXRhOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBkYXRhKCdkYXRhJykgfSxcbiAgICAgIGxheW91dERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IGRhdGEoJ2xheW91dERhdGEnKSB9LFxuICAgICAgc2NyYXRjaDogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogZGF0YSgnc2NyYXRjaCcpIH0sXG4gICAgICBtYXBEYXRhOiB7IG1hcHBpbmc6IHRydWUsIHJlZ2V4OiBtYXBEYXRhKCdtYXBEYXRhJykgfSxcbiAgICAgIG1hcExheW91dERhdGE6IHsgbWFwcGluZzogdHJ1ZSwgcmVnZXg6IG1hcERhdGEoJ21hcExheW91dERhdGEnKSB9LFxuICAgICAgbWFwU2NyYXRjaDogeyBtYXBwaW5nOiB0cnVlLCByZWdleDogbWFwRGF0YSgnbWFwU2NyYXRjaCcpIH0sXG4gICAgICBmbjogeyBtYXBwaW5nOiB0cnVlLCBmbjogdHJ1ZSB9LFxuICAgICAgdXJsOiB7IHJlZ2V4OiAnXnVybFxcXFxzKlxcXFwoXFxcXHMqKFteXFxcXHNdKylcXFxccypcXFxccypcXFxcKXxub25lfCguKykkJyB9LFxuICAgICAgcHJvcExpc3Q6IHsgcHJvcExpc3Q6IHRydWUgfSxcbiAgICAgIGFuZ2xlOiB7IG51bWJlcjogdHJ1ZSwgdW5pdHM6ICdkZWd8cmFkJyB9LFxuICAgICAgdGV4dFJvdGF0aW9uOiB7IGVudW1zOiBbJ25vbmUnLCAnYXV0b3JvdGF0ZSddIH1cbiAgICB9O1xuXG4gICAgLy8gZGVmaW5lIHZpc3VhbCBzdHlsZSBwcm9wZXJ0aWVzXG4gICAgdmFyIHQgPSAkJC5zdHlsZS50eXBlcztcbiAgICB2YXIgcHJvcHMgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzID0gW1xuICAgICAgLy8gbGFiZWxzXG4gICAgICB7IG5hbWU6ICd0ZXh0LXZhbGlnbicsIHR5cGU6IHQudmFsaWduIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LWhhbGlnbicsIHR5cGU6IHQuaGFsaWduIH0sXG4gICAgICB7IG5hbWU6ICdjb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ2NvbnRlbnQnLCB0eXBlOiB0LnRleHQgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtb3V0bGluZS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtb3V0bGluZS13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1vdXRsaW5lLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtYm9yZGVyLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1ib3JkZXItd2lkdGgnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ3RleHQtYm9yZGVyLXN0eWxlJywgdHlwZTogdC5ib3JkZXJTdHlsZSB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1iYWNrZ3JvdW5kLXNoYXBlJywgdHlwZTogdC50ZXh0QmFja2dyb3VuZFNoYXBlfSxcbiAgICAgIC8vIHsgbmFtZTogJ3RleHQtZGVjb3JhdGlvbicsIHR5cGU6IHQudGV4dERlY29yYXRpb24gfSwgLy8gbm90IHN1cHBvcnRlZCBpbiBjYW52YXNcbiAgICAgIHsgbmFtZTogJ3RleHQtdHJhbnNmb3JtJywgdHlwZTogdC50ZXh0VHJhbnNmb3JtIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LXdyYXAnLCB0eXBlOiB0LnRleHRXcmFwIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LW1heC13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuXG4gICAgICAvLyB7IG5hbWU6ICd0ZXh0LXJvdGF0aW9uJywgdHlwZTogdC5hbmdsZSB9LCAvLyBUT0RPIGRpc2FibGVkIGIvYyByb3RhdGlvbiBicmVha3MgYm91bmRpbmcgYm94ZXNcbiAgICAgIHsgbmFtZTogJ2ZvbnQtZmFtaWx5JywgdHlwZTogdC5mb250RmFtaWx5IH0sXG4gICAgICB7IG5hbWU6ICdmb250LXN0eWxlJywgdHlwZTogdC5mb250U3R5bGUgfSxcbiAgICAgIC8vIHsgbmFtZTogJ2ZvbnQtdmFyaWFudCcsIHR5cGU6IHQuZm9udFZhcmlhbnQgfSwgLy8gbm90IHVzZWZ1bFxuICAgICAgeyBuYW1lOiAnZm9udC13ZWlnaHQnLCB0eXBlOiB0LmZvbnRXZWlnaHQgfSxcbiAgICAgIHsgbmFtZTogJ2ZvbnQtc2l6ZScsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnbWluLXpvb21lZC1mb250LXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ2VkZ2UtdGV4dC1yb3RhdGlvbicsIHR5cGU6IHQudGV4dFJvdGF0aW9uIH0sXG5cbiAgICAgIC8vIHZpc2liaWxpdHlcbiAgICAgIHsgbmFtZTogJ2Rpc3BsYXknLCB0eXBlOiB0LmRpc3BsYXkgfSxcbiAgICAgIHsgbmFtZTogJ3Zpc2liaWxpdHknLCB0eXBlOiB0LnZpc2liaWxpdHkgfSxcbiAgICAgIHsgbmFtZTogJ29wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ3otaW5kZXgnLCB0eXBlOiB0Lm5vbk5lZ2F0aXZlSW50IH0sXG5cbiAgICAgIC8vIG92ZXJsYXlzXG4gICAgICB7IG5hbWU6ICdvdmVybGF5LXBhZGRpbmcnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ292ZXJsYXktY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdvdmVybGF5LW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcblxuICAgICAgLy8gc2hhZG93c1xuICAgICAgeyBuYW1lOiAnc2hhZG93LWJsdXInLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ3NoYWRvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ3NoYWRvdy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdzaGFkb3ctb2Zmc2V0LXgnLCB0eXBlOiB0Lm51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnc2hhZG93LW9mZnNldC15JywgdHlwZTogdC5udW1iZXIgfSxcblxuICAgICAgLy8gbGFiZWwgc2hhZG93c1xuICAgICAgeyBuYW1lOiAndGV4dC1zaGFkb3ctYmx1cicsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAndGV4dC1zaGFkb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1vZmZzZXQteCcsIHR5cGU6IHQubnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICd0ZXh0LXNoYWRvdy1vZmZzZXQteScsIHR5cGU6IHQubnVtYmVyIH0sXG5cbiAgICAgIC8vIHRyYW5zaXRpb24gYW5pc1xuICAgICAgeyBuYW1lOiAndHJhbnNpdGlvbi1wcm9wZXJ0eScsIHR5cGU6IHQucHJvcExpc3QgfSxcbiAgICAgIHsgbmFtZTogJ3RyYW5zaXRpb24tZHVyYXRpb24nLCB0eXBlOiB0LnRpbWUgfSxcbiAgICAgIHsgbmFtZTogJ3RyYW5zaXRpb24tZGVsYXknLCB0eXBlOiB0LnRpbWUgfSxcblxuICAgICAgLy8gbm9kZSBib2R5XG4gICAgICB7IG5hbWU6ICdoZWlnaHQnLCB0eXBlOiB0LmF1dG9TaXplIH0sXG4gICAgICB7IG5hbWU6ICd3aWR0aCcsIHR5cGU6IHQuYXV0b1NpemUgfSxcbiAgICAgIHsgbmFtZTogJ3NoYXBlJywgdHlwZTogdC5ub2RlU2hhcGUgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtYmxhY2tlbicsIHR5cGU6IHQubk9uZU9uZU51bWJlciB9LFxuXG4gICAgICAvLyBub2RlIGJvcmRlclxuICAgICAgeyBuYW1lOiAnYm9yZGVyLWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnYm9yZGVyLW9wYWNpdHknLCB0eXBlOiB0Lnplcm9PbmVOdW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ2JvcmRlci13aWR0aCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAnYm9yZGVyLXN0eWxlJywgdHlwZTogdC5ib3JkZXJTdHlsZSB9LFxuXG4gICAgICAvLyBub2RlIGJhY2tncm91bmQgaW1hZ2VzXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWltYWdlJywgdHlwZTogdC51cmwgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtaW1hZ2Utb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi14JywgdHlwZTogdC5iZ1BvcyB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1wb3NpdGlvbi15JywgdHlwZTogdC5iZ1BvcyB9LFxuICAgICAgeyBuYW1lOiAnYmFja2dyb3VuZC1yZXBlYXQnLCB0eXBlOiB0LmJnUmVwZWF0IH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWZpdCcsIHR5cGU6IHQuYmdGaXQgfSxcbiAgICAgIHsgbmFtZTogJ2JhY2tncm91bmQtY2xpcCcsIHR5cGU6IHQuYmdDbGlwIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLXdpZHRoJywgdHlwZTogdC5iZ1dIIH0sXG4gICAgICB7IG5hbWU6ICdiYWNrZ3JvdW5kLWhlaWdodCcsIHR5cGU6IHQuYmdXSCB9LFxuXG4gICAgICAvLyBjb21wb3VuZCBwcm9wc1xuICAgICAgeyBuYW1lOiAncGFkZGluZy1sZWZ0JywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdwYWRkaW5nLXJpZ2h0JywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdwYWRkaW5nLXRvcCcsIHR5cGU6IHQuc2l6ZSB9LFxuICAgICAgeyBuYW1lOiAncGFkZGluZy1ib3R0b20nLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ3Bvc2l0aW9uJywgdHlwZTogdC5wb3NpdGlvbiB9LFxuICAgICAgeyBuYW1lOiAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnLCB0eXBlOiB0LmNvbXBvdW5kSW5jbHVkZUxhYmVscyB9LFxuXG4gICAgICAvLyBlZGdlIGxpbmVcbiAgICAgIHsgbmFtZTogJ2xpbmUtc3R5bGUnLCB0eXBlOiB0LmxpbmVTdHlsZSB9LFxuICAgICAgeyBuYW1lOiAnbGluZS1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdjb250cm9sLXBvaW50LWRpc3RhbmNlJywgdHlwZTogdC5udW1iZXIgfSxcbiAgICAgIHsgbmFtZTogJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdjdXJ2ZS1zdHlsZScsIHR5cGU6IHQuY3VydmVTdHlsZSB9LFxuICAgICAgeyBuYW1lOiAnaGF5c3RhY2stcmFkaXVzJywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG5cbiAgICAgIC8vIGVkZ2UgYXJyb3dzXG4gICAgICB7IG5hbWU6ICdzb3VyY2UtYXJyb3ctc2hhcGUnLCB0eXBlOiB0LmFycm93U2hhcGUgfSxcbiAgICAgIHsgbmFtZTogJ3RhcmdldC1hcnJvdy1zaGFwZScsIHR5cGU6IHQuYXJyb3dTaGFwZSB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXNvdXJjZS1hcnJvdy1zaGFwZScsIHR5cGU6IHQuYXJyb3dTaGFwZSB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXRhcmdldC1hcnJvdy1zaGFwZScsIHR5cGU6IHQuYXJyb3dTaGFwZSB9LFxuICAgICAgeyBuYW1lOiAnc291cmNlLWFycm93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAndGFyZ2V0LWFycm93LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXNvdXJjZS1hcnJvdy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ21pZC10YXJnZXQtYXJyb3ctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdzb3VyY2UtYXJyb3ctZmlsbCcsIHR5cGU6IHQuYXJyb3dGaWxsIH0sXG4gICAgICB7IG5hbWU6ICd0YXJnZXQtYXJyb3ctZmlsbCcsIHR5cGU6IHQuYXJyb3dGaWxsIH0sXG4gICAgICB7IG5hbWU6ICdtaWQtc291cmNlLWFycm93LWZpbGwnLCB0eXBlOiB0LmFycm93RmlsbCB9LFxuICAgICAgeyBuYW1lOiAnbWlkLXRhcmdldC1hcnJvdy1maWxsJywgdHlwZTogdC5hcnJvd0ZpbGwgfSxcblxuICAgICAgLy8gdGhlc2UgYXJlIGp1c3QgZm9yIHRoZSBjb3JlXG4gICAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LWNvbG9yJywgdHlwZTogdC5jb2xvciB9LFxuICAgICAgeyBuYW1lOiAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH0sXG4gICAgICB7IG5hbWU6ICdzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJywgdHlwZTogdC5zaXplIH0sXG4gICAgICB7IG5hbWU6ICdhY3RpdmUtYmctY29sb3InLCB0eXBlOiB0LmNvbG9yIH0sXG4gICAgICB7IG5hbWU6ICdhY3RpdmUtYmctb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9LFxuICAgICAgeyBuYW1lOiAnYWN0aXZlLWJnLXNpemUnLCB0eXBlOiB0LnNpemUgfSxcbiAgICAgIHsgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1jb2xvcicsIHR5cGU6IHQuY29sb3IgfSxcbiAgICAgIHsgbmFtZTogJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JywgdHlwZTogdC56ZXJvT25lTnVtYmVyIH1cbiAgICBdO1xuXG4gICAgLy8gcGllIGJhY2tncm91bmRzIGZvciBub2Rlc1xuICAgICQkLnN0eWxlLnBpZUJhY2tncm91bmROID0gMTY7IC8vIGJlY2F1c2UgdGhlIHBpZSBwcm9wZXJ0aWVzIGFyZSBudW1iZXJlZCwgZ2l2ZSBhY2Nlc3MgdG8gYSBjb25zdGFudCBOIChmb3IgcmVuZGVyZXIgdXNlKVxuICAgIHByb3BzLnB1c2goeyBuYW1lOiAncGllLXNpemUnLCB0eXBlOiB0LmJnU2l6ZSB9KTtcbiAgICBmb3IoIHZhciBpID0gMTsgaSA8PSAkJC5zdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrICl7XG4gICAgICBwcm9wcy5wdXNoKHsgbmFtZTogJ3BpZS0nK2krJy1iYWNrZ3JvdW5kLWNvbG9yJywgdHlwZTogdC5jb2xvciB9KTtcbiAgICAgIHByb3BzLnB1c2goeyBuYW1lOiAncGllLScraSsnLWJhY2tncm91bmQtc2l6ZScsIHR5cGU6IHQucGVyY2VudCB9KTtcbiAgICAgIHByb3BzLnB1c2goeyBuYW1lOiAncGllLScraSsnLWJhY2tncm91bmQtb3BhY2l0eScsIHR5cGU6IHQuemVyb09uZU51bWJlciB9KTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBhY2Nlc3Mgb2YgcHJvcGVydGllcyBieSBuYW1lICggZS5nLiAkJC5zdHlsZS5wcm9wZXJ0aWVzLmhlaWdodCApXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcblxuICAgICAgcHJvcHNbIHByb3AubmFtZSBdID0gcHJvcDsgLy8gYWxsb3cgbG9va3VwIGJ5IG5hbWVcbiAgICB9XG4gIH0pKCk7XG5cbiAgLy8gYWRkcyB0aGUgZGVmYXVsdCBzdHlsZXNoZWV0IHRvIHRoZSBjdXJyZW50IHN0eWxlXG4gICQkLnN0eWZuLmFkZERlZmF1bHRTdHlsZXNoZWV0ID0gZnVuY3Rpb24oKXtcbiAgICAvLyB0byBiZSBuaWNlLCB3ZSBidWlsZCBmb250IHJlbGF0ZWQgc3R5bGUgcHJvcGVydGllcyBmcm9tIHRoZSBjb3JlIGNvbnRhaW5lclxuICAgIC8vIHNvIHRoYXQgY3l0b3NjYXBlIG1hdGNoZXMgdGhlIHN0eWxlIG9mIGl0cyBjb250YWluZXIgYnkgZGVmYXVsdFxuICAgIC8vXG4gICAgLy8gdW5mb3J0dW5hdGVseSwgdGhpcyBkb2Vzbid0IHNlZW0gd29yayBjb25zaXN0ZW50bHkgYW5kIGNhbiBncmFiIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXQgdmFsdWVzXG4gICAgLy8gaW5zdGVhZCBvZiB0aGUgZGV2ZWxvcGVyJ3MgdmFsdWVzIHNvIGxldCdzIGp1c3QgbWFrZSBpdCBleHBsaWNpdCBmb3IgdGhlIGRldiBmb3Igbm93XG4gICAgLy9cbiAgICAvLyBkZWxheWluZyB0aGUgcmVhZCBvZiB0aGVzZSB2YWwncyBpcyBub3QgYW4gb3B0J246IHRoYXQgd291bGQgZGVsYXkgaW5pdCdsIGxvYWQgdGltZVxuICAgIHZhciBmb250RmFtaWx5ID0gJ0hlbHZldGljYScgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCdmb250LWZhbWlseScpIHx8ICdzYW5zLXNlcmlmJztcbiAgICB2YXIgZm9udFN0eWxlID0gJ25vcm1hbCcgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCdmb250LXN0eWxlJykgfHwgJ25vcm1hbCc7XG4gICAgLy8gdmFyIGZvbnRWYXJpYW50ID0gJ25vcm1hbCcgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCdmb250LXZhcmlhbnQnKSB8fCAnbm9ybWFsJztcbiAgICB2YXIgZm9udFdlaWdodCA9ICdub3JtYWwnIHx8IHRoaXMuY29udGFpbmVyUHJvcGVydHlBc1N0cmluZygnZm9udC13ZWlnaHQnKSB8fCAnbm9ybWFsJztcbiAgICB2YXIgY29sb3IgPSAnIzAwMCcgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCdjb2xvcicpIHx8ICcjMDAwJztcbiAgICB2YXIgdGV4dFRyYW5zZm9ybSA9ICdub25lJyB8fCB0aGlzLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcoJ3RleHQtdHJhbnNmb3JtJykgfHwgJ25vbmUnO1xuICAgIHZhciBmb250U2l6ZSA9IDE2IHx8IHRoaXMuY29udGFpbmVyUHJvcGVydHlBc1N0cmluZygnZm9udC1zaXplJykgfHwgMTY7XG4gICAgdmFyIHRleHRNYXhXaWR0aCA9IDk5OTkgfHwgdGhpcy5jb250YWluZXJQcm9wZXJ0eUFzU3RyaW5nKCd0ZXh0LW1heC13aWR0aCcpIHx8IDk5OTk7XG5cbiAgICAvLyBmaWxsIHRoZSBzdHlsZSB3aXRoIHRoZSBkZWZhdWx0IHN0eWxlc2hlZXRcbiAgICB0aGlzXG4gICAgICAuc2VsZWN0b3IoJ25vZGUsIGVkZ2UnKSAvLyBjb21tb24gcHJvcGVydGllc1xuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAndGV4dC12YWxpZ24nOiAndG9wJyxcbiAgICAgICAgICAndGV4dC1oYWxpZ24nOiAnY2VudGVyJyxcbiAgICAgICAgICAnY29sb3InOiBjb2xvcixcbiAgICAgICAgICAndGV4dC1vdXRsaW5lLWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAgICd0ZXh0LW91dGxpbmUtd2lkdGgnOiAwLFxuICAgICAgICAgICd0ZXh0LW91dGxpbmUtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3RleHQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3RleHQtZGVjb3JhdGlvbic6ICdub25lJyxcbiAgICAgICAgICAndGV4dC10cmFuc2Zvcm0nOiB0ZXh0VHJhbnNmb3JtLFxuICAgICAgICAgICd0ZXh0LXdyYXAnOiAnbm9uZScsXG4gICAgICAgICAgJ3RleHQtbWF4LXdpZHRoJzogdGV4dE1heFdpZHRoLFxuICAgICAgICAgICd0ZXh0LWJhY2tncm91bmQtY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5JzogMCxcbiAgICAgICAgICAndGV4dC1ib3JkZXItb3BhY2l0eSc6IDAsXG4gICAgICAgICAgJ3RleHQtYm9yZGVyLXdpZHRoJzogMCxcbiAgICAgICAgICAndGV4dC1ib3JkZXItc3R5bGUnOiAnc29saWQnLFxuICAgICAgICAgICd0ZXh0LWJvcmRlci1jb2xvcic6JyMwMDAnLFxuICAgICAgICAgICd0ZXh0LWJhY2tncm91bmQtc2hhcGUnOidyZWN0YW5nbGUnLFxuICAgICAgICAgICdmb250LWZhbWlseSc6IGZvbnRGYW1pbHksXG4gICAgICAgICAgJ2ZvbnQtc3R5bGUnOiBmb250U3R5bGUsXG4gICAgICAgICAgLy8gJ2ZvbnQtdmFyaWFudCc6IGZvbnRWYXJpYW50LFxuICAgICAgICAgICdmb250LXdlaWdodCc6IGZvbnRXZWlnaHQsXG4gICAgICAgICAgJ2ZvbnQtc2l6ZSc6IGZvbnRTaXplLFxuICAgICAgICAgICdtaW4tem9vbWVkLWZvbnQtc2l6ZSc6IDAsXG4gICAgICAgICAgJ2VkZ2UtdGV4dC1yb3RhdGlvbic6ICdub25lJyxcbiAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICAgICAnZGlzcGxheSc6ICdlbGVtZW50JyxcbiAgICAgICAgICAnb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3otaW5kZXgnOiAwLFxuICAgICAgICAgICdjb250ZW50JzogJycsXG4gICAgICAgICAgJ292ZXJsYXktb3BhY2l0eSc6IDAsXG4gICAgICAgICAgJ292ZXJsYXktY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICAgICAgICdzaGFkb3ctb3BhY2l0eSc6IDAsXG4gICAgICAgICAgJ3NoYWRvdy1jb2xvcic6ICcjMDAwJyxcbiAgICAgICAgICAnc2hhZG93LWJsdXInOiAxMCxcbiAgICAgICAgICAnc2hhZG93LW9mZnNldC14JzogMCxcbiAgICAgICAgICAnc2hhZG93LW9mZnNldC15JzogMCxcbiAgICAgICAgICAndGV4dC1zaGFkb3ctb3BhY2l0eSc6IDAsXG4gICAgICAgICAgJ3RleHQtc2hhZG93LWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAgICd0ZXh0LXNoYWRvdy1ibHVyJzogNSxcbiAgICAgICAgICAndGV4dC1zaGFkb3ctb2Zmc2V0LXgnOiAwLFxuICAgICAgICAgICd0ZXh0LXNoYWRvdy1vZmZzZXQteSc6IDAsXG4gICAgICAgICAgJ3RyYW5zaXRpb24tcHJvcGVydHknOiAnbm9uZScsXG4gICAgICAgICAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiAwLFxuICAgICAgICAgICd0cmFuc2l0aW9uLWRlbGF5JzogMCxcblxuICAgICAgICAgIC8vIG5vZGUgcHJvcHNcbiAgICAgICAgICAnYmFja2dyb3VuZC1ibGFja2VuJzogMCxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICcjODg4JyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZSc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1pbWFnZS1vcGFjaXR5JzogMSxcbiAgICAgICAgICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogJzUwJScsXG4gICAgICAgICAgJ2JhY2tncm91bmQtcG9zaXRpb24teSc6ICc1MCUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXJlcGVhdCc6ICduby1yZXBlYXQnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWZpdCc6ICdub25lJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1jbGlwJzogJ25vZGUnLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLXdpZHRoJzogJ2F1dG8nLFxuICAgICAgICAgICdiYWNrZ3JvdW5kLWhlaWdodCc6ICdhdXRvJyxcbiAgICAgICAgICAnYm9yZGVyLWNvbG9yJzogJyMwMDAnLFxuICAgICAgICAgICdib3JkZXItb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ2JvcmRlci13aWR0aCc6IDAsXG4gICAgICAgICAgJ2JvcmRlci1zdHlsZSc6ICdzb2xpZCcsXG4gICAgICAgICAgJ2hlaWdodCc6IDMwLFxuICAgICAgICAgICd3aWR0aCc6IDMwLFxuICAgICAgICAgICdzaGFwZSc6ICdlbGxpcHNlJyxcblxuICAgICAgICAgIC8vIGNvbXBvdW5kIHByb3BzXG4gICAgICAgICAgJ3BhZGRpbmctdG9wJzogMCxcbiAgICAgICAgICAncGFkZGluZy1ib3R0b20nOiAwLFxuICAgICAgICAgICdwYWRkaW5nLWxlZnQnOiAwLFxuICAgICAgICAgICdwYWRkaW5nLXJpZ2h0JzogMCxcbiAgICAgICAgICAncG9zaXRpb24nOiAnb3JpZ2luJyxcbiAgICAgICAgICAnY29tcG91bmQtc2l6aW5nLXdydC1sYWJlbHMnOiAnaW5jbHVkZScsXG5cblxuICAgICAgICAgIC8vIG5vZGUgcGllIGJnXG4gICAgICAgICAgJ3BpZS1zaXplJzogJzEwMCUnLFxuICAgICAgICAgICdwaWUtMS1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTItYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0zLWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtNC1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTUtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS02LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtNy1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTgtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS05LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTAtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xMS1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTEyLWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTMtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xNC1iYWNrZ3JvdW5kLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAncGllLTE1LWJhY2tncm91bmQtY29sb3InOiAnYmxhY2snLFxuICAgICAgICAgICdwaWUtMTYtYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ3BpZS0xLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0yLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0zLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS00LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS01LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS02LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS03LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS04LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS05LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xMC1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMTEtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTEyLWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xMy1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMTQtYmFja2dyb3VuZC1zaXplJzogJzAlJyxcbiAgICAgICAgICAncGllLTE1LWJhY2tncm91bmQtc2l6ZSc6ICcwJScsXG4gICAgICAgICAgJ3BpZS0xNi1iYWNrZ3JvdW5kLXNpemUnOiAnMCUnLFxuICAgICAgICAgICdwaWUtMS1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMi1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMy1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtNC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtNS1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtNi1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtNy1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtOC1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtOS1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTAtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAncGllLTExLWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xMi1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTMtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAncGllLTE0LWJhY2tncm91bmQtb3BhY2l0eSc6IDEsXG4gICAgICAgICAgJ3BpZS0xNS1iYWNrZ3JvdW5kLW9wYWNpdHknOiAxLFxuICAgICAgICAgICdwaWUtMTYtYmFja2dyb3VuZC1vcGFjaXR5JzogMSxcblxuICAgICAgICAgIC8vIGVkZ2UgcHJvcHNcbiAgICAgICAgICAnc291cmNlLWFycm93LXNoYXBlJzogJ25vbmUnLFxuICAgICAgICAgICdtaWQtc291cmNlLWFycm93LXNoYXBlJzogJ25vbmUnLFxuICAgICAgICAgICd0YXJnZXQtYXJyb3ctc2hhcGUnOiAnbm9uZScsXG4gICAgICAgICAgJ21pZC10YXJnZXQtYXJyb3ctc2hhcGUnOiAnbm9uZScsXG4gICAgICAgICAgJ3NvdXJjZS1hcnJvdy1jb2xvcic6ICcjZGRkJyxcbiAgICAgICAgICAnbWlkLXNvdXJjZS1hcnJvdy1jb2xvcic6ICcjZGRkJyxcbiAgICAgICAgICAndGFyZ2V0LWFycm93LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdtaWQtdGFyZ2V0LWFycm93LWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdzb3VyY2UtYXJyb3ctZmlsbCc6ICdmaWxsZWQnLFxuICAgICAgICAgICdtaWQtc291cmNlLWFycm93LWZpbGwnOiAnZmlsbGVkJyxcbiAgICAgICAgICAndGFyZ2V0LWFycm93LWZpbGwnOiAnZmlsbGVkJyxcbiAgICAgICAgICAnbWlkLXRhcmdldC1hcnJvdy1maWxsJzogJ2ZpbGxlZCcsXG4gICAgICAgICAgJ2xpbmUtc3R5bGUnOiAnc29saWQnLFxuICAgICAgICAgICdsaW5lLWNvbG9yJzogJyNkZGQnLFxuICAgICAgICAgICdjb250cm9sLXBvaW50LXN0ZXAtc2l6ZSc6IDQwLFxuICAgICAgICAgICdjb250cm9sLXBvaW50LXdlaWdodCc6IDAuNSxcbiAgICAgICAgICAnY3VydmUtc3R5bGUnOiAnYmV6aWVyJyxcbiAgICAgICAgICAnaGF5c3RhY2stcmFkaXVzJzogMC44XG4gICAgICAgIH0pXG4gICAgICAuc2VsZWN0b3IoJyRub2RlID4gbm9kZScpIC8vIGNvbXBvdW5kIChwYXJlbnQpIG5vZGUgcHJvcGVydGllc1xuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnd2lkdGgnOiAnYXV0bycsXG4gICAgICAgICAgJ2hlaWdodCc6ICdhdXRvJyxcbiAgICAgICAgICAnc2hhcGUnOiAncmVjdGFuZ2xlJyxcbiAgICAgICAgICAnYmFja2dyb3VuZC1vcGFjaXR5JzogMC41LFxuICAgICAgICAgICdwYWRkaW5nLXRvcCc6IDEwLFxuICAgICAgICAgICdwYWRkaW5nLXJpZ2h0JzogMTAsXG4gICAgICAgICAgJ3BhZGRpbmctbGVmdCc6IDEwLFxuICAgICAgICAgICdwYWRkaW5nLWJvdHRvbSc6IDEwXG4gICAgICAgIH0pXG4gICAgICAuc2VsZWN0b3IoJ2VkZ2UnKSAvLyBqdXN0IGVkZ2UgcHJvcGVydGllc1xuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnd2lkdGgnOiAxXG4gICAgICAgIH0pXG4gICAgICAuc2VsZWN0b3IoJzphY3RpdmUnKVxuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnb3ZlcmxheS1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICAgJ292ZXJsYXktcGFkZGluZyc6IDEwLFxuICAgICAgICAgICdvdmVybGF5LW9wYWNpdHknOiAwLjI1XG4gICAgICAgIH0pXG4gICAgICAuc2VsZWN0b3IoJ2NvcmUnKSAvLyBqdXN0IGNvcmUgcHJvcGVydGllc1xuICAgICAgICAuY3NzKHtcbiAgICAgICAgICAnc2VsZWN0aW9uLWJveC1jb2xvcic6ICcjZGRkJyxcbiAgICAgICAgICAnc2VsZWN0aW9uLWJveC1vcGFjaXR5JzogMC42NSxcbiAgICAgICAgICAnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InOiAnI2FhYScsXG4gICAgICAgICAgJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJzogMSxcbiAgICAgICAgICAnYWN0aXZlLWJnLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgICAnYWN0aXZlLWJnLW9wYWNpdHknOiAwLjE1LFxuICAgICAgICAgICdhY3RpdmUtYmctc2l6ZSc6IDMwLFxuICAgICAgICAgICdvdXRzaWRlLXRleHR1cmUtYmctY29sb3InOiAnIzAwMCcsXG4gICAgICAgICAgJ291dHNpZGUtdGV4dHVyZS1iZy1vcGFjaXR5JzogMC4xMjVcbiAgICAgICAgfSlcbiAgICA7XG5cbiAgICB0aGlzLmRlZmF1bHRMZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgfTtcblxuICAvLyByZW1vdmUgYWxsIGNvbnRleHRzXG4gICQkLnN0eWZuLmNsZWFyID0gZnVuY3Rpb24oKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHRoaXNbaV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB0aGlzLl9wcml2YXRlLm5ld1N0eWxlID0gdHJ1ZTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gICQkLnN0eWZuLnJlc2V0VG9EZWZhdWx0ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5hZGREZWZhdWx0U3R5bGVzaGVldCgpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gYnVpbGRzIGEgc3R5bGUgb2JqZWN0IGZvciB0aGUgJ2NvcmUnIHNlbGVjdG9yXG4gICQkLnN0eWZuLmNvcmUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmNvcmVTdHlsZTtcbiAgfTtcblxuICAvLyBwYXJzZSBhIHByb3BlcnR5OyByZXR1cm4gbnVsbCBvbiBpbnZhbGlkOyByZXR1cm4gcGFyc2VkIHByb3BlcnR5IG90aGVyd2lzZVxuICAvLyBmaWVsZHMgOlxuICAvLyAtIG5hbWUgOiB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgLy8gLSB2YWx1ZSA6IHRoZSBwYXJzZWQsIG5hdGl2ZS10eXBlZCB2YWx1ZSBvZiB0aGUgcHJvcGVydHlcbiAgLy8gLSBzdHJWYWx1ZSA6IGEgc3RyaW5nIHZhbHVlIHRoYXQgcmVwcmVzZW50cyB0aGUgcHJvcGVydHkgdmFsdWUgaW4gdmFsaWQgY3NzXG4gIC8vIC0gYnlwYXNzIDogdHJ1ZSBpZmYgdGhlIHByb3BlcnR5IGlzIGEgYnlwYXNzIHByb3BlcnR5XG4gICQkLnN0eWZuLnBhcnNlID0gZnVuY3Rpb24oIG5hbWUsIHZhbHVlLCBwcm9wSXNCeXBhc3MsIHByb3BJc0ZsYXQgKXtcblxuICAgIG5hbWUgPSAkJC51dGlsLmNhbWVsMmRhc2goIG5hbWUgKTsgLy8gbWFrZSBzdXJlIHRoZSBwcm9wZXJ0eSBuYW1lIGlzIGluIGRhc2ggZm9ybSAoZS5nLiAncHJvcGVydHktbmFtZScgbm90ICdwcm9wZXJ0eU5hbWUnKVxuICAgIHZhciBwcm9wZXJ0eSA9ICQkLnN0eWxlLnByb3BlcnRpZXNbIG5hbWUgXTtcbiAgICB2YXIgcGFzc2VkVmFsdWUgPSB2YWx1ZTtcbiAgICB2YXIgdHlwZXMgPSAkJC5zdHlsZS50eXBlcztcblxuICAgIGlmKCAhcHJvcGVydHkgKXsgcmV0dXJuIG51bGw7IH0gLy8gcmV0dXJuIG51bGwgb24gcHJvcGVydHkgb2YgdW5rbm93biBuYW1lXG4gICAgaWYoIHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwgKXsgcmV0dXJuIG51bGw7IH0gLy8gY2FuJ3QgYXNzaWduIG51bGxcblxuICAgIHZhciB2YWx1ZUlzU3RyaW5nID0gJCQuaXMuc3RyaW5nKHZhbHVlKTtcbiAgICBpZiggdmFsdWVJc1N0cmluZyApeyAvLyB0cmltIHRoZSB2YWx1ZSB0byBtYWtlIHBhcnNpbmcgZWFzaWVyXG4gICAgICB2YWx1ZSA9ICQkLnV0aWwudHJpbSggdmFsdWUgKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHByb3BlcnR5LnR5cGU7XG4gICAgaWYoICF0eXBlICl7IHJldHVybiBudWxsOyB9IC8vIG5vIHR5cGUsIG5vIGx1Y2tcblxuICAgIC8vIGNoZWNrIGlmIGJ5cGFzcyBpcyBudWxsIG9yIGVtcHR5IHN0cmluZyAoaS5lLiBpbmRpY2F0aW9uIHRvIGRlbGV0ZSBieXBhc3MgcHJvcGVydHkpXG4gICAgaWYoIHByb3BJc0J5cGFzcyAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBudWxsKSApe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBieXBhc3M6IHRydWUsXG4gICAgICAgIGRlbGV0ZUJ5cGFzczogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgaGFzUGllID0gbmFtZS5tYXRjaCgvcGllLShcXGQrKS1iYWNrZ3JvdW5kLXNpemUvKTtcblxuICAgIC8vIGNoZWNrIGlmIHZhbHVlIGlzIGEgZnVuY3Rpb24gdXNlZCBhcyBhIG1hcHBlclxuICAgIGlmKCAkJC5pcy5mbih2YWx1ZSkgKXtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgc3RyVmFsdWU6ICdmbicsXG4gICAgICAgIG1hcHBlZDogdHlwZXMuZm4sXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgICBoYXNQaWU6IGhhc1BpZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB2YWx1ZSBpcyBtYXBwZWRcbiAgICB2YXIgZGF0YSwgbWFwRGF0YSwgbGF5b3V0RGF0YSwgbWFwTGF5b3V0RGF0YSwgc2NyYXRjaCwgbWFwU2NyYXRjaDtcbiAgICBpZiggIXZhbHVlSXNTdHJpbmcgfHwgcHJvcElzRmxhdCApe1xuICAgICAgLy8gdGhlbiBkb24ndCBib3RoZXIgdG8gZG8gdGhlIGV4cGVuc2l2ZSByZWdleCBjaGVja3NcblxuICAgIH0gZWxzZSBpZihcbiAgICAgICggZGF0YSA9IG5ldyBSZWdFeHAoIHR5cGVzLmRhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApICkgfHxcbiAgICAgICggbGF5b3V0RGF0YSA9IG5ldyBSZWdFeHAoIHR5cGVzLmxheW91dERhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApICkgfHxcbiAgICAgICggc2NyYXRjaCA9IG5ldyBSZWdFeHAoIHR5cGVzLnNjcmF0Y2gucmVnZXggKS5leGVjKCB2YWx1ZSApIClcbiAgICApe1xuICAgICAgaWYoIHByb3BJc0J5cGFzcyApeyByZXR1cm4gZmFsc2U7IH0gLy8gbWFwcGVycyBub3QgYWxsb3dlZCBpbiBieXBhc3NcblxuICAgICAgdmFyIG1hcHBlZDtcbiAgICAgIGlmKCBkYXRhICl7XG4gICAgICAgIG1hcHBlZCA9IHR5cGVzLmRhdGE7XG4gICAgICB9IGVsc2UgaWYoIGxheW91dERhdGEgKXtcbiAgICAgICAgbWFwcGVkID0gdHlwZXMubGF5b3V0RGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlZCA9IHR5cGVzLnNjcmF0Y2g7XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSBkYXRhIHx8IGxheW91dERhdGEgfHwgc2NyYXRjaDtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IGRhdGEsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBtYXBwZWQ6IG1hcHBlZCxcbiAgICAgICAgZmllbGQ6IGRhdGFbMV0sXG4gICAgICAgIGJ5cGFzczogcHJvcElzQnlwYXNzLFxuICAgICAgICBoYXNQaWU6IGhhc1BpZVxuICAgICAgfTtcblxuICAgIH0gZWxzZSBpZihcbiAgICAgICggbWFwRGF0YSA9IG5ldyBSZWdFeHAoIHR5cGVzLm1hcERhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApICkgfHxcbiAgICAgICggbWFwTGF5b3V0RGF0YSA9IG5ldyBSZWdFeHAoIHR5cGVzLm1hcExheW91dERhdGEucmVnZXggKS5leGVjKCB2YWx1ZSApICkgfHxcbiAgICAgICggbWFwU2NyYXRjaCA9IG5ldyBSZWdFeHAoIHR5cGVzLm1hcFNjcmF0Y2gucmVnZXggKS5leGVjKCB2YWx1ZSApIClcbiAgICApe1xuICAgICAgaWYoIHByb3BJc0J5cGFzcyApeyByZXR1cm4gZmFsc2U7IH0gLy8gbWFwcGVycyBub3QgYWxsb3dlZCBpbiBieXBhc3NcblxuICAgICAgdmFyIG1hcHBlZDtcbiAgICAgIGlmKCBtYXBEYXRhICl7XG4gICAgICAgIG1hcHBlZCA9IHR5cGVzLm1hcERhdGE7XG4gICAgICB9IGVsc2UgaWYoIG1hcExheW91dERhdGEgKXtcbiAgICAgICAgbWFwcGVkID0gdHlwZXMubWFwTGF5b3V0RGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBlZCA9IHR5cGVzLm1hcFNjcmF0Y2g7XG4gICAgICB9XG5cbiAgICAgIG1hcERhdGEgPSBtYXBEYXRhIHx8IG1hcExheW91dERhdGEgfHwgbWFwU2NyYXRjaDtcblxuICAgICAgLy8gd2UgY2FuIG1hcCBvbmx5IGlmIHRoZSB0eXBlIGlzIGEgY29sb3VyIG9yIGEgbnVtYmVyXG4gICAgICBpZiggISh0eXBlLmNvbG9yIHx8IHR5cGUubnVtYmVyKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgdmFyIHZhbHVlTWluID0gdGhpcy5wYXJzZSggbmFtZSwgbWFwRGF0YVs0XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG4gICAgICBpZiggIXZhbHVlTWluIHx8IHZhbHVlTWluLm1hcHBlZCApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgICAgdmFyIHZhbHVlTWF4ID0gdGhpcy5wYXJzZSggbmFtZSwgbWFwRGF0YVs1XSk7IC8vIHBhcnNlIHRvIHZhbGlkYXRlXG4gICAgICBpZiggIXZhbHVlTWF4IHx8IHZhbHVlTWF4Lm1hcHBlZCApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgYmUgaW52YWxpZCBvciBtYXBwZWRcblxuICAgICAgLy8gY2hlY2sgaWYgdmFsdWVNaW4gYW5kIHZhbHVlTWF4IGFyZSB0aGUgc2FtZVxuICAgICAgaWYoIHZhbHVlTWluLnZhbHVlID09PSB2YWx1ZU1heC52YWx1ZSApe1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIGNhbid0IG1ha2UgbXVjaCBvZiBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcblxuICAgICAgfSBlbHNlIGlmKCB0eXBlLmNvbG9yICl7XG4gICAgICAgIHZhciBjMSA9IHZhbHVlTWluLnZhbHVlO1xuICAgICAgICB2YXIgYzIgPSB2YWx1ZU1heC52YWx1ZTtcblxuICAgICAgICB2YXIgc2FtZSA9IGMxWzBdID09PSBjMlswXSAvLyByZWRcbiAgICAgICAgICAmJiBjMVsxXSA9PT0gYzJbMV0gLy8gZ3JlZW5cbiAgICAgICAgICAmJiBjMVsyXSA9PT0gYzJbMl0gLy8gYmx1ZVxuICAgICAgICAgICYmICggLy8gb3B0aW9uYWwgYWxwaGFcbiAgICAgICAgICAgIGMxWzNdID09PSBjMlszXSAvLyBzYW1lIGFscGhhIG91dHJpZ2h0XG4gICAgICAgICAgICB8fCAoXG4gICAgICAgICAgICAgIChjMVszXSA9PSBudWxsIHx8IGMxWzNdID09PSAxKSAvLyBmdWxsIG9wYWNpdHkgZm9yIGNvbG91ciAxP1xuICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgICAoYzJbM10gPT0gbnVsbCB8fCBjMlszXSA9PT0gMSkgLy8gZnVsbCBvcGFjaXR5IGZvciBjb2xvdXIgMj9cbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIDtcblxuICAgICAgICBpZiggc2FtZSApeyByZXR1cm4gZmFsc2U7IH0gLy8gY2FuJ3QgbWFrZSBhIG1hcHBlciB3aXRob3V0IGEgcmFuZ2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IG1hcERhdGEsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBtYXBwZWQ6IG1hcHBlZCxcbiAgICAgICAgZmllbGQ6IG1hcERhdGFbMV0sXG4gICAgICAgIGZpZWxkTWluOiBwYXJzZUZsb2F0KCBtYXBEYXRhWzJdICksIC8vIG1pbiAmIG1heCBhcmUgbnVtZXJpY1xuICAgICAgICBmaWVsZE1heDogcGFyc2VGbG9hdCggbWFwRGF0YVszXSApLFxuICAgICAgICB2YWx1ZU1pbjogdmFsdWVNaW4udmFsdWUsXG4gICAgICAgIHZhbHVlTWF4OiB2YWx1ZU1heC52YWx1ZSxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3MsXG4gICAgICAgIGhhc1BpZTogaGFzUGllXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGNoZWNrIHRoZSB0eXBlIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIG9iamVjdFxuICAgIGlmKCB0eXBlLm51bWJlciApe1xuICAgICAgdmFyIHVuaXRzO1xuICAgICAgdmFyIGltcGxpY2l0VW5pdHMgPSAncHgnOyAvLyBub3Qgc2V0ID0+IHB4XG5cbiAgICAgIGlmKCB0eXBlLnVuaXRzICl7IC8vIHVzZSBzcGVjaWZpZWQgdW5pdHMgaWYgc2V0XG4gICAgICAgIHVuaXRzID0gdHlwZS51bml0cztcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGUuaW1wbGljaXRVbml0cyApe1xuICAgICAgICBpbXBsaWNpdFVuaXRzID0gdHlwZS5pbXBsaWNpdFVuaXRzO1xuICAgICAgfVxuXG4gICAgICBpZiggIXR5cGUudW5pdGxlc3MgKXtcbiAgICAgICAgaWYoIHZhbHVlSXNTdHJpbmcgKXtcbiAgICAgICAgICB2YXIgdW5pdHNSZWdleCA9ICdweHxlbScgKyAodHlwZS5hbGxvd1BlcmNlbnQgPyAnfFxcXFwlJyA6ICcnKTtcbiAgICAgICAgICBpZiggdW5pdHMgKXsgdW5pdHNSZWdleCA9IHVuaXRzOyB9IC8vIG9ubHkgYWxsb3cgZXhwbGljaXQgdW5pdHMgaWYgc28gc2V0XG4gICAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2goICdeKCcgKyAkJC51dGlsLnJlZ2V4Lm51bWJlciArICcpKCcgKyB1bml0c1JlZ2V4ICsgJyk/JyArICckJyApO1xuXG4gICAgICAgICAgaWYoIG1hdGNoICl7XG4gICAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgdW5pdHMgPSBtYXRjaFsyXSB8fCBpbXBsaWNpdFVuaXRzO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYoICF1bml0cyB8fCB0eXBlLmltcGxpY2l0VW5pdHMgKSB7XG4gICAgICAgICAgdW5pdHMgPSBpbXBsaWNpdFVuaXRzOyAvLyBpbXBsaWNpdGx5IHB4IGlmIHVuc3BlY2lmaWVkXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuXG4gICAgICAvLyBpZiBub3QgYSBudW1iZXIgYW5kIGVudW1zIG5vdCBhbGxvd2VkLCB0aGVuIHRoZSB2YWx1ZSBpcyBpbnZhbGlkXG4gICAgICBpZiggaXNOYU4odmFsdWUpICYmIHR5cGUuZW51bXMgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgdGhpcyBudW1iZXIgdHlwZSBhbHNvIGFjY2VwdHMgc3BlY2lhbCBrZXl3b3JkcyBpbiBwbGFjZSBvZiBudW1iZXJzXG4gICAgICAvLyAoaS5lLiBgbGVmdGAsIGBhdXRvYCwgZXRjKVxuICAgICAgaWYoIGlzTmFOKHZhbHVlKSAmJiB0eXBlLmVudW1zICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdmFsdWUgPSBwYXNzZWRWYWx1ZTtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHR5cGUuZW51bXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZW4gPSB0eXBlLmVudW1zW2ldO1xuXG4gICAgICAgICAgaWYoIGVuID09PSB2YWx1ZSApe1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGZhaWxlZCBvbiBlbnVtIGFmdGVyIGZhaWxpbmcgb24gbnVtYmVyXG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGlmIHZhbHVlIG11c3QgYmUgYW4gaW50ZWdlclxuICAgICAgaWYoIHR5cGUuaW50ZWdlciAmJiAhJCQuaXMuaW50ZWdlcih2YWx1ZSkgKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHZhbHVlIGlzIHdpdGhpbiByYW5nZVxuICAgICAgaWYoICh0eXBlLm1pbiAhPT0gdW5kZWZpbmVkICYmIHZhbHVlIDwgdHlwZS5taW4pXG4gICAgICB8fCAodHlwZS5tYXggIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSA+IHR5cGUubWF4KVxuICAgICAgKXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUgKyAodW5pdHMgPyB1bml0cyA6ICcnKSxcbiAgICAgICAgdW5pdHM6IHVuaXRzLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzcyxcbiAgICAgICAgaGFzUGllOiBoYXNQaWUgJiYgdmFsdWUgIT0gbnVsbCAmJiB2YWx1ZSAhPT0gMCAmJiB2YWx1ZSAhPT0gJydcbiAgICAgIH07XG5cbiAgICAgIC8vIG5vcm1hbGlzZSB2YWx1ZSBpbiBwaXhlbHNcbiAgICAgIGlmKCB0eXBlLnVuaXRsZXNzIHx8ICh1bml0cyAhPT0gJ3B4JyAmJiB1bml0cyAhPT0gJ2VtJykgKXtcbiAgICAgICAgLy8gdGhlbiBweFZhbHVlIGRvZXMgbm90IGFwcGx5XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQucHhWYWx1ZSA9ICggdW5pdHMgPT09ICdweCcgfHwgIXVuaXRzID8gKHZhbHVlKSA6ICh0aGlzLmdldEVtU2l6ZUluUGl4ZWxzKCkgKiB2YWx1ZSkgKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm9ybWFsaXNlIHZhbHVlIGluIG1zXG4gICAgICBpZiggdW5pdHMgPT09ICdtcycgfHwgdW5pdHMgPT09ICdzJyApe1xuICAgICAgICByZXQubXNWYWx1ZSA9IHVuaXRzID09PSAnbXMnID8gdmFsdWUgOiAxMDAwICogdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG5cbiAgICB9IGVsc2UgaWYoIHR5cGUucHJvcExpc3QgKSB7XG5cbiAgICAgIHZhciBwcm9wcyA9IFtdO1xuICAgICAgdmFyIHByb3BzU3RyID0gJycgKyB2YWx1ZTtcblxuICAgICAgaWYoIHByb3BzU3RyID09PSAnbm9uZScgKXtcbiAgICAgICAgLy8gbGVhdmUgZW1wdHlcblxuICAgICAgfSBlbHNlIHsgLy8gZ28gb3ZlciBlYWNoIHByb3BcblxuICAgICAgICB2YXIgcHJvcHNTcGxpdCA9IHByb3BzU3RyLnNwbGl0KCcsJyk7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHNTcGxpdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBwcm9wTmFtZSA9ICQkLnV0aWwudHJpbSggcHJvcHNTcGxpdFtpXSApO1xuXG4gICAgICAgICAgaWYoICQkLnN0eWxlLnByb3BlcnRpZXNbcHJvcE5hbWVdICl7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKCBwcm9wTmFtZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwcm9wcy5sZW5ndGggPT09IDAgKXsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogcHJvcHMsXG4gICAgICAgIHN0clZhbHVlOiBwcm9wcy5sZW5ndGggPT09IDAgPyAnbm9uZScgOiBwcm9wcy5qb2luKCcsICcpLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiggdHlwZS5jb2xvciApe1xuICAgICAgdmFyIHR1cGxlID0gJCQudXRpbC5jb2xvcjJ0dXBsZSggdmFsdWUgKTtcblxuICAgICAgaWYoICF0dXBsZSApeyByZXR1cm4gbnVsbDsgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICB2YWx1ZTogdHVwbGUsXG4gICAgICAgIHN0clZhbHVlOiAnJyArIHZhbHVlLFxuICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgfTtcblxuICAgIH0gZWxzZSBpZiggdHlwZS5lbnVtcyApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0eXBlLmVudW1zLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbiA9IHR5cGUuZW51bXNbaV07XG5cbiAgICAgICAgaWYoIGVuID09PSB2YWx1ZSApe1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgICBieXBhc3M6IHByb3BJc0J5cGFzc1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB9IGVsc2UgaWYoIHR5cGUucmVnZXggKXtcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAoIHR5cGUucmVnZXggKTsgLy8gbWFrZSBhIHJlZ2V4IGZyb20gdGhlIHR5cGVcbiAgICAgIHZhciBtID0gcmVnZXguZXhlYyggdmFsdWUgKTtcblxuICAgICAgaWYoIG0gKXsgLy8gcmVnZXggbWF0Y2hlc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgdmFsdWU6IG0sXG4gICAgICAgICAgc3RyVmFsdWU6ICcnICsgdmFsdWUsXG4gICAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7IC8vIHJlZ2V4IGRvZXNuJ3QgbWF0Y2hcbiAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRpZG4ndCBtYXRjaCB0aGUgcmVnZXggc28gdGhlIHZhbHVlIGlzIGJvZ3VzXG4gICAgICB9XG5cbiAgICB9IGVsc2UgaWYoIHR5cGUuc3RyaW5nICl7XG4gICAgICAvLyBqdXN0IHJldHVyblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBzdHJWYWx1ZTogJycgKyB2YWx1ZSxcbiAgICAgICAgYnlwYXNzOiBwcm9wSXNCeXBhc3NcbiAgICAgIH07XG5cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7IC8vIG5vdCBhIHR5cGUgd2UgY2FuIGhhbmRsZVxuICAgIH1cblxuICB9O1xuXG4gIC8vIGNyZWF0ZSBhIG5ldyBjb250ZXh0IGZyb20gdGhlIHNwZWNpZmllZCBzZWxlY3RvciBzdHJpbmcgYW5kIHN3aXRjaCB0byB0aGF0IGNvbnRleHRcbiAgJCQuc3R5Zm4uc2VsZWN0b3IgPSBmdW5jdGlvbiggc2VsZWN0b3JTdHIgKXtcbiAgICAvLyAnY29yZScgaXMgYSBzcGVjaWFsIGNhc2UgYW5kIGRvZXMgbm90IG5lZWQgYSBzZWxlY3RvclxuICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yU3RyID09PSAnY29yZScgPyBudWxsIDogbmV3ICQkLlNlbGVjdG9yKCBzZWxlY3RvclN0ciApO1xuXG4gICAgdmFyIGkgPSB0aGlzLmxlbmd0aCsrOyAvLyBuZXcgY29udGV4dCBtZWFucyBuZXcgaW5kZXhcbiAgICB0aGlzW2ldID0ge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yLFxuICAgICAgcHJvcGVydGllczogW10sXG4gICAgICBtYXBwZWRQcm9wZXJ0aWVzOiBbXSxcbiAgICAgIGluZGV4OiBpXG4gICAgfTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIGFkZCBvbmUgb3IgbWFueSBjc3MgcnVsZXMgdG8gdGhlIGN1cnJlbnQgY29udGV4dFxuICAkJC5zdHlmbi5jc3MgPSBmdW5jdGlvbigpe1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuXG4gICAgc3dpdGNoKCBhcmdzLmxlbmd0aCApe1xuICAgIGNhc2UgMTpcbiAgICAgIHZhciBtYXAgPSBhcmdzWzBdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgbWFwVmFsID0gbWFwWyBwcm9wLm5hbWUgXTtcblxuICAgICAgICBpZiggbWFwVmFsID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBtYXBWYWwgPSBtYXBbICQkLnV0aWwuZGFzaDJjYW1lbChwcm9wLm5hbWUpIF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiggbWFwVmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICB0aGlzLmNzc1J1bGUoIHByb3AubmFtZSwgbWFwVmFsICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDI6XG4gICAgICB0aGlzLmNzc1J1bGUoIGFyZ3NbMF0sIGFyZ3NbMV0gKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrOyAvLyBkbyBub3RoaW5nIGlmIGFyZ3MgYXJlIGludmFsaWRcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcbiAgJCQuc3R5Zm4uc3R5bGUgPSAkJC5zdHlmbi5jc3M7XG5cbiAgLy8gYWRkIGEgc2luZ2xlIGNzcyBydWxlIHRvIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgJCQuc3R5Zm4uY3NzUnVsZSA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApe1xuICAgIC8vIG5hbWUtdmFsdWUgcGFpclxuICAgIHZhciBwcm9wZXJ0eSA9IHRoaXMucGFyc2UoIG5hbWUsIHZhbHVlICk7XG5cbiAgICAvLyBhZGQgcHJvcGVydHkgdG8gY3VycmVudCBjb250ZXh0IGlmIHZhbGlkXG4gICAgaWYoIHByb3BlcnR5ICl7XG4gICAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKCBwcm9wZXJ0eSApO1xuICAgICAgdGhpc1tpXS5wcm9wZXJ0aWVzWyBwcm9wZXJ0eS5uYW1lIF0gPSBwcm9wZXJ0eTsgLy8gYWxsb3cgYWNjZXNzIGJ5IG5hbWUgYXMgd2VsbFxuXG4gICAgICBpZiggcHJvcGVydHkuaGFzUGllICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuaGFzUGllID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIHByb3BlcnR5Lm1hcHBlZCApe1xuICAgICAgICB0aGlzW2ldLm1hcHBlZFByb3BlcnRpZXMucHVzaCggcHJvcGVydHkgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYWRkIHRvIGNvcmUgc3R5bGUgaWYgbmVjZXNzYXJ5XG4gICAgICB2YXIgY3VycmVudFNlbGVjdG9ySXNDb3JlID0gIXRoaXNbaV0uc2VsZWN0b3I7XG4gICAgICBpZiggY3VycmVudFNlbGVjdG9ySXNDb3JlICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuY29yZVN0eWxlWyBwcm9wZXJ0eS5uYW1lIF0gPSBwcm9wZXJ0eTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIChwb3RlbnRpYWxseSBleHBlbnNpdmUgY2FsY3VsYXRpb24pXG4gIC8vIGFwcGx5IHRoZSBzdHlsZSB0byB0aGUgZWxlbWVudCBiYXNlZCBvblxuICAvLyAtIGl0cyBieXBhc3NcbiAgLy8gLSB3aGF0IHNlbGVjdG9ycyBtYXRjaCBpdFxuICAkJC5zdHlmbi5hcHBseSA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYoIHNlbGYuX3ByaXZhdGUubmV3U3R5bGUgKXsgLy8gY2xlYXIgc3R5bGUgY2FjaGVzXG4gICAgICB0aGlzLl9wcml2YXRlLmNvbnRleHRTdHlsZXMgPSB7fTtcbiAgICAgIHRoaXMuX3ByaXZhdGUucHJvcERpZmZzID0ge307XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaWUgPSAwOyBpZSA8IGVsZXMubGVuZ3RoOyBpZSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1tpZV07XG4gICAgICB2YXIgY3h0TWV0YSA9IHNlbGYuZ2V0Q29udGV4dE1ldGEoIGVsZSApO1xuICAgICAgdmFyIGN4dFN0eWxlID0gc2VsZi5nZXRDb250ZXh0U3R5bGUoIGN4dE1ldGEgKTtcbiAgICAgIHZhciBhcHAgPSBzZWxmLmFwcGx5Q29udGV4dFN0eWxlKCBjeHRNZXRhLCBjeHRTdHlsZSwgZWxlICk7XG5cbiAgICAgIHNlbGYudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgYXBwLmRpZmZQcm9wcyApO1xuICAgICAgc2VsZi51cGRhdGVTdHlsZUhpbnRzKCBlbGUgKTtcblxuICAgIH0gLy8gZm9yIGVsZW1lbnRzXG5cbiAgICBzZWxmLl9wcml2YXRlLm5ld1N0eWxlID0gZmFsc2U7XG4gIH07XG5cbiAgJCQuc3R5Zm4uZ2V0UHJvcGVydGllc0RpZmYgPSBmdW5jdGlvbiggb2xkQ3h0S2V5LCBuZXdDeHRLZXkgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNhY2hlID0gc2VsZi5fcHJpdmF0ZS5wcm9wRGlmZnMgPSBzZWxmLl9wcml2YXRlLnByb3BEaWZmcyB8fCB7fTtcbiAgICB2YXIgZHVhbEN4dEtleSA9IG9sZEN4dEtleSArICctJyArIG5ld0N4dEtleTtcbiAgICB2YXIgY2FjaGVkVmFsID0gY2FjaGVbZHVhbEN4dEtleV07XG5cbiAgICBpZiggY2FjaGVkVmFsICl7XG4gICAgICByZXR1cm4gY2FjaGVkVmFsO1xuICAgIH1cblxuICAgIHZhciBkaWZmUHJvcHMgPSBbXTtcbiAgICB2YXIgYWRkZWRQcm9wID0ge307XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjeHQgPSBzZWxmW2ldO1xuICAgICAgdmFyIG9sZEhhc0N4dCA9IG9sZEN4dEtleVtpXSA9PT0gJ3QnO1xuICAgICAgdmFyIG5ld0hhc0N4dCA9IG5ld0N4dEtleVtpXSA9PT0gJ3QnO1xuICAgICAgdmFyIGN4dEhhc0RpZmZlZCA9IG9sZEhhc0N4dCAhPT0gbmV3SGFzQ3h0O1xuICAgICAgdmFyIGN4dEhhc01hcHBlZFByb3BzID0gY3h0Lm1hcHBlZFByb3BlcnRpZXMubGVuZ3RoID4gMDtcblxuICAgICAgaWYoIGN4dEhhc0RpZmZlZCB8fCBjeHRIYXNNYXBwZWRQcm9wcyApe1xuICAgICAgICB2YXIgcHJvcHM7XG5cbiAgICAgICAgaWYoIGN4dEhhc0RpZmZlZCAmJiBjeHRIYXNNYXBwZWRQcm9wcyApe1xuICAgICAgICAgIHByb3BzID0gY3h0LnByb3BlcnRpZXM7IC8vIHN1ZmZpY2VzIGIvYyBtYXBwZWRQcm9wZXJ0aWVzIGlzIGEgc3Vic2V0IG9mIHByb3BlcnRpZXNcbiAgICAgICAgfSBlbHNlIGlmKCBjeHRIYXNEaWZmZWQgKXtcbiAgICAgICAgICBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzOyAvLyBuZWVkIHRvIGNoZWNrIHRoZW0gYWxsXG4gICAgICAgIH0gZWxzZSBpZiggY3h0SGFzTWFwcGVkUHJvcHMgKXtcbiAgICAgICAgICBwcm9wcyA9IGN4dC5tYXBwZWRQcm9wZXJ0aWVzOyAvLyBvbmx5IG5lZWQgdG8gY2hlY2sgbWFwcGVkXG4gICAgICAgIH1cblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tqXTtcbiAgICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcblxuICAgICAgICAgIC8vIGlmIGEgbGF0ZXIgY29udGV4dCBvdmVycmlkZXMgdGhpcyBwcm9wZXJ0eSwgdGhlbiB0aGUgZmFjdCB0aGF0IHRoaXMgY29udGV4dCBoYXMgc3dpdGNoZWQvZGlmZmVkIGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgLy8gKHNlbWkgZXhwZW5zaXZlIGNoZWNrIHNpbmNlIGl0IG1ha2VzIHRoaXMgZnVuY3Rpb24gTyhuXjIpIG9uIGNvbnRleHQgbGVuZ3RoLCBidXQgd29ydGggaXQgc2luY2Ugb3ZlcmFsbCByZXN1bHRcbiAgICAgICAgICAvLyBpcyBjYWNoZWQpXG4gICAgICAgICAgdmFyIGxhdGVyQ3h0T3ZlcnJpZGVzID0gZmFsc2U7XG4gICAgICAgICAgZm9yKCB2YXIgayA9IGkgKyAxOyBrIDwgc2VsZi5sZW5ndGg7IGsrKyApe1xuICAgICAgICAgICAgdmFyIGxhdGVyQ3h0ID0gc2VsZltrXTtcbiAgICAgICAgICAgIHZhciBoYXNMYXRlckN4dCA9IG5ld0N4dEtleVtrXSA9PT0gJ3QnO1xuXG4gICAgICAgICAgICBpZiggIWhhc0xhdGVyQ3h0ICl7IGNvbnRpbnVlOyB9IC8vIGNhbid0IG92ZXJyaWRlIHVubGVzcyB0aGUgY29udGV4dCBpcyBhY3RpdmVcblxuICAgICAgICAgICAgbGF0ZXJDeHRPdmVycmlkZXMgPSBsYXRlckN4dC5wcm9wZXJ0aWVzWyBwcm9wLm5hbWUgXSAhPSBudWxsO1xuXG4gICAgICAgICAgICBpZiggbGF0ZXJDeHRPdmVycmlkZXMgKXsgYnJlYWs7IH0gLy8gZXhpdCBlYXJseSBhcyBsb25nIGFzIG9uZSBsYXRlciBjb250ZXh0IG92ZXJyaWRlc1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAhYWRkZWRQcm9wW25hbWVdICYmICFsYXRlckN4dE92ZXJyaWRlcyApe1xuICAgICAgICAgICAgYWRkZWRQcm9wW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGRpZmZQcm9wcy5wdXNoKCBuYW1lICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIGZvciBwcm9wc1xuICAgICAgfSAvLyBpZlxuXG4gICAgfSAvLyBmb3IgY29udGV4dHNcblxuICAgIGNhY2hlWyBkdWFsQ3h0S2V5IF0gPSBkaWZmUHJvcHM7XG4gICAgcmV0dXJuIGRpZmZQcm9wcztcbiAgfTtcblxuICAkJC5zdHlmbi5nZXRDb250ZXh0TWV0YSA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGN4dEtleSA9ICcnO1xuICAgIHZhciBkaWZmUHJvcHM7XG4gICAgdmFyIHByZXZLZXkgPSBlbGUuX3ByaXZhdGUuc3R5bGVDeHRLZXkgfHwgJyc7XG5cbiAgICBpZiggc2VsZi5fcHJpdmF0ZS5uZXdTdHlsZSApe1xuICAgICAgcHJldktleSA9ICcnOyAvLyBzaW5jZSB3ZSBuZWVkIHRvIGFwcGx5IGFsbCBzdHlsZSBpZiBhIGZyZXNoIHN0eWxlc2hlZXRcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIGN4dCBrZXlcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjb250ZXh0ID0gc2VsZltpXTtcbiAgICAgIHZhciBjb250ZXh0U2VsZWN0b3JNYXRjaGVzID0gY29udGV4dC5zZWxlY3RvciAmJiBjb250ZXh0LnNlbGVjdG9yLm1hdGNoZXMoIGVsZSApOyAvLyBOQjogY29udGV4dC5zZWxlY3RvciBtYXkgYmUgbnVsbCBmb3IgJ2NvcmUnXG5cbiAgICAgIGlmKCBjb250ZXh0U2VsZWN0b3JNYXRjaGVzICl7XG4gICAgICAgIGN4dEtleSArPSAndCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjeHRLZXkgKz0gJ2YnO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGNvbnRleHRcblxuICAgIGRpZmZQcm9wcyA9IHNlbGYuZ2V0UHJvcGVydGllc0RpZmYoIHByZXZLZXksIGN4dEtleSApO1xuXG4gICAgZWxlLl9wcml2YXRlLnN0eWxlQ3h0S2V5ID0gY3h0S2V5O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogY3h0S2V5LFxuICAgICAgZGlmZlByb3BOYW1lczogZGlmZlByb3BzXG4gICAgfTtcbiAgfTtcblxuICAvLyBnZXRzIGEgY29tcHV0ZWQgZWxlIHN0eWxlIG9iamVjdCBiYXNlZCBvbiBtYXRjaGVkIGNvbnRleHRzXG4gICQkLnN0eWZuLmdldENvbnRleHRTdHlsZSA9IGZ1bmN0aW9uKCBjeHRNZXRhICl7XG4gICAgdmFyIGN4dEtleSA9IGN4dE1ldGEua2V5O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY3h0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzID0gdGhpcy5fcHJpdmF0ZS5jb250ZXh0U3R5bGVzIHx8IHt9O1xuXG4gICAgLy8gaWYgYWxyZWFkeSBjb21wdXRlZCBzdHlsZSwgcmV0dXJuZWQgY2FjaGVkIGNvcHlcbiAgICBpZiggY3h0U3R5bGVzW2N4dEtleV0gKXsgcmV0dXJuIGN4dFN0eWxlc1tjeHRLZXldOyB9XG5cbiAgICB2YXIgc3R5bGUgPSB7XG4gICAgICBfcHJpdmF0ZToge1xuICAgICAgICBrZXk6IGN4dEtleVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjeHQgPSBzZWxmW2ldO1xuICAgICAgdmFyIGhhc0N4dCA9IGN4dEtleVtpXSA9PT0gJ3QnO1xuXG4gICAgICBpZiggIWhhc0N4dCApeyBjb250aW51ZTsgfVxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGN4dC5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBwcm9wID0gY3h0LnByb3BlcnRpZXNbal07XG4gICAgICAgIHZhciBzdHlQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcDtcblxuICAgICAgICBzdHlQcm9wLmNvbnRleHQgPSBjeHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3h0U3R5bGVzW2N4dEtleV0gPSBzdHlsZTtcbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbiAgJCQuc3R5Zm4uYXBwbHlDb250ZXh0U3R5bGUgPSBmdW5jdGlvbiggY3h0TWV0YSwgY3h0U3R5bGUsIGVsZSApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZGlmZlByb3BzID0gY3h0TWV0YS5kaWZmUHJvcE5hbWVzO1xuICAgIHZhciByZXREaWZmUHJvcHMgPSB7fTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGlmZlByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZGlmZlByb3BOYW1lID0gZGlmZlByb3BzW2ldO1xuICAgICAgdmFyIGN4dFByb3AgPSBjeHRTdHlsZVsgZGlmZlByb3BOYW1lIF07XG4gICAgICB2YXIgZWxlUHJvcCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsgZGlmZlByb3BOYW1lIF07XG5cbiAgICAgIC8vIHNhdmUgY3ljbGVzIHdoZW4gdGhlIGNvbnRleHQgcHJvcCBkb2Vzbid0IG5lZWQgdG8gYmUgYXBwbGllZFxuICAgICAgaWYoICFjeHRQcm9wIHx8IGVsZVByb3AgPT09IGN4dFByb3AgKXsgY29udGludWU7IH1cblxuICAgICAgdmFyIHJldERpZmZQcm9wID0gcmV0RGlmZlByb3BzWyBkaWZmUHJvcE5hbWUgXSA9IHtcbiAgICAgICAgcHJldjogZWxlUHJvcFxuICAgICAgfTtcblxuICAgICAgc2VsZi5hcHBseVBhcnNlZFByb3BlcnR5KCBlbGUsIGN4dFByb3AgKTtcblxuICAgICAgcmV0RGlmZlByb3AubmV4dCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsgZGlmZlByb3BOYW1lIF07XG5cbiAgICAgIGlmKCByZXREaWZmUHJvcC5uZXh0ICYmIHJldERpZmZQcm9wLm5leHQuYnlwYXNzICl7XG4gICAgICAgIHJldERpZmZQcm9wLm5leHQgPSByZXREaWZmUHJvcC5uZXh0LmJ5cGFzc2VkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaWZmUHJvcHM6IHJldERpZmZQcm9wc1xuICAgIH07XG4gIH07XG5cbiAgJCQuc3R5Zm4udXBkYXRlU3R5bGVIaW50cyA9IGZ1bmN0aW9uKGVsZSl7XG4gICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcblxuICAgIC8vIHNldCB3aGV0aGVyIGhhcyBwaWUgb3Igbm90OyBmb3IgZ3JlYXRlciBlZmZpY2llbmN5XG4gICAgdmFyIGhhc1BpZSA9IGZhbHNlO1xuICAgIGlmKCBfcC5ncm91cCA9PT0gJ25vZGVzJyAmJiBzZWxmLl9wcml2YXRlLmhhc1BpZSApe1xuICAgICAgZm9yKCB2YXIgaSA9IDE7IGkgPD0gJCQuc3R5bGUucGllQmFja2dyb3VuZE47IGkrKyApeyAvLyAxLi5OXG4gICAgICAgIHZhciBzaXplID0gX3Auc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJ10udmFsdWU7XG5cbiAgICAgICAgaWYoIHNpemUgPiAwICl7XG4gICAgICAgICAgaGFzUGllID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9wLmhhc1BpZSA9IGhhc1BpZTtcblxuICAgIHZhciB0cmFuc2Zvcm0gPSBzdHlsZVsndGV4dC10cmFuc2Zvcm0nXS5zdHJWYWx1ZTtcbiAgICB2YXIgY29udGVudCA9IHN0eWxlWydjb250ZW50J10uc3RyVmFsdWU7XG4gICAgdmFyIGZTdHlsZSA9IHN0eWxlWydmb250LXN0eWxlJ10uc3RyVmFsdWU7XG4gICAgdmFyIHNpemUgPSBzdHlsZVsnZm9udC1zaXplJ10ucHhWYWx1ZSArICdweCc7XG4gICAgdmFyIGZhbWlseSA9IHN0eWxlWydmb250LWZhbWlseSddLnN0clZhbHVlO1xuICAgIC8vIHZhciB2YXJpYW50ID0gc3R5bGVbJ2ZvbnQtdmFyaWFudCddLnN0clZhbHVlO1xuICAgIHZhciB3ZWlnaHQgPSBzdHlsZVsnZm9udC13ZWlnaHQnXS5zdHJWYWx1ZTtcbiAgICB2YXIgdmFsaWduID0gc3R5bGVbJ3RleHQtdmFsaWduJ10uc3RyVmFsdWU7XG4gICAgdmFyIGhhbGlnbiA9IHN0eWxlWyd0ZXh0LXZhbGlnbiddLnN0clZhbHVlO1xuICAgIHZhciBvV2lkdGggPSBzdHlsZVsndGV4dC1vdXRsaW5lLXdpZHRoJ10ucHhWYWx1ZTtcbiAgICB2YXIgd3JhcCA9IHN0eWxlWyd0ZXh0LXdyYXAnXS5zdHJWYWx1ZTtcbiAgICB2YXIgd3JhcFcgPSBzdHlsZVsndGV4dC1tYXgtd2lkdGgnXS5weFZhbHVlO1xuICAgIF9wLmxhYmVsS2V5ID0gZlN0eWxlICsnJCcrIHNpemUgKyckJysgZmFtaWx5ICsnJCcrIHdlaWdodCArJyQnKyBjb250ZW50ICsnJCcrIHRyYW5zZm9ybSArJyQnKyB2YWxpZ24gKyckJysgaGFsaWduICsnJCcrIG9XaWR0aCArICckJyArIHdyYXAgKyAnJCcgKyB3cmFwVztcbiAgICBfcC5mb250S2V5ID0gZlN0eWxlICsnJCcrIHdlaWdodCArJyQnKyBzaXplICsnJCcrIGZhbWlseTtcblxuICAgIHZhciB3aWR0aCA9IHN0eWxlWyd3aWR0aCddLnB4VmFsdWU7XG4gICAgdmFyIGhlaWdodCA9IHN0eWxlWydoZWlnaHQnXS5weFZhbHVlO1xuICAgIHZhciBib3JkZXJXID0gc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWU7XG4gICAgX3AuYm91bmRpbmdCb3hLZXkgPSB3aWR0aCArJyQnKyBoZWlnaHQgKyckJysgYm9yZGVyVztcblxuICAgIGlmKCBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdlZGdlcycgKXtcbiAgICAgIHZhciBjcHNzID0gc3R5bGVbJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJ10ucHhWYWx1ZTtcbiAgICAgIHZhciBjcGQgPSBzdHlsZVsnY29udHJvbC1wb2ludC1kaXN0YW5jZSddID8gc3R5bGVbJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnXS5weFZhbHVlIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGNwdyA9IHN0eWxlWydjb250cm9sLXBvaW50LXdlaWdodCddLnZhbHVlO1xuICAgICAgdmFyIGN1cnZlID0gc3R5bGVbJ2N1cnZlLXN0eWxlJ10uc3RyVmFsdWU7XG5cbiAgICAgIF9wLmJvdW5kaW5nQm94S2V5ICs9ICckJysgY3BzcyArJyQnKyBjcGQgKyckJysgY3B3ICsnJCcrIGN1cnZlO1xuICAgIH1cblxuICAgIF9wLnN0eWxlS2V5ID0gRGF0ZS5ub3coKTsgLy8gcHJvYmFibHkgc2FmZSB0byB1c2UgYXBwbGllZCB0aW1lIGFuZCBtdWNoIGZhc3RlclxuICAgIC8vIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgIC8vICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgIC8vICAgdmFyIGVsZVByb3AgPSBfcC5zdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgLy8gICB2YXIgdmFsID0gZWxlUHJvcCAmJiBlbGVQcm9wLnN0clZhbHVlID8gZWxlUHJvcC5zdHJWYWx1ZSA6ICd1bmRlZmluZWQnO1xuXG4gICAgLy8gICBfcC5zdHlsZUtleSArPSAnJCcgKyB2YWw7XG4gICAgLy8gfVxuICB9O1xuXG4gIC8vIGFwcGx5IGEgcHJvcGVydHkgdG8gdGhlIHN0eWxlIChmb3IgaW50ZXJuYWwgdXNlKVxuICAvLyByZXR1cm5zIHdoZXRoZXIgYXBwbGljYXRpb24gd2FzIHN1Y2Nlc3NmdWxcbiAgLy9cbiAgLy8gbm93LCB0aGlzIGZ1bmN0aW9uIGZsYXR0ZW5zIHRoZSBwcm9wZXJ0eSwgYW5kIGhlcmUncyBob3c6XG4gIC8vXG4gIC8vIGZvciBwYXJzZWRQcm9wOnsgYnlwYXNzOiB0cnVlLCBkZWxldGVCeXBhc3M6IHRydWUgfVxuICAvLyBubyBwcm9wZXJ0eSBpcyBnZW5lcmF0ZWQsIGluc3RlYWQgdGhlIGJ5cGFzcyBwcm9wZXJ0eSBpbiB0aGVcbiAgLy8gZWxlbWVudCdzIHN0eWxlIGlzIHJlcGxhY2VkIGJ5IHdoYXQncyBwb2ludGVkIHRvIGJ5IHRoZSBgYnlwYXNzZWRgXG4gIC8vIGZpZWxkIGluIHRoZSBieXBhc3MgcHJvcGVydHkgKGkuZS4gcmVzdG9yaW5nIHRoZSBwcm9wZXJ0eSB0aGVcbiAgLy8gYnlwYXNzIHdhcyBvdmVycmlkaW5nKVxuICAvL1xuICAvLyBmb3IgcGFyc2VkUHJvcDp7IG1hcHBlZDogdHJ1dGh5IH1cbiAgLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgbWFwcGluZzogcHJvcCB9XG4gIC8vXG4gIC8vIGZvciBwYXJzZWRQcm9wOnsgYnlwYXNzOiB0cnVlIH1cbiAgLy8gdGhlIGdlbmVyYXRlZCBmbGF0dGVuZWRQcm9wOnsgYnlwYXNzZWQ6IHBhcnNlZFByb3AgfVxuICAkJC5zdHlmbi5hcHBseVBhcnNlZFByb3BlcnR5ID0gZnVuY3Rpb24oIGVsZSwgcGFyc2VkUHJvcCApe1xuICAgIHZhciBwcm9wID0gcGFyc2VkUHJvcDtcbiAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIGZpZWxkVmFsLCBmbGF0UHJvcDtcbiAgICB2YXIgdHlwZXMgPSAkJC5zdHlsZS50eXBlcztcbiAgICB2YXIgdHlwZSA9ICQkLnN0eWxlLnByb3BlcnRpZXNbIHByb3AubmFtZSBdLnR5cGU7XG4gICAgdmFyIHByb3BJc0J5cGFzcyA9IHByb3AuYnlwYXNzO1xuICAgIHZhciBvcmlnUHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICB2YXIgb3JpZ1Byb3BJc0J5cGFzcyA9IG9yaWdQcm9wICYmIG9yaWdQcm9wLmJ5cGFzcztcbiAgICB2YXIgX3AgPSBlbGUuX3ByaXZhdGU7XG5cbiAgICAvLyBjYW4ndCBhcHBseSBhdXRvIHRvIHdpZHRoIG9yIGhlaWdodCB1bmxlc3MgaXQncyBhIHBhcmVudCBub2RlXG4gICAgaWYoIChwYXJzZWRQcm9wLm5hbWUgPT09ICdoZWlnaHQnIHx8IHBhcnNlZFByb3AubmFtZSA9PT0gJ3dpZHRoJykgJiYgZWxlLmlzTm9kZSgpICl7XG4gICAgICBpZiggcGFyc2VkUHJvcC52YWx1ZSA9PT0gJ2F1dG8nICYmICFlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYoIHBhcnNlZFByb3AudmFsdWUgIT09ICdhdXRvJyAmJiBlbGUuaXNQYXJlbnQoKSApe1xuICAgICAgICBwcm9wID0gcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UoIHBhcnNlZFByb3AubmFtZSwgJ2F1dG8nLCBwcm9wSXNCeXBhc3MgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBieXBhc3NcbiAgICBpZiggcHJvcElzQnlwYXNzICYmIHByb3AuZGVsZXRlQnlwYXNzICl7IC8vIHRoZW4gdGhpcyBwcm9wZXJ0eSBpcyBqdXN0IGhlcmUgdG8gaW5kaWNhdGUgd2UgbmVlZCB0byBkZWxldGVcbiAgICAgIHZhciBjdXJyZW50UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcblxuICAgICAgLy8gY2FuIG9ubHkgZGVsZXRlIGlmIHRoZSBjdXJyZW50IHByb3AgaXMgYSBieXBhc3MgYW5kIGl0IHBvaW50cyB0byB0aGUgcHJvcGVydHkgaXQgd2FzIG92ZXJyaWRpbmdcbiAgICAgIGlmKCAhY3VycmVudFByb3AgKXtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIHByb3BlcnR5IGlzIGFscmVhZHkgbm90IGRlZmluZWRcbiAgICAgIH0gZWxzZSBpZiggY3VycmVudFByb3AuYnlwYXNzICYmIGN1cnJlbnRQcm9wLmJ5cGFzc2VkICl7IC8vIHRoZW4gcmVwbGFjZSB0aGUgYnlwYXNzIHByb3BlcnR5IHdpdGggdGhlIG9yaWdpbmFsXG5cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYnlwYXNzZWQgcHJvcGVydHkgd2FzIGFscmVhZHkgYXBwbGllZCAoYW5kIHRoZXJlZm9yZSBwYXJzZWQpLCB3ZSBjYW4ganVzdCByZXBsYWNlIGl0IChubyByZWFwcGx5aW5nIG5lY2Vzc2FyeSlcbiAgICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gY3VycmVudFByb3AuYnlwYXNzZWQ7XG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHdlJ3JlIHVuc3VjY2Vzc2Z1bCBkZWxldGluZyB0aGUgYnlwYXNzXG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByaW50TWFwcGluZ0VyciA9IGZ1bmN0aW9uKCl7XG4gICAgICAkJC51dGlsLmVycm9yKCdEbyBub3QgYXNzaWduIG1hcHBpbmdzIHRvIGVsZW1lbnRzIHdpdGhvdXQgY29ycmVzcG9uZGluZyBkYXRhIChlLmcuIGVsZSBgJysgZWxlLmlkKCkgKydgIGZvciBwcm9wZXJ0eSBgJysgcHJvcC5uYW1lICsnYCB3aXRoIGRhdGEgZmllbGQgYCcrIHByb3AuZmllbGQgKydgKTsgdHJ5IGEgYFsnKyBwcm9wLmZpZWxkICsnXWAgc2VsZWN0b3IgdG8gbGltaXQgc2NvcGUgdG8gZWxlbWVudHMgd2l0aCBgJysgcHJvcC5maWVsZCArJ2AgZGVmaW5lZCcpO1xuICAgIH07XG5cbiAgICAvLyBwdXQgdGhlIHByb3BlcnR5IGluIHRoZSBzdHlsZSBvYmplY3RzXG4gICAgc3dpdGNoKCBwcm9wLm1hcHBlZCApeyAvLyBmbGF0dGVuIHRoZSBwcm9wZXJ0eSBpZiBtYXBwZWRcbiAgICBjYXNlIHR5cGVzLm1hcERhdGE6XG4gICAgY2FzZSB0eXBlcy5tYXBMYXlvdXREYXRhOlxuICAgIGNhc2UgdHlwZXMubWFwU2NyYXRjaDpcblxuICAgICAgdmFyIGlzTGF5b3V0ID0gcHJvcC5tYXBwZWQgPT09IHR5cGVzLm1hcExheW91dERhdGE7XG4gICAgICB2YXIgaXNTY3JhdGNoID0gcHJvcC5tYXBwZWQgPT09IHR5cGVzLm1hcFNjcmF0Y2g7XG5cbiAgICAgIC8vIGZsYXR0ZW4gdGhlIGZpZWxkIChlLmcuIGRhdGEuZm9vLmJhcilcbiAgICAgIHZhciBmaWVsZHMgPSBwcm9wLmZpZWxkLnNwbGl0KFwiLlwiKTtcbiAgICAgIHZhciBmaWVsZFZhbDtcblxuICAgICAgaWYoIGlzU2NyYXRjaCB8fCBpc0xheW91dCApe1xuICAgICAgICBmaWVsZFZhbCA9IF9wLnNjcmF0Y2g7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWVsZFZhbCA9IF9wLmRhdGE7XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aCAmJiBmaWVsZFZhbDsgaSsrICl7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgZmllbGRWYWwgPSBmaWVsZFZhbFsgZmllbGQgXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBlcmNlbnQ7XG4gICAgICBpZiggISQkLmlzLm51bWJlcihmaWVsZFZhbCkgKXsgLy8gdGhlbiBrZWVwIHRoZSBtYXBwaW5nIGJ1dCBhc3N1bWUgMCUgZm9yIG5vd1xuICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlcmNlbnQgPSAoZmllbGRWYWwgLSBwcm9wLmZpZWxkTWluKSAvIChwcm9wLmZpZWxkTWF4IC0gcHJvcC5maWVsZE1pbik7XG4gICAgICB9XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSB0byBib3VuZCBwZXJjZW50IHZhbHVlXG4gICAgICBpZiggcGVyY2VudCA8IDAgKXtcbiAgICAgICAgcGVyY2VudCA9IDA7XG4gICAgICB9IGVsc2UgaWYoIHBlcmNlbnQgPiAxICl7XG4gICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgfVxuXG4gICAgICBpZiggdHlwZS5jb2xvciApe1xuICAgICAgICB2YXIgcjEgPSBwcm9wLnZhbHVlTWluWzBdO1xuICAgICAgICB2YXIgcjIgPSBwcm9wLnZhbHVlTWF4WzBdO1xuICAgICAgICB2YXIgZzEgPSBwcm9wLnZhbHVlTWluWzFdO1xuICAgICAgICB2YXIgZzIgPSBwcm9wLnZhbHVlTWF4WzFdO1xuICAgICAgICB2YXIgYjEgPSBwcm9wLnZhbHVlTWluWzJdO1xuICAgICAgICB2YXIgYjIgPSBwcm9wLnZhbHVlTWF4WzJdO1xuICAgICAgICB2YXIgYTEgPSBwcm9wLnZhbHVlTWluWzNdID09IG51bGwgPyAxIDogcHJvcC52YWx1ZU1pblszXTtcbiAgICAgICAgdmFyIGEyID0gcHJvcC52YWx1ZU1heFszXSA9PSBudWxsID8gMSA6IHByb3AudmFsdWVNYXhbM107XG5cbiAgICAgICAgdmFyIGNsciA9IFtcbiAgICAgICAgICBNYXRoLnJvdW5kKCByMSArIChyMiAtIHIxKSpwZXJjZW50ICksXG4gICAgICAgICAgTWF0aC5yb3VuZCggZzEgKyAoZzIgLSBnMSkqcGVyY2VudCApLFxuICAgICAgICAgIE1hdGgucm91bmQoIGIxICsgKGIyIC0gYjEpKnBlcmNlbnQgKSxcbiAgICAgICAgICBNYXRoLnJvdW5kKCBhMSArIChhMiAtIGExKSpwZXJjZW50IClcbiAgICAgICAgXTtcblxuICAgICAgICBmbGF0UHJvcCA9IHsgLy8gY29sb3VycyBhcmUgc2ltcGxlLCBzbyBqdXN0IGNyZWF0ZSB0aGUgZmxhdCBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGV4cGVuc2l2ZSBzdHJpbmcgcGFyc2luZ1xuICAgICAgICAgIGJ5cGFzczogcHJvcC5ieXBhc3MsIC8vIHdlJ3JlIGEgYnlwYXNzIGlmIHRoZSBtYXBwaW5nIHByb3BlcnR5IGlzIGEgYnlwYXNzXG4gICAgICAgICAgbmFtZTogcHJvcC5uYW1lLFxuICAgICAgICAgIHZhbHVlOiBjbHIsXG4gICAgICAgICAgc3RyVmFsdWU6ICdyZ2IoJyArIGNsclswXSArICcsICcgKyBjbHJbMV0gKyAnLCAnICsgY2xyWzJdICsgJyknXG4gICAgICAgIH07XG5cbiAgICAgIH0gZWxzZSBpZiggdHlwZS5udW1iZXIgKXtcbiAgICAgICAgdmFyIGNhbGNWYWx1ZSA9IHByb3AudmFsdWVNaW4gKyAocHJvcC52YWx1ZU1heCAtIHByb3AudmFsdWVNaW4pICogcGVyY2VudDtcbiAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIGNhbGNWYWx1ZSwgcHJvcC5ieXBhc3MsIHRydWUgKTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBjYW4gb25seSBtYXAgdG8gY29sb3VycyBhbmQgbnVtYmVyc1xuICAgICAgfVxuXG4gICAgICBpZiggIWZsYXRQcm9wICl7IC8vIGlmIHdlIGNhbid0IGZsYXR0ZW4gdGhlIHByb3BlcnR5LCB0aGVuIHVzZSB0aGUgb3JpZ1Byb3Agc28gd2Ugc3RpbGwga2VlcCB0aGUgbWFwcGluZyBpdHNlbGZcbiAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIG9yaWdQcm9wLnN0clZhbHVlLCBwcm9wLmJ5cGFzcywgdHJ1ZSApO1xuICAgICAgfVxuXG4gICAgICBpZiggIWZsYXRQcm9wICl7IHByaW50TWFwcGluZ0VycigpOyB9XG4gICAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICBicmVhaztcblxuICAgIC8vIGRpcmVjdCBtYXBwaW5nXG4gICAgY2FzZSB0eXBlcy5kYXRhOlxuICAgIGNhc2UgdHlwZXMubGF5b3V0RGF0YTpcbiAgICBjYXNlIHR5cGVzLnNjcmF0Y2g6XG4gICAgICB2YXIgaXNMYXlvdXQgPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMubGF5b3V0RGF0YTtcbiAgICAgIHZhciBpc1NjcmF0Y2ggPSBwcm9wLm1hcHBlZCA9PT0gdHlwZXMuc2NyYXRjaDtcblxuICAgICAgLy8gZmxhdHRlbiB0aGUgZmllbGQgKGUuZy4gZGF0YS5mb28uYmFyKVxuICAgICAgdmFyIGZpZWxkcyA9IHByb3AuZmllbGQuc3BsaXQoXCIuXCIpO1xuICAgICAgdmFyIGZpZWxkVmFsO1xuXG4gICAgICBpZiggaXNTY3JhdGNoIHx8IGlzTGF5b3V0ICl7XG4gICAgICAgIGZpZWxkVmFsID0gX3Auc2NyYXRjaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpZWxkVmFsID0gX3AuZGF0YTtcbiAgICAgIH1cblxuICAgICAgaWYoIGZpZWxkVmFsICl7IGZvciggdmFyIGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgZmllbGRWYWwgPSBmaWVsZFZhbFsgZmllbGQgXTtcbiAgICAgIH0gfVxuXG4gICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgZmllbGRWYWwsIHByb3AuYnlwYXNzLCB0cnVlICk7XG5cbiAgICAgIGlmKCAhZmxhdFByb3AgKXsgLy8gaWYgd2UgY2FuJ3QgZmxhdHRlbiB0aGUgcHJvcGVydHksIHRoZW4gdXNlIHRoZSBvcmlnUHJvcCBzbyB3ZSBzdGlsbCBrZWVwIHRoZSBtYXBwaW5nIGl0c2VsZlxuICAgICAgICB2YXIgZmxhdFByb3BWYWwgPSBvcmlnUHJvcCA/IG9yaWdQcm9wLnN0clZhbHVlIDogJyc7XG5cbiAgICAgICAgZmxhdFByb3AgPSB0aGlzLnBhcnNlKCBwcm9wLm5hbWUsIGZsYXRQcm9wVmFsLCBwcm9wLmJ5cGFzcywgdHJ1ZSApO1xuICAgICAgfVxuXG4gICAgICBpZiggIWZsYXRQcm9wICl7IHByaW50TWFwcGluZ0VycigpOyB9XG4gICAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgdHlwZXMuZm46XG4gICAgICB2YXIgZm4gPSBwcm9wLnZhbHVlO1xuICAgICAgdmFyIGZuUmV0VmFsID0gZm4oIGVsZSApO1xuXG4gICAgICBmbGF0UHJvcCA9IHRoaXMucGFyc2UoIHByb3AubmFtZSwgZm5SZXRWYWwsIHByb3AuYnlwYXNzLCB0cnVlICk7XG4gICAgICBmbGF0UHJvcC5tYXBwaW5nID0gcHJvcDsgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgbWFwcGluZ1xuICAgICAgcHJvcCA9IGZsYXRQcm9wOyAvLyB0aGUgZmxhdHRlbmVkIChtYXBwZWQpIHByb3BlcnR5IGlzIHRoZSBvbmUgd2Ugd2FudFxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgYnJlYWs7IC8vIGp1c3Qgc2V0IHRoZSBwcm9wZXJ0eVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTsgLy8gbm90IGEgdmFsaWQgbWFwcGluZ1xuICAgIH1cblxuICAgIC8vIGlmIHRoZSBwcm9wZXJ0eSBpcyBhIGJ5cGFzcyBwcm9wZXJ0eSwgdGhlbiBsaW5rIHRoZSByZXN1bHRhbnQgcHJvcGVydHkgdG8gdGhlIG9yaWdpbmFsIG9uZVxuICAgIGlmKCBwcm9wSXNCeXBhc3MgKXtcbiAgICAgIGlmKCBvcmlnUHJvcElzQnlwYXNzICl7IC8vIHRoZW4gdGhpcyBieXBhc3Mgb3ZlcnJpZGVzIHRoZSBleGlzdGluZyBvbmVcbiAgICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wLmJ5cGFzc2VkOyAvLyBzdGVhbCBieXBhc3NlZCBwcm9wIGZyb20gb2xkIGJ5cGFzc1xuICAgICAgfSBlbHNlIHsgLy8gdGhlbiBsaW5rIHRoZSBvcmlnIHByb3AgdG8gdGhlIG5ldyBieXBhc3NcbiAgICAgICAgcHJvcC5ieXBhc3NlZCA9IG9yaWdQcm9wO1xuICAgICAgfVxuXG4gICAgICBzdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wOyAvLyBhbmQgc2V0XG5cbiAgICB9IGVsc2UgeyAvLyBwcm9wIGlzIG5vdCBieXBhc3NcbiAgICAgIGlmKCBvcmlnUHJvcElzQnlwYXNzICl7IC8vIHRoZW4ga2VlcCB0aGUgb3JpZyBwcm9wIChzaW5jZSBpdCdzIGEgYnlwYXNzKSBhbmQgbGluayB0byB0aGUgbmV3IHByb3BcbiAgICAgICAgb3JpZ1Byb3AuYnlwYXNzZWQgPSBwcm9wO1xuICAgICAgfSBlbHNlIHsgLy8gdGhlbiBqdXN0IHJlcGxhY2UgdGhlIG9sZCBwcm9wIHdpdGggdGhlIG5ldyBvbmVcbiAgICAgICAgc3R5bGVbIHByb3AubmFtZSBdID0gcHJvcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyB1cGRhdGVzIHRoZSB2aXN1YWwgc3R5bGUgZm9yIGFsbCBlbGVtZW50cyAodXNlZnVsIGZvciBtYW51YWwgc3R5bGUgbW9kaWZpY2F0aW9uIGFmdGVyIGluaXQpXG4gICQkLnN0eWZuLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICB2YXIgZWxlcyA9IGN5LmVsZW1lbnRzKCk7XG5cbiAgICBlbGVzLnVwZGF0ZVN0eWxlKCk7XG4gIH07XG5cbiAgLy8ganVzdCB1cGRhdGUgdGhlIGZ1bmN0aW9uYWwgcHJvcGVydGllcyAoaS5lLiBtYXBwaW5ncykgaW4gdGhlIGVsZW1lbnRzJ1xuICAvLyBzdHlsZXMgKGxlc3MgZXhwZW5zaXZlIHRoYW4gcmVjYWxjdWxhdGlvbilcbiAgJCQuc3R5Zm4udXBkYXRlTWFwcGVycyA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7IC8vIGZvciBlYWNoIGVsZVxuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGorKyApeyAvLyBmb3IgZWFjaCBwcm9wXG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tqXTtcbiAgICAgICAgdmFyIHByb3BJblN0eWxlID0gc3R5bGVbIHByb3AubmFtZSBdO1xuXG4gICAgICAgIGlmKCBwcm9wSW5TdHlsZSAmJiBwcm9wSW5TdHlsZS5tYXBwaW5nICl7XG4gICAgICAgICAgdmFyIG1hcHBpbmcgPSBwcm9wSW5TdHlsZS5tYXBwaW5nO1xuICAgICAgICAgIHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eSggZWxlLCBtYXBwaW5nICk7IC8vIHJlYXBwbHkgdGhlIG1hcHBpbmcgcHJvcGVydHlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVN0eWxlSGludHMoIGVsZSApO1xuICAgIH1cbiAgfTtcblxuICAvLyBkaWZmUHJvcHMgOiB7IG5hbWUgPT4geyBwcmV2LCBuZXh0IH0gfVxuICAkJC5zdHlmbi51cGRhdGVUcmFuc2l0aW9ucyA9IGZ1bmN0aW9uKCBlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgdmFyIHByb3BzID0gc3R5bGVbJ3RyYW5zaXRpb24tcHJvcGVydHknXS52YWx1ZTtcbiAgICB2YXIgZHVyYXRpb24gPSBzdHlsZVsndHJhbnNpdGlvbi1kdXJhdGlvbiddLm1zVmFsdWU7XG4gICAgdmFyIGRlbGF5ID0gc3R5bGVbJ3RyYW5zaXRpb24tZGVsYXknXS5tc1ZhbHVlO1xuICAgIHZhciBjc3MgPSB7fTtcblxuICAgIGlmKCBwcm9wcy5sZW5ndGggPiAwICYmIGR1cmF0aW9uID4gMCApe1xuXG4gICAgICAvLyBidWlsZCB1cCB0aGUgc3R5bGUgdG8gYW5pbWF0ZSB0b3dhcmRzXG4gICAgICB2YXIgYW55UHJldiA9IGZhbHNlO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICB2YXIgc3R5UHJvcCA9IHN0eWxlWyBwcm9wIF07XG4gICAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1sgcHJvcCBdO1xuXG4gICAgICAgIGlmKCAhZGlmZlByb3AgKXsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgcHJldlByb3AgPSBkaWZmUHJvcC5wcmV2O1xuICAgICAgICB2YXIgZnJvbVByb3AgPSBwcmV2UHJvcDtcbiAgICAgICAgdmFyIHRvUHJvcCA9IGRpZmZQcm9wLm5leHQgIT0gbnVsbCA/IGRpZmZQcm9wLm5leHQgOiBzdHlQcm9wO1xuICAgICAgICB2YXIgZGlmZiA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCAhZnJvbVByb3AgKXsgY29udGludWU7IH1cblxuICAgICAgICAvLyBjb25zaWRlciBweCB2YWx1ZXNcbiAgICAgICAgaWYoICQkLmlzLm51bWJlciggZnJvbVByb3AucHhWYWx1ZSApICYmICQkLmlzLm51bWJlciggdG9Qcm9wLnB4VmFsdWUgKSApe1xuICAgICAgICAgIGRpZmYgPSBmcm9tUHJvcC5weFZhbHVlICE9PSB0b1Byb3AucHhWYWx1ZTtcblxuICAgICAgICAvLyBjb25zaWRlciBudW1lcmljYWwgdmFsdWVzXG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKCBmcm9tUHJvcC52YWx1ZSApICYmICQkLmlzLm51bWJlciggdG9Qcm9wLnZhbHVlICkgKXtcbiAgICAgICAgICBkaWZmID0gZnJvbVByb3AudmFsdWUgIT09IHRvUHJvcC52YWx1ZTtcblxuICAgICAgICAvLyBjb25zaWRlciBjb2xvdXIgdmFsdWVzXG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMuYXJyYXkoIGZyb21Qcm9wLnZhbHVlICkgJiYgJCQuaXMuYXJyYXkoIHRvUHJvcC52YWx1ZSApICl7XG4gICAgICAgICAgZGlmZiA9IGZyb21Qcm9wLnZhbHVlWzBdICE9PSB0b1Byb3AudmFsdWVbMF1cbiAgICAgICAgICAgIHx8IGZyb21Qcm9wLnZhbHVlWzFdICE9PSB0b1Byb3AudmFsdWVbMV1cbiAgICAgICAgICAgIHx8IGZyb21Qcm9wLnZhbHVlWzJdICE9PSB0b1Byb3AudmFsdWVbMl1cbiAgICAgICAgICA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgdmFsdWUgaXMgZ29vZCBmb3IgYW4gYW5pbWF0aW9uIG9ubHkgaWYgaXQncyBkaWZmZXJlbnRcbiAgICAgICAgaWYoIGRpZmYgKXtcbiAgICAgICAgICBjc3NbIHByb3AgXSA9IHRvUHJvcC5zdHJWYWx1ZTsgLy8gdG8gdmFsXG4gICAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyhlbGUsIHByb3AsIGZyb21Qcm9wLnN0clZhbHVlKTsgLy8gZnJvbSB2YWxcbiAgICAgICAgICBhbnlQcmV2ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICB9IC8vIGVuZCBpZiBwcm9wcyBhbGxvdyBhbmlcblxuICAgICAgLy8gY2FuJ3QgdHJhbnNpdGlvbiBpZiB0aGVyZSdzIG5vdGhpbmcgcHJldmlvdXMgdG8gdHJhbnNpdGlvbiBmcm9tXG4gICAgICBpZiggIWFueVByZXYgKXsgcmV0dXJuOyB9XG5cbiAgICAgIGVsZS5fcHJpdmF0ZS50cmFuc2l0aW9uaW5nID0gdHJ1ZTtcblxuICAgICAgZWxlLnN0b3AoKTtcblxuICAgICAgaWYoIGRlbGF5ID4gMCApe1xuICAgICAgICBlbGUuZGVsYXkoIGRlbGF5ICk7XG4gICAgICB9XG5cbiAgICAgIGVsZS5hbmltYXRlKHtcbiAgICAgICAgY3NzOiBjc3NcbiAgICAgIH0sIHtcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBxdWV1ZTogZmFsc2UsXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpe1xuICAgICAgICAgIGlmKCAhaXNCeXBhc3MgKXtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlQnlwYXNzZXMoIGVsZSwgcHJvcHMgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGUuX3ByaXZhdGUudHJhbnNpdGlvbmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiggZWxlLl9wcml2YXRlLnRyYW5zaXRpb25pbmcgKXtcbiAgICAgIGVsZS5zdG9wKCk7XG5cbiAgICAgIHRoaXMucmVtb3ZlQnlwYXNzZXMoIGVsZSwgcHJvcHMgKTtcblxuICAgICAgZWxlLl9wcml2YXRlLnRyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBieXBhc3NlcyBhcmUgYXBwbGllZCB0byBhbiBleGlzdGluZyBzdHlsZSBvbiBhbiBlbGVtZW50LCBhbmQganVzdCB0YWNrZWQgb24gdGVtcG9yYXJpbHlcbiAgLy8gcmV0dXJucyB0cnVlIGlmZiBhcHBsaWNhdGlvbiB3YXMgc3VjY2Vzc2Z1bCBmb3IgYXQgbGVhc3QgMSBzcGVjaWZpZWQgcHJvcGVydHlcbiAgJCQuc3R5Zm4uYXBwbHlCeXBhc3MgPSBmdW5jdGlvbiggZWxlcywgbmFtZSwgdmFsdWUsIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgdmFyIHByb3BzID0gW107XG4gICAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcbiAgICBcbiAgICAvLyBwdXQgYWxsIHRoZSBwcm9wZXJ0aWVzIChjYW4gc3BlY2lmeSBvbmUgb3IgbWFueSkgaW4gYW4gYXJyYXkgYWZ0ZXIgcGFyc2luZyB0aGVtXG4gICAgaWYoIG5hbWUgPT09IFwiKlwiIHx8IG5hbWUgPT09IFwiKipcIiApeyAvLyBhcHBseSB0byBhbGwgcHJvcGVydHkgbmFtZXNcblxuICAgICAgaWYoIHZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuXG4gICAgICAgICAgdmFyIHBhcnNlZFByb3AgPSB0aGlzLnBhcnNlKG5hbWUsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggcGFyc2VkUHJvcCApe1xuICAgICAgICAgICAgcHJvcHMucHVzaCggcGFyc2VkUHJvcCApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcobmFtZSkgKXsgLy8gdGhlbiBwYXJzZSB0aGUgc2luZ2xlIHByb3BlcnR5XG4gICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuXG4gICAgICBpZiggcGFyc2VkUHJvcCApe1xuICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdChuYW1lKSApeyAvLyB0aGVuIHBhcnNlIGVhY2ggcHJvcGVydHlcbiAgICAgIHZhciBzcGVjaWZpZWRQcm9wcyA9IG5hbWU7XG4gICAgICB1cGRhdGVUcmFuc2l0aW9ucyA9IHZhbHVlO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8ICQkLnN0eWxlLnByb3BlcnRpZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzW2ldO1xuICAgICAgICB2YXIgbmFtZSA9IHByb3AubmFtZTtcbiAgICAgICAgdmFyIHZhbHVlID0gc3BlY2lmaWVkUHJvcHNbIG5hbWUgXTtcblxuICAgICAgICBpZiggdmFsdWUgPT09IHVuZGVmaW5lZCApeyAvLyB0cnkgY2FtZWwgY2FzZSBuYW1lIHRvb1xuICAgICAgICAgIHZhbHVlID0gc3BlY2lmaWVkUHJvcHNbICQkLnV0aWwuZGFzaDJjYW1lbChuYW1lKSBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHZhbHVlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBwYXJzZWRQcm9wICl7XG4gICAgICAgICAgICBwcm9wcy5wdXNoKCBwYXJzZWRQcm9wICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gY2FuJ3QgZG8gYW55dGhpbmcgd2l0aG91dCB3ZWxsIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIHdlJ3ZlIGZhaWxlZCBpZiB0aGVyZSBhcmUgbm8gdmFsaWQgcHJvcGVydGllc1xuICAgIGlmKCBwcm9wcy5sZW5ndGggPT09IDAgKXsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAvLyBub3csIGFwcGx5IHRoZSBieXBhc3MgcHJvcGVydGllcyBvbiB0aGUgZWxlbWVudHNcbiAgICB2YXIgcmV0ID0gZmFsc2U7IC8vIHJldHVybiB0cnVlIGlmIGF0IGxlYXN0IG9uZSBzdWNjZXNmdWwgYnlwYXNzIGFwcGxpZWRcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXsgLy8gZm9yIGVhY2ggZWxlXG4gICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciBkaWZmUHJvcHMgPSB7fTtcbiAgICAgIHZhciBkaWZmUHJvcDtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBwcm9wcy5sZW5ndGg7IGorKyApeyAvLyBmb3IgZWFjaCBwcm9wXG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG5cbiAgICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgICAgdmFyIHByZXZQcm9wID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgICAgICAgIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wLm5hbWUgXSA9IHsgcHJldjogcHJldlByb3AgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IHRoaXMuYXBwbHlQYXJzZWRQcm9wZXJ0eSggZWxlLCBwcm9wICkgfHwgcmV0O1xuXG4gICAgICAgIGlmKCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICAgICAgICAgIGRpZmZQcm9wLm5leHQgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICAgIH1cblxuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVsZXNcblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgLy8gb25seSB1c2VmdWwgaW4gc3BlY2lmaWMgY2FzZXMgbGlrZSBhbmltYXRpb25cbiAgJCQuc3R5Zm4ub3ZlcnJpZGVCeXBhc3MgPSBmdW5jdGlvbiggZWxlcywgbmFtZSwgdmFsdWUgKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIHByb3AgPSBlbGUuX3ByaXZhdGUuc3R5bGVbICQkLnV0aWwuY2FtZWwyZGFzaChuYW1lKSBdO1xuXG4gICAgICBpZiggIXByb3AuYnlwYXNzICl7IC8vIG5lZWQgYSBieXBhc3MgaWYgb25lIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgdGhpcy5hcHBseUJ5cGFzcyggZWxlLCBuYW1lLCB2YWx1ZSApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcHJvcC52YWx1ZSA9IHZhbHVlO1xuICAgICAgcHJvcC5weFZhbHVlID0gdmFsdWU7XG4gICAgfVxuICB9O1xuXG4gICQkLnN0eWZuLnJlbW92ZUFsbEJ5cGFzc2VzID0gZnVuY3Rpb24oIGVsZXMsIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbal07XG4gICAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICB2YXIgdmFsdWUgPSAnJzsgLy8gZW1wdHkgPT4gcmVtb3ZlIGJ5cGFzc1xuICAgICAgICB2YXIgcGFyc2VkUHJvcCA9IHRoaXMucGFyc2UobmFtZSwgdmFsdWUsIHRydWUpO1xuICAgICAgICB2YXIgcHJldlByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG4gICAgICAgIHZhciBkaWZmUHJvcCA9IGRpZmZQcm9wc1sgcHJvcC5uYW1lIF0gPSB7IHByZXY6IHByZXZQcm9wIH07XG5cbiAgICAgICAgdGhpcy5hcHBseVBhcnNlZFByb3BlcnR5KGVsZSwgcGFyc2VkUHJvcCk7XG5cbiAgICAgICAgZGlmZlByb3AubmV4dCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgIH0gLy8gZm9yIHByb3BzXG5cbiAgICAgIGlmKCB1cGRhdGVUcmFuc2l0aW9ucyApe1xuICAgICAgICB0aGlzLnVwZGF0ZVRyYW5zaXRpb25zKCBlbGUsIGRpZmZQcm9wcywgaXNCeXBhc3MgKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvciBlbGVzXG4gIH07XG5cbiAgJCQuc3R5Zm4ucmVtb3ZlQnlwYXNzZXMgPSBmdW5jdGlvbiggZWxlcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgdmFyIGlzQnlwYXNzID0gdHJ1ZTtcblxuICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWxlcy5sZW5ndGg7IGorKyApe1xuICAgICAgdmFyIGVsZSA9IGVsZXNbal07XG4gICAgICB2YXIgZGlmZlByb3BzID0ge307XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5hbWUgPSBwcm9wc1tpXTtcbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzWyBuYW1lIF07XG4gICAgICAgIHZhciB2YWx1ZSA9ICcnOyAvLyBlbXB0eSA9PiByZW1vdmUgYnlwYXNzXG4gICAgICAgIHZhciBwYXJzZWRQcm9wID0gdGhpcy5wYXJzZShuYW1lLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBwcmV2UHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcbiAgICAgICAgdmFyIGRpZmZQcm9wID0gZGlmZlByb3BzWyBwcm9wLm5hbWUgXSA9IHsgcHJldjogcHJldlByb3AgfTtcblxuICAgICAgICB0aGlzLmFwcGx5UGFyc2VkUHJvcGVydHkoZWxlLCBwYXJzZWRQcm9wKTtcblxuICAgICAgICBkaWZmUHJvcC5uZXh0ID0gc3R5bGVbIHByb3AubmFtZSBdO1xuICAgICAgfSAvLyBmb3IgcHJvcHNcblxuICAgICAgaWYoIHVwZGF0ZVRyYW5zaXRpb25zICl7XG4gICAgICAgIHRoaXMudXBkYXRlVHJhbnNpdGlvbnMoIGVsZSwgZGlmZlByb3BzLCBpc0J5cGFzcyApO1xuICAgICAgfVxuICAgIH0gLy8gZm9yIGVsZXNcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCwgd2luZG93KXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGdldHMgd2hhdCBhbiBlbSBzaXplIGNvcnJlc3BvbmRzIHRvIGluIHBpeGVscyByZWxhdGl2ZSB0byBhIGRvbSBlbGVtZW50XG4gICQkLnN0eWZuLmdldEVtU2l6ZUluUGl4ZWxzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBkb21FbGVtZW50ID0gY3kuY29udGFpbmVyKCk7XG5cbiAgICBpZiggd2luZG93ICYmIGRvbUVsZW1lbnQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUgKXtcbiAgICAgIHZhciBweEFzU3RyID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tRWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnZm9udC1zaXplJyk7XG4gICAgICB2YXIgcHggPSBwYXJzZUZsb2F0KCBweEFzU3RyICk7XG4gICAgICByZXR1cm4gcHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAxOyAvLyBpbiBjYXNlIHdlJ3JlIHJ1bm5pbmcgb3V0c2lkZSBvZiB0aGUgYnJvd3NlclxuICAgIH1cbiAgfTtcblxuICAvLyBnZXRzIGNzcyBwcm9wZXJ0eSBmcm9tIHRoZSBjb3JlIGNvbnRhaW5lclxuICAkJC5zdHlmbi5jb250YWluZXJDc3MgPSBmdW5jdGlvbiggcHJvcE5hbWUgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBkb21FbGVtZW50ID0gY3kuY29udGFpbmVyKCk7XG5cbiAgICBpZiggd2luZG93ICYmIGRvbUVsZW1lbnQgJiYgd2luZG93LmdldENvbXB1dGVkU3R5bGUgKXtcbiAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb21FbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCBwcm9wTmFtZSApO1xuICAgIH1cbiAgfTtcblxuICAkJC5zdHlmbi5jb250YWluZXJQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBwcm9wTmFtZSApe1xuICAgIHZhciBwcm9wU3RyID0gdGhpcy5jb250YWluZXJDc3MoIHByb3BOYW1lICk7XG4gICAgdmFyIHByb3AgPSB0aGlzLnBhcnNlKCBwcm9wTmFtZSwgcHJvcFN0ciApO1xuICAgIHJldHVybiBwcm9wO1xuICB9O1xuXG4gICQkLnN0eWZuLmNvbnRhaW5lclByb3BlcnR5QXNTdHJpbmcgPSBmdW5jdGlvbiggcHJvcE5hbWUgKXtcbiAgICB2YXIgcHJvcCA9IHRoaXMuY29udGFpbmVyUHJvcGVydHkoIHByb3BOYW1lICk7XG5cbiAgICBpZiggcHJvcCApe1xuICAgICAgcmV0dXJuIHByb3Auc3RyVmFsdWU7XG4gICAgfVxuICB9O1xuXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gZ2V0cyB0aGUgcmVuZGVyZWQgc3R5bGUgZm9yIGFuIGVsZW1lbnRcbiAgJCQuc3R5Zm4uZ2V0UmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICB2YXIgZWxlID0gZWxlWzBdOyAvLyBpbnN1cmUgaXQncyBhbiBlbGVtZW50XG5cbiAgICBpZiggZWxlICl7XG4gICAgICB2YXIgcnN0eWxlID0ge307XG4gICAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgJCQuc3R5bGUucHJvcGVydGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgcHJvcCA9ICQkLnN0eWxlLnByb3BlcnRpZXNbaV07XG4gICAgICAgIHZhciBzdHlsZVByb3AgPSBzdHlsZVsgcHJvcC5uYW1lIF07XG5cbiAgICAgICAgaWYoIHN0eWxlUHJvcCApe1xuICAgICAgICAgIHZhciB2YWwgPSBzdHlsZVByb3AudW5pdGxlc3MgPyBzdHlsZVByb3Auc3RyVmFsdWUgOiAoc3R5bGVQcm9wLnB4VmFsdWUgKiB6b29tKSArICdweCc7XG4gICAgICAgICAgcnN0eWxlWyBwcm9wLm5hbWUgXSA9IHZhbDtcbiAgICAgICAgICByc3R5bGVbICQkLnV0aWwuZGFzaDJjYW1lbChwcm9wLm5hbWUpIF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJzdHlsZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZ2V0cyB0aGUgcmF3IHN0eWxlIGZvciBhbiBlbGVtZW50XG4gICQkLnN0eWZuLmdldFJhd1N0eWxlID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIHZhciBlbGUgPSBlbGVbMF07IC8vIGluc3VyZSBpdCdzIGFuIGVsZW1lbnRcblxuICAgIGlmKCBlbGUgKXtcbiAgICAgIHZhciByc3R5bGUgPSB7fTtcbiAgICAgIHZhciBzdHlsZSA9IGVsZS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIHN0eWxlUHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXTtcblxuICAgICAgICBpZiggc3R5bGVQcm9wICl7XG4gICAgICAgICAgcnN0eWxlWyBwcm9wLm5hbWUgXSA9IHN0eWxlUHJvcC5zdHJWYWx1ZTtcbiAgICAgICAgICByc3R5bGVbICQkLnV0aWwuZGFzaDJjYW1lbChwcm9wLm5hbWUpIF0gPSBzdHlsZVByb3Auc3RyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJzdHlsZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gZ2V0cyB0aGUgdmFsdWUgc3R5bGUgZm9yIGFuIGVsZW1lbnQgKHVzZWZ1bCBmb3IgdGhpbmdzIGxpa2UgYW5pbWF0aW9ucylcbiAgJCQuc3R5Zm4uZ2V0VmFsdWVTdHlsZSA9IGZ1bmN0aW9uKCBlbGUsIG9wdHMgKXtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICAgIHZhciByc3R5bGUgPSBvcHRzLmFycmF5ID8gW10gOiB7fTsgXG4gICAgdmFyIHN0eWxlO1xuXG4gICAgaWYoICQkLmlzLmVsZW1lbnQoZWxlKSApe1xuICAgICAgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7ICAgIFxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZSA9IGVsZTsgLy8ganVzdCBwYXNzZWQgdGhlIHN0eWxlIGl0c2VsZlxuICAgIH1cblxuICAgIGlmKCBzdHlsZSApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tpXTtcbiAgICAgICAgdmFyIHN0eWxlUHJvcCA9IHN0eWxlWyBwcm9wLm5hbWUgXSB8fCBzdHlsZVsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXTtcblxuICAgICAgICBpZiggc3R5bGVQcm9wICE9PSB1bmRlZmluZWQgJiYgISQkLmlzLnBsYWluT2JqZWN0KCBzdHlsZVByb3AgKSApeyAvLyB0aGVuIG1ha2UgYSBwcm9wIG9mIGl0XG4gICAgICAgICAgc3R5bGVQcm9wID0gdGhpcy5wYXJzZShwcm9wLm5hbWUsIHN0eWxlUHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggc3R5bGVQcm9wICl7XG4gICAgICAgICAgaWYoIG9wdHMuYXJyYXkgKXtcbiAgICAgICAgICAgIHJzdHlsZS5wdXNoKCBzdHlsZVByb3AgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcnN0eWxlWyBwcm9wLm5hbWUgXSA9IHN0eWxlUHJvcDtcbiAgICAgICAgICAgIHJzdHlsZVsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXSA9IHN0eWxlUHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnN0eWxlO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLnN0eWxlLmFwcGx5RnJvbUpzb24gPSBmdW5jdGlvbiggc3R5bGUsIGpzb24gKXtcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGpzb24ubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBjb250ZXh0ID0ganNvbltpXTtcbiAgICAgIHZhciBzZWxlY3RvciA9IGNvbnRleHQuc2VsZWN0b3I7XG4gICAgICB2YXIgcHJvcHMgPSBjb250ZXh0LnN0eWxlIHx8IGNvbnRleHQuY3NzO1xuXG4gICAgICBzdHlsZS5zZWxlY3Rvciggc2VsZWN0b3IgKTsgLy8gYXBwbHkgc2VsZWN0b3JcblxuICAgICAgZm9yKCB2YXIgbmFtZSBpbiBwcm9wcyApe1xuICAgICAgICB2YXIgdmFsdWUgPSBwcm9wc1tuYW1lXTtcblxuICAgICAgICBzdHlsZS5jc3MoIG5hbWUsIHZhbHVlICk7IC8vIGFwcGx5IHByb3BlcnR5XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIC8vIHN0YXRpYyBmdW5jdGlvblxuICAkJC5zdHlsZS5mcm9tSnNvbiA9IGZ1bmN0aW9uKCBjeSwganNvbiApe1xuICAgIHZhciBzdHlsZSA9IG5ldyAkJC5TdHlsZShjeSk7XG5cbiAgICAkJC5zdHlsZS5hcHBseUZyb21Kc29uKCBzdHlsZSwganNvbiApO1xuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIC8vIGFjY2Vzc2libGUgY3kuc3R5bGUoKSBmdW5jdGlvblxuICAkJC5zdHlmbi5mcm9tSnNvbiA9IGZ1bmN0aW9uKCBqc29uICl7XG4gICAgdmFyIHN0eWxlID0gdGhpcztcblxuICAgIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG5cbiAgICAkJC5zdHlsZS5hcHBseUZyb21Kc29uKCBzdHlsZSwganNvbiApO1xuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIC8vIGdldCBqc29uIGZyb20gY3kuc3R5bGUoKSBhcGlcbiAgJCQuc3R5Zm4uanNvbiA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGpzb24gPSBbXTtcblxuICAgIGZvciggdmFyIGkgPSB0aGlzLmRlZmF1bHRMZW5ndGg7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY3h0ID0gdGhpc1tpXTtcbiAgICAgIHZhciBzZWxlY3RvciA9IGN4dC5zZWxlY3RvcjtcbiAgICAgIHZhciBwcm9wcyA9IGN4dC5wcm9wZXJ0aWVzO1xuICAgICAgdmFyIGNzcyA9IHt9O1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG4gICAgICAgIGNzc1sgcHJvcC5uYW1lIF0gPSBwcm9wLnN0clZhbHVlO1xuICAgICAgfVxuXG4gICAgICBqc29uLnB1c2goe1xuICAgICAgICBzZWxlY3RvcjogIXNlbGVjdG9yID8gJ2NvcmUnIDogc2VsZWN0b3IudG9TdHJpbmcoKSxcbiAgICAgICAgc3R5bGU6IGNzc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb247XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuc3R5bGUuYXBwbHlGcm9tU3RyaW5nID0gZnVuY3Rpb24oIHN0eWxlLCBzdHJpbmcgKXtcbiAgICB2YXIgcmVtYWluaW5nID0gJycgKyBzdHJpbmc7XG4gICAgdmFyIHNlbEFuZEJsb2NrU3RyO1xuICAgIHZhciBibG9ja1JlbTtcbiAgICB2YXIgcHJvcEFuZFZhbFN0cjtcblxuICAgIC8vIHJlbW92ZSBjb21tZW50cyBmcm9tIHRoZSBzdHlsZSBzdHJpbmdcbiAgICByZW1haW5pbmcgPSByZW1haW5pbmcucmVwbGFjZSgvWy9dWypdKFxcc3wuKSs/WypdWy9dL2csICcnKTtcblxuICAgIGZ1bmN0aW9uIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpe1xuICAgICAgLy8gcmVtb3ZlIHRoZSBwYXJzZWQgc2VsZWN0b3IgYW5kIGJsb2NrIGZyb20gdGhlIHJlbWFpbmluZyB0ZXh0IHRvIHBhcnNlXG4gICAgICBpZiggcmVtYWluaW5nLmxlbmd0aCA+IHNlbEFuZEJsb2NrU3RyLmxlbmd0aCApe1xuICAgICAgICByZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyKCBzZWxBbmRCbG9ja1N0ci5sZW5ndGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbWFpbmluZyA9ICcnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCl7XG4gICAgICAvLyByZW1vdmUgdGhlIHBhcnNlZCBwcm9wZXJ0eSBhbmQgdmFsdWUgZnJvbSB0aGUgcmVtYWluaW5nIGJsb2NrIHRleHQgdG8gcGFyc2VcbiAgICAgIGlmKCBibG9ja1JlbS5sZW5ndGggPiBwcm9wQW5kVmFsU3RyLmxlbmd0aCApe1xuICAgICAgICBibG9ja1JlbSA9IGJsb2NrUmVtLnN1YnN0ciggcHJvcEFuZFZhbFN0ci5sZW5ndGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJsb2NrUmVtID0gJyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2hpbGUodHJ1ZSl7XG4gICAgICB2YXIgbm90aGluZ0xlZnRUb1BhcnNlID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKiQvKTtcbiAgICAgIGlmKCBub3RoaW5nTGVmdFRvUGFyc2UgKXsgYnJlYWs7IH1cblxuICAgICAgdmFyIHNlbEFuZEJsb2NrID0gcmVtYWluaW5nLm1hdGNoKC9eXFxzKigoPzoufFxccykrPylcXHMqXFx7KCg/Oi58XFxzKSs/KVxcfS8pO1xuXG4gICAgICBpZiggIXNlbEFuZEJsb2NrICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0hhbHRpbmcgc3R5bGVzaGVldCBwYXJzaW5nOiBTdHJpbmcgc3R5bGVzaGVldCBjb250YWlucyBtb3JlIHRvIHBhcnNlIGJ1dCBubyBzZWxlY3RvciBhbmQgYmxvY2sgZm91bmQgaW46ICcgKyByZW1haW5pbmcpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc2VsQW5kQmxvY2tTdHIgPSBzZWxBbmRCbG9ja1swXTtcblxuICAgICAgLy8gcGFyc2UgdGhlIHNlbGVjdG9yXG4gICAgICB2YXIgc2VsZWN0b3JTdHIgPSBzZWxBbmRCbG9ja1sxXTtcbiAgICAgIGlmKCBzZWxlY3RvclN0ciAhPT0gJ2NvcmUnICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IG5ldyAkJC5TZWxlY3Rvciggc2VsZWN0b3JTdHIgKTtcbiAgICAgICAgaWYoIHNlbGVjdG9yLl9wcml2YXRlLmludmFsaWQgKXtcbiAgICAgICAgICAkJC51dGlsLmVycm9yKCdTa2lwcGluZyBwYXJzaW5nIG9mIGJsb2NrOiBJbnZhbGlkIHNlbGVjdG9yIGZvdW5kIGluIHN0cmluZyBzdHlsZXNoZWV0OiAnICsgc2VsZWN0b3JTdHIpO1xuXG4gICAgICAgICAgLy8gc2tpcCB0aGlzIHNlbGVjdG9yIGFuZCBibG9ja1xuICAgICAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgICAgICAgIGNvbnRpbnVlOyBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwYXJzZSB0aGUgYmxvY2sgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gICAgICB2YXIgYmxvY2tTdHIgPSBzZWxBbmRCbG9ja1syXTtcbiAgICAgIHZhciBpbnZhbGlkQmxvY2sgPSBmYWxzZTtcbiAgICAgIGJsb2NrUmVtID0gYmxvY2tTdHI7XG4gICAgICB2YXIgcHJvcHMgPSBbXTtcblxuICAgICAgd2hpbGUodHJ1ZSl7XG4gICAgICAgIHZhciBub3RoaW5nTGVmdFRvUGFyc2UgPSBibG9ja1JlbS5tYXRjaCgvXlxccyokLyk7XG4gICAgICAgIGlmKCBub3RoaW5nTGVmdFRvUGFyc2UgKXsgYnJlYWs7IH1cblxuICAgICAgICB2YXIgcHJvcEFuZFZhbCA9IGJsb2NrUmVtLm1hdGNoKC9eXFxzKiguKz8pXFxzKjpcXHMqKC4rPylcXHMqOy8pO1xuXG4gICAgICAgIGlmKCAhcHJvcEFuZFZhbCApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1NraXBwaW5nIHBhcnNpbmcgb2YgYmxvY2s6IEludmFsaWQgZm9ybWF0dGluZyBvZiBzdHlsZSBwcm9wZXJ0eSBhbmQgdmFsdWUgZGVmaW5pdGlvbnMgZm91bmQgaW46JyArIGJsb2NrU3RyKTtcbiAgICAgICAgICBpbnZhbGlkQmxvY2sgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvcEFuZFZhbFN0ciA9IHByb3BBbmRWYWxbMF07XG4gICAgICAgIHZhciBwcm9wU3RyID0gcHJvcEFuZFZhbFsxXTtcbiAgICAgICAgdmFyIHZhbFN0ciA9IHByb3BBbmRWYWxbMl07XG5cbiAgICAgICAgdmFyIHByb3AgPSAkJC5zdHlsZS5wcm9wZXJ0aWVzWyBwcm9wU3RyIF07XG4gICAgICAgIGlmKCAhcHJvcCApe1xuICAgICAgICAgICQkLnV0aWwuZXJyb3IoJ1NraXBwaW5nIHByb3BlcnR5OiBJbnZhbGlkIHByb3BlcnR5IG5hbWUgaW46ICcgKyBwcm9wQW5kVmFsU3RyKTtcblxuICAgICAgICAgIC8vIHNraXAgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgYmxvY2tcbiAgICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcnNlZFByb3AgPSBzdHlsZS5wYXJzZSggcHJvcFN0ciwgdmFsU3RyICk7XG5cbiAgICAgICAgaWYoICFwYXJzZWRQcm9wICl7XG4gICAgICAgICAgJCQudXRpbC5lcnJvcignU2tpcHBpbmcgcHJvcGVydHk6IEludmFsaWQgcHJvcGVydHkgZGVmaW5pdGlvbiBpbjogJyArIHByb3BBbmRWYWxTdHIpO1xuXG4gICAgICAgICAgLy8gc2tpcCB0aGlzIHByb3BlcnR5IGluIHRoZSBibG9ja1xuICAgICAgICAgIHJlbW92ZVByb3BBbmRWYWxGcm9tUmVtKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBwcm9wU3RyLFxuICAgICAgICAgIHZhbDogdmFsU3RyXG4gICAgICAgIH0pO1xuICAgICAgICByZW1vdmVQcm9wQW5kVmFsRnJvbVJlbSgpO1xuICAgICAgfVxuXG4gICAgICBpZiggaW52YWxpZEJsb2NrICl7XG4gICAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gcHV0IHRoZSBwYXJzZWQgYmxvY2sgaW4gdGhlIHN0eWxlXG4gICAgICBzdHlsZS5zZWxlY3Rvciggc2VsZWN0b3JTdHIgKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgc3R5bGUuY3NzKCBwcm9wLm5hbWUsIHByb3AudmFsICk7XG4gICAgICB9XG5cbiAgICAgIHJlbW92ZVNlbEFuZEJsb2NrRnJvbVJlbWFpbmluZygpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxuICAkJC5zdHlsZS5mcm9tU3RyaW5nID0gZnVuY3Rpb24oIGN5LCBzdHJpbmcgKXtcbiAgICB2YXIgc3R5bGUgPSBuZXcgJCQuU3R5bGUoY3kpO1xuICAgIFxuICAgICQkLnN0eWxlLmFwcGx5RnJvbVN0cmluZyggc3R5bGUsIHN0cmluZyApO1xuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gICQkLnN0eWZuLmZyb21TdHJpbmcgPSBmdW5jdGlvbiggc3RyaW5nICl7XG4gICAgdmFyIHN0eWxlID0gdGhpcztcblxuICAgIHN0eWxlLnJlc2V0VG9EZWZhdWx0KCk7XG5cbiAgICAkJC5zdHlsZS5hcHBseUZyb21TdHJpbmcoIHN0eWxlLCBzdHJpbmcgKTtcblxuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGEgZHVtbXkgc3R5bGVzaGVldCBvYmplY3QgdGhhdCBkb2Vzbid0IG5lZWQgYSByZWZlcmVuY2UgdG8gdGhlIGNvcmVcbiAgLy8gKHVzZWZ1bCBmb3IgaW5pdClcbiAgJCQuc3R5bGVzaGVldCA9ICQkLlN0eWxlc2hlZXQgPSBmdW5jdGlvbigpe1xuICAgIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiAkJC5TdHlsZXNoZWV0KSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5TdHlsZXNoZWV0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9O1xuXG4gICQkLnNoZWV0Zm4gPSAkJC5TdHlsZXNoZWV0LnByb3RvdHlwZTtcblxuICAvLyBqdXN0IHN0b3JlIHRoZSBzZWxlY3RvciB0byBiZSBwYXJzZWQgbGF0ZXJcbiAgJCQuc2hlZXRmbi5zZWxlY3RvciA9IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgIHZhciBpID0gdGhpcy5sZW5ndGgrKztcblxuICAgIHRoaXNbaV0gPSB7XG4gICAgICBzZWxlY3Rvcjogc2VsZWN0b3IsXG4gICAgICBwcm9wZXJ0aWVzOiBbXVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICAvLyBqdXN0IHN0b3JlIHRoZSBwcm9wZXJ0eSB0byBiZSBwYXJzZWQgbGF0ZXJcbiAgJCQuc2hlZXRmbi5jc3MgPSBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKXtcbiAgICB2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTtcblxuICAgIGlmKCAkJC5pcy5zdHJpbmcobmFtZSkgKXtcbiAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYoICQkLmlzLnBsYWluT2JqZWN0KG5hbWUpICl7XG4gICAgICB2YXIgbWFwID0gbmFtZTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCAkJC5zdHlsZS5wcm9wZXJ0aWVzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBwcm9wID0gJCQuc3R5bGUucHJvcGVydGllc1tqXTtcbiAgICAgICAgdmFyIG1hcFZhbCA9IG1hcFsgcHJvcC5uYW1lIF07XG5cbiAgICAgICAgaWYoIG1hcFZhbCA9PT0gdW5kZWZpbmVkICl7IC8vIGFsc28gdHJ5IGNhbWVsIGNhc2UgbmFtZVxuICAgICAgICAgIG1hcFZhbCA9IG1hcFsgJCQudXRpbC5kYXNoMmNhbWVsKHByb3AubmFtZSkgXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBtYXBWYWwgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHZhciBuYW1lID0gcHJvcC5uYW1lO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG1hcFZhbDtcblxuICAgICAgICAgIHRoaXNbaV0ucHJvcGVydGllcy5wdXNoKHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gICQkLnNoZWV0Zm4uc3R5bGUgPSAkJC5zaGVldGZuLmNzcztcblxuICAvLyBnZW5lcmF0ZSBhIHJlYWwgc3R5bGUgb2JqZWN0IGZyb20gdGhlIGR1bW15IHN0eWxlc2hlZXRcbiAgJCQuc2hlZXRmbi5nZW5lcmF0ZVN0eWxlID0gZnVuY3Rpb24oIGN5ICl7XG4gICAgdmFyIHN0eWxlID0gbmV3ICQkLlN0eWxlKGN5KTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzW2ldO1xuICAgICAgdmFyIHNlbGVjdG9yID0gY29udGV4dC5zZWxlY3RvcjtcbiAgICAgIHZhciBwcm9wcyA9IGNvbnRleHQucHJvcGVydGllcztcblxuICAgICAgc3R5bGUuc2VsZWN0b3Ioc2VsZWN0b3IpOyAvLyBhcHBseSBzZWxlY3RvclxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHByb3BzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBwcm9wID0gcHJvcHNbal07XG5cbiAgICAgICAgc3R5bGUuY3NzKCBwcm9wLm5hbWUsIHByb3AudmFsdWUgKTsgLy8gYXBwbHkgcHJvcGVydHlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcbi8vIGNyb3NzLWVudiB0aHJlYWQvd29ya2VyXG4vLyBOQiA6IHVzZXMgKGhlYXZ5d2VpZ2h0KSBwcm9jZXNzZXMgb24gbm9kZWpzIHNvIGJlc3Qgbm90IHRvIGNyZWF0ZSB0b28gbWFueSB0aHJlYWRzXG5cbjsoZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5UaHJlYWQgPSBmdW5jdGlvbiggZm4gKXtcbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuVGhyZWFkKSApe1xuICAgICAgcmV0dXJuIG5ldyAkJC5UaHJlYWQoIGZuICk7XG4gICAgfVxuXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIHJlcXVpcmVzOiBbXSxcbiAgICAgIGZpbGVzOiBbXSxcbiAgICAgIHF1ZXVlOiBudWxsLFxuICAgICAgcGFzczogW11cbiAgICB9O1xuXG4gICAgaWYoIGZuICl7XG4gICAgICB0aGlzLnJ1biggZm4gKTtcbiAgICB9XG5cbiAgfTtcblxuICAkJC50aHJlYWQgPSAkJC5UaHJlYWQ7XG4gICQkLnRoZGZuID0gJCQuVGhyZWFkLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcblxuICAkJC5mbi50aHJlYWQgPSBmdW5jdGlvbiggZm5NYXAsIG9wdGlvbnMgKXtcbiAgICBmb3IoIHZhciBuYW1lIGluIGZuTWFwICl7XG4gICAgICB2YXIgZm4gPSBmbk1hcFtuYW1lXTtcbiAgICAgICQkLlRocmVhZC5wcm90b3R5cGVbIG5hbWUgXSA9IGZuO1xuICAgIH1cbiAgfTtcblxuICB2YXIgc3RyaW5naWZ5RmllbGRWYWwgPSBmdW5jdGlvbiggdmFsICl7XG4gICAgdmFyIHZhbFN0ciA9ICQkLmlzLmZuKCB2YWwgKSA/IHZhbC50b1N0cmluZygpIDogJ0pTT04ucGFyc2UoXCInICsgSlNPTi5zdHJpbmdpZnkodmFsKSArICdcIiknO1xuXG4gICAgcmV0dXJuIHZhbFN0cjtcbiAgfTtcblxuICAvLyBhbGxvd3MgZm9yIHJlcXVpcmVzIHdpdGggcHJvdG90eXBlcyBhbmQgc3Vib2JqcyBldGNcbiAgdmFyIGZuQXNSZXF1aXJlID0gZnVuY3Rpb24oIGZuICl7XG4gICAgdmFyIHJlcTtcbiAgICB2YXIgZm5OYW1lO1xuXG4gICAgaWYoICQkLmlzLm9iamVjdChmbikgJiYgZm4uZm4gKXsgLy8gbWFudWFsIGZuXG4gICAgICByZXEgPSBmbkFzKCBmbi5mbiwgZm4ubmFtZSApO1xuICAgICAgZm5OYW1lID0gZm4ubmFtZTtcbiAgICAgIGZuID0gZm4uZm47XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5mbihmbikgKXsgLy8gYXV0byBmblxuICAgICAgcmVxID0gZm4udG9TdHJpbmcoKTtcbiAgICAgIGZuTmFtZSA9IGZuLm5hbWU7XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcoZm4pICl7IC8vIHN0cmluZ2lmaWVkIGZuXG4gICAgICByZXEgPSBmbjtcbiAgICB9IGVsc2UgaWYoICQkLmlzLm9iamVjdChmbikgKXsgLy8gcGxhaW4gb2JqZWN0XG4gICAgICBpZiggZm4ucHJvdG8gKXtcbiAgICAgICAgcmVxID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXEgPSBmbi5uYW1lICsgJyA9IHt9Oyc7XG4gICAgICB9XG5cbiAgICAgIGZuTmFtZSA9IGZuLm5hbWU7XG4gICAgICBmbiA9IGZuLm9iajtcbiAgICB9XG5cbiAgICByZXEgKz0gJ1xcbic7XG5cbiAgICB2YXIgcHJvdG9yZXEgPSBmdW5jdGlvbiggdmFsLCBzdWJuYW1lICl7XG4gICAgICBpZiggdmFsLnByb3RvdHlwZSApe1xuICAgICAgICB2YXIgcHJvdG9Ob25lbXB0eSA9IGZhbHNlO1xuICAgICAgICBmb3IoIHZhciBwcm9wIGluIHZhbC5wcm90b3R5cGUgKXsgcHJvdG9Ob25lbXB0eSA9IHRydWU7IGJyZWFrOyB9XG5cbiAgICAgICAgaWYoIHByb3RvTm9uZW1wdHkgKXtcbiAgICAgICAgICByZXEgKz0gZm5Bc1JlcXVpcmUoIHtcbiAgICAgICAgICAgIG5hbWU6IHN1Ym5hbWUsXG4gICAgICAgICAgICBvYmo6IHZhbCxcbiAgICAgICAgICAgIHByb3RvOiB0cnVlXG4gICAgICAgICAgfSwgdmFsICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gcHVsbCBpbiBwcm90b3R5cGVcbiAgICBpZiggZm4ucHJvdG90eXBlICYmIGZuTmFtZSAhPSBudWxsICl7XG5cbiAgICAgIGZvciggdmFyIG5hbWUgaW4gZm4ucHJvdG90eXBlICl7XG4gICAgICAgIHZhciBwcm90b1N0ciA9ICcnO1xuXG4gICAgICAgIHZhciB2YWwgPSBmbi5wcm90b3R5cGVbIG5hbWUgXTtcbiAgICAgICAgdmFyIHZhbFN0ciA9IHN0cmluZ2lmeUZpZWxkVmFsKCB2YWwgKTtcbiAgICAgICAgdmFyIHN1Ym5hbWUgPSBmbk5hbWUgKyAnLnByb3RvdHlwZS4nICsgbmFtZTtcblxuICAgICAgICBwcm90b1N0ciArPSBzdWJuYW1lICsgJyA9ICcgKyB2YWxTdHIgKyAnO1xcbic7XG5cbiAgICAgICAgaWYoIHByb3RvU3RyICl7XG4gICAgICAgICAgcmVxICs9IHByb3RvU3RyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvdG9yZXEoIHZhbCwgc3VibmFtZSApOyAvLyBzdWJvYmplY3Qgd2l0aCBwcm90b3R5cGVcbiAgICAgIH1cbiAgXG4gICAgfVxuXG4gICAgLy8gcHVsbCBpbiBwcm9wZXJ0aWVzIGZvciBvYmovZm5zXG4gICAgaWYoICEkJC5pcy5zdHJpbmcoZm4pICl7IGZvciggdmFyIG5hbWUgaW4gZm4gKXtcbiAgICAgIHZhciBwcm9wc1N0ciA9ICcnO1xuXG4gICAgICBpZiggZm4uaGFzT3duUHJvcGVydHkobmFtZSkgKXtcbiAgICAgICAgdmFyIHZhbCA9IGZuWyBuYW1lIF07XG4gICAgICAgIHZhciB2YWxTdHIgPSBzdHJpbmdpZnlGaWVsZFZhbCggdmFsICk7XG4gICAgICAgIHZhciBzdWJuYW1lID0gZm5OYW1lICsgJ1tcIicgKyBuYW1lICsgJ1wiXSc7XG5cbiAgICAgICAgcHJvcHNTdHIgKz0gc3VibmFtZSArICcgPSAnICsgdmFsU3RyICsgJztcXG4nO1xuICAgICAgfVxuXG4gICAgICBpZiggcHJvcHNTdHIgKXtcbiAgICAgICAgcmVxICs9IHByb3BzU3RyO1xuICAgICAgfVxuXG4gICAgICBwcm90b3JlcSggdmFsLCBzdWJuYW1lICk7IC8vIHN1Ym9iamVjdCB3aXRoIHByb3RvdHlwZVxuICAgIH0gfVxuXG4gICAgcmV0dXJuIHJlcTtcbiAgfTtcbiAgXG4gIHZhciBpc1BhdGhTdHIgPSBmdW5jdGlvbiggc3RyICl7XG4gICAgcmV0dXJuICQkLmlzLnN0cmluZyhzdHIpICYmIHN0ci5tYXRjaCgvXFwuanMkLyk7XG4gIH07XG5cbiAgJCQuZm4udGhyZWFkKHtcblxuICAgIHJlcXVpcmU6IGZ1bmN0aW9uKCBmbiwgYXMgKXtcbiAgICAgIGlmKCBpc1BhdGhTdHIoZm4pICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuZmlsZXMucHVzaCggZm4gKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgICBcbiAgICAgIGlmKCBhcyApe1xuICAgICAgICBpZiggJCQuaXMuZm4oZm4pICl7XG4gICAgICAgICAgLy8gZGlzYWJsZWQgYi9jIGRvZXNuJ3Qgd29yayB3aXRoIGZvcmNlZCBuYW1lcyBvbiBmdW5jdGlvbnMgdy8gcHJvdG90eXBlc1xuICAgICAgICAgIC8vZm4gPSBmbkFzKCBmbiwgYXMgKTtcblxuICAgICAgICAgIGFzID0gYXMgfHwgZm4ubmFtZTtcblxuICAgICAgICAgIGZuID0geyBuYW1lOiBhcywgZm46IGZuIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm4gPSB7IG5hbWU6IGFzLCBvYmo6IGZuIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJpdmF0ZS5yZXF1aXJlcy5wdXNoKCBmbiApO1xuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgcGFzczogZnVuY3Rpb24oIGRhdGEgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUucGFzcy5wdXNoKCBkYXRhICk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBydW46IGZ1bmN0aW9uKCBmbiwgcGFzcyApeyAvLyBmbiB1c2VkIGxpa2UgbWFpbigpXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgcGFzcyA9IHBhc3MgfHwgX3AucGFzcy5zaGlmdCgpO1xuXG4gICAgICBpZiggX3Auc3RvcHBlZCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdBdHRlbXB0ZWQgdG8gcnVuIGEgc3RvcHBlZCB0aHJlYWQhICBTdGFydCBhIG5ldyB0aHJlYWQgb3IgZG8gbm90IHN0b3AgdGhlIGV4aXN0aW5nIHRocmVhZCBhbmQgcmV1c2UgaXQuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYoIF9wLnJ1bm5pbmcgKXtcbiAgICAgICAgcmV0dXJuIF9wLnF1ZXVlID0gX3AucXVldWUudGhlbihmdW5jdGlvbigpeyAvLyBpbmR1Y3RpdmUgc3RlcFxuICAgICAgICAgIHJldHVybiBzZWxmLnJ1biggZm4sIHBhc3MgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciB1c2VXVyA9IHdpbmRvdyAhPSBudWxsO1xuICAgICAgdmFyIHVzZU5vZGUgPSB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJztcblxuICAgICAgc2VsZi50cmlnZ2VyKCdydW4nKTtcblxuICAgICAgdmFyIHJ1blAgPSBuZXcgJCQuUHJvbWlzZShmdW5jdGlvbiggcmVzb2x2ZSwgcmVqZWN0ICl7XG5cbiAgICAgICAgX3AucnVubmluZyA9IHRydWU7XG5cbiAgICAgICAgdmFyIHRocmVhZFRlY2hBbHJlYWR5RXhpc3RzID0gX3AucmFuO1xuXG4gICAgICAgIHZhciBmbkltcGxTdHIgPSAkJC5pcy5zdHJpbmcoIGZuICkgPyBmbiA6IGZuLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgLy8gd29ya2VyIGNvZGUgdG8gZXhlY1xuICAgICAgICB2YXIgZm5TdHIgPSAnXFxuJyArICggX3AucmVxdWlyZXMubWFwKGZ1bmN0aW9uKCByICl7XG4gICAgICAgICAgcmV0dXJuIGZuQXNSZXF1aXJlKCByICk7XG4gICAgICAgIH0pICkuY29uY2F0KCBfcC5maWxlcy5tYXAoZnVuY3Rpb24oIGYgKXtcbiAgICAgICAgICBpZiggdXNlV1cgKXtcbiAgICAgICAgICAgIHZhciB3d2lmeUZpbGUgPSBmdW5jdGlvbiggZmlsZSApe1xuICAgICAgICAgICAgICBpZiggZmlsZS5tYXRjaCgvXlxcLlxcLy8pIHx8IGZpbGUubWF0Y2goL15cXC5cXC4vKSApe1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubG9jYXRpb24ub3JpZ2luICsgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgZmlsZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmKCBmaWxlLm1hdGNoKC9eXFwvLykgKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LmxvY2F0aW9uLm9yaWdpbiArICcvJyArIGZpbGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZpbGU7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gJ2ltcG9ydFNjcmlwdHMoXCInICsgd3dpZnlGaWxlKGYpICsgJ1wiKTsnO1xuICAgICAgICAgIH0gZWxzZSBpZiggdXNlTm9kZSApIHtcbiAgICAgICAgICAgIHJldHVybiAnZXZhbCggcmVxdWlyZShcImZzXCIpLnJlYWRGaWxlU3luYyhcIicgKyBmICsgJ1wiLCB7IGVuY29kaW5nOiBcInV0ZjhcIiB9KSApOyc7XG4gICAgICAgICAgfVxuICAgICAgICB9KSApLmNvbmNhdChbXG4gICAgICAgICAgJyggZnVuY3Rpb24oKXsnLFxuICAgICAgICAgICAgJ3ZhciByZXQgPSAoJyArIGZuSW1wbFN0ciArICcpKCcgKyBKU09OLnN0cmluZ2lmeShwYXNzKSArICcpOycsXG4gICAgICAgICAgICAnaWYoIHJldCAhPT0gdW5kZWZpbmVkICl7IHJlc29sdmUocmV0KTsgfScsIC8vIGFzc3VtZSBpZiByYW4gZm4gcmV0dXJucyBkZWZpbmVkIHZhbHVlIChpbmNsLiBudWxsKSwgdGhhdCB3ZSB3YW50IHRvIHJlc29sdmUgdG8gaXRcbiAgICAgICAgICAnfSApKClcXG4nXG4gICAgICAgIF0pLmpvaW4oJ1xcbicpO1xuXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UndmUgbm93IGNvbnN1bWVkIHRoZSByZXF1aXJlcywgZW1wdHkgdGhlIGxpc3Qgc28gd2UgZG9uJ3QgZHVwZSBvbiBuZXh0IHJ1bigpXG4gICAgICAgIF9wLnJlcXVpcmVzID0gW107XG4gICAgICAgIF9wLmZpbGVzID0gW107XG5cbiAgICAgICAgaWYoIHVzZVdXICl7XG4gICAgICAgICAgdmFyIGZuQmxvYiwgZm5Vcmw7XG5cbiAgICAgICAgICAvLyBhZGQgbm9ybWFsaXNlZCB0aHJlYWQgYXBpIGZ1bmN0aW9uc1xuICAgICAgICAgIGlmKCAhdGhyZWFkVGVjaEFscmVhZHlFeGlzdHMgKXtcbiAgICAgICAgICAgIHZhciBmblByZSA9IGZuU3RyICsgJyc7XG5cbiAgICAgICAgICAgIGZuU3RyID0gW1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gYnJvYWRjYXN0KG0peyByZXR1cm4gbWVzc2FnZShtKTsgfTsnLCAvLyBhbGlhc1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gbWVzc2FnZShtKXsgcG9zdE1lc3NhZ2UobSk7IH07JyxcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGxpc3Rlbihmbil7JyxcbiAgICAgICAgICAgICAgJyAgc2VsZi5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihtKXsgJyxcbiAgICAgICAgICAgICAgJyAgICBpZiggdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgKG0uZGF0YS4kJGV2YWwgfHwgbS5kYXRhID09PSBcIiQkc3RhcnRcIikgKXsnLFxuICAgICAgICAgICAgICAnICAgIH0gZWxzZSB7ICcsXG4gICAgICAgICAgICAgICcgICAgICBmbiggbS5kYXRhICk7JyxcbiAgICAgICAgICAgICAgJyAgICB9JyxcbiAgICAgICAgICAgICAgJyAgfSk7JyxcbiAgICAgICAgICAgICAgJ307JywgXG4gICAgICAgICAgICAgICdzZWxmLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uKG0peyAgaWYoIG0uZGF0YS4kJGV2YWwgKXsgZXZhbCggbS5kYXRhLiQkZXZhbCApOyB9ICB9KTsnLFxuICAgICAgICAgICAgICAnZnVuY3Rpb24gcmVzb2x2ZSh2KXsgcG9zdE1lc3NhZ2UoeyAkJHJlc29sdmU6IHYgfSk7IH07JywgXG4gICAgICAgICAgICAgICdmdW5jdGlvbiByZWplY3Qodil7IHBvc3RNZXNzYWdlKHsgJCRyZWplY3Q6IHYgfSk7IH07J1xuICAgICAgICAgICAgXS5qb2luKCdcXG4nKTtcbiAgICAgICAgICBcbiAgICAgICAgICAgIGZuU3RyICs9IGZuUHJlO1xuXG4gICAgICAgICAgICBmbkJsb2IgPSBuZXcgQmxvYihbIGZuU3RyIF0sIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZuVXJsID0gd2luZG93LlVSTC5jcmVhdGVPYmplY3RVUkwoIGZuQmxvYiApO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjcmVhdGUgd2Vid29ya2VyIGFuZCBsZXQgaXQgZXhlYyB0aGUgc2VyaWFsaXNlZCBjb2RlXG4gICAgICAgICAgdmFyIHd3ID0gX3Aud2Vid29ya2VyID0gX3Aud2Vid29ya2VyIHx8IG5ldyBXb3JrZXIoIGZuVXJsICk7XG5cbiAgICAgICAgICBpZiggdGhyZWFkVGVjaEFscmVhZHlFeGlzdHMgKXsgLy8gdGhlbiBqdXN0IGV4ZWMgbmV3IHJ1bigpIGNvZGVcbiAgICAgICAgICAgIHd3LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgJCRldmFsOiBmblN0clxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gd29ya2VyIG1lc3NhZ2VzID0+IGV2ZW50c1xuICAgICAgICAgIHZhciBjYjtcbiAgICAgICAgICB3dy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgY2IgPSBmdW5jdGlvbiggbSApe1xuICAgICAgICAgICAgdmFyIGlzT2JqZWN0ID0gJCQuaXMub2JqZWN0KG0pICYmICQkLmlzLm9iamVjdCggbS5kYXRhICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBpc09iamVjdCAmJiAoJyQkcmVzb2x2ZScgaW4gbS5kYXRhKSApe1xuICAgICAgICAgICAgICB3dy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgY2IpOyAvLyBkb25lIGxpc3RlbmluZyBiL2MgcmVzb2x2ZSgpXG5cbiAgICAgICAgICAgICAgcmVzb2x2ZSggbS5kYXRhLiQkcmVzb2x2ZSApO1xuICAgICAgICAgICAgfSBlbHNlIGlmKCBpc09iamVjdCAmJiAoJyQkcmVqZWN0JyBpbiBtLmRhdGEpICl7XG4gICAgICAgICAgICAgIHd3LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBjYik7IC8vIGRvbmUgbGlzdGVuaW5nIGIvYyByZWplY3QoKVxuXG4gICAgICAgICAgICAgIHJlamVjdCggbS5kYXRhLiQkcmVqZWN0ICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxmLnRyaWdnZXIoIG5ldyAkJC5FdmVudChtLCB7IHR5cGU6ICdtZXNzYWdlJywgbWVzc2FnZTogbS5kYXRhIH0pICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgICAgaWYoICF0aHJlYWRUZWNoQWxyZWFkeUV4aXN0cyApe1xuICAgICAgICAgICAgd3cucG9zdE1lc3NhZ2UoJyQkc3RhcnQnKTsgLy8gc3RhcnQgdXAgdGhlIHdvcmtlclxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYoIHVzZU5vZGUgKXtcbiAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgcHJvY2Vzc1xuICAgICAgICAgIHZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuICAgICAgICAgIHZhciBjaGlsZF9wcm9jZXNzID0gcmVxdWlyZSgnY2hpbGRfcHJvY2VzcycpO1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9wLmNoaWxkID0gX3AuY2hpbGQgfHwgY2hpbGRfcHJvY2Vzcy5mb3JrKCBwYXRoLmpvaW4oX19kaXJuYW1lLCAndGhyZWFkLW5vZGUtZm9yaycpICk7XG5cbiAgICAgICAgICAvLyBjaGlsZCBwcm9jZXNzIG1lc3NhZ2VzID0+IGV2ZW50c1xuICAgICAgICAgIHZhciBjYjtcbiAgICAgICAgICBjaGlsZC5vbignbWVzc2FnZScsIGNiID0gZnVuY3Rpb24oIG0gKXtcbiAgICAgICAgICAgIGlmKCAkJC5pcy5vYmplY3QobSkgJiYgKCckJHJlc29sdmUnIGluIG0pICl7XG4gICAgICAgICAgICAgIGNoaWxkLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgY2IpOyAvLyBkb25lIGxpc3RlbmluZyBiL2MgcmVzb2x2ZSgpXG5cbiAgICAgICAgICAgICAgcmVzb2x2ZSggbS4kJHJlc29sdmUgKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiggJCQuaXMub2JqZWN0KG0pICYmICgnJCRyZWplY3QnIGluIG0pICl7XG4gICAgICAgICAgICAgIGNoaWxkLnJlbW92ZUxpc3RlbmVyKCdtZXNzYWdlJywgY2IpOyAvLyBkb25lIGxpc3RlbmluZyBiL2MgcmVqZWN0KClcblxuICAgICAgICAgICAgICByZWplY3QoIG0uJCRyZWplY3QgKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNlbGYudHJpZ2dlciggbmV3ICQkLkV2ZW50KHt9LCB7IHR5cGU6ICdtZXNzYWdlJywgbWVzc2FnZTogbSB9KSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gYXNrIHRoZSBjaGlsZCBwcm9jZXNzIHRvIGV2YWwgdGhlIHdvcmtlciBjb2RlXG4gICAgICAgICAgY2hpbGQuc2VuZCh7XG4gICAgICAgICAgICAkJGV2YWw6IGZuU3RyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCQuZXJyb3IoJ1RyaWVkIHRvIGNyZWF0ZSB0aHJlYWQgYnV0IG5vIHVuZGVybHlpbmcgdGVjaCBmb3VuZCEnKTtcbiAgICAgICAgICAvLyBUT0RPIGZhbGxiYWNrIG9uIG1haW4gSlMgdGhyZWFkP1xuICAgICAgICB9XG5cbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24oIHYgKXtcbiAgICAgICAgX3AucnVubmluZyA9IGZhbHNlO1xuICAgICAgICBfcC5yYW4gPSB0cnVlO1xuXG4gICAgICAgIHNlbGYudHJpZ2dlcigncmFuJyk7XG5cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgICB9KTtcblxuICAgICAgaWYoIF9wLnF1ZXVlID09IG51bGwgKXtcbiAgICAgICAgX3AucXVldWUgPSBydW5QOyAvLyBpLmUuIGZpcnN0IHN0ZXAgb2YgaW5kdWN0aXZlIHByb21pc2UgY2hhaW4gKGZvciBxdWV1ZSlcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ1blA7XG4gICAgfSxcblxuICAgIC8vIHNlbmQgdGhlIHRocmVhZCBhIG1lc3NhZ2VcbiAgICBtZXNzYWdlOiBmdW5jdGlvbiggbSApe1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYoIF9wLndlYndvcmtlciApe1xuICAgICAgICBfcC53ZWJ3b3JrZXIucG9zdE1lc3NhZ2UoIG0gKTtcbiAgICAgIH1cblxuICAgICAgaWYoIF9wLmNoaWxkICl7XG4gICAgICAgIF9wLmNoaWxkLnNlbmQoIG0gKTtcbiAgICAgIH0gXG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgaWYoIF9wLndlYndvcmtlciApe1xuICAgICAgICBfcC53ZWJ3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBfcC5jaGlsZCApe1xuICAgICAgICBfcC5jaGlsZC5raWxsKCk7XG4gICAgICB9IFxuXG4gICAgICBfcC5zdG9wcGVkID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignc3RvcCcpOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBzdG9wcGVkOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc3RvcHBlZDtcbiAgICB9XG5cbiAgfSk7XG5cbiAgdmFyIGZuQXMgPSBmdW5jdGlvbiggZm4sIG5hbWUgKXtcbiAgICB2YXIgZm5TdHIgPSBmbi50b1N0cmluZygpO1xuICAgIGZuU3RyID0gZm5TdHIucmVwbGFjZSgvZnVuY3Rpb24uKlxcKC8sICdmdW5jdGlvbiAnICsgbmFtZSArICcoJyk7XG5cbiAgICByZXR1cm4gZm5TdHI7XG4gIH07XG5cbiAgdmFyIGRlZmluZUZuYWwgPSBmdW5jdGlvbiggb3B0cyApe1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGZuYWxJbXBsKCBmbiwgYXJnMSApe1xuICAgICAgdmFyIGZuU3RyID0gZm5BcyggZm4sICdfJF8kXycgKyBvcHRzLm5hbWUgKTtcblxuICAgICAgdGhpcy5yZXF1aXJlKCBmblN0ciApO1xuXG4gICAgICByZXR1cm4gdGhpcy5ydW4oIFsgXG4gICAgICAgICdmdW5jdGlvbiggZGF0YSApeycsXG4gICAgICAgICcgIHZhciBvcmlnUmVzb2x2ZSA9IHJlc29sdmU7JyxcbiAgICAgICAgJyAgdmFyIHJlcyA9IFtdOycsXG4gICAgICAgICcgICcsXG4gICAgICAgICcgIHJlc29sdmUgPSBmdW5jdGlvbiggdmFsICl7JyxcbiAgICAgICAgJyAgICByZXMucHVzaCggdmFsICk7JyxcbiAgICAgICAgJyAgfTsnLFxuICAgICAgICAnICAnLFxuICAgICAgICAnICB2YXIgcmV0ID0gZGF0YS4nICsgb3B0cy5uYW1lICsgJyggXyRfJF8nICsgb3B0cy5uYW1lICsgKCBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICcsICcgKyBKU09OLnN0cmluZ2lmeShhcmcxKSA6ICcnICkgKyAnICk7JyxcbiAgICAgICAgJyAgJyxcbiAgICAgICAgJyAgcmVzb2x2ZSA9IG9yaWdSZXNvbHZlOycsXG4gICAgICAgICcgIHJlc29sdmUoIHJlcy5sZW5ndGggPiAwID8gcmVzIDogcmV0ICk7JyxcbiAgICAgICAgJ30nXG4gICAgICBdLmpvaW4oJ1xcbicpICk7XG4gICAgfTtcbiAgfTtcblxuICAkJC5mbi50aHJlYWQoe1xuICAgIHJlZHVjZTogZGVmaW5lRm5hbCh7IG5hbWU6ICdyZWR1Y2UnIH0pLFxuXG4gICAgcmVkdWNlUmlnaHQ6IGRlZmluZUZuYWwoeyBuYW1lOiAncmVkdWNlUmlnaHQnIH0pLFxuXG4gICAgbWFwOiBkZWZpbmVGbmFsKHsgbmFtZTogJ21hcCcgfSlcbiAgfSk7XG5cbiAgLy8gYWxpYXNlc1xuICB2YXIgZm4gPSAkJC50aGRmbjtcbiAgZm4ucHJvbWlzZSA9IGZuLnJ1bjtcbiAgZm4udGVybWluYXRlID0gZm4uaGFsdCA9IGZuLnN0b3A7XG4gIGZuLmluY2x1ZGUgPSBmbi5yZXF1aXJlO1xuXG4gIC8vIGhpZ2hlciBsZXZlbCBhbGlhcyAoaW4gY2FzZSB5b3UgbGlrZSB0aGUgd29ya2VyIG1ldGFwaG9yKVxuICAkJC53b3JrZXIgPSAkJC5Xb3JrZXIgPSAkJC5UaHJlYWQ7XG5cbiAgLy8gcHVsbCBpbiBldmVudCBhcGlzXG4gICQkLmZuLnRocmVhZCh7XG4gICAgb246ICQkLmRlZmluZS5vbigpLFxuICAgIG9uZTogJCQuZGVmaW5lLm9uKHsgdW5iaW5kU2VsZk9uVHJpZ2dlcjogdHJ1ZSB9KSxcbiAgICBvZmY6ICQkLmRlZmluZS5vZmYoKSwgXG4gICAgdHJpZ2dlcjogJCQuZGVmaW5lLnRyaWdnZXIoKVxuICB9KTtcblxuICAkJC5kZWZpbmUuZXZlbnRBbGlhc2VzT24oICQkLnRoZGZuICk7XG4gIFxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cbjsoZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5GYWJyaWMgPSBmdW5jdGlvbiggTiApe1xuICAgIGlmKCAhKHRoaXMgaW5zdGFuY2VvZiAkJC5GYWJyaWMpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLkZhYnJpYyggTiApO1xuICAgIH1cblxuICAgIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBwYXNzOiBbXVxuICAgIH07XG5cbiAgICB2YXIgZGVmTiA9IDQ7XG5cbiAgICBpZiggJCQuaXMubnVtYmVyKE4pICl7XG4gICAgICAvLyB0aGVuIHVzZSB0aGUgc3BlY2lmaWVkIG51bWJlciBvZiB0aHJlYWRzXG4gICAgfSBpZiggdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgIT0gbnVsbCApe1xuICAgICAgTiA9IG5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O1xuICAgIH0gZWxzZSBpZiggdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgKXtcbiAgICAgIE4gPSByZXF1aXJlKCdvcycpLmNwdXMoKS5sZW5ndGg7XG4gICAgfSBlbHNlIHsgLy8gVE9ETyBjb3VsZCB1c2UgYW4gZXN0aW1hdGlvbiBoZXJlIGJ1dCB3b3VsZCB0aGUgYWRkaXRpb25hbCBleHBlbnNlIGJlIHdvcnRoIGl0P1xuICAgICAgTiA9IGRlZk47XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBOOyBpKysgKXtcbiAgICAgIHRoaXNbaV0gPSAkJC5UaHJlYWQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE47XG4gIH07XG5cbiAgJCQuZmFicmljID0gJCQuRmFicmljO1xuICAkJC5mYWJmbiA9ICQkLkZhYnJpYy5wcm90b3R5cGU7IC8vIHNob3J0IGFsaWFzXG5cbiAgJCQuZm4uZmFicmljID0gZnVuY3Rpb24oIGZuTWFwLCBvcHRpb25zICl7XG4gICAgZm9yKCB2YXIgbmFtZSBpbiBmbk1hcCApe1xuICAgICAgdmFyIGZuID0gZm5NYXBbbmFtZV07XG4gICAgICAkJC5GYWJyaWMucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG5cbiAgJCQuZm4uZmFicmljKHtcblxuICAgIC8vIHJlcXVpcmUgZm4gaW4gYWxsIHRocmVhZHNcbiAgICByZXF1aXJlOiBmdW5jdGlvbiggZm4sIGFzICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHRocmVhZCA9IHRoaXNbaV07XG5cbiAgICAgICAgdGhyZWFkLnJlcXVpcmUoIGZuLCBhcyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gZ2V0IGEgcmFuZG9tIHRocmVhZFxuICAgIHJhbmRvbTogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBpID0gTWF0aC5yb3VuZCggKHRoaXMubGVuZ3RoIC0gMSkgKiBNYXRoLnJhbmRvbSgpICk7XG4gICAgICB2YXIgdGhyZWFkID0gdGhpc1tpXTtcblxuICAgICAgcmV0dXJuIHRocmVhZDtcbiAgICB9LFxuXG4gICAgLy8gcnVuIG9uIHJhbmRvbSB0aHJlYWRcbiAgICBydW46IGZ1bmN0aW9uKCBmbiApe1xuICAgICAgdmFyIHBhc3MgPSB0aGlzLl9wcml2YXRlLnBhc3Muc2hpZnQoKTtcblxuICAgICAgcmV0dXJuIHRoaXMucmFuZG9tKCkucGFzcyggcGFzcyApLnJ1biggZm4gKTtcbiAgICB9LFxuXG4gICAgLy8gc2VuZHMgYSByYW5kb20gdGhyZWFkIGEgbWVzc2FnZVxuICAgIG1lc3NhZ2U6IGZ1bmN0aW9uKCBtICl7XG4gICAgICByZXR1cm4gdGhpcy5yYW5kb20oKS5tZXNzYWdlKCBtICk7XG4gICAgfSxcblxuICAgIC8vIHNlbmQgYWxsIHRocmVhZHMgYSBtZXNzYWdlXG4gICAgYnJvYWRjYXN0OiBmdW5jdGlvbiggbSApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciB0aHJlYWQgPSB0aGlzW2ldO1xuXG4gICAgICAgIHRocmVhZC5tZXNzYWdlKCBtICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICAvLyBzdG9wIGFsbCB0aHJlYWRzXG4gICAgc3RvcDogZnVuY3Rpb24oKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgdGhyZWFkID0gdGhpc1tpXTtcblxuICAgICAgICB0aHJlYWQuc3RvcCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgLy8gcGFzcyBkYXRhIHRvIGJlIHVzZWQgd2l0aCAuc3ByZWFkKCkgZXRjLlxuICAgIHBhc3M6IGZ1bmN0aW9uKCBkYXRhICl7XG4gICAgICB2YXIgcGFzcyA9IHRoaXMuX3ByaXZhdGUucGFzcztcblxuICAgICAgaWYoICQkLmlzLmFycmF5KGRhdGEpICl7XG4gICAgICAgIHBhc3MucHVzaCggZGF0YSApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCQudXRpbC5lcnJvcignT25seSBhcnJheXMgb3IgY29sbGVjdGlvbnMgbWF5IGJlIHVzZWQgd2l0aCBmYWJyaWMucGFzcygpJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBzcHJlYWRTaXplOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIHN1YnNpemUgPSAgTWF0aC5jZWlsKCB0aGlzLl9wcml2YXRlLnBhc3NbMF0ubGVuZ3RoIC8gdGhpcy5sZW5ndGggKTtcblxuICAgICAgc3Vic2l6ZSA9IE1hdGgubWF4KCAxLCBzdWJzaXplICk7IC8vIGRvbid0IHBhc3MgbGVzcyB0aGFuIG9uZSBlbGUgdG8gZWFjaCB0aHJlYWRcblxuICAgICAgcmV0dXJuIHN1YnNpemU7XG4gICAgfSxcblxuICAgIC8vIHNwbGl0IHRoZSBkYXRhIGludG8gc2xpY2VzIHRvIHNwcmVhZCB0aGUgZGF0YSBlcXVhbGx5IGFtb25nIHRocmVhZHNcbiAgICBzcHJlYWQ6IGZ1bmN0aW9uKCBmbiApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIF9wID0gc2VsZi5fcHJpdmF0ZTtcbiAgICAgIHZhciBzdWJzaXplID0gc2VsZi5zcHJlYWRTaXplKCk7IC8vIG51bWJlciBvZiBwYXNzIGVsZXMgdG8gaGFuZGxlIGluIGVhY2ggdGhyZWFkXG4gICAgICB2YXIgcGFzcyA9IF9wLnBhc3Muc2hpZnQoKS5jb25jYXQoW10pOyAvLyBrZWVwIGEgY29weVxuICAgICAgdmFyIHJ1blBzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgdGhyZWFkID0gdGhpc1tpXTtcbiAgICAgICAgdmFyIHNsaWNlID0gcGFzcy5zcGxpY2UoIDAsIHN1YnNpemUgKTtcblxuICAgICAgICB2YXIgcnVuUCA9IHRocmVhZC5wYXNzKCBzbGljZSApLnJ1biggZm4gKTtcblxuICAgICAgICBydW5Qcy5wdXNoKCBydW5QICk7XG5cbiAgICAgICAgdmFyIGRvbmVFYXJseSA9IHBhc3MubGVuZ3RoID09PSAwO1xuICAgICAgICBpZiggZG9uZUVhcmx5ICl7IGJyZWFrOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAkJC5Qcm9taXNlLmFsbCggcnVuUHMgKS50aGVuKGZ1bmN0aW9uKCB0aGVucyApe1xuICAgICAgICB2YXIgcG9zdHBhc3MgPSBbXTtcbiAgICAgICAgdmFyIHAgPSAwO1xuXG4gICAgICAgIC8vIGZpbGwgcG9zdHBhc3Mgd2l0aCB0aGUgdG90YWwgcmVzdWx0IGpvaW5lZCBmcm9tIGFsbCB0aHJlYWRzXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhlbnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgdGhlbiA9IHRoZW5zW2ldOyAvLyBhcnJheSByZXN1bHQgZnJvbSB0aHJlYWQgaVxuXG4gICAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCB0aGVuLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgICB2YXIgdCA9IHRoZW5bal07IC8vIGFycmF5IGVsZW1lbnRcblxuICAgICAgICAgICAgcG9zdHBhc3NbIHArKyBdID0gdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcG9zdHBhc3M7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gcGFyYWxsZWwgdmVyc2lvbiBvZiBhcnJheS5tYXAoKVxuICAgIG1hcDogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHNlbGYucmVxdWlyZSggZm4sICdfJF8kX2ZhYm1hcCcgKTtcblxuICAgICAgcmV0dXJuIHNlbGYuc3ByZWFkKGZ1bmN0aW9uKCBzcGxpdCApe1xuICAgICAgICB2YXIgbWFwcGVkID0gW107XG4gICAgICAgIHZhciBvcmlnUmVzb2x2ZSA9IHJlc29sdmU7XG5cbiAgICAgICAgcmVzb2x2ZSA9IGZ1bmN0aW9uKCB2YWwgKXtcbiAgICAgICAgICBtYXBwZWQucHVzaCggdmFsICk7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBzcGxpdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBvbGRMZW4gPSBtYXBwZWQubGVuZ3RoO1xuICAgICAgICAgIHZhciByZXQgPSBfJF8kX2ZhYm1hcCggc3BsaXRbaV0gKTtcbiAgICAgICAgICB2YXIgbm90aGluZ0luc2RCeVJlc29sdmUgPSBvbGRMZW4gPT09IG1hcHBlZC5sZW5ndGg7XG5cbiAgICAgICAgICBpZiggbm90aGluZ0luc2RCeVJlc29sdmUgKXtcbiAgICAgICAgICAgIG1hcHBlZC5wdXNoKCByZXQgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlID0gb3JpZ1Jlc29sdmU7XG5cbiAgICAgICAgcmV0dXJuIG1hcHBlZDtcbiAgICAgIH0pO1xuXG4gICAgfSxcblxuICAgIC8vIHBhcmFsbGVsIHZlcnNpb24gb2YgYXJyYXkuZmlsdGVyKClcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKCBmbiApe1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIHZhciBwYXNzID0gX3AucGFzc1swXTtcblxuICAgICAgcmV0dXJuIHRoaXMubWFwKCBmbiApLnRoZW4oZnVuY3Rpb24oIGluY2x1ZGUgKXtcbiAgICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcGFzcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBkYXR1bSA9IHBhc3NbaV07XG4gICAgICAgICAgdmFyIGluY0RhdHVtID0gaW5jbHVkZVtpXTtcblxuICAgICAgICAgIGlmKCBpbmNEYXR1bSApe1xuICAgICAgICAgICAgcmV0LnB1c2goIGRhdHVtICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBzb3J0cyB0aGUgcGFzc2VkIGFycmF5IHVzaW5nIGEgZGl2aWRlIGFuZCBjb25xdWVyIHN0cmF0ZWd5XG4gICAgc29ydDogZnVuY3Rpb24oIGNtcCApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIFAgPSB0aGlzLl9wcml2YXRlLnBhc3NbMF0ubGVuZ3RoO1xuICAgICAgdmFyIHN1YnNpemUgPSB0aGlzLnNwcmVhZFNpemUoKTtcblxuICAgICAgY21wID0gY21wIHx8IGZ1bmN0aW9uKCBhLCBiICl7IC8vIGRlZmF1bHQgY29tcGFyaXNvbiBmdW5jdGlvblxuICAgICAgICBpZiggYSA8IGIgKXtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH0gZWxzZSBpZiggYSA+IGIgKXtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5yZXF1aXJlKCBjbXAsICdfJF8kX2NtcCcgKTtcblxuICAgICAgcmV0dXJuIHNlbGYuc3ByZWFkKGZ1bmN0aW9uKCBzcGxpdCApeyAvLyBzb3J0IGVhY2ggc3BsaXQgbm9ybWFsbHlcbiAgICAgICAgdmFyIHNvcnRlZFNwbGl0ID0gc3BsaXQuc29ydCggXyRfJF9jbXAgKTtcbiAgICAgICAgcmVzb2x2ZSggc29ydGVkU3BsaXQgKTtcblxuICAgICAgfSkudGhlbihmdW5jdGlvbiggam9pbmVkICl7XG4gICAgICAgIC8vIGRvIGFsbCB0aGUgbWVyZ2luZyBpbiB0aGUgbWFpbiB0aHJlYWQgdG8gbWluaW1pc2UgZGF0YSB0cmFuc2ZlclxuXG4gICAgICAgIC8vIFRPRE8gY291bGQgZG8gbWVyZ2luZyBpbiBzZXBhcmF0ZSB0aHJlYWRzIGJ1dCB3b3VsZCBpbmN1ciBhZGQnbCBjb3N0IG9mIGRhdGEgdHJhbnNmZXJcbiAgICAgICAgLy8gZm9yIGVhY2ggbGV2ZWwgb2YgdGhlIG1lcmdlXG5cbiAgICAgICAgdmFyIG1lcmdlID0gZnVuY3Rpb24oIGksIGosIG1heCApe1xuICAgICAgICAgIC8vIGRvbid0IG92ZXJmbG93IGFycmF5XG4gICAgICAgICAgaiA9IE1hdGgubWluKCBqLCBQICk7XG4gICAgICAgICAgbWF4ID0gTWF0aC5taW4oIG1heCwgUCApO1xuXG4gICAgICAgICAgLy8gbGVmdCBhbmQgcmlnaHQgc2lkZXMgb2YgbWVyZ2VcbiAgICAgICAgICB2YXIgbCA9IGk7XG4gICAgICAgICAgdmFyIHIgPSBqO1xuXG4gICAgICAgICAgdmFyIHNvcnRlZCA9IFtdO1xuXG4gICAgICAgICAgZm9yKCB2YXIgayA9IGw7IGsgPCBtYXg7IGsrKyApe1xuXG4gICAgICAgICAgICB2YXIgZWxlSSA9IGpvaW5lZFtpXTtcbiAgICAgICAgICAgIHZhciBlbGVKID0gam9pbmVkW2pdO1xuXG4gICAgICAgICAgICBpZiggaSA8IHIgJiYgKCBqID49IG1heCB8fCBjbXAoZWxlSSwgZWxlSikgPD0gMCApICl7XG4gICAgICAgICAgICAgIHNvcnRlZC5wdXNoKCBlbGVJICk7XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNvcnRlZC5wdXNoKCBlbGVKICk7XG4gICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGluIHRoZSBhcnJheSBwcm9wZXIsIHB1dCB0aGUgc29ydGVkIHZhbHVlc1xuICAgICAgICAgIGZvciggdmFyIGsgPSAwOyBrIDwgc29ydGVkLmxlbmd0aDsgaysrICl7IC8vIGt0aCBzb3J0ZWQgaXRlbVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gbCArIGs7XG5cbiAgICAgICAgICAgIGpvaW5lZFsgaW5kZXggXSA9IHNvcnRlZFtrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yKCB2YXIgc3BsaXRMID0gc3Vic2l6ZTsgc3BsaXRMIDwgUDsgc3BsaXRMICo9IDIgKXsgLy8gbWVyZ2UgdW50aWwgYXJyYXkgaXMgXCJzcGxpdFwiIGFzIDFcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgUDsgaSArPSAyKnNwbGl0TCApe1xuICAgICAgICAgICAgbWVyZ2UoIGksIGkgKyBzcGxpdEwsIGkgKyAyKnNwbGl0TCApO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGpvaW5lZDtcbiAgICAgIH0pO1xuICAgIH1cblxuXG4gIH0pO1xuXG4gIHZhciBkZWZpbmVSYW5kb21QYXNzZXIgPSBmdW5jdGlvbiggb3B0cyApe1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBmbiwgYXJnMSApe1xuICAgICAgdmFyIHBhc3MgPSB0aGlzLl9wcml2YXRlLnBhc3Muc2hpZnQoKTtcblxuICAgICAgcmV0dXJuIHRoaXMucmFuZG9tKCkucGFzcyggcGFzcyApWyBvcHRzLnRocmVhZEZuIF0oIGZuLCBhcmcxICk7XG4gICAgfTtcbiAgfTtcblxuICAkJC5mbi5mYWJyaWMoe1xuICAgIHJhbmRvbU1hcDogZGVmaW5lUmFuZG9tUGFzc2VyKHsgdGhyZWFkRm46ICdtYXAnIH0pLFxuXG4gICAgcmVkdWNlOiBkZWZpbmVSYW5kb21QYXNzZXIoeyB0aHJlYWRGbjogJ3JlZHVjZScgfSksXG5cbiAgICByZWR1Y2VSaWdodDogZGVmaW5lUmFuZG9tUGFzc2VyKHsgdGhyZWFkRm46ICdyZWR1Y2VSaWdodCcgfSlcbiAgfSk7XG5cbiAgLy8gYWxpYXNlc1xuICB2YXIgZm4gPSAkJC5mYWJmbjtcbiAgZm4ucHJvbWlzZSA9IGZuLnJ1bjtcbiAgZm4udGVybWluYXRlID0gZm4uaGFsdCA9IGZuLnN0b3A7XG4gIGZuLmluY2x1ZGUgPSBmbi5yZXF1aXJlO1xuXG4gIC8vIHB1bGwgaW4gZXZlbnQgYXBpc1xuICAkJC5mbi5mYWJyaWMoe1xuICAgIG9uOiAkJC5kZWZpbmUub24oKSxcbiAgICBvbmU6ICQkLmRlZmluZS5vbih7IHVuYmluZFNlbGZPblRyaWdnZXI6IHRydWUgfSksXG4gICAgb2ZmOiAkJC5kZWZpbmUub2ZmKCksXG4gICAgdHJpZ2dlcjogJCQuZGVmaW5lLnRyaWdnZXIoKVxuICB9KTtcblxuICAkJC5kZWZpbmUuZXZlbnRBbGlhc2VzT24oICQkLmZhYmZuICk7XG5cbn0pKCBjeXRvc2NhcGUsIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApO1xuXG47KGZ1bmN0aW9uKCQkLCB3aW5kb3cpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICB9O1xuICBcbiAgdmFyIG9yaWdEZWZhdWx0cyA9ICQkLnV0aWwuY29weSggZGVmYXVsdHMgKTtcblxuICAkJC5kZWZhdWx0cyA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgZGVmYXVsdHMgPSAkJC51dGlsLmV4dGVuZCh7fSwgb3JpZ0RlZmF1bHRzLCBvcHRzKTtcbiAgfTtcblxuICAkJC5mbi5jb3JlID0gZnVuY3Rpb24oIGZuTWFwLCBvcHRpb25zICl7XG4gICAgZm9yKCB2YXIgbmFtZSBpbiBmbk1hcCApe1xuICAgICAgdmFyIGZuID0gZm5NYXBbbmFtZV07XG4gICAgICAkJC5Db3JlLnByb3RvdHlwZVsgbmFtZSBdID0gZm47XG4gICAgfVxuICB9O1xuICBcbiAgJCQuQ29yZSA9IGZ1bmN0aW9uKCBvcHRzICl7XG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLkNvcmUpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLkNvcmUob3B0cyk7XG4gICAgfVxuICAgIHZhciBjeSA9IHRoaXM7XG5cbiAgICBvcHRzID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRzKTtcblxuICAgIHZhciBjb250YWluZXIgPSBvcHRzLmNvbnRhaW5lcjtcbiAgICB2YXIgcmVnID0gY29udGFpbmVyID8gY29udGFpbmVyLl9jeXJlZyA6IG51bGw7IC8vIGUuZy4gYWxyZWFkeSByZWdpc3RlcmVkIHNvbWUgaW5mbyAoZS5nLiByZWFkaWVzKSB2aWEganF1ZXJ5XG4gICAgcmVnID0gcmVnIHx8IHt9O1xuXG4gICAgaWYoIHJlZyAmJiByZWcuY3kgKXsgXG4gICAgICBpZiggY29udGFpbmVyICl7XG4gICAgICAgIHdoaWxlKCBjb250YWluZXIuZmlyc3RDaGlsZCApeyAvLyBjbGVhbiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKCBjb250YWluZXIuZmlyc3RDaGlsZCApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJlZy5jeS5ub3RpZnkoeyB0eXBlOiAnZGVzdHJveScgfSk7IC8vIGRlc3Ryb3kgdGhlIHJlbmRlcmVyXG5cbiAgICAgIHJlZyA9IHt9OyAvLyBvbGQgaW5zdGFuY2UgPT4gcmVwbGFjZSByZWcgY29tcGxldGVseVxuICAgIH1cblxuICAgIHZhciByZWFkaWVzID0gcmVnLnJlYWRpZXMgPSByZWcucmVhZGllcyB8fCBbXTtcbiAgICBcbiAgICBpZiggY29udGFpbmVyICl7IGNvbnRhaW5lci5fY3lyZWcgPSByZWc7IH0gLy8gbWFrZSBzdXJlIGNvbnRhaW5lciBhc3NvYydkIHJlZyBwb2ludHMgdG8gdGhpcyBjeVxuICAgIHJlZy5jeSA9IGN5O1xuXG4gICAgdmFyIGhlYWQgPSB3aW5kb3cgIT09IHVuZGVmaW5lZCAmJiBjb250YWluZXIgIT09IHVuZGVmaW5lZCAmJiAhb3B0cy5oZWFkbGVzcztcbiAgICB2YXIgb3B0aW9ucyA9IG9wdHM7XG4gICAgb3B0aW9ucy5sYXlvdXQgPSAkJC51dGlsLmV4dGVuZCggeyBuYW1lOiBoZWFkID8gJ2dyaWQnIDogJ251bGwnIH0sIG9wdGlvbnMubGF5b3V0ICk7XG4gICAgb3B0aW9ucy5yZW5kZXJlciA9ICQkLnV0aWwuZXh0ZW5kKCB7IG5hbWU6IGhlYWQgPyAnY2FudmFzJyA6ICdudWxsJyB9LCBvcHRpb25zLnJlbmRlcmVyICk7XG4gICAgXG4gICAgdmFyIGRlZlZhbCA9IGZ1bmN0aW9uKCBkZWYsIHZhbCwgYWx0VmFsICl7XG4gICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0gZWxzZSBpZiggYWx0VmFsICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIGFsdFZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWY7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBjb250YWluZXI6IG9wdGlvbnMuY29udGFpbmVyLCAvLyBodG1sIGRvbSBlbGUgY29udGFpbmVyXG4gICAgICByZWFkeTogZmFsc2UsIC8vIHdoZXRoZXIgcmVhZHkgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICBpbml0cmVuZGVyOiBmYWxzZSwgLy8gaGFzIGluaXRyZW5kZXIgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICBvcHRpb25zOiBvcHRpb25zLCAvLyBjYWNoZWQgb3B0aW9uc1xuICAgICAgZWxlbWVudHM6IFtdLCAvLyBhcnJheSBvZiBlbGVtZW50c1xuICAgICAgaWQyaW5kZXg6IHt9LCAvLyBlbGVtZW50IGlkID0+IGluZGV4IGluIGVsZW1lbnRzIGFycmF5XG4gICAgICBsaXN0ZW5lcnM6IFtdLCAvLyBsaXN0IG9mIGxpc3RlbmVyc1xuICAgICAgb25SZW5kZXJzOiBbXSwgLy8gcmVuZGVyaW5nIGxpc3RlbmVyc1xuICAgICAgYW5pRWxlczogJCQuQ29sbGVjdGlvbih0aGlzKSwgLy8gZWxlbWVudHMgYmVpbmcgYW5pbWF0ZWRcbiAgICAgIHNjcmF0Y2g6IHt9LCAvLyBzY3JhdGNoIG9iamVjdCBmb3IgY29yZVxuICAgICAgbGF5b3V0OiBudWxsLFxuICAgICAgcmVuZGVyZXI6IG51bGwsXG4gICAgICBub3RpZmljYXRpb25zRW5hYmxlZDogdHJ1ZSwgLy8gd2hldGhlciBub3RpZmljYXRpb25zIGFyZSBzZW50IHRvIHRoZSByZW5kZXJlclxuICAgICAgbWluWm9vbTogMWUtNTAsXG4gICAgICBtYXhab29tOiAxZTUwLFxuICAgICAgem9vbWluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnpvb21pbmdFbmFibGVkKSxcbiAgICAgIHVzZXJab29taW5nRW5hYmxlZDogZGVmVmFsKHRydWUsIG9wdGlvbnMudXNlclpvb21pbmdFbmFibGVkKSxcbiAgICAgIHBhbm5pbmdFbmFibGVkOiBkZWZWYWwodHJ1ZSwgb3B0aW9ucy5wYW5uaW5nRW5hYmxlZCksXG4gICAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGRlZlZhbCh0cnVlLCBvcHRpb25zLnVzZXJQYW5uaW5nRW5hYmxlZCksXG4gICAgICBib3hTZWxlY3Rpb25FbmFibGVkOiBkZWZWYWwoZmFsc2UsIG9wdGlvbnMuYm94U2VsZWN0aW9uRW5hYmxlZCksXG4gICAgICBhdXRvbG9jazogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG9sb2NrLCBvcHRpb25zLmF1dG9sb2NrTm9kZXMpLFxuICAgICAgYXV0b3VuZ3JhYmlmeTogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG91bmdyYWJpZnksIG9wdGlvbnMuYXV0b3VuZ3JhYmlmeU5vZGVzKSxcbiAgICAgIGF1dG91bnNlbGVjdGlmeTogZGVmVmFsKGZhbHNlLCBvcHRpb25zLmF1dG91bnNlbGVjdGlmeSksXG4gICAgICBzdHlsZUVuYWJsZWQ6IG9wdGlvbnMuc3R5bGVFbmFibGVkID09PSB1bmRlZmluZWQgPyBoZWFkIDogb3B0aW9ucy5zdHlsZUVuYWJsZWQsXG4gICAgICB6b29tOiAkJC5pcy5udW1iZXIob3B0aW9ucy56b29tKSA/IG9wdGlvbnMuem9vbSA6IDEsXG4gICAgICBwYW46IHtcbiAgICAgICAgeDogJCQuaXMucGxhaW5PYmplY3Qob3B0aW9ucy5wYW4pICYmICQkLmlzLm51bWJlcihvcHRpb25zLnBhbi54KSA/IG9wdGlvbnMucGFuLnggOiAwLFxuICAgICAgICB5OiAkJC5pcy5wbGFpbk9iamVjdChvcHRpb25zLnBhbikgJiYgJCQuaXMubnVtYmVyKG9wdGlvbnMucGFuLnkpID8gb3B0aW9ucy5wYW4ueSA6IDBcbiAgICAgIH0sXG4gICAgICBhbmltYXRpb246IHsgLy8gb2JqZWN0IGZvciBjdXJyZW50bHktcnVubmluZyBhbmltYXRpb25zXG4gICAgICAgIGN1cnJlbnQ6IFtdLFxuICAgICAgICBxdWV1ZTogW11cbiAgICAgIH0sXG4gICAgICBoYXNDb21wb3VuZE5vZGVzOiBmYWxzZSxcbiAgICAgIGRlZmVycmVkRXhlY1F1ZXVlOiBbXVxuICAgIH07XG5cbiAgICAvLyBzZXQgc2VsZWN0aW9uIHR5cGVcbiAgICB2YXIgc2VsVHlwZSA9IG9wdGlvbnMuc2VsZWN0aW9uVHlwZTtcbiAgICBpZiggc2VsVHlwZSA9PT0gdW5kZWZpbmVkIHx8IChzZWxUeXBlICE9PSAnYWRkaXRpdmUnICYmIHNlbFR5cGUgIT09ICdzaW5nbGUnKSApe1xuICAgICAgLy8gdGhlbiBzZXQgZGVmYXVsdFxuXG4gICAgICBfcC5zZWxlY3Rpb25UeXBlID0gJ3NpbmdsZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wLnNlbGVjdGlvblR5cGUgPSBzZWxUeXBlO1xuICAgIH1cblxuICAgIC8vIGluaXQgem9vbSBib3VuZHNcbiAgICBpZiggJCQuaXMubnVtYmVyKG9wdGlvbnMubWluWm9vbSkgJiYgJCQuaXMubnVtYmVyKG9wdGlvbnMubWF4Wm9vbSkgJiYgb3B0aW9ucy5taW5ab29tIDwgb3B0aW9ucy5tYXhab29tICl7XG4gICAgICBfcC5taW5ab29tID0gb3B0aW9ucy5taW5ab29tO1xuICAgICAgX3AubWF4Wm9vbSA9IG9wdGlvbnMubWF4Wm9vbTtcbiAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcihvcHRpb25zLm1pblpvb20pICYmIG9wdGlvbnMubWF4Wm9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBfcC5taW5ab29tID0gb3B0aW9ucy5taW5ab29tO1xuICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKG9wdGlvbnMubWF4Wm9vbSkgJiYgb3B0aW9ucy5taW5ab29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgIF9wLm1heFpvb20gPSBvcHRpb25zLm1heFpvb207XG4gICAgfVxuXG4gICAgdmFyIGxvYWRFeHREYXRhID0gZnVuY3Rpb24oIG5leHQgKXtcbiAgICAgIHZhciBhbnlJc1Byb21pc2UgPSBmYWxzZTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBleHREYXRhLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBkYXR1bSA9IGV4dERhdGFbaV07XG5cbiAgICAgICAgaWYoICQkLmlzLnByb21pc2UoZGF0dW0pICl7XG4gICAgICAgICAgYW55SXNQcm9taXNlID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggYW55SXNQcm9taXNlICl7XG4gICAgICAgIHJldHVybiAkJC5Qcm9taXNlLmFsbCggZXh0RGF0YSApLnRoZW4oIG5leHQgKTsgLy8gbG9hZCBhbGwgZGF0YSBhc3luY2hyb25vdXNseSwgdGhlbiBleGVjIHJlc3Qgb2YgaW5pdFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCggZXh0RGF0YSApOyAvLyBleGVjIHN5bmNocm9ub3VzbHkgZm9yIGNvbnZlbmllbmNlXG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBleHREYXRhID0gWyBvcHRpb25zLnN0eWxlLCBvcHRpb25zLmVsZW1lbnRzIF07XG4gICAgbG9hZEV4dERhdGEoZnVuY3Rpb24oIHRoZW5zICl7XG4gICAgICB2YXIgaW5pdFN0eWxlID0gdGhlbnNbMF07XG4gICAgICB2YXIgaW5pdEVsZXMgPSB0aGVuc1sxXTtcbiAgIFxuICAgICAgLy8gaW5pdCBzdHlsZVxuICAgICAgaWYoIF9wLnN0eWxlRW5hYmxlZCApe1xuICAgICAgICBjeS5zZXRTdHlsZSggaW5pdFN0eWxlICk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNyZWF0ZSB0aGUgcmVuZGVyZXJcbiAgICAgIGN5LmluaXRSZW5kZXJlciggJCQudXRpbC5leHRlbmQoe1xuICAgICAgICBoaWRlRWRnZXNPblZpZXdwb3J0OiBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQsXG4gICAgICAgIGhpZGVMYWJlbHNPblZpZXdwb3J0OiBvcHRpb25zLmhpZGVMYWJlbHNPblZpZXdwb3J0LFxuICAgICAgICB0ZXh0dXJlT25WaWV3cG9ydDogb3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydCxcbiAgICAgICAgd2hlZWxTZW5zaXRpdml0eTogJCQuaXMubnVtYmVyKG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSkgJiYgb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5ID4gMCA/IG9wdGlvbnMud2hlZWxTZW5zaXRpdml0eSA6IDEsXG4gICAgICAgIG1vdGlvbkJsdXI6IG9wdGlvbnMubW90aW9uQmx1ciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMubW90aW9uQmx1ciwgLy8gb24gYnkgZGVmYXVsdFxuICAgICAgICBtb3Rpb25CbHVyT3BhY2l0eTogb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eSA9PT0gdW5kZWZpbmVkID8gMC4wNSA6IG9wdGlvbnMubW90aW9uQmx1ck9wYWNpdHksXG4gICAgICAgIHBpeGVsUmF0aW86ICQkLmlzLm51bWJlcihvcHRpb25zLnBpeGVsUmF0aW8pICYmIG9wdGlvbnMucGl4ZWxSYXRpbyA+IDAgPyBvcHRpb25zLnBpeGVsUmF0aW8gOiAob3B0aW9ucy5waXhlbFJhdGlvID09PSAnYXV0bycgPyB1bmRlZmluZWQgOiAxKSxcbiAgICAgICAgZGVza3RvcFRhcFRocmVzaG9sZDogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkID09PSB1bmRlZmluZWQgPyA0IDogb3B0aW9ucy5kZXNrdG9wVGFwVGhyZXNob2xkLFxuICAgICAgICB0b3VjaFRhcFRocmVzaG9sZDogb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZCA9PT0gdW5kZWZpbmVkID8gOCA6IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGRcbiAgICAgIH0sIG9wdGlvbnMucmVuZGVyZXIpICk7XG5cbiAgICAgIC8vIHRyaWdnZXIgdGhlIHBhc3NlZCBmdW5jdGlvbiBmb3IgdGhlIGBpbml0cmVuZGVyYCBldmVudFxuICAgICAgaWYoIG9wdGlvbnMuaW5pdHJlbmRlciApe1xuICAgICAgICBjeS5vbignaW5pdHJlbmRlcicsIG9wdGlvbnMuaW5pdHJlbmRlcik7XG4gICAgICAgIGN5Lm9uKCdpbml0cmVuZGVyJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICBjeS5fcHJpdmF0ZS5pbml0cmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGluaXRpYWwgbG9hZFxuICAgICAgY3kubG9hZChpbml0RWxlcywgZnVuY3Rpb24oKXsgLy8gb25yZWFkeVxuICAgICAgICBjeS5zdGFydEFuaW1hdGlvbkxvb3AoKTtcbiAgICAgICAgY3kuX3ByaXZhdGUucmVhZHkgPSB0cnVlO1xuXG4gICAgICAgIC8vIGlmIGEgcmVhZHkgY2FsbGJhY2sgaXMgc3BlY2lmaWVkIGFzIGFuIG9wdGlvbiwgdGhlIGJpbmQgaXRcbiAgICAgICAgaWYoICQkLmlzLmZuKCBvcHRpb25zLnJlYWR5ICkgKXtcbiAgICAgICAgICBjeS5vbigncmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGJpbmQgYWxsIHRoZSByZWFkeSBoYW5kbGVycyByZWdpc3RlcmVkIGJlZm9yZSBjcmVhdGluZyB0aGlzIGluc3RhbmNlXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgcmVhZGllcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBmbiA9IHJlYWRpZXNbaV07XG4gICAgICAgICAgY3kub24oJ3JlYWR5JywgZm4pO1xuICAgICAgICB9XG4gICAgICAgIGlmKCByZWcgKXsgcmVnLnJlYWRpZXMgPSBbXTsgfSAvLyBjbGVhciBiL2Mgd2UndmUgYm91bmQgdGhlbSBhbGwgYW5kIGRvbid0IHdhbnQgdG8ga2VlcCBpdCBhcm91bmQgaW4gY2FzZSBhIG5ldyBjb3JlIHVzZXMgdGhlIHNhbWUgZGl2IGV0Y1xuICAgICAgICBcbiAgICAgICAgY3kudHJpZ2dlcigncmVhZHknKTtcbiAgICAgIH0sIG9wdGlvbnMuZG9uZSk7XG5cbiAgICB9KTtcbiAgfTtcblxuICAkJC5jb3JlZm4gPSAkJC5Db3JlLnByb3RvdHlwZTsgLy8gc2hvcnQgYWxpYXNcbiAgXG5cbiAgJCQuZm4uY29yZSh7XG4gICAgaXNSZWFkeTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnJlYWR5O1xuICAgIH0sXG5cbiAgICByZWFkeTogZnVuY3Rpb24oIGZuICl7XG4gICAgICBpZiggdGhpcy5pc1JlYWR5KCkgKXtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZWFkeScsIFtdLCBmbik7IC8vIGp1c3QgY2FsbHMgZm4gYXMgdGhvdWdoIHRyaWdnZXJlZCB2aWEgcmVhZHkgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub24oJ3JlYWR5JywgZm4pO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBpbml0cmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuaW5pdHJlbmRlcjtcbiAgICB9LFxuXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMubm90aWZ5KHsgdHlwZTogJ2Rlc3Ryb3knIH0pOyAvLyBkZXN0cm95IHRoZSByZW5kZXJlclxuXG4gICAgICB2YXIgZG9tRWxlID0gdGhpcy5jb250YWluZXIoKTtcbiAgICAgIHZhciBwYXJFbGUgPSBkb21FbGUucGFyZW50Tm9kZTtcbiAgICAgIGlmKCBwYXJFbGUgKXtcbiAgICAgICAgcGFyRWxlLnJlbW92ZUNoaWxkKCBkb21FbGUgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldEVsZW1lbnRCeUlkOiBmdW5jdGlvbiggaWQgKXtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuX3ByaXZhdGUuaWQyaW5kZXhbIGlkIF07XG4gICAgICBpZiggaW5kZXggIT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5lbGVtZW50c1sgaW5kZXggXTtcbiAgICAgIH1cblxuICAgICAgLy8gd29yc3QgY2FzZSwgcmV0dXJuIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcyApO1xuICAgIH0sXG5cbiAgICBzZWxlY3Rpb25UeXBlOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuc2VsZWN0aW9uVHlwZTtcbiAgICB9LFxuXG4gICAgaGFzQ29tcG91bmROb2RlczogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXM7XG4gICAgfSxcblxuICAgIHN0eWxlRW5hYmxlZDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlRW5hYmxlZDtcbiAgICB9LFxuXG4gICAgYWRkVG9Qb29sOiBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgdmFyIGVsZW1lbnRzID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50cztcbiAgICAgIHZhciBpZDJpbmRleCA9IHRoaXMuX3ByaXZhdGUuaWQyaW5kZXg7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICB2YXIgaWQgPSBlbGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGluZGV4ID0gaWQyaW5kZXhbIGlkIF07XG4gICAgICAgIHZhciBhbHJlYWR5SW5Qb29sID0gaW5kZXggIT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiggIWFscmVhZHlJblBvb2wgKXtcbiAgICAgICAgICBpbmRleCA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICBpZDJpbmRleFsgaWQgXSA9IGluZGV4O1xuICAgICAgICAgIGVsZS5fcHJpdmF0ZS5pbmRleCA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICByZW1vdmVGcm9tUG9vbDogZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuX3ByaXZhdGUuZWxlbWVudHM7XG4gICAgICB2YXIgaWQyaW5kZXggPSB0aGlzLl9wcml2YXRlLmlkMmluZGV4O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBpbmRleCA9IGlkMmluZGV4WyBpZCBdO1xuICAgICAgICB2YXIgaW5Qb29sID0gaW5kZXggIT09IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiggaW5Qb29sICl7XG4gICAgICAgICAgdGhpcy5fcHJpdmF0ZS5pZDJpbmRleFsgaWQgXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBlbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgICAgICAgLy8gYWRqdXN0IHRoZSBpbmRleCBvZiBhbGwgZWxlbWVudHMgcGFzdCB0aGlzIGluZGV4XG4gICAgICAgICAgZm9yKCB2YXIgaiA9IGluZGV4OyBqIDwgZWxlbWVudHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciBqaWQgPSBlbGVtZW50c1tqXS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICAgICAgaWQyaW5kZXhbIGppZCBdLS07XG4gICAgICAgICAgICBlbGVtZW50c1tqXS5fcHJpdmF0ZS5pbmRleC0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb250YWluZXI6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5jb250YWluZXI7XG4gICAgfSxcblxuICAgIG9wdGlvbnM6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gJCQudXRpbC5jb3B5KCB0aGlzLl9wcml2YXRlLm9wdGlvbnMgKTtcbiAgICB9LFxuICAgIFxuICAgIGpzb246IGZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgICB2YXIganNvbiA9IHt9O1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIFxuICAgICAganNvbi5lbGVtZW50cyA9IHt9O1xuICAgICAgY3kuZWxlbWVudHMoKS5lYWNoKGZ1bmN0aW9uKGksIGVsZSl7XG4gICAgICAgIHZhciBncm91cCA9IGVsZS5ncm91cCgpO1xuICAgICAgICBcbiAgICAgICAgaWYoICFqc29uLmVsZW1lbnRzW2dyb3VwXSApe1xuICAgICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGpzb24uZWxlbWVudHNbZ3JvdXBdLnB1c2goIGVsZS5qc29uKCkgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiggdGhpcy5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQgKXtcbiAgICAgICAganNvbi5zdHlsZSA9IGN5LnN0eWxlKCkuanNvbigpO1xuICAgICAgfVxuXG4gICAgICBqc29uLnpvb21pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQ7XG4gICAgICBqc29uLnVzZXJab29taW5nRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnVzZXJab29taW5nRW5hYmxlZDtcbiAgICAgIGpzb24uem9vbSA9IGN5Ll9wcml2YXRlLnpvb207XG4gICAgICBqc29uLm1pblpvb20gPSBjeS5fcHJpdmF0ZS5taW5ab29tO1xuICAgICAganNvbi5tYXhab29tID0gY3kuX3ByaXZhdGUubWF4Wm9vbTtcbiAgICAgIGpzb24ucGFubmluZ0VuYWJsZWQgPSBjeS5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZDtcbiAgICAgIGpzb24udXNlclBhbm5pbmdFbmFibGVkID0gY3kuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkO1xuICAgICAganNvbi5wYW4gPSBjeS5fcHJpdmF0ZS5wYW47XG4gICAgICBqc29uLmJveFNlbGVjdGlvbkVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkO1xuICAgICAganNvbi5sYXlvdXQgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLmxheW91dDtcbiAgICAgIGpzb24ucmVuZGVyZXIgPSBjeS5fcHJpdmF0ZS5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAganNvbi5oaWRlRWRnZXNPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy5oaWRlRWRnZXNPblZpZXdwb3J0O1xuICAgICAganNvbi5oaWRlTGFiZWxzT25WaWV3cG9ydCA9IGN5Ll9wcml2YXRlLm9wdGlvbnMuaGlkZUxhYmVsc09uVmlld3BvcnQ7XG4gICAgICBqc29uLnRleHR1cmVPblZpZXdwb3J0ID0gY3kuX3ByaXZhdGUub3B0aW9ucy50ZXh0dXJlT25WaWV3cG9ydDtcbiAgICAgIGpzb24ud2hlZWxTZW5zaXRpdml0eSA9IGN5Ll9wcml2YXRlLm9wdGlvbnMud2hlZWxTZW5zaXRpdml0eTtcbiAgICAgIGpzb24ubW90aW9uQmx1ciA9IGN5Ll9wcml2YXRlLm9wdGlvbnMubW90aW9uQmx1cjtcbiAgICAgIFxuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcblxuICAgIC8vIGRlZmVyIGV4ZWN1dGlvbiB1bnRpbCBub3QgYnVzeSBhbmQgZ3VhcmFudGVlIHJlbGF0aXZlIGV4ZWN1dGlvbiBvcmRlciBvZiBkZWZlcnJlZCBmdW5jdGlvbnNcbiAgICBkZWZlcjogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgdmFyIF9wID0gY3kuX3ByaXZhdGU7XG4gICAgICB2YXIgcSA9IF9wLmRlZmVycmVkRXhlY1F1ZXVlO1xuXG4gICAgICBxLnB1c2goIGZuICk7XG5cbiAgICAgIGlmKCAhX3AuZGVmZXJyZWRUaW1lb3V0ICl7XG4gICAgICAgIF9wLmRlZmVycmVkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICB3aGlsZSggcS5sZW5ndGggPiAwICl7XG4gICAgICAgICAgICAoIHEuc2hpZnQoKSApKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3AuZGVmZXJyZWRUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICB9KTsgIFxuICBcbn0pKCBjeXRvc2NhcGUsIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdyApO1xuXG4oZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiByZWFkeShmKSB7XG4gICAgdmFyIGZuID0gKCBkb2N1bWVudCAmJiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2ludGVyYWN0aXZlJyB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSApICA/IGYgOiByZWFkeTtcblxuICAgIHNldFRpbWVvdXQoZm4sIDksIGYpO1xuICB9XG5cbiAgJCQuZm4uY29yZSh7XG4gICAgYWRkOiBmdW5jdGlvbihvcHRzKXtcbiAgICAgIFxuICAgICAgdmFyIGVsZW1lbnRzO1xuICAgICAgdmFyIGN5ID0gdGhpcztcbiAgICAgIFxuICAgICAgLy8gYWRkIHRoZSBlbGVtZW50c1xuICAgICAgaWYoICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24ob3B0cykgKXtcbiAgICAgICAgdmFyIGVsZXMgPSBvcHRzO1xuXG4gICAgICAgIGlmKCBlbGVzLl9wcml2YXRlLmN5ID09PSBjeSApeyAvLyBzYW1lIGluc3RhbmNlID0+IGp1c3QgcmVzdG9yZVxuICAgICAgICAgIGVsZW1lbnRzID0gZWxlcy5yZXN0b3JlKCk7XG5cbiAgICAgICAgfSBlbHNlIHsgLy8gb3RoZXJ3aXNlLCBjb3B5IGZyb20ganNvblxuICAgICAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgICAgIGpzb25zLnB1c2goIGVsZS5qc29uKCkgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlbGVtZW50cyA9IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwganNvbnMgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBzcGVjaWZ5IGFuIGFycmF5IG9mIG9wdGlvbnNcbiAgICAgIGVsc2UgaWYoICQkLmlzLmFycmF5KG9wdHMpICl7XG4gICAgICAgIHZhciBqc29ucyA9IG9wdHM7XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgJCQuQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBzcGVjaWZ5IHZpYSBvcHRzLm5vZGVzIGFuZCBvcHRzLmVkZ2VzXG4gICAgICBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdChvcHRzKSAmJiAoJCQuaXMuYXJyYXkob3B0cy5ub2RlcykgfHwgJCQuaXMuYXJyYXkob3B0cy5lZGdlcykpICl7XG4gICAgICAgIHZhciBlbGVzQnlHcm91cCA9IG9wdHM7XG4gICAgICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgICAgIHZhciBncnMgPSBbJ25vZGVzJywgJ2VkZ2VzJ107XG4gICAgICAgIGZvciggdmFyIGkgPSAwLCBpbCA9IGdycy5sZW5ndGg7IGkgPCBpbDsgaSsrICl7XG4gICAgICAgICAgdmFyIGdyb3VwID0gZ3JzW2ldO1xuICAgICAgICAgIHZhciBlbGVzQXJyYXkgPSBlbGVzQnlHcm91cFtncm91cF07XG5cbiAgICAgICAgICBpZiggJCQuaXMuYXJyYXkoZWxlc0FycmF5KSApe1xuXG4gICAgICAgICAgICBmb3IoIHZhciBqID0gMCwgamwgPSBlbGVzQXJyYXkubGVuZ3RoOyBqIDwgamw7IGorKyApe1xuICAgICAgICAgICAgICB2YXIganNvbiA9IGVsZXNBcnJheVtqXTtcbiAgICAgICAgICAgICAganNvbi5ncm91cCA9IGdyb3VwO1xuXG4gICAgICAgICAgICAgIGpzb25zLnB1c2goIGpzb24gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IFxuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudHMgPSBuZXcgJCQuQ29sbGVjdGlvbihjeSwganNvbnMpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBzcGVjaWZ5IG9wdGlvbnMgZm9yIG9uZSBlbGVtZW50XG4gICAgICBlbHNlIHtcbiAgICAgICAgdmFyIGpzb24gPSBvcHRzO1xuICAgICAgICBlbGVtZW50cyA9IChuZXcgJCQuRWxlbWVudCggY3ksIGpzb24gKSkuY29sbGVjdGlvbigpO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfSxcbiAgICBcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGNvbGxlY3Rpb24pe1xuICAgICAgaWYoICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oY29sbGVjdGlvbikgKXtcbiAgICAgICAgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhjb2xsZWN0aW9uKSApe1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBjb2xsZWN0aW9uO1xuICAgICAgICBjb2xsZWN0aW9uID0gdGhpcy4kKCBzZWxlY3RvciApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gY29sbGVjdGlvbi5yZW1vdmUoKTtcbiAgICB9LFxuICAgIFxuICAgIGxvYWQ6IGZ1bmN0aW9uKGVsZW1lbnRzLCBvbmxvYWQsIG9uZG9uZSl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuICAgICAgXG4gICAgICBjeS5ub3RpZmljYXRpb25zKGZhbHNlKTtcblxuICAgICAgLy8gcmVtb3ZlIG9sZCBlbGVtZW50c1xuICAgICAgdmFyIG9sZEVsZXMgPSBjeS5lbGVtZW50cygpO1xuICAgICAgaWYoIG9sZEVsZXMubGVuZ3RoID4gMCApe1xuICAgICAgICBvbGRFbGVzLnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggZWxlbWVudHMgIT0gbnVsbCApe1xuICAgICAgICBpZiggJCQuaXMucGxhaW5PYmplY3QoZWxlbWVudHMpIHx8ICQkLmlzLmFycmF5KGVsZW1lbnRzKSApe1xuICAgICAgICAgIGN5LmFkZCggZWxlbWVudHMgKTtcbiAgICAgICAgfSBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gY2FsbGJhY2soKXsgICAgICAgIFxuICAgICAgICBjeS5vbmUoJ2xheW91dHJlYWR5JywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgY3kubm90aWZpY2F0aW9ucyh0cnVlKTtcbiAgICAgICAgICBjeS50cmlnZ2VyKGUpOyAvLyB3ZSBtaXNzZWQgdGhpcyBldmVudCBieSB0dXJuaW5nIG5vdGlmaWNhdGlvbnMgb2ZmLCBzbyBwYXNzIGl0IG9uXG5cbiAgICAgICAgICBjeS5ub3RpZnkoe1xuICAgICAgICAgICAgdHlwZTogJ2xvYWQnLFxuICAgICAgICAgICAgY29sbGVjdGlvbjogY3kuZWxlbWVudHMoKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY3kub25lKCdsb2FkJywgb25sb2FkKTtcbiAgICAgICAgICBjeS50cmlnZ2VyKCdsb2FkJyk7XG4gICAgICAgIH0pLm9uZSgnbGF5b3V0c3RvcCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgY3kub25lKCdkb25lJywgb25kb25lKTtcbiAgICAgICAgICBjeS50cmlnZ2VyKCdkb25lJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdmFyIGxheW91dE9wdHMgPSAkJC51dGlsLmV4dGVuZCh7fSwgY3kuX3ByaXZhdGUub3B0aW9ucy5sYXlvdXQpO1xuICAgICAgICBsYXlvdXRPcHRzLmVsZXMgPSBjeS4kKCk7XG5cbiAgICAgICAgY3kubGF5b3V0KCBsYXlvdXRPcHRzICk7XG5cbiAgICAgIH1cblxuICAgICAgaWYoIHdpbmRvdyApe1xuICAgICAgICByZWFkeSggY2FsbGJhY2sgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogd2luZG93ICk7XG5cbjsoZnVuY3Rpb24oJCQsIHdpbmRvdyl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIFxuICAgIC8vIHB1bGwgaW4gYW5pbWF0aW9uIGZ1bmN0aW9uc1xuICAgIGFuaW1hdGVkOiAkJC5kZWZpbmUuYW5pbWF0ZWQoKSxcbiAgICBjbGVhclF1ZXVlOiAkJC5kZWZpbmUuY2xlYXJRdWV1ZSgpLFxuICAgIGRlbGF5OiAkJC5kZWZpbmUuZGVsYXkoKSxcbiAgICBhbmltYXRlOiAkJC5kZWZpbmUuYW5pbWF0ZSgpLFxuICAgIHN0b3A6ICQkLmRlZmluZS5zdG9wKCksXG5cbiAgICBhZGRUb0FuaW1hdGlvblBvb2w6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcbiAgICAgIFxuICAgICAgY3kuX3ByaXZhdGUuYW5pRWxlcy5tZXJnZSggZWxlcyApO1xuICAgIH0sXG5cbiAgICBzdGFydEFuaW1hdGlvbkxvb3A6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY3kgPSB0aGlzO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybjsgfSAvLyBzYXZlIGN5Y2xlcyB3aGVuIG5vIHN0eWxlIHVzZWRcblxuICAgICAgLy8gZG9uJ3QgZXhlY3V0ZSB0aGUgYW5pbWF0aW9uIGxvb3AgaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzXG4gICAgICBpZiggIXdpbmRvdyApe1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGdsb2JhbEFuaW1hdGlvblN0ZXAoKXtcbiAgICAgICAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24obm93KXtcbiAgICAgICAgICBoYW5kbGVFbGVtZW50cyhub3cpO1xuICAgICAgICAgIGdsb2JhbEFuaW1hdGlvblN0ZXAoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGdsb2JhbEFuaW1hdGlvblN0ZXAoKTsgLy8gZmlyc3QgY2FsbFxuICAgICAgXG4gICAgICBmdW5jdGlvbiBoYW5kbGVFbGVtZW50cyhub3cpe1xuICAgICAgICBub3cgPSArbmV3IERhdGUoKTtcblxuICAgICAgICB2YXIgZWxlcyA9IGN5Ll9wcml2YXRlLmFuaUVsZXM7XG4gICAgICAgIHZhciBkb25lRWxlcyA9IFtdO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUVsZW1lbnQoIGVsZSwgaXNDb3JlICl7XG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBlbGUuX3ByaXZhdGUuYW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgICAgICAgdmFyIHF1ZXVlID0gZWxlLl9wcml2YXRlLmFuaW1hdGlvbi5xdWV1ZTtcbiAgICAgICAgICB2YXIgcmFuQW5pcyA9IGZhbHNlO1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIGlmIG5vdGhpbmcgY3VycmVudGx5IGFuaW1hdGluZywgZ2V0IHNvbWV0aGluZyBmcm9tIHRoZSBxdWV1ZVxuICAgICAgICAgIGlmKCBjdXJyZW50Lmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgICAgdmFyIG5leHQgPSBxdWV1ZS5sZW5ndGggPiAwID8gcXVldWUuc2hpZnQoKSA6IG51bGw7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBuZXh0ICl7XG4gICAgICAgICAgICAgIG5leHQuY2FsbFRpbWUgPSBub3c7IC8vIHdhcyBxdWV1ZWQsIHNvIHVwZGF0ZSBjYWxsIHRpbWVcbiAgICAgICAgICAgICAgY3VycmVudC5wdXNoKCBuZXh0ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIHN0ZXAgYW5kIHJlbW92ZSBpZiBkb25lXG4gICAgICAgICAgdmFyIGNvbXBsZXRlcyA9IFtdO1xuICAgICAgICAgIGZvcih2YXIgaSA9IGN1cnJlbnQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICAgICAgdmFyIGFuaSA9IGN1cnJlbnRbaV07XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IGlmIG5lZWQgYmVcbiAgICAgICAgICAgIGlmKCAhYW5pLnN0YXJ0ZWQgKXsgc3RhcnRBbmltYXRpb24oIGVsZSwgYW5pICk7IH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3RlcCggZWxlLCBhbmksIG5vdywgaXNDb3JlICk7XG5cbiAgICAgICAgICAgIGlmKCBhbmkuZG9uZSApe1xuICAgICAgICAgICAgICBjb21wbGV0ZXMucHVzaCggYW5pICk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAvLyByZW1vdmUgY3VycmVudFtpXVxuICAgICAgICAgICAgICBjdXJyZW50LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmFuQW5pcyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGNhbGwgY29tcGxldGUgY2FsbGJhY2tzXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb21wbGV0ZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBhbmkgPSBjb21wbGV0ZXNbaV07XG4gICAgICAgICAgICB2YXIgY29tcGxldGUgPSBhbmkucGFyYW1zLmNvbXBsZXRlO1xuXG4gICAgICAgICAgICBpZiggJCQuaXMuZm4oY29tcGxldGUpICl7XG4gICAgICAgICAgICAgIGNvbXBsZXRlLmFwcGx5KCBlbGUsIFsgbm93IF0gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggIWlzQ29yZSAmJiBjdXJyZW50Lmxlbmd0aCA9PT0gMCAmJiBxdWV1ZS5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgICAgIGRvbmVFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByYW5BbmlzO1xuICAgICAgICB9IC8vIGhhbmRsZUVsZW1lbnRzXG5cbiAgICAgICAgLy8gaGFuZGxlIGFsbCBlbGVzXG4gICAgICAgIGZvciggdmFyIGUgPSAwOyBlIDwgZWxlcy5sZW5ndGg7IGUrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2VdO1xuICAgICAgICAgIFxuICAgICAgICAgIGhhbmRsZUVsZW1lbnQoIGVsZSApO1xuICAgICAgICB9IC8vIGVhY2ggZWxlbWVudFxuXG4gICAgICAgIHZhciByYW5Db3JlQW5pID0gaGFuZGxlRWxlbWVudCggY3ksIHRydWUgKTtcbiAgICAgICAgXG4gICAgICAgIC8vIG5vdGlmeSByZW5kZXJlclxuICAgICAgICBpZiggZWxlcy5sZW5ndGggPiAwIHx8IHJhbkNvcmVBbmkgKXtcbiAgICAgICAgICB2YXIgdG9Ob3RpZnk7XG5cbiAgICAgICAgICBpZiggZWxlcy5sZW5ndGggPiAwICl7XG4gICAgICAgICAgICB2YXIgdXBkYXRlZEVsZXMgPSBlbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgICB0b05vdGlmeSA9IHVwZGF0ZWRFbGVzLmxlbmd0aCA+IDAgPyBlbGVzLmFkZCggdXBkYXRlZEVsZXMgKSA6IGVsZXM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3kubm90aWZ5KHtcbiAgICAgICAgICAgIHR5cGU6ICdkcmF3JyxcbiAgICAgICAgICAgIGNvbGxlY3Rpb246IHRvTm90aWZ5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgZWxlbWVudHMgZnJvbSBsaXN0IG9mIGN1cnJlbnRseSBhbmltYXRpbmcgaWYgaXRzIHF1ZXVlcyBhcmUgZW1wdHlcbiAgICAgICAgZWxlcy51bm1lcmdlKCBkb25lRWxlcyApO1xuXG4gICAgICB9IC8vIGhhbmRsZUVsZW1lbnRzXG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKCBzZWxmLCBhbmkgKXtcbiAgICAgICAgdmFyIGlzQ29yZSA9ICQkLmlzLmNvcmUoIHNlbGYgKTtcbiAgICAgICAgdmFyIGlzRWxlcyA9ICFpc0NvcmU7XG4gICAgICAgIHZhciBlbGUgPSBzZWxmO1xuICAgICAgICB2YXIgc3R5bGUgPSBjeS5fcHJpdmF0ZS5zdHlsZTtcblxuICAgICAgICBpZiggaXNFbGVzICl7XG4gICAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgIHg6IHBvcy54LFxuICAgICAgICAgICAgeTogcG9zLnlcbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBzdGFydFN0eWxlID0gc3R5bGUuZ2V0VmFsdWVTdHlsZSggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggaXNDb3JlICl7XG4gICAgICAgICAgdmFyIHBhbiA9IGN5Ll9wcml2YXRlLnBhbjtcbiAgICAgICAgICB2YXIgc3RhcnRQYW4gPSB7XG4gICAgICAgICAgICB4OiBwYW4ueCxcbiAgICAgICAgICAgIHk6IHBhbi55XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBzdGFydFpvb20gPSBjeS5fcHJpdmF0ZS56b29tO1xuICAgICAgICB9XG5cbiAgICAgICAgYW5pLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBhbmkuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgYW5pLnN0YXJ0UG9zaXRpb24gPSBzdGFydFBvc2l0aW9uO1xuICAgICAgICBhbmkuc3RhcnRTdHlsZSA9IHN0YXJ0U3R5bGU7XG4gICAgICAgIGFuaS5zdGFydFBhbiA9IHN0YXJ0UGFuO1xuICAgICAgICBhbmkuc3RhcnRab29tID0gc3RhcnRab29tO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzdGVwKCBzZWxmLCBhbmltYXRpb24sIG5vdywgaXNDb3JlICl7XG4gICAgICAgIHZhciBzdHlsZSA9IGN5Ll9wcml2YXRlLnN0eWxlO1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IGFuaW1hdGlvbi5wcm9wZXJ0aWVzO1xuICAgICAgICB2YXIgcGFyYW1zID0gYW5pbWF0aW9uLnBhcmFtcztcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IGFuaW1hdGlvbi5zdGFydFRpbWU7XG4gICAgICAgIHZhciBwZXJjZW50O1xuICAgICAgICB2YXIgaXNFbGVzID0gIWlzQ29yZTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBhbmltYXRpb24uZHVyYXRpb24gPT09IDAgKXtcbiAgICAgICAgICBwZXJjZW50ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZXJjZW50ID0gTWF0aC5taW4oMSwgKG5vdyAtIHN0YXJ0VGltZSkvYW5pbWF0aW9uLmR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwZXJjZW50IDwgMCApe1xuICAgICAgICAgIHBlcmNlbnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYoIHBlcmNlbnQgPiAxICl7XG4gICAgICAgICAgcGVyY2VudCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCBwcm9wZXJ0aWVzLmRlbGF5ID09IG51bGwgKXsgLy8gdGhlbiB1cGRhdGVcblxuICAgICAgICAgIHZhciBzdGFydFBvcyA9IGFuaW1hdGlvbi5zdGFydFBvc2l0aW9uO1xuICAgICAgICAgIHZhciBlbmRQb3MgPSBwcm9wZXJ0aWVzLnBvc2l0aW9uO1xuICAgICAgICAgIHZhciBwb3MgPSBzZWxmLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIGlmKCBlbmRQb3MgJiYgaXNFbGVzICl7XG4gICAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UG9zLngsIGVuZFBvcy54ICkgKXtcbiAgICAgICAgICAgICAgcG9zLnggPSBlYXNlKCBzdGFydFBvcy54LCBlbmRQb3MueCwgcGVyY2VudCApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggdmFsaWQoIHN0YXJ0UG9zLnksIGVuZFBvcy55ICkgKXtcbiAgICAgICAgICAgICAgcG9zLnkgPSBlYXNlKCBzdGFydFBvcy55LCBlbmRQb3MueSwgcGVyY2VudCApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzdGFydFBhbiA9IGFuaW1hdGlvbi5zdGFydFBhbjtcbiAgICAgICAgICB2YXIgZW5kUGFuID0gcHJvcGVydGllcy5wYW47XG4gICAgICAgICAgdmFyIHBhbiA9IHNlbGYuX3ByaXZhdGUucGFuO1xuICAgICAgICAgIHZhciBhbmltYXRpbmdQYW4gPSBlbmRQYW4gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgICAgICAgaWYoIGFuaW1hdGluZ1BhbiApe1xuICAgICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBhbi54LCBlbmRQYW4ueCApICl7XG4gICAgICAgICAgICAgIHBhbi54ID0gZWFzZSggc3RhcnRQYW4ueCwgZW5kUGFuLngsIHBlcmNlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIHZhbGlkKCBzdGFydFBhbi55LCBlbmRQYW4ueSApICl7XG4gICAgICAgICAgICAgIHBhbi55ID0gZWFzZSggc3RhcnRQYW4ueSwgZW5kUGFuLnksIHBlcmNlbnQgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCdwYW4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3RhcnRab29tID0gYW5pbWF0aW9uLnN0YXJ0Wm9vbTtcbiAgICAgICAgICB2YXIgZW5kWm9vbSA9IHByb3BlcnRpZXMuem9vbTtcbiAgICAgICAgICB2YXIgYW5pbWF0aW5nWm9vbSA9IGVuZFpvb20gIT0gbnVsbCAmJiBpc0NvcmU7XG4gICAgICAgICAgaWYoIGFuaW1hdGluZ1pvb20gKXtcbiAgICAgICAgICAgIGlmKCB2YWxpZCggc3RhcnRab29tLCBlbmRab29tICkgKXtcbiAgICAgICAgICAgICAgc2VsZi5fcHJpdmF0ZS56b29tID0gZWFzZSggc3RhcnRab29tLCBlbmRab29tLCBwZXJjZW50ICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYudHJpZ2dlcignem9vbScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBhbmltYXRpbmdQYW4gfHwgYW5pbWF0aW5nWm9vbSApe1xuICAgICAgICAgICAgc2VsZi50cmlnZ2VyKCd2aWV3cG9ydCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcm9wcyA9IHByb3BlcnRpZXMuc3R5bGUgfHwgcHJvcGVydGllcy5jc3M7XG4gICAgICAgICAgaWYoIHByb3BzICYmIGlzRWxlcyApe1xuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gcHJvcHNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgdmFyIHByb3AgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgICAgdmFyIGVuZCA9IHByb3A7XG5cbiAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYW5pbWF0aW9uLnN0YXJ0U3R5bGVbIG5hbWUgXTtcbiAgICAgICAgICAgICAgdmFyIGVhc2VkVmFsID0gZWFzZSggc3RhcnQsIGVuZCwgcGVyY2VudCApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgc3R5bGUub3ZlcnJpZGVCeXBhc3MoIHNlbGYsIG5hbWUsIGVhc2VkVmFsICk7XG4gICAgICAgICAgICB9IC8vIGZvciBwcm9wc1xuICAgICAgICAgICAgXG4gICAgICAgICAgfSAvLyBpZiBcblxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggJCQuaXMuZm4ocGFyYW1zLnN0ZXApICl7XG4gICAgICAgICAgcGFyYW1zLnN0ZXAuYXBwbHkoIHNlbGYsIFsgbm93IF0gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIHBlcmNlbnQgPj0gMSApe1xuICAgICAgICAgIGFuaW1hdGlvbi5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHBlcmNlbnQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHZhbGlkKHN0YXJ0LCBlbmQpe1xuICAgICAgICBpZiggc3RhcnQgPT0gbnVsbCB8fCBlbmQgPT0gbnVsbCApe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoICQkLmlzLm51bWJlcihzdGFydCkgJiYgJCQuaXMubnVtYmVyKGVuZCkgKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmKCAoc3RhcnQpICYmIChlbmQpICl7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gZWFzZShzdGFydFByb3AsIGVuZFByb3AsIHBlcmNlbnQpe1xuICAgICAgICBpZiggcGVyY2VudCA8IDAgKXtcbiAgICAgICAgICBwZXJjZW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmKCBwZXJjZW50ID4gMSApe1xuICAgICAgICAgIHBlcmNlbnQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgICAgICAgaWYoIHN0YXJ0UHJvcC5weFZhbHVlICE9IG51bGwgfHwgc3RhcnRQcm9wLnZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgICBzdGFydCA9IHN0YXJ0UHJvcC5weFZhbHVlICE9IG51bGwgPyBzdGFydFByb3AucHhWYWx1ZSA6IHN0YXJ0UHJvcC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGFydCA9IHN0YXJ0UHJvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBlbmRQcm9wLnB4VmFsdWUgIT0gbnVsbCB8fCBlbmRQcm9wLnZhbHVlICE9IG51bGwgKXtcbiAgICAgICAgICBlbmQgPSBlbmRQcm9wLnB4VmFsdWUgIT0gbnVsbCA/IGVuZFByb3AucHhWYWx1ZSA6IGVuZFByb3AudmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kID0gZW5kUHJvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAkJC5pcy5udW1iZXIoc3RhcnQpICYmICQkLmlzLm51bWJlcihlbmQpICl7XG4gICAgICAgICAgcmV0dXJuIHN0YXJ0ICsgKGVuZCAtIHN0YXJ0KSAqIHBlcmNlbnQ7XG5cbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIoc3RhcnRbMF0pICYmICQkLmlzLm51bWJlcihlbmRbMF0pICl7IC8vIHRoZW4gYXNzdW1lIGEgY29sb3VyXG4gICAgICAgICAgdmFyIGMxID0gc3RhcnQ7XG4gICAgICAgICAgdmFyIGMyID0gZW5kO1xuXG4gICAgICAgICAgdmFyIGNoID0gZnVuY3Rpb24oY2gxLCBjaDIpe1xuICAgICAgICAgICAgdmFyIGRpZmYgPSBjaDIgLSBjaDE7XG4gICAgICAgICAgICB2YXIgbWluID0gY2gxO1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoIHBlcmNlbnQgKiBkaWZmICsgbWluICk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgciA9IGNoKCBjMVswXSwgYzJbMF0gKTtcbiAgICAgICAgICB2YXIgZyA9IGNoKCBjMVsxXSwgYzJbMV0gKTtcbiAgICAgICAgICB2YXIgYiA9IGNoKCBjMVsyXSwgYzJbMl0gKTtcbiAgICAgICAgICBcbiAgICAgICAgICByZXR1cm4gW3IsIGcsIGJdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgXG4gICAgfVxuICAgIFxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlLCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cgKTtcblxuXG4gIFxuICAgIFxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIGRhdGE6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ2RhdGEnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWVcbiAgICB9KSxcblxuICAgIHJlbW92ZURhdGE6ICQkLmRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiB0cnVlXG4gICAgfSksXG5cbiAgICBzY3JhdGNoOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ3NjcmF0Y2gnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVtb3ZlU2NyYXRjaDogJCQuZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIHRyaWdnZXJFdmVudDogZmFsc2VcbiAgICB9KVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uY29yZSh7XG4gICAgb246ICQkLmRlZmluZS5vbigpLCAvLyAub24oIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgZGF0YV0sIGhhbmRsZXIpXG4gICAgb25lOiAkJC5kZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICAgIG9uY2U6ICQkLmRlZmluZS5vbih7IHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHRydWUgfSksXG4gICAgb2ZmOiAkJC5kZWZpbmUub2ZmKCksIC8vIC5vZmYoIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgaGFuZGxlcl0gKVxuICAgIHRyaWdnZXI6ICQkLmRlZmluZS50cmlnZ2VyKCkgLy8gLnRyaWdnZXIoIGV2ZW50cyBbLCBleHRyYVBhcmFtc10gKVxuICB9KTtcblxuICAkJC5kZWZpbmUuZXZlbnRBbGlhc2VzT24oICQkLmNvcmVmbiApO1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcbiAgICBcbiAgICBwbmc6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9wcml2YXRlLnJlbmRlcmVyO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHJldHVybiByZW5kZXJlci5wbmcoIG9wdGlvbnMgKTsgICAgICBcbiAgICB9LFxuICAgIFxuICAgIGpwZzogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIFxuICAgICAgb3B0aW9ucy5iZyA9IG9wdGlvbnMuYmcgfHwgJyNmZmYnO1xuXG4gICAgICByZXR1cm4gcmVuZGVyZXIuanBnKCBvcHRpb25zICk7ICAgICAgXG4gICAgfVxuICAgIFxuICB9KTtcbiAgXG4gICQkLmNvcmVmbi5qcGVnID0gJCQuY29yZWZuLmpwZztcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcbiAgICBcbiAgICBsYXlvdXQ6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHZhciBsYXlvdXQ7XG5cbiAgICAgIC8vIGFsd2F5cyB1c2UgYSBuZXcgbGF5b3V0IHcvIGluaXQgb3B0czsgc2xpZ2h0bHkgZGlmZmVyZW50IGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAvLyBidXQgZml4ZXMgbGF5b3V0IHJldXNlIGlzc3VlcyBsaWtlIGRhZ3JlICM4MTkgXG4gICAgICBpZiggcGFyYW1zID09IG51bGwgKXsgXG4gICAgICAgIHBhcmFtcyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCB0aGlzLl9wcml2YXRlLm9wdGlvbnMubGF5b3V0KTtcbiAgICAgICAgcGFyYW1zLmVsZXMgPSB0aGlzLiQoKTtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0ID0gdGhpcy5pbml0TGF5b3V0KCBwYXJhbXMgKTtcbiAgICAgIGxheW91dC5ydW4oKTtcblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIG1ha2VMYXlvdXQ6IGZ1bmN0aW9uKCBwYXJhbXMgKXtcbiAgICAgIHJldHVybiB0aGlzLmluaXRMYXlvdXQoIHBhcmFtcyApO1xuICAgIH0sXG4gICAgXG4gICAgaW5pdExheW91dDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIGlmKCBvcHRpb25zID09IG51bGwgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignTGF5b3V0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQgdG8gbWFrZSBhIGxheW91dCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBvcHRpb25zLm5hbWUgPT0gbnVsbCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdBIGBuYW1lYCBtdXN0IGJlIHNwZWNpZmllZCB0byBtYWtlIGEgbGF5b3V0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgICB2YXIgTGF5b3V0UHJvdG8gPSAkJC5leHRlbnNpb24oJ2xheW91dCcsIG5hbWUpO1xuICAgICAgXG4gICAgICBpZiggTGF5b3V0UHJvdG8gPT0gbnVsbCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGFwcGx5IGxheW91dDogTm8gc3VjaCBsYXlvdXQgYCcgKyBuYW1lICsgJ2AgZm91bmQ7IGRpZCB5b3UgaW5jbHVkZSBpdHMgSlMgZmlsZT8nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLmVsZXMgPSBvcHRpb25zLmVsZXMgIT0gbnVsbCA/IG9wdGlvbnMuZWxlcyA6IHRoaXMuJCgpO1xuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKCBvcHRpb25zLmVsZXMgKSApe1xuICAgICAgICBvcHRpb25zLmVsZXMgPSB0aGlzLiQoIG9wdGlvbnMuZWxlcyApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgbGF5b3V0ID0gbmV3IExheW91dFByb3RvKCAkJC51dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge1xuICAgICAgICBjeTogdGhpc1xuICAgICAgfSkgKTtcblxuICAgICAgLy8gbWFrZSBzdXJlIGxheW91dCBoYXMgX3ByaXZhdGUgZm9yIHVzZSB3LyBzdGQgYXBpcyBsaWtlIC5vbigpXG4gICAgICBpZiggISQkLmlzLnBsYWluT2JqZWN0KGxheW91dC5fcHJpdmF0ZSkgKXtcbiAgICAgICAgbGF5b3V0Ll9wcml2YXRlID0ge307XG4gICAgICB9XG5cbiAgICAgIGxheW91dC5fcHJpdmF0ZS5jeSA9IHRoaXM7XG4gICAgICBsYXlvdXQuX3ByaXZhdGUubGlzdGVuZXJzID0gW107XG4gICAgICBcbiAgICAgIHJldHVybiBsYXlvdXQ7XG4gICAgfVxuICAgIFxuICB9KTtcblxuICAkJC5jb3JlZm4uY3JlYXRlTGF5b3V0ID0gJCQuY29yZWZuLm1ha2VMYXlvdXQ7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuKGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uY29yZSh7XG4gICAgbm90aWZ5OiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICBpZiggdGhpcy5fcHJpdmF0ZS5iYXRjaGluZ05vdGlmeSApe1xuICAgICAgICB2YXIgYkVsZXMgPSB0aGlzLl9wcml2YXRlLmJhdGNoTm90aWZ5RWxlcztcbiAgICAgICAgdmFyIGJUeXBlcyA9IHRoaXMuX3ByaXZhdGUuYmF0Y2hOb3RpZnlUeXBlcztcblxuICAgICAgICBpZiggcGFyYW1zLmNvbGxlY3Rpb24gKXsgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJhbXMuY29sbGVjdGlvbi5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBwYXJhbXMuY29sbGVjdGlvbltpXTtcblxuICAgICAgICAgIGlmKCAhYkVsZXMuaWRzWyBlbGUuX3ByaXZhdGUuaWQgXSApe1xuICAgICAgICAgICAgYkVsZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IH1cblxuICAgICAgICBpZiggIWJUeXBlcy5pZHNbIHBhcmFtcy50eXBlIF0gKXtcbiAgICAgICAgICBiVHlwZXMucHVzaCggcGFyYW1zLnR5cGUgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjsgLy8gbm90aWZpY2F0aW9ucyBhcmUgZGlzYWJsZWQgZHVyaW5nIGJhdGNoaW5nXG4gICAgICB9XG5cbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5ub3RpZmljYXRpb25zRW5hYmxlZCApeyByZXR1cm47IH0gLy8gZXhpdCBvbiBkaXNhYmxlZFxuXG4gICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLnJlbmRlcmVyKCk7XG4gICAgICBcbiAgICAgIHJlbmRlcmVyLm5vdGlmeShwYXJhbXMpO1xuICAgIH0sXG4gICAgXG4gICAgbm90aWZpY2F0aW9uczogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIHZhciBwID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgIFxuICAgICAgaWYoIGJvb2wgPT09IHVuZGVmaW5lZCApe1xuICAgICAgICByZXR1cm4gcC5ub3RpZmljYXRpb25zRW5hYmxlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAubm90aWZpY2F0aW9uc0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgbm9Ob3RpZmljYXRpb25zOiBmdW5jdGlvbiggY2FsbGJhY2sgKXtcbiAgICAgIHRoaXMubm90aWZpY2F0aW9ucyhmYWxzZSk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgdGhpcy5ub3RpZmljYXRpb25zKHRydWUpO1xuICAgIH0sXG5cbiAgICBzdGFydEJhdGNoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcblxuICAgICAgX3AuYmF0Y2hpbmdTdHlsZSA9IF9wLmJhdGNoaW5nTm90aWZ5ID0gdHJ1ZTtcbiAgICAgIF9wLmJhdGNoU3R5bGVFbGVzID0gW107XG4gICAgICBfcC5iYXRjaE5vdGlmeUVsZXMgPSBbXTtcbiAgICAgIF9wLmJhdGNoTm90aWZ5VHlwZXMgPSBbXTtcblxuICAgICAgX3AuYmF0Y2hTdHlsZUVsZXMuaWRzID0ge307XG4gICAgICBfcC5iYXRjaE5vdGlmeUVsZXMuaWRzID0ge307XG4gICAgICBfcC5iYXRjaE5vdGlmeVR5cGVzLmlkcyA9IHt9O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZW5kQmF0Y2g6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICAvLyB1cGRhdGUgc3R5bGUgZm9yIGRpcnR5IGVsZXNcbiAgICAgIF9wLmJhdGNoaW5nU3R5bGUgPSBmYWxzZTtcbiAgICAgIG5ldyAkJC5Db2xsZWN0aW9uKHRoaXMsIF9wLmJhdGNoU3R5bGVFbGVzKS51cGRhdGVTdHlsZSgpO1xuXG4gICAgICAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIG9mIHF1ZXVlZCBlbGVzIGFuZCBldmVudCB0eXBlc1xuICAgICAgX3AuYmF0Y2hpbmdOb3RpZnkgPSBmYWxzZTtcbiAgICAgIHRoaXMubm90aWZ5KHtcbiAgICAgICAgdHlwZTogX3AuYmF0Y2hOb3RpZnlUeXBlcyxcbiAgICAgICAgY29sbGVjdGlvbjogX3AuYmF0Y2hOb3RpZnlFbGVzXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGJhdGNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKXtcbiAgICAgIHRoaXMuc3RhcnRCYXRjaCgpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIHRoaXMuZW5kQmF0Y2goKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGJhdGNoRGF0YTogZnVuY3Rpb24oIG1hcCApe1xuICAgICAgdmFyIGN5ID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMuYmF0Y2goZnVuY3Rpb24oKXtcbiAgICAgICAgZm9yKCB2YXIgaWQgaW4gbWFwICl7XG4gICAgICAgICAgdmFyIGRhdGEgPSBtYXBbaWRdO1xuICAgICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZCggaWQgKTtcbiAgICAgICAgICBcbiAgICAgICAgICBlbGUuZGF0YSggZGF0YSApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuICAgIFxuICAgIHJlbmRlclRvOiBmdW5jdGlvbiggY29udGV4dCwgem9vbSwgcGFuLCBweFJhdGlvICl7XG4gICAgICB2YXIgciA9IHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG5cbiAgICAgIHIucmVuZGVyVG8oIGNvbnRleHQsIHpvb20sIHBhbiwgcHhSYXRpbyApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlcmVyOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucmVuZGVyZXI7XG4gICAgfSxcblxuICAgIGZvcmNlUmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICB0eXBlOiAnZHJhdydcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICB0eXBlOiAncmVzaXplJ1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMudHJpZ2dlcigncmVzaXplJyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgXG4gICAgaW5pdFJlbmRlcmVyOiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIGN5ID0gdGhpcztcblxuICAgICAgdmFyIFJlbmRlcmVyUHJvdG8gPSAkJC5leHRlbnNpb24oJ3JlbmRlcmVyJywgb3B0aW9ucy5uYW1lKTtcbiAgICAgIGlmKCBSZW5kZXJlclByb3RvID09IG51bGwgKXtcbiAgICAgICAgJCQudXRpbC5lcnJvcignQ2FuIG5vdCBpbml0aWFsaXNlOiBObyBzdWNoIHJlbmRlcmVyIGAlc2AgZm91bmQ7IGRpZCB5b3UgaW5jbHVkZSBpdHMgSlMgZmlsZT8nLCBvcHRpb25zLm5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBcbiAgICAgIHRoaXMuX3ByaXZhdGUucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXJQcm90byhcbiAgICAgICAgJCQudXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICBjeTogY3ksXG4gICAgICAgICAgc3R5bGU6IGN5Ll9wcml2YXRlLnN0eWxlXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgIFxuICAgIH0sXG5cbiAgICB0cmlnZ2VyT25SZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY2JzID0gdGhpcy5fcHJpdmF0ZS5vblJlbmRlcnM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBjYiA9IGNic1tpXTtcblxuICAgICAgICBjYigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgb25SZW5kZXI6IGZ1bmN0aW9uKCBjYiApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5vblJlbmRlcnMucHVzaCggY2IgKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIG9mZlJlbmRlcjogZnVuY3Rpb24oIGZuICl7XG4gICAgICB2YXIgY2JzID0gdGhpcy5fcHJpdmF0ZS5vblJlbmRlcnM7XG5cbiAgICAgIGlmKCBmbiA9PSBudWxsICl7IC8vIHVuYmluZCBhbGxcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5vblJlbmRlcnMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrICl7IC8vIHVuYmluZCBzcGVjaWZpZWRcbiAgICAgICAgdmFyIGNiID0gY2JzW2ldO1xuXG4gICAgICAgIGlmKCBmbiA9PT0gY2IgKXtcbiAgICAgICAgICBjYnMuc3BsaWNlKCBpLCAxICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIFxuICB9KTsgIFxuICBcbn0pKCBjeXRvc2NhcGUgKTtcbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcblxuICAgIC8vIGdldCBhIGNvbGxlY3Rpb25cbiAgICAvLyAtIGVtcHR5IGNvbGxlY3Rpb24gb24gbm8gYXJnc1xuICAgIC8vIC0gY29sbGVjdGlvbiBvZiBlbGVtZW50cyBpbiB0aGUgZ3JhcGggb24gc2VsZWN0b3IgYXJnXG4gICAgLy8gLSBndWFyYW50ZWUgYSByZXR1cm5lZCBjb2xsZWN0aW9uIHdoZW4gZWxlbWVudHMgb3IgY29sbGVjdGlvbiBzcGVjaWZpZWRcbiAgICBjb2xsZWN0aW9uOiBmdW5jdGlvbiggZWxlcyApe1xuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKCBlbGVzICkgKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuJCggZWxlcyApO1xuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24oIGVsZXMgKSApe1xuICAgICAgICByZXR1cm4gZWxlcy5jb2xsZWN0aW9uKCk7XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuYXJyYXkoIGVsZXMgKSApe1xuICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMsIGVsZXMgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzICk7XG4gICAgfSxcbiAgICBcbiAgICBub2RlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLiQoZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNOb2RlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYoIHNlbGVjdG9yICl7XG4gICAgICAgIHJldHVybiBub2Rlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgICB9IFxuXG4gICAgICByZXR1cm4gbm9kZXM7XG4gICAgfSxcbiAgICBcbiAgICBlZGdlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLiQoZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFZGdlKCk7XG4gICAgICB9KTtcblxuICAgICAgaWYoIHNlbGVjdG9yICl7XG4gICAgICAgIHJldHVybiBlZGdlcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9LFxuICAgICAgXG4gICAgLy8gc2VhcmNoIHRoZSBncmFwaCBsaWtlIGpRdWVyeVxuICAgICQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcywgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cyApO1xuXG4gICAgICBpZiggc2VsZWN0b3IgKXtcbiAgICAgICAgcmV0dXJuIGVsZXMuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZWxlcztcbiAgICB9XG4gICAgXG4gIH0pOyAgXG5cbiAgLy8gYWxpYXNlc1xuICAkJC5jb3JlZm4uZWxlbWVudHMgPSAkJC5jb3JlZm4uZmlsdGVyID0gJCQuY29yZWZuLiQ7ICBcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAkJC5mbi5jb3JlKHtcbiAgICBcbiAgICBzdHlsZTogZnVuY3Rpb24oIG5ld1N0eWxlICl7XG4gICAgICBpZiggbmV3U3R5bGUgKXtcbiAgICAgICAgdmFyIHMgPSB0aGlzLnNldFN0eWxlKCBuZXdTdHlsZSApO1xuXG4gICAgICAgIHMudXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnN0eWxlO1xuICAgIH0sXG5cbiAgICBzZXRTdHlsZTogZnVuY3Rpb24oIHN0eWxlICl7XG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuXG4gICAgICBpZiggJCQuaXMuc3R5bGVzaGVldChzdHlsZSkgKXtcbiAgICAgICAgX3Auc3R5bGUgPSBzdHlsZS5nZW5lcmF0ZVN0eWxlKHRoaXMpO1xuICAgICAgXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmFycmF5KHN0eWxlKSApIHtcbiAgICAgICAgX3Auc3R5bGUgPSAkJC5zdHlsZS5mcm9tSnNvbih0aGlzLCBzdHlsZSk7XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKHN0eWxlKSApe1xuICAgICAgICBfcC5zdHlsZSA9ICQkLnN0eWxlLmZyb21TdHJpbmcodGhpcywgc3R5bGUpO1xuICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfcC5zdHlsZSA9IG5ldyAkJC5TdHlsZSggdGhpcyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3Auc3R5bGU7XG4gICAgfVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gICQkLmZuLmNvcmUoe1xuXG4gICAgYXV0b2xvY2s6IGZ1bmN0aW9uKGJvb2wpe1xuICAgICAgaWYoIGJvb2wgIT09IHVuZGVmaW5lZCApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLmF1dG9sb2NrID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmF1dG9sb2NrO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgYXV0b3VuZ3JhYmlmeTogZnVuY3Rpb24oYm9vbCl7XG4gICAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuYXV0b3VuZ3JhYmlmeSA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS5hdXRvdW5ncmFiaWZ5O1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgYXV0b3Vuc2VsZWN0aWZ5OiBmdW5jdGlvbihib29sKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5hdXRvdW5zZWxlY3RpZnkgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUuYXV0b3Vuc2VsZWN0aWZ5O1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgcGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICB1c2VyUGFubmluZ0VuYWJsZWQ6IGZ1bmN0aW9uKCBib29sICl7XG4gICAgICBpZiggYm9vbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUudXNlclBhbm5pbmdFbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLnVzZXJQYW5uaW5nRW5hYmxlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcbiAgICBcbiAgICB6b29taW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCA9IGJvb2wgPyB0cnVlIDogZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHVzZXJab29taW5nRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS51c2VyWm9vbWluZ0VuYWJsZWQgPSBib29sID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUudXNlclpvb21pbmdFbmFibGVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgYm94U2VsZWN0aW9uRW5hYmxlZDogZnVuY3Rpb24oIGJvb2wgKXtcbiAgICAgIGlmKCBib29sICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5ib3hTZWxlY3Rpb25FbmFibGVkID0gYm9vbCA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmJveFNlbGVjdGlvbkVuYWJsZWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgcGFuOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICB2YXIgZGltLCB2YWwsIGRpbXMsIHgsIHk7XG5cbiAgICAgIHN3aXRjaCggYXJncy5sZW5ndGggKXtcbiAgICAgIGNhc2UgMDogLy8gLnBhbigpXG4gICAgICAgIHJldHVybiBwYW47XG5cbiAgICAgIGNhc2UgMTogXG5cbiAgICAgICAgaWYoICQkLmlzLnN0cmluZyggYXJnc1swXSApICl7IC8vIC5wYW4oJ3gnKVxuICAgICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgICAgcmV0dXJuIHBhblsgZGltIF07XG5cbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdCggYXJnc1swXSApICkgeyAvLyAucGFuKHsgeDogMCwgeTogMTAwIH0pXG4gICAgICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKHgpICl7XG4gICAgICAgICAgICBwYW4ueCA9IHg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICQkLmlzLm51bWJlcih5KSApe1xuICAgICAgICAgICAgcGFuLnkgPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMudHJpZ2dlcigncGFuIHZpZXdwb3J0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjogLy8gLnBhbigneCcsIDEwMClcbiAgICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICBkaW0gPSBhcmdzWzBdO1xuICAgICAgICB2YWwgPSBhcmdzWzFdO1xuXG4gICAgICAgIGlmKCAoZGltID09PSAneCcgfHwgZGltID09PSAneScpICYmICQkLmlzLm51bWJlcih2YWwpICl7XG4gICAgICAgICAgcGFuW2RpbV0gPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7IC8vIGludmFsaWRcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgcGFuQnk6IGZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciBkaW0sIHZhbCwgZGltcywgeCwgeTtcblxuICAgICAgaWYoICF0aGlzLl9wcml2YXRlLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2goIGFyZ3MubGVuZ3RoICl7XG4gICAgICBjYXNlIDE6IFxuXG4gICAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdCggYXJnc1swXSApICkgeyAvLyAucGFuQnkoeyB4OiAwLCB5OiAxMDAgfSlcbiAgICAgICAgICBkaW1zID0gYXJnc1swXTtcbiAgICAgICAgICB4ID0gZGltcy54O1xuICAgICAgICAgIHkgPSBkaW1zLnk7XG5cbiAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKHgpICl7XG4gICAgICAgICAgICBwYW4ueCArPSB4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoeSkgKXtcbiAgICAgICAgICAgIHBhbi55ICs9IHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gdmlld3BvcnQnKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOiAvLyAucGFuQnkoJ3gnLCAxMDApXG4gICAgICAgIGRpbSA9IGFyZ3NbMF07XG4gICAgICAgIHZhbCA9IGFyZ3NbMV07XG5cbiAgICAgICAgaWYoIChkaW0gPT09ICd4JyB8fCBkaW0gPT09ICd5JykgJiYgJCQuaXMubnVtYmVyKHZhbCkgKXtcbiAgICAgICAgICBwYW5bZGltXSArPSB2YWw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7IC8vIGludmFsaWRcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgZml0OiBmdW5jdGlvbiggZWxlbWVudHMsIHBhZGRpbmcgKXtcbiAgICAgIHZhciB2aWV3cG9ydFN0YXRlID0gdGhpcy5nZXRGaXRWaWV3cG9ydCggZWxlbWVudHMsIHBhZGRpbmcgKTtcblxuICAgICAgaWYoIHZpZXdwb3J0U3RhdGUgKXtcbiAgICAgICAgdmFyIF9wID0gdGhpcy5fcHJpdmF0ZTtcbiAgICAgICAgX3Auem9vbSA9IHZpZXdwb3J0U3RhdGUuem9vbTtcbiAgICAgICAgX3AucGFuID0gdmlld3BvcnRTdGF0ZS5wYW47XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwYW4gem9vbSB2aWV3cG9ydCcpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5KHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIGdldEZpdFZpZXdwb3J0OiBmdW5jdGlvbiggZWxlbWVudHMsIHBhZGRpbmcgKXtcbiAgICAgIGlmKCAkJC5pcy5udW1iZXIoZWxlbWVudHMpICYmIHBhZGRpbmcgPT09IHVuZGVmaW5lZCApeyAvLyBlbGVtZW50cyBpcyBvcHRpb25hbFxuICAgICAgICBwYWRkaW5nID0gZWxlbWVudHM7XG4gICAgICAgIGVsZW1lbnRzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgfHwgIXRoaXMuX3ByaXZhdGUuem9vbWluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYmI7XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcoZWxlbWVudHMpICl7XG4gICAgICAgIHZhciBzZWwgPSBlbGVtZW50cztcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLiQoIHNlbCApO1xuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmJvdW5kaW5nQm94KGVsZW1lbnRzKSApeyAvLyBhc3N1bWUgYmJcbiAgICAgICAgdmFyIGJiZSA9IGVsZW1lbnRzO1xuICAgICAgICBiYiA9IHtcbiAgICAgICAgICB4MTogYmJlLngxLFxuICAgICAgICAgIHkxOiBiYmUueTEsXG4gICAgICAgICAgeDI6IGJiZS54MixcbiAgICAgICAgICB5MjogYmJlLnkyXG4gICAgICAgIH07XG5cbiAgICAgICAgYmIudyA9IGJiLngyIC0gYmIueDE7XG4gICAgICAgIGJiLmggPSBiYi55MiAtIGJiLnkxO1xuXG4gICAgICB9IGVsc2UgaWYoICEkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKGVsZW1lbnRzKSApe1xuICAgICAgICBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHMoKTtcbiAgICAgIH1cblxuICAgICAgYmIgPSBiYiB8fCBlbGVtZW50cy5ib3VuZGluZ0JveCgpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICAgIHZhciB6b29tO1xuICAgICAgcGFkZGluZyA9ICQkLmlzLm51bWJlcihwYWRkaW5nKSA/IHBhZGRpbmcgOiAwO1xuXG4gICAgICBpZiggIWlzTmFOKHcpICYmICFpc05hTihoKSAmJiB3ID4gMCAmJiBoID4gMCAmJiAhaXNOYU4oYmIudykgJiYgIWlzTmFOKGJiLmgpICYmICBiYi53ID4gMCAmJiBiYi5oID4gMCApe1xuICAgICAgICB6b29tID0gTWF0aC5taW4oICh3IC0gMipwYWRkaW5nKS9iYi53LCAoaCAtIDIqcGFkZGluZykvYmIuaCApO1xuXG4gICAgICAgIC8vIGNyb3Agem9vbVxuICAgICAgICB6b29tID0gem9vbSA+IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA/IHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA6IHpvb207XG4gICAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcblxuICAgICAgICB2YXIgcGFuID0geyAvLyBub3cgcGFuIHRvIG1pZGRsZVxuICAgICAgICAgIHg6ICh3IC0gem9vbSooIGJiLngxICsgYmIueDIgKSkvMixcbiAgICAgICAgICB5OiAoaCAtIHpvb20qKCBiYi55MSArIGJiLnkyICkpLzJcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHpvb206IHpvb20sIFxuICAgICAgICAgIHBhbjogcGFuXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9LFxuICAgIFxuICAgIG1pblpvb206IGZ1bmN0aW9uKCB6b29tICl7XG4gICAgICBpZiggem9vbSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLm1pblpvb207XG4gICAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcih6b29tKSApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLm1pblpvb20gPSB6b29tO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbWF4Wm9vbTogZnVuY3Rpb24oIHpvb20gKXtcbiAgICAgIGlmKCB6b29tID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByaXZhdGUubWF4Wm9vbTtcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKHpvb20pICl7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUubWF4Wm9vbSA9IHpvb207XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB6b29tOiBmdW5jdGlvbiggcGFyYW1zICl7XG4gICAgICB2YXIgcG9zOyAvLyBpbiByZW5kZXJlZCBweFxuICAgICAgdmFyIHpvb207XG5cbiAgICAgIGlmKCBwYXJhbXMgPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIGdldCB0aGUgem9vbVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJpdmF0ZS56b29tO1xuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLm51bWJlcihwYXJhbXMpICl7IC8vIHRoZW4gc2V0IHRoZSB6b29tXG4gICAgICAgIHpvb20gPSBwYXJhbXM7XG5cbiAgICAgIH0gZWxzZSBpZiggJCQuaXMucGxhaW5PYmplY3QocGFyYW1zKSApeyAvLyB0aGVuIHpvb20gYWJvdXQgYSBwb2ludFxuICAgICAgICB6b29tID0gcGFyYW1zLmxldmVsO1xuXG4gICAgICAgIGlmKCBwYXJhbXMucG9zaXRpb24gKXtcbiAgICAgICAgICB2YXIgcCA9IHBhcmFtcy5wb3NpdGlvbjtcbiAgICAgICAgICB2YXIgcGFuID0gdGhpcy5fcHJpdmF0ZS5wYW47XG4gICAgICAgICAgdmFyIHogPSB0aGlzLl9wcml2YXRlLnpvb207XG5cbiAgICAgICAgICBwb3MgPSB7IC8vIGNvbnZlcnQgdG8gcmVuZGVyZWQgcHhcbiAgICAgICAgICAgIHg6IHAueCAqIHogKyBwYW4ueCxcbiAgICAgICAgICAgIHk6IHAueSAqIHogKyBwYW4ueVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiggcGFyYW1zLnJlbmRlcmVkUG9zaXRpb24gKXtcbiAgICAgICAgICBwb3MgPSBwYXJhbXMucmVuZGVyZWRQb3NpdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBwb3MgJiYgIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgICByZXR1cm4gdGhpczsgLy8gcGFubmluZyBkaXNhYmxlZFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gem9vbWluZyBkaXNhYmxlZFxuICAgICAgfVxuXG4gICAgICBpZiggISQkLmlzLm51bWJlcih6b29tKSB8fCAoIHBvcyAmJiAoISQkLmlzLm51bWJlcihwb3MueCkgfHwgISQkLmlzLm51bWJlcihwb3MueSkpICkgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGNhbid0IHpvb20gd2l0aCBpbnZhbGlkIHBhcmFtc1xuICAgICAgfVxuXG4gICAgICAvLyBjcm9wIHpvb21cbiAgICAgIHpvb20gPSB6b29tID4gdGhpcy5fcHJpdmF0ZS5tYXhab29tID8gdGhpcy5fcHJpdmF0ZS5tYXhab29tIDogem9vbTtcbiAgICAgIHpvb20gPSB6b29tIDwgdGhpcy5fcHJpdmF0ZS5taW5ab29tID8gdGhpcy5fcHJpdmF0ZS5taW5ab29tIDogem9vbTtcblxuICAgICAgaWYoIHBvcyApeyAvLyBzZXQgem9vbSBhYm91dCBwb3NpdGlvblxuICAgICAgICB2YXIgcGFuMSA9IHRoaXMuX3ByaXZhdGUucGFuO1xuICAgICAgICB2YXIgem9vbTEgPSB0aGlzLl9wcml2YXRlLnpvb207XG4gICAgICAgIHZhciB6b29tMiA9IHpvb207XG4gICAgICAgIFxuICAgICAgICB2YXIgcGFuMiA9IHtcbiAgICAgICAgICB4OiAtem9vbTIvem9vbTEgKiAocG9zLnggLSBwYW4xLngpICsgcG9zLngsXG4gICAgICAgICAgeTogLXpvb20yL3pvb20xICogKHBvcy55IC0gcGFuMS55KSArIHBvcy55XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fcHJpdmF0ZS56b29tID0gem9vbTtcbiAgICAgICAgdGhpcy5fcHJpdmF0ZS5wYW4gPSBwYW4yO1xuXG4gICAgICAgIHZhciBwb3NDaGFuZ2VkID0gcGFuMS54ICE9PSBwYW4yLnggfHwgcGFuMS55ICE9PSBwYW4yLnk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignIHpvb20gJyArIChwb3NDaGFuZ2VkID8gJyBwYW4gJyA6ICcnKSArICcgdmlld3BvcnQgJyApO1xuICAgICAgXG4gICAgICB9IGVsc2UgeyAvLyBqdXN0IHNldCB0aGUgem9vbVxuICAgICAgICB0aGlzLl9wcml2YXRlLnpvb20gPSB6b29tO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ3pvb20gdmlld3BvcnQnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ub3RpZnkoeyAvLyBub3RpZnkgdGhlIHJlbmRlcmVyIHRoYXQgdGhlIHZpZXdwb3J0IGNoYW5nZWRcbiAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICB2aWV3cG9ydDogZnVuY3Rpb24oIG9wdHMgKXsgXG4gICAgICB2YXIgX3AgPSB0aGlzLl9wcml2YXRlO1xuICAgICAgdmFyIHpvb21EZWZkID0gdHJ1ZTtcbiAgICAgIHZhciBwYW5EZWZkID0gdHJ1ZTtcbiAgICAgIHZhciBldmVudHMgPSBbXTsgLy8gdG8gdHJpZ2dlclxuICAgICAgdmFyIHpvb21GYWlsZWQgPSBmYWxzZTtcbiAgICAgIHZhciBwYW5GYWlsZWQgPSBmYWxzZTtcblxuICAgICAgaWYoICFvcHRzICl7IHJldHVybiB0aGlzOyB9XG4gICAgICBpZiggISQkLmlzLm51bWJlcihvcHRzLnpvb20pICl7IHpvb21EZWZkID0gZmFsc2U7IH1cbiAgICAgIGlmKCAhJCQuaXMucGxhaW5PYmplY3Qob3B0cy5wYW4pICl7IHBhbkRlZmQgPSBmYWxzZTsgfVxuICAgICAgaWYoICF6b29tRGVmZCAmJiAhcGFuRGVmZCApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICBpZiggem9vbURlZmQgKXtcbiAgICAgICAgdmFyIHogPSBvcHRzLnpvb207XG5cbiAgICAgICAgaWYoIHogPCBfcC5taW5ab29tIHx8IHogPiBfcC5tYXhab29tIHx8ICFfcC56b29taW5nRW5hYmxlZCApe1xuICAgICAgICAgIHpvb21GYWlsZWQgPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3Auem9vbSA9IHo7XG5cbiAgICAgICAgICBldmVudHMucHVzaCgnem9vbScpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBwYW5EZWZkICYmICghem9vbUZhaWxlZCB8fCAhb3B0cy5jYW5jZWxPbkZhaWxlZFpvb20pICYmIF9wLnBhbm5pbmdFbmFibGVkICl7XG4gICAgICAgIHZhciBwID0gb3B0cy5wYW47XG5cbiAgICAgICAgaWYoICQkLmlzLm51bWJlcihwLngpICl7XG4gICAgICAgICAgX3AucGFuLnggPSBwLng7XG4gICAgICAgICAgcGFuRmFpbGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggJCQuaXMubnVtYmVyKHAueSkgKXtcbiAgICAgICAgICBfcC5wYW4ueSA9IHAueTtcbiAgICAgICAgICBwYW5GYWlsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhcGFuRmFpbGVkICl7XG4gICAgICAgICAgZXZlbnRzLnB1c2goJ3BhbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBldmVudHMubGVuZ3RoID4gMCApe1xuICAgICAgICBldmVudHMucHVzaCgndmlld3BvcnQnKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCBldmVudHMuam9pbignICcpICk7XG5cbiAgICAgICAgdGhpcy5ub3RpZnkoe1xuICAgICAgICAgIHR5cGU6ICd2aWV3cG9ydCdcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG4gICAgXG4gICAgY2VudGVyOiBmdW5jdGlvbiggZWxlbWVudHMgKXtcbiAgICAgIHZhciBwYW4gPSB0aGlzLmdldENlbnRlclBhbiggZWxlbWVudHMgKTtcblxuICAgICAgaWYoIHBhbiApe1xuICAgICAgICB0aGlzLl9wcml2YXRlLnBhbiA9IHBhbjtcblxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3BhbiB2aWV3cG9ydCcpO1xuXG4gICAgICAgIHRoaXMubm90aWZ5KHsgLy8gbm90aWZ5IHRoZSByZW5kZXJlciB0aGF0IHRoZSB2aWV3cG9ydCBjaGFuZ2VkXG4gICAgICAgICAgdHlwZTogJ3ZpZXdwb3J0J1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIGdldENlbnRlclBhbjogZnVuY3Rpb24oIGVsZW1lbnRzLCB6b29tICl7XG4gICAgICBpZiggIXRoaXMuX3ByaXZhdGUucGFubmluZ0VuYWJsZWQgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKGVsZW1lbnRzKSApe1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSBlbGVtZW50cztcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCBzZWxlY3RvciApO1xuICAgICAgfSBlbHNlIGlmKCAhJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihlbGVtZW50cykgKXtcbiAgICAgICAgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBiYiA9IGVsZW1lbnRzLmJvdW5kaW5nQm94KCk7XG4gICAgICB2YXIgdyA9IHRoaXMud2lkdGgoKTtcbiAgICAgIHZhciBoID0gdGhpcy5oZWlnaHQoKTtcbiAgICAgIHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl9wcml2YXRlLnpvb20gOiB6b29tO1xuXG4gICAgICB2YXIgcGFuID0geyAvLyBtaWRkbGVcbiAgICAgICAgeDogKHcgLSB6b29tKiggYmIueDEgKyBiYi54MiApKS8yLFxuICAgICAgICB5OiAoaCAtIHpvb20qKCBiYi55MSArIGJiLnkyICkpLzJcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHJldHVybiBwYW47XG4gICAgfSxcbiAgICBcbiAgICByZXNldDogZnVuY3Rpb24oKXtcbiAgICAgIGlmKCAhdGhpcy5fcHJpdmF0ZS5wYW5uaW5nRW5hYmxlZCB8fCAhdGhpcy5fcHJpdmF0ZS56b29taW5nRW5hYmxlZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy52aWV3cG9ydCh7XG4gICAgICAgIHBhbjogeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgIHpvb206IDFcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgd2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fcHJpdmF0ZS5jb250YWluZXI7XG5cbiAgICAgIGlmKCBjb250YWluZXIgKXtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7IC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gICAgfSxcblxuICAgIGhlaWdodDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9wcml2YXRlLmNvbnRhaW5lcjtcblxuICAgICAgaWYoIGNvbnRhaW5lciApe1xuICAgICAgICByZXR1cm4gY29udGFpbmVyLmNsaWVudEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7IC8vIGZhbGxiYWNrIGlmIG5vIGNvbnRhaW5lciAobm90IDAgYi9jIGNhbiBiZSB1c2VkIGZvciBkaXZpZGluZyBldGMpXG4gICAgfSxcblxuICAgIGV4dGVudDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBwYW4gPSB0aGlzLl9wcml2YXRlLnBhbjtcbiAgICAgIHZhciB6b29tID0gdGhpcy5fcHJpdmF0ZS56b29tO1xuICAgICAgdmFyIHJiID0gdGhpcy5yZW5kZXJlZEV4dGVudCgpO1xuXG4gICAgICB2YXIgYiA9IHtcbiAgICAgICAgeDE6ICggcmIueDEgLSBwYW4ueCApL3pvb20sXG4gICAgICAgIHgyOiAoIHJiLngyIC0gcGFuLnggKS96b29tLFxuICAgICAgICB5MTogKCByYi55MSAtIHBhbi55ICkvem9vbSxcbiAgICAgICAgeTI6ICggcmIueTIgLSBwYW4ueSApL3pvb20sXG4gICAgICB9O1xuXG4gICAgICBiLncgPSBiLngyIC0gYi54MTtcbiAgICAgIGIuaCA9IGIueTIgLSBiLnkxO1xuXG4gICAgICByZXR1cm4gYjtcbiAgICB9LFxuXG4gICAgcmVuZGVyZWRFeHRlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoKCk7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IDAsXG4gICAgICAgIHkxOiAwLFxuICAgICAgICB4Mjogd2lkdGgsXG4gICAgICAgIHkyOiBoZWlnaHQsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBhbGlhc2VzXG4gICQkLmNvcmVmbi5jZW50cmUgPSAkJC5jb3JlZm4uY2VudGVyO1xuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICQkLmNvcmVmbi5hdXRvbG9ja05vZGVzID0gJCQuY29yZWZuLmF1dG9sb2NrO1xuICAkJC5jb3JlZm4uYXV0b3VuZ3JhYmlmeU5vZGVzID0gJCQuY29yZWZuLmF1dG91bmdyYWJpZnk7XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIFVzZSB0aGlzIGludGVyZmFjZSB0byBkZWZpbmUgZnVuY3Rpb25zIGZvciBjb2xsZWN0aW9ucy9lbGVtZW50cy5cbiAgLy8gVGhpcyBpbnRlcmZhY2UgaXMgZ29vZCwgYmVjYXVzZSBpdCBmb3JjZXMgeW91IHRvIHRoaW5rIGluIHRlcm1zXG4gIC8vIG9mIHRoZSBjb2xsZWN0aW9ucyBjYXNlIChtb3JlIHRoYW4gMSBlbGVtZW50KSwgc28gd2UgZG9uJ3QgbmVlZFxuICAvLyBub3RpZmljYXRpb24gYmxvY2tpbmcgbm9uc2Vuc2UgZXZlcnl3aGVyZS5cbiAgLy9cbiAgLy8gT3RoZXIgY29sbGVjdGlvbi0qLmpzIGZpbGVzIGRlcGVuZCBvbiB0aGlzIGJlaW5nIGRlZmluZWQgZmlyc3QuXG4gIC8vIEl0J3MgYSB0cmFkZSBvZmY6IEl0IHNpbXBsaWZpZXMgdGhlIGNvZGUgZm9yIENvbGxlY3Rpb24gYW5kIFxuICAvLyBFbGVtZW50IGludGVncmF0aW9uIHNvIG11Y2ggdGhhdCBpdCdzIHdvcnRoIGl0IHRvIGNyZWF0ZSB0aGVcbiAgLy8gSlMgZGVwZW5kZW5jeS5cbiAgLy9cbiAgLy8gSGF2aW5nIHRoaXMgaW50ZWdyYXRpb24gZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiBjYWxsIGFueVxuICAvLyBjb2xsZWN0aW9uIGZ1bmN0aW9uIG9uIGFuIGVsZW1lbnQgYW5kIHZpY2UgdmVyc2EuXG5cbiAgLy8gZS5nLiAkJC5mbi5jb2xsZWN0aW9uKHsgc29tZUZ1bmM6IGZ1bmN0aW9uKCl7IC8qIC4uLiAqLyB9IH0pXG4gICQkLmZuLmNvbGxlY3Rpb24gPSAkJC5mbi5lbGVzID0gZnVuY3Rpb24oIGZuTWFwLCBvcHRpb25zICl7XG4gICAgZm9yKCB2YXIgbmFtZSBpbiBmbk1hcCApe1xuICAgICAgdmFyIGZuID0gZm5NYXBbbmFtZV07XG5cbiAgICAgICQkLkNvbGxlY3Rpb24ucHJvdG90eXBlWyBuYW1lIF0gPSBmbjtcbiAgICB9XG4gIH07XG4gIFxuICAvLyBmYWN0b3J5IGZvciBnZW5lcmF0aW5nIGVkZ2UgaWRzIHdoZW4gbm8gaWQgaXMgc3BlY2lmaWVkIGZvciBhIG5ldyBlbGVtZW50XG4gIHZhciBpZEZhY3RvcnkgPSB7XG4gICAgcHJlZml4OiB7XG4gICAgICBub2RlczogJ24nLFxuICAgICAgZWRnZXM6ICdlJ1xuICAgIH0sXG4gICAgaWQ6IHtcbiAgICAgIG5vZGVzOiAwLFxuICAgICAgZWRnZXM6IDBcbiAgICB9LFxuICAgIGdlbmVyYXRlOiBmdW5jdGlvbihjeSwgZWxlbWVudCwgdHJ5VGhpc0lkKXtcbiAgICAgIHZhciBqc29uID0gJCQuaXMuZWxlbWVudCggZWxlbWVudCApID8gZWxlbWVudC5fcHJpdmF0ZSA6IGVsZW1lbnQ7XG4gICAgICB2YXIgZ3JvdXAgPSBqc29uLmdyb3VwO1xuICAgICAgdmFyIGlkID0gdHJ5VGhpc0lkICE9IG51bGwgPyB0cnlUaGlzSWQgOiB0aGlzLnByZWZpeFtncm91cF0gKyB0aGlzLmlkW2dyb3VwXTtcbiAgICAgIFxuICAgICAgaWYoIGN5LmdldEVsZW1lbnRCeUlkKGlkKS5lbXB0eSgpICl7XG4gICAgICAgIHRoaXMuaWRbZ3JvdXBdKys7IC8vIHdlJ3ZlIHVzZWQgdGhlIGN1cnJlbnQgaWQsIHNvIG1vdmUgaXQgdXBcbiAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBrZWVwIHRyeWluZyBzdWNjZXNzaXZlIHVudXNlZCBpZHNcbiAgICAgICAgd2hpbGUoICFjeS5nZXRFbGVtZW50QnlJZChpZCkuZW1wdHkoKSApe1xuICAgICAgICAgIGlkID0gdGhpcy5wcmVmaXhbZ3JvdXBdICsgKCArK3RoaXMuaWRbZ3JvdXBdICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgfTtcbiAgXG4gIC8vIEVsZW1lbnRcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgLy8gcmVwcmVzZW50cyBhIG5vZGUgb3IgYW4gZWRnZVxuICAkJC5FbGVtZW50ID0gZnVuY3Rpb24oY3ksIHBhcmFtcywgcmVzdG9yZSl7XG4gICAgaWYoICEodGhpcyBpbnN0YW5jZW9mICQkLkVsZW1lbnQpICl7XG4gICAgICByZXR1cm4gbmV3ICQkLkVsZW1lbnQoY3ksIHBhcmFtcywgcmVzdG9yZSk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHJlc3RvcmUgPSAocmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUgPyB0cnVlIDogZmFsc2UpO1xuICAgIFxuICAgIGlmKCBjeSA9PT0gdW5kZWZpbmVkIHx8IHBhcmFtcyA9PT0gdW5kZWZpbmVkIHx8ICEkJC5pcy5jb3JlKGN5KSApe1xuICAgICAgJCQudXRpbC5lcnJvcignQW4gZWxlbWVudCBtdXN0IGhhdmUgYSBjb3JlIHJlZmVyZW5jZSBhbmQgcGFyYW1ldGVycyBzZXQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gdmFsaWRhdGUgZ3JvdXBcbiAgICBpZiggcGFyYW1zLmdyb3VwICE9PSAnbm9kZXMnICYmIHBhcmFtcy5ncm91cCAhPT0gJ2VkZ2VzJyApe1xuICAgICAgJCQudXRpbC5lcnJvcignQW4gZWxlbWVudCBtdXN0IGJlIG9mIHR5cGUgYG5vZGVzYCBvciBgZWRnZXNgOyB5b3Ugc3BlY2lmaWVkIGAnICsgcGFyYW1zLmdyb3VwICsgJ2AnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgLy8gbWFrZSB0aGUgZWxlbWVudCBhcnJheS1saWtlLCBqdXN0IGxpa2UgYSBjb2xsZWN0aW9uXG4gICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIHRoaXNbMF0gPSB0aGlzO1xuICAgIFxuICAgIC8vIE5PVEU6IHdoZW4gc29tZXRoaW5nIGlzIGFkZGVkIGhlcmUsIGFkZCBhbHNvIHRvIGVsZS5qc29uKClcbiAgICB0aGlzLl9wcml2YXRlID0ge1xuICAgICAgY3k6IGN5LFxuICAgICAgc2luZ2xlOiB0cnVlLCAvLyBpbmRpY2F0ZXMgdGhpcyBpcyBhbiBlbGVtZW50XG4gICAgICBkYXRhOiBwYXJhbXMuZGF0YSB8fCB7fSwgLy8gZGF0YSBvYmplY3RcbiAgICAgIHBvc2l0aW9uOiBwYXJhbXMucG9zaXRpb24gfHwge30sIC8vICh4LCB5KSBwb3NpdGlvbiBwYWlyXG4gICAgICBhdXRvV2lkdGg6IHVuZGVmaW5lZCwgLy8gd2lkdGggYW5kIGhlaWdodCBvZiBub2RlcyBjYWxjdWxhdGVkIGJ5IHRoZSByZW5kZXJlciB3aGVuIHNldCB0byBzcGVjaWFsICdhdXRvJyB2YWx1ZVxuICAgICAgYXV0b0hlaWdodDogdW5kZWZpbmVkLCBcbiAgICAgIGxpc3RlbmVyczogW10sIC8vIGFycmF5IG9mIGJvdW5kIGxpc3RlbmVyc1xuICAgICAgZ3JvdXA6IHBhcmFtcy5ncm91cCwgLy8gc3RyaW5nOyAnbm9kZXMnIG9yICdlZGdlcydcbiAgICAgIHN0eWxlOiB7fSwgLy8gcHJvcGVydGllcyBhcyBzZXQgYnkgdGhlIHN0eWxlXG4gICAgICByc3R5bGU6IHt9LCAvLyBwcm9wZXJ0aWVzIGZvciBzdHlsZSBzZW50IGZyb20gdGhlIHJlbmRlcmVyIHRvIHRoZSBjb3JlXG4gICAgICBzdHlsZUN4dHM6IFtdLCAvLyBhcHBsaWVkIHN0eWxlIGNvbnRleHRzIGZyb20gdGhlIHN0eWxlclxuICAgICAgcmVtb3ZlZDogdHJ1ZSwgLy8gd2hldGhlciBpdCdzIGluc2lkZSB0aGUgdmlzOyB0cnVlIGlmIHJlbW92ZWQgKHNldCB0cnVlIGhlcmUgc2luY2Ugd2UgY2FsbCByZXN0b3JlKVxuICAgICAgc2VsZWN0ZWQ6IHBhcmFtcy5zZWxlY3RlZCA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGVkXG4gICAgICBzZWxlY3RhYmxlOiBwYXJhbXMuc2VsZWN0YWJsZSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICggcGFyYW1zLnNlbGVjdGFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciBpdCdzIHNlbGVjdGFibGVcbiAgICAgIGxvY2tlZDogcGFyYW1zLmxvY2tlZCA/IHRydWUgOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBsb2NrZWQgKGNhbm5vdCBiZSBtb3ZlZClcbiAgICAgIGdyYWJiZWQ6IGZhbHNlLCAvLyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGdyYWJiZWQgYnkgdGhlIG1vdXNlOyByZW5kZXJlciBzZXRzIHRoaXMgcHJpdmF0ZWx5XG4gICAgICBncmFiYmFibGU6IHBhcmFtcy5ncmFiYmFibGUgPT09IHVuZGVmaW5lZCA/IHRydWUgOiAoIHBhcmFtcy5ncmFiYmFibGUgPyB0cnVlIDogZmFsc2UgKSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBjYW4gYmUgZ3JhYmJlZFxuICAgICAgYWN0aXZlOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgZWxlbWVudCBpcyBhY3RpdmUgZnJvbSB1c2VyIGludGVyYWN0aW9uXG4gICAgICBjbGFzc2VzOiB7fSwgLy8gbWFwICggY2xhc3NOYW1lID0+IHRydWUgKVxuICAgICAgYW5pbWF0aW9uOiB7IC8vIG9iamVjdCBmb3IgY3VycmVudGx5LXJ1bm5pbmcgYW5pbWF0aW9uc1xuICAgICAgICBjdXJyZW50OiBbXSxcbiAgICAgICAgcXVldWU6IFtdXG4gICAgICB9LFxuICAgICAgcnNjcmF0Y2g6IHt9LCAvLyBvYmplY3QgaW4gd2hpY2ggdGhlIHJlbmRlcmVyIGNhbiBzdG9yZSBpbmZvcm1hdGlvblxuICAgICAgc2NyYXRjaDogcGFyYW1zLnNjcmF0Y2ggfHwge30sIC8vIHNjcmF0Y2ggb2JqZWN0c1xuICAgICAgZWRnZXM6IFtdLCAvLyBhcnJheSBvZiBjb25uZWN0ZWQgZWRnZXNcbiAgICAgIGNoaWxkcmVuOiBbXSAvLyBhcnJheSBvZiBjaGlsZHJlblxuICAgIH07XG4gICAgXG4gICAgLy8gcmVuZGVyZWRQb3NpdGlvbiBvdmVycmlkZXMgaWYgc3BlY2lmaWVkXG4gICAgaWYoIHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uICl7XG4gICAgICB2YXIgcnBvcyA9IHBhcmFtcy5yZW5kZXJlZFBvc2l0aW9uO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgIHg6IChycG9zLnggLSBwYW4ueCkvem9vbSxcbiAgICAgICAgeTogKHJwb3MueSAtIHBhbi55KS96b29tXG4gICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBpZiggJCQuaXMuc3RyaW5nKHBhcmFtcy5jbGFzc2VzKSApe1xuICAgICAgdmFyIGNsYXNzZXMgPSBwYXJhbXMuY2xhc3Nlcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGw7IGkrKyApe1xuICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcbiAgICAgICAgaWYoICFjbHMgfHwgY2xzID09PSAnJyApeyBjb250aW51ZTsgfVxuXG4gICAgICAgIHNlbGYuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggcGFyYW1zLmNzcyApe1xuICAgICAgY3kuc3R5bGUoKS5hcHBseUJ5cGFzcyggdGhpcywgcGFyYW1zLmNzcyApO1xuICAgIH1cbiAgICBcbiAgICBpZiggcmVzdG9yZSA9PT0gdW5kZWZpbmVkIHx8IHJlc3RvcmUgKXtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICBcbiAgfTtcblxuICBcbiAgLy8gQ29sbGVjdGlvblxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAvLyByZXByZXNlbnRzIGEgc2V0IG9mIG5vZGVzLCBlZGdlcywgb3IgYm90aCB0b2dldGhlclxuICAkJC5Db2xsZWN0aW9uID0gZnVuY3Rpb24oY3ksIGVsZW1lbnRzLCBvcHRpb25zKXtcbiAgICBpZiggISh0aGlzIGluc3RhbmNlb2YgJCQuQ29sbGVjdGlvbikgKXtcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgZWxlbWVudHMpO1xuICAgIH1cblxuICAgIGlmKCBjeSA9PT0gdW5kZWZpbmVkIHx8ICEkJC5pcy5jb3JlKGN5KSApe1xuICAgICAgJCQudXRpbC5lcnJvcignQSBjb2xsZWN0aW9uIG11c3QgaGF2ZSBhIHJlZmVyZW5jZSB0byB0aGUgY29yZScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICB2YXIgaWRzID0ge307XG4gICAgdmFyIGluZGV4ZXMgPSB7fTtcbiAgICB2YXIgY3JlYXRlZEVsZW1lbnRzID0gZmFsc2U7XG4gICAgXG4gICAgaWYoICFlbGVtZW50cyApe1xuICAgICAgZWxlbWVudHMgPSBbXTtcbiAgICB9IGVsc2UgaWYoIGVsZW1lbnRzLmxlbmd0aCA+IDAgJiYgJCQuaXMucGxhaW5PYmplY3QoIGVsZW1lbnRzWzBdICkgJiYgISQkLmlzLmVsZW1lbnQoIGVsZW1lbnRzWzBdICkgKXtcbiAgICAgIGNyZWF0ZWRFbGVtZW50cyA9IHRydWU7XG5cbiAgICAgIC8vIG1ha2UgZWxlbWVudHMgZnJvbSBqc29uIGFuZCByZXN0b3JlIGFsbCBhdCBvbmNlIGxhdGVyXG4gICAgICB2YXIgZWxlcyA9IFtdO1xuICAgICAgdmFyIGVsZXNJZHMgPSB7fTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDAsIGwgPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKXtcbiAgICAgICAgdmFyIGpzb24gPSBlbGVtZW50c1tpXTtcblxuICAgICAgICBpZigganNvbi5kYXRhID09IG51bGwgKXtcbiAgICAgICAgICBqc29uLmRhdGEgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGRhdGEgPSBqc29uLmRhdGE7XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIG5ld2x5IGNyZWF0ZWQgZWxlbWVudHMgaGF2ZSB2YWxpZCBpZHNcbiAgICAgICAgaWYoIGRhdGEuaWQgPT0gbnVsbCApe1xuICAgICAgICAgIGRhdGEuaWQgPSBpZEZhY3RvcnkuZ2VuZXJhdGUoIGN5LCBqc29uICk7XG4gICAgICAgIH0gZWxzZSBpZiggY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEuaWQgKS5sZW5ndGggIT09IDAgfHwgZWxlc0lkc1sgZGF0YS5pZCBdICl7XG4gICAgICAgICAgY29udGludWU7IC8vIGNhbid0IGNyZWF0ZSBlbGVtZW50IGlmIHByaW9yIGlkIGFscmVhZHkgZXhpc3RzXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWxlID0gbmV3ICQkLkVsZW1lbnQoIGN5LCBqc29uLCBmYWxzZSApO1xuICAgICAgICBlbGVzLnB1c2goIGVsZSApO1xuICAgICAgICBlbGVzSWRzWyBkYXRhLmlkIF0gPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50cyA9IGVsZXM7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIGZvciggdmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYoICFlbGVtZW50ICl7ICBjb250aW51ZTsgfVxuICAgICAgXG4gICAgICB2YXIgaWQgPSBlbGVtZW50Ll9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICBcbiAgICAgIGlmKCAhb3B0aW9ucyB8fCAob3B0aW9ucy51bmlxdWUgJiYgIWlkc1sgaWQgXSApICl7XG4gICAgICAgIGlkc1sgaWQgXSA9IGVsZW1lbnQ7XG4gICAgICAgIGluZGV4ZXNbIGlkIF0gPSB0aGlzLmxlbmd0aDtcblxuICAgICAgICB0aGlzWyB0aGlzLmxlbmd0aCBdID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5fcHJpdmF0ZSA9IHtcbiAgICAgIGN5OiBjeSxcbiAgICAgIGlkczogaWRzLFxuICAgICAgaW5kZXhlczogaW5kZXhlc1xuICAgIH07XG5cbiAgICAvLyByZXN0b3JlIHRoZSBlbGVtZW50cyBpZiB3ZSBjcmVhdGVkIHRoZW0gZnJvbSBqc29uXG4gICAgaWYoIGNyZWF0ZWRFbGVtZW50cyApe1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfVxuICB9O1xuICBcbiAgXG4gIC8vIEZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICAvLyBrZWVwIHRoZSBwcm90b3R5cGVzIGluIHN5bmMgKGFuIGVsZW1lbnQgaGFzIHRoZSBzYW1lIGZ1bmN0aW9ucyBhcyBhIGNvbGxlY3Rpb24pXG4gIC8vIGFuZCB1c2UgJCQuZWxlZm4gYW5kICQkLmVsZXNmbiBhcyBzaG9ydGhhbmRzIHRvIHRoZSBwcm90b3R5cGVzXG4gICQkLmVsZWZuID0gJCQuZWxlc2ZuID0gJCQuRWxlbWVudC5wcm90b3R5cGUgPSAkJC5Db2xsZWN0aW9uLnByb3RvdHlwZTtcblxuICAkJC5lbGVzZm4uY3kgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmN5O1xuICB9O1xuICBcbiAgJCQuZWxlc2ZuLmVsZW1lbnQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzWzBdO1xuICB9O1xuICBcbiAgJCQuZWxlc2ZuLmNvbGxlY3Rpb24gPSBmdW5jdGlvbigpe1xuICAgIGlmKCAkJC5pcy5jb2xsZWN0aW9uKHRoaXMpICl7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2UgeyAvLyBhbiBlbGVtZW50XG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIFt0aGlzXSApO1xuICAgIH1cbiAgfTtcblxuICAkJC5lbGVzZm4udW5pcXVlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIHRoaXMsIHsgdW5pcXVlOiB0cnVlIH0gKTtcbiAgfTtcblxuICAkJC5lbGVzZm4uZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbiggaWQgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIHZhciBlbGUgPSB0aGlzLl9wcml2YXRlLmlkc1sgaWQgXTtcblxuICAgIHJldHVybiBlbGUgPyBlbGUgOiAkJC5Db2xsZWN0aW9uKGN5KTsgLy8gZ2V0IGVsZSBvciBlbXB0eSBjb2xsZWN0aW9uXG4gIH07XG5cbiAgJCQuZWxlc2ZuLmpzb24gPSBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzLmVsZW1lbnQoKTtcbiAgICBpZiggZWxlID09IG51bGwgKXsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gICAgdmFyIHAgPSBlbGUuX3ByaXZhdGU7XG4gICAgXG4gICAgdmFyIGpzb24gPSAkJC51dGlsLmNvcHkoe1xuICAgICAgZGF0YTogcC5kYXRhLFxuICAgICAgcG9zaXRpb246IHAucG9zaXRpb24sXG4gICAgICBncm91cDogcC5ncm91cCxcbiAgICAgIGJ5cGFzczogcC5ieXBhc3MsXG4gICAgICByZW1vdmVkOiBwLnJlbW92ZWQsXG4gICAgICBzZWxlY3RlZDogcC5zZWxlY3RlZCxcbiAgICAgIHNlbGVjdGFibGU6IHAuc2VsZWN0YWJsZSxcbiAgICAgIGxvY2tlZDogcC5sb2NrZWQsXG4gICAgICBncmFiYmVkOiBwLmdyYWJiZWQsXG4gICAgICBncmFiYmFibGU6IHAuZ3JhYmJhYmxlLFxuICAgICAgY2xhc3NlczogJydcbiAgICB9KTtcbiAgICBcbiAgICB2YXIgY2xhc3NlcyA9IFtdO1xuICAgIGZvciggdmFyIGNscyBpbiBwLmNsYXNzZXMgKXtcbiAgICAgIGlmKCBwLmNsYXNzZXNbY2xzXSApe1xuICAgICAgICBjbGFzc2VzLnB1c2goY2xzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcbiAgICAgIGpzb24uY2xhc3NlcyArPSBjbHMgKyAoIGkgPCBjbGFzc2VzLmxlbmd0aCAtIDEgPyAnICcgOiAnJyApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4ganNvbjtcbiAgfTtcblxuICAkJC5lbGVzZm4uanNvbnMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBqc29ucyA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcblxuICAgICAganNvbnMucHVzaCgganNvbiApO1xuICAgIH1cblxuICAgIHJldHVybiBqc29ucztcbiAgfTtcblxuICAkJC5lbGVzZm4uY2xvbmUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICB2YXIgZWxlc0FyciA9IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1tpXTtcbiAgICAgIHZhciBqc29uID0gZWxlLmpzb24oKTtcbiAgICAgIHZhciBjbG9uZSA9IG5ldyAkJC5FbGVtZW50KGN5LCBqc29uLCBmYWxzZSk7IC8vIE5CIG5vIHJlc3RvcmVcblxuICAgICAgZWxlc0Fyci5wdXNoKCBjbG9uZSApO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZXNBcnIgKTtcbiAgfTtcbiAgJCQuZWxlc2ZuLmNvcHkgPSAkJC5lbGVzZm4uY2xvbmU7XG5cbiAgJCQuZWxlc2ZuLnJlc3RvcmUgPSBmdW5jdGlvbiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlc3RvcmVkID0gW107XG4gICAgdmFyIGN5ID0gc2VsZi5jeSgpO1xuICAgIFxuICAgIGlmKCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkICl7XG4gICAgICBub3RpZnlSZW5kZXJlciA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gY3JlYXRlIGFycmF5cyBvZiBub2RlcyBhbmQgZWRnZXMsIHNpbmNlIHdlIG5lZWQgdG9cbiAgICAvLyByZXN0b3JlIHRoZSBub2RlcyBmaXJzdFxuICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgIHZhciBub2RlcyA9IFtdLCBlZGdlcyA9IFtdO1xuICAgIHZhciBudW1Ob2RlcyA9IDA7XG4gICAgdmFyIG51bUVkZ2VzID0gMDtcbiAgICBmb3IoIHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gc2VsZltpXTtcbiAgICAgIFxuICAgICAgLy8ga2VlcCBub2RlcyBmaXJzdCBpbiB0aGUgYXJyYXkgYW5kIGVkZ2VzIGFmdGVyXG4gICAgICBpZiggZWxlLmlzTm9kZSgpICl7IC8vIHB1dCB0byBmcm9udCBvZiBhcnJheSBpZiBub2RlXG4gICAgICAgIG5vZGVzLnB1c2goIGVsZSApO1xuICAgICAgICBudW1Ob2RlcysrO1xuICAgICAgfSBlbHNlIHsgLy8gcHV0IHRvIGVuZCBvZiBhcnJheSBpZiBlZGdlXG4gICAgICAgIGVkZ2VzLnB1c2goIGVsZSApO1xuICAgICAgICBudW1FZGdlcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnRzID0gbm9kZXMuY29uY2F0KCBlZGdlcyApO1xuXG4gICAgLy8gbm93LCByZXN0b3JlIGVhY2ggZWxlbWVudFxuICAgIGZvciggdmFyIGkgPSAwLCBsID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlbWVudHNbaV07XG5cbiAgICAgIGlmKCAhZWxlLnJlbW92ZWQoKSApe1xuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgX3ByaXZhdGUgPSBlbGUuX3ByaXZhdGU7XG4gICAgICB2YXIgZGF0YSA9IF9wcml2YXRlLmRhdGE7XG4gICAgICBcbiAgICAgIC8vIHNldCBpZCBhbmQgdmFsaWRhdGVcbiAgICAgIGlmKCBkYXRhLmlkID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgZGF0YS5pZCA9IGlkRmFjdG9yeS5nZW5lcmF0ZSggY3ksIGVsZSApO1xuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5lbXB0eVN0cmluZyhkYXRhLmlkKSB8fCAhJCQuaXMuc3RyaW5nKGRhdGEuaWQpICl7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoJ0NhbiBub3QgY3JlYXRlIGVsZW1lbnQgd2l0aCBpbnZhbGlkIHN0cmluZyBJRCBgJyArIGRhdGEuaWQgKyAnYCcpO1xuICAgICAgICBcbiAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVsZW1lbnQgaWYgaXQgaGFzIGVtcHR5IHN0cmluZyBhcyBpZCBvciBub24tc3RyaW5nIGlkXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmKCBjeS5nZXRFbGVtZW50QnlJZCggZGF0YS5pZCApLmxlbmd0aCAhPT0gMCApe1xuICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBzZWNvbmQgZWxlbWVudCB3aXRoIElEIGAnICsgZGF0YS5pZCArICdgJyk7XG4gICAgICAgIFxuICAgICAgICAvLyBjYW4ndCBjcmVhdGUgZWxlbWVudCBpZiBvbmUgYWxyZWFkeSBoYXMgdGhhdCBpZFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGlkID0gZGF0YS5pZDsgLy8gaWQgaXMgZmluYWxpc2VkLCBub3cgbGV0J3Mga2VlcCBhIHJlZlxuICAgICAgXG4gICAgICBpZiggZWxlLmlzRWRnZSgpICl7IC8vIGV4dHJhIGNoZWNrcyBmb3IgZWRnZXNcbiAgICAgICAgXG4gICAgICAgIHZhciBlZGdlID0gZWxlO1xuICAgICAgICB2YXIgZmllbGRzID0gWydzb3VyY2UnLCAndGFyZ2V0J107XG4gICAgICAgIHZhciBmaWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgICB2YXIgYmFkU291cmNlT3JUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IGZpZWxkc0xlbmd0aDsgaisrKXtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgZmllbGQgPSBmaWVsZHNbal07XG4gICAgICAgICAgdmFyIHZhbCA9IGRhdGFbZmllbGRdO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCB2YWwgPT0gbnVsbCB8fCB2YWwgPT09ICcnICl7XG4gICAgICAgICAgICAvLyBjYW4ndCBjcmVhdGUgaWYgc291cmNlIG9yIHRhcmdldCBpcyBub3QgZGVmaW5lZCBwcm9wZXJseVxuICAgICAgICAgICAgJCQudXRpbC5lcnJvcignQ2FuIG5vdCBjcmVhdGUgZWRnZSBgJyArIGlkICsgJ2Agd2l0aCB1bnNwZWNpZmllZCAnICsgZmllbGQpO1xuICAgICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiggY3kuZ2V0RWxlbWVudEJ5SWQodmFsKS5lbXB0eSgpICl7IFxuICAgICAgICAgICAgLy8gY2FuJ3QgY3JlYXRlIGVkZ2UgaWYgb25lIG9mIGl0cyBub2RlcyBkb2Vzbid0IGV4aXN0XG4gICAgICAgICAgICAkJC51dGlsLmVycm9yKCdDYW4gbm90IGNyZWF0ZSBlZGdlIGAnICsgaWQgKyAnYCB3aXRoIG5vbmV4aXN0YW50ICcgKyBmaWVsZCArICcgYCcgKyB2YWwgKyAnYCcpO1xuICAgICAgICAgICAgYmFkU291cmNlT3JUYXJnZXQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBiYWRTb3VyY2VPclRhcmdldCApeyBjb250aW51ZTsgfSAvLyBjYW4ndCBjcmVhdGUgdGhpc1xuICAgICAgICBcbiAgICAgICAgdmFyIHNyYyA9IGN5LmdldEVsZW1lbnRCeUlkKCBkYXRhLnNvdXJjZSApO1xuICAgICAgICB2YXIgdGd0ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGRhdGEudGFyZ2V0ICk7XG5cbiAgICAgICAgc3JjLl9wcml2YXRlLmVkZ2VzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgdGd0Ll9wcml2YXRlLmVkZ2VzLnB1c2goIGVkZ2UgKTtcblxuICAgICAgICBlZGdlLl9wcml2YXRlLnNvdXJjZSA9IHNyYztcbiAgICAgICAgZWRnZS5fcHJpdmF0ZS50YXJnZXQgPSB0Z3Q7XG5cbiAgICAgIH0gLy8gaWYgaXMgZWRnZVxuICAgICAgIFxuICAgICAgLy8gY3JlYXRlIG1vY2sgaWRzIG1hcCBmb3IgZWxlbWVudCBzbyBpdCBjYW4gYmUgdXNlZCBsaWtlIGNvbGxlY3Rpb25zXG4gICAgICBfcHJpdmF0ZS5pZHMgPSB7fTtcbiAgICAgIF9wcml2YXRlLmlkc1sgaWQgXSA9IGVsZTtcblxuICAgICAgX3ByaXZhdGUucmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgY3kuYWRkVG9Qb29sKCBlbGUgKTtcbiAgICAgIFxuICAgICAgcmVzdG9yZWQucHVzaCggZWxlICk7XG4gICAgfSAvLyBmb3IgZWFjaCBlbGVtZW50XG5cbiAgICAvLyBkbyBjb21wb3VuZCBub2RlIHNhbml0eSBjaGVja3NcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKysgKXsgLy8gZWFjaCBub2RlIFxuICAgICAgdmFyIG5vZGUgPSBlbGVtZW50c1tpXTtcbiAgICAgIHZhciBkYXRhID0gbm9kZS5fcHJpdmF0ZS5kYXRhO1xuXG4gICAgICB2YXIgcGFyZW50SWQgPSBub2RlLl9wcml2YXRlLmRhdGEucGFyZW50O1xuICAgICAgdmFyIHNwZWNpZmllZFBhcmVudCA9IHBhcmVudElkICE9IG51bGw7XG5cbiAgICAgIGlmKCBzcGVjaWZpZWRQYXJlbnQgKXtcbiAgICAgICAgdmFyIHBhcmVudCA9IGN5LmdldEVsZW1lbnRCeUlkKCBwYXJlbnRJZCApO1xuXG4gICAgICAgIGlmKCBwYXJlbnQuZW1wdHkoKSApe1xuICAgICAgICAgIC8vIG5vbi1leGlzdGFudCBwYXJlbnQ7IGp1c3QgcmVtb3ZlIGl0XG4gICAgICAgICAgZGF0YS5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNlbGZBc1BhcmVudCA9IGZhbHNlO1xuICAgICAgICAgIHZhciBhbmNlc3RvciA9IHBhcmVudDtcbiAgICAgICAgICB3aGlsZSggIWFuY2VzdG9yLmVtcHR5KCkgKXtcbiAgICAgICAgICAgIGlmKCBub2RlLnNhbWUoYW5jZXN0b3IpICl7XG4gICAgICAgICAgICAgIC8vIG1hcmsgc2VsZiBhcyBwYXJlbnQgYW5kIHJlbW92ZSBmcm9tIGRhdGFcbiAgICAgICAgICAgICAgc2VsZkFzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZGF0YS5wYXJlbnQgPSB1bmRlZmluZWQ7IC8vIHJlbW92ZSBwYXJlbnQgcmVmZXJlbmNlXG5cbiAgICAgICAgICAgICAgLy8gZXhpdCBvciB3ZSBsb29wIGZvcmV2ZXJcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICFzZWxmQXNQYXJlbnQgKXtcbiAgICAgICAgICAgIC8vIGNvbm5lY3Qgd2l0aCBjaGlsZHJlblxuICAgICAgICAgICAgcGFyZW50WzBdLl9wcml2YXRlLmNoaWxkcmVuLnB1c2goIG5vZGUgKTtcbiAgICAgICAgICAgIG5vZGUuX3ByaXZhdGUucGFyZW50ID0gcGFyZW50WzBdO1xuXG4gICAgICAgICAgICAvLyBsZXQgdGhlIGNvcmUga25vdyB3ZSBoYXZlIGEgY29tcG91bmQgZ3JhcGhcbiAgICAgICAgICAgIGN5Ll9wcml2YXRlLmhhc0NvbXBvdW5kTm9kZXMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBlbHNlXG4gICAgICB9IC8vIGlmIHNwZWNpZmllZCBwYXJlbnRcbiAgICB9IC8vIGZvciBlYWNoIG5vZGVcbiAgICBcbiAgICByZXN0b3JlZCA9IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcmVzdG9yZWQgKTtcbiAgICBpZiggcmVzdG9yZWQubGVuZ3RoID4gMCApe1xuXG4gICAgICB2YXIgdG9VcGRhdGVTdHlsZSA9IHJlc3RvcmVkLmFkZCggcmVzdG9yZWQuY29ubmVjdGVkTm9kZXMoKSApLmFkZCggcmVzdG9yZWQucGFyZW50KCkgKTtcbiAgICAgIHRvVXBkYXRlU3R5bGUudXBkYXRlU3R5bGUoIG5vdGlmeVJlbmRlcmVyICk7XG5cbiAgICAgIGlmKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgICByZXN0b3JlZC5ydHJpZ2dlcignYWRkJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN0b3JlZC50cmlnZ2VyKCdhZGQnKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHNlbGY7IC8vIGNoYWluYWJpbGl0eVxuICB9O1xuICBcbiAgJCQuZWxlc2ZuLnJlbW92ZWQgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIHJldHVybiBlbGUgJiYgZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG4gIH07XG5cbiAgJCQuZWxlc2ZuLmluc2lkZSA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgcmV0dXJuIGVsZSAmJiAhZWxlLl9wcml2YXRlLnJlbW92ZWQ7XG4gIH07XG5cbiAgJCQuZWxlc2ZuLnJlbW92ZSA9IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgIHZhciBlbGVzVG9SZW1vdmUgPSBbXTtcbiAgICB2YXIgZWxlc1RvUmVtb3ZlSWRzID0ge307XG4gICAgdmFyIGN5ID0gc2VsZi5fcHJpdmF0ZS5jeTtcbiAgICBcbiAgICBpZiggbm90aWZ5UmVuZGVyZXIgPT09IHVuZGVmaW5lZCApe1xuICAgICAgbm90aWZ5UmVuZGVyZXIgPSB0cnVlO1xuICAgIH1cbiAgICBcbiAgICAvLyBhZGQgY29ubmVjdGVkIGVkZ2VzXG4gICAgZnVuY3Rpb24gYWRkQ29ubmVjdGVkRWRnZXMobm9kZSl7XG4gICAgICB2YXIgZWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzOyBcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgYWRkKCBlZGdlc1tpXSApO1xuICAgICAgfVxuICAgIH1cbiAgICBcblxuICAgIC8vIGFkZCBkZXNjZW5kYW50IG5vZGVzXG4gICAgZnVuY3Rpb24gYWRkQ2hpbGRyZW4obm9kZSl7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLl9wcml2YXRlLmNoaWxkcmVuO1xuICAgICAgXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGFkZCggY2hpbGRyZW5baV0gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGQoIGVsZSApe1xuICAgICAgdmFyIGFscmVhZHlBZGRlZCA9ICBlbGVzVG9SZW1vdmVJZHNbIGVsZS5pZCgpIF07XG4gICAgICBpZiggYWxyZWFkeUFkZGVkICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZXNUb1JlbW92ZUlkc1sgZWxlLmlkKCkgXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgZWxlc1RvUmVtb3ZlLnB1c2goIGVsZSApOyAvLyBub2RlcyBhcmUgcmVtb3ZlZCBsYXN0XG5cbiAgICAgICAgYWRkQ29ubmVjdGVkRWRnZXMoIGVsZSApO1xuICAgICAgICBhZGRDaGlsZHJlbiggZWxlICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVzVG9SZW1vdmUudW5zaGlmdCggZWxlICk7IC8vIGVkZ2VzIGFyZSByZW1vdmVkIGZpcnN0XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbWFrZSB0aGUgbGlzdCBvZiBlbGVtZW50cyB0byByZW1vdmVcbiAgICAvLyAobWF5IGJlIHJlbW92aW5nIG1vcmUgdGhhbiBzcGVjaWZpZWQgZHVlIHRvIGNvbm5lY3RlZCBlZGdlcyBldGMpXG5cbiAgICBmb3IoIHZhciBpID0gMCwgbCA9IHNlbGYubGVuZ3RoOyBpIDwgbDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gc2VsZltpXTtcblxuICAgICAgYWRkKCBlbGUgKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gcmVtb3ZlRWRnZVJlZihub2RlLCBlZGdlKXtcbiAgICAgIHZhciBjb25uZWN0ZWRFZGdlcyA9IG5vZGUuX3ByaXZhdGUuZWRnZXM7XG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciBjb25uZWN0ZWRFZGdlID0gY29ubmVjdGVkRWRnZXNbal07XG4gICAgICAgIFxuICAgICAgICBpZiggZWRnZSA9PT0gY29ubmVjdGVkRWRnZSApe1xuICAgICAgICAgIGNvbm5lY3RlZEVkZ2VzLnNwbGljZSggaiwgMSApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBlbGUpe1xuICAgICAgZWxlID0gZWxlWzBdO1xuICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgdmFyIGNoaWxkcmVuID0gcGFyZW50Ll9wcml2YXRlLmNoaWxkcmVuO1xuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrICl7XG4gICAgICAgIGlmKCBjaGlsZHJlbltqXVswXSA9PT0gZWxlWzBdICl7XG4gICAgICAgICAgY2hpbGRyZW4uc3BsaWNlKGosIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzVG9SZW1vdmUubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzVG9SZW1vdmVbaV07XG5cbiAgICAgIC8vIG1hcmsgYXMgcmVtb3ZlZFxuICAgICAgZWxlLl9wcml2YXRlLnJlbW92ZWQgPSB0cnVlO1xuXG4gICAgICAvLyByZW1vdmUgZnJvbSBjb3JlIHBvb2xcbiAgICAgIGN5LnJlbW92ZUZyb21Qb29sKCBlbGUgKTtcblxuICAgICAgLy8gYWRkIHRvIGxpc3Qgb2YgcmVtb3ZlZCBlbGVtZW50c1xuICAgICAgcmVtb3ZlZC5wdXNoKCBlbGUgKTtcblxuICAgICAgaWYoIGVsZS5pc0VkZ2UoKSApeyAvLyByZW1vdmUgcmVmZXJlbmNlcyB0byB0aGlzIGVkZ2UgaW4gaXRzIGNvbm5lY3RlZCBub2Rlc1xuICAgICAgICB2YXIgc3JjID0gZWxlLnNvdXJjZSgpWzBdO1xuICAgICAgICB2YXIgdGd0ID0gZWxlLnRhcmdldCgpWzBdO1xuXG4gICAgICAgIHJlbW92ZUVkZ2VSZWYoIHNyYywgZWxlICk7XG4gICAgICAgIHJlbW92ZUVkZ2VSZWYoIHRndCwgZWxlICk7XG5cbiAgICAgIH0gZWxzZSB7IC8vIHJlbW92ZSByZWZlcmVuY2UgdG8gcGFyZW50IFxuICAgICAgICB2YXIgcGFyZW50ID0gZWxlLnBhcmVudCgpO1xuXG4gICAgICAgIGlmKCBwYXJlbnQubGVuZ3RoICE9PSAwICl7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGRSZWYocGFyZW50LCBlbGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSBjb21wb3VuZCBncmFwaCBvciBub3RcbiAgICB2YXIgZWxlc1N0aWxsSW5zaWRlID0gY3kuX3ByaXZhdGUuZWxlbWVudHM7XG4gICAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IGZhbHNlO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1N0aWxsSW5zaWRlLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1N0aWxsSW5zaWRlW2ldO1xuXG4gICAgICBpZiggZWxlLmlzUGFyZW50KCkgKXtcbiAgICAgICAgY3kuX3ByaXZhdGUuaGFzQ29tcG91bmROb2RlcyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZW1vdmVkRWxlbWVudHMgPSBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpLCByZW1vdmVkICk7XG4gICAgaWYoIHJlbW92ZWRFbGVtZW50cy5zaXplKCkgPiAwICl7XG4gICAgICAvLyBtdXN0IG1hbnVhbGx5IG5vdGlmeSBzaW5jZSB0cmlnZ2VyIHdvbid0IGRvIHRoaXMgYXV0b21hdGljYWxseSBvbmNlIHJlbW92ZWRcbiAgICAgIFxuICAgICAgaWYoIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICAgIHRoaXMuY3koKS5ub3RpZnkoe1xuICAgICAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgICAgICAgIGNvbGxlY3Rpb246IHJlbW92ZWRFbGVtZW50c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmVtb3ZlZEVsZW1lbnRzLnRyaWdnZXIoJ3JlbW92ZScpO1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciBlbXB0eSByZW1haW5pbmcgcGFyZW50IG5vZGVzXG4gICAgdmFyIGNoZWNrZWRQYXJlbnRJZCA9IHt9O1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlc1RvUmVtb3ZlLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgZWxlID0gZWxlc1RvUmVtb3ZlW2ldO1xuICAgICAgdmFyIGlzTm9kZSA9IGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJztcbiAgICAgIHZhciBwYXJlbnRJZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudDtcblxuICAgICAgaWYoIGlzTm9kZSAmJiBwYXJlbnRJZCAhPT0gdW5kZWZpbmVkICYmICFjaGVja2VkUGFyZW50SWRbIHBhcmVudElkIF0gKXtcbiAgICAgICAgY2hlY2tlZFBhcmVudElkWyBwYXJlbnRJZCBdID0gdHJ1ZTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGN5LmdldEVsZW1lbnRCeUlkKCBwYXJlbnRJZCApO1xuXG4gICAgICAgIGlmKCBwYXJlbnQgJiYgcGFyZW50Lmxlbmd0aCAhPT0gMCAmJiAhcGFyZW50Ll9wcml2YXRlLnJlbW92ZWQgJiYgcGFyZW50LmNoaWxkcmVuKCkubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgcGFyZW50LnVwZGF0ZVN0eWxlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAkJC5lbGVzZm4ubW92ZSA9IGZ1bmN0aW9uKCBzdHJ1Y3QgKXtcbiAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgaWYoIHN0cnVjdC5zb3VyY2UgIT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudGFyZ2V0ICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHZhciBzcmNJZCA9IHN0cnVjdC5zb3VyY2U7XG4gICAgICB2YXIgdGd0SWQgPSBzdHJ1Y3QudGFyZ2V0O1xuICAgICAgdmFyIHNyY0V4aXN0cyA9IGN5LmdldEVsZW1lbnRCeUlkKCBzcmNJZCApLmxlbmd0aCA+IDA7XG4gICAgICB2YXIgdGd0RXhpc3RzID0gY3kuZ2V0RWxlbWVudEJ5SWQoIHRndElkICkubGVuZ3RoID4gMDtcblxuICAgICAgaWYoIHNyY0V4aXN0cyB8fCB0Z3RFeGlzdHMgKXtcbiAgICAgICAgdmFyIGpzb25zID0gdGhpcy5qc29ucygpO1xuXG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBqc29ucy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBqc29uID0ganNvbnNbaV07XG5cbiAgICAgICAgICBpZigganNvbi5ncm91cCA9PT0gJ2VkZ2VzJyApe1xuICAgICAgICAgICAgaWYoIHNyY0V4aXN0cyApeyBqc29uLmRhdGEuc291cmNlID0gc3JjSWQ7IH1cbiAgICAgICAgICAgIGlmKCB0Z3RFeGlzdHMgKXsganNvbi5kYXRhLnRhcmdldCA9IHRndElkOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGN5LmFkZCgganNvbnMgKTtcbiAgICAgIH1cbiBcbiAgICB9IGVsc2UgaWYoIHN0cnVjdC5wYXJlbnQgIT09IHVuZGVmaW5lZCApeyAvLyBtb3ZlIG5vZGUgdG8gbmV3IHBhcmVudFxuICAgICAgdmFyIHBhcmVudElkID0gc3RydWN0LnBhcmVudDtcbiAgICAgIHZhciBwYXJlbnRFeGlzdHMgPSBwYXJlbnRJZCA9PT0gbnVsbCB8fCBjeS5nZXRFbGVtZW50QnlJZCggcGFyZW50SWQgKS5sZW5ndGggPiAwO1xuICAgIFxuICAgICAgaWYoIHBhcmVudEV4aXN0cyApe1xuICAgICAgICB2YXIganNvbnMgPSB0aGlzLmpzb25zKCk7XG4gICAgICAgIHZhciBkZXNjcyA9IHRoaXMuZGVzY2VuZGFudHMoKTtcbiAgICAgICAgdmFyIGRlc2NzRXRjID0gZGVzY3MubWVyZ2UoIGRlc2NzLmFkZCh0aGlzKS5jb25uZWN0ZWRFZGdlcygpICk7XG5cbiAgICAgICAgdGhpcy5yZW1vdmUoKTsgLy8gTkI6IGFsc28gcmVtb3ZlcyBkZXNjZW5kYW50cyBhbmQgdGhlaXIgY29ubmVjdGVkIGVkZ2VzXG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGpzb24gPSBqc29uc1tpXTtcblxuICAgICAgICAgIGlmKCBqc29uLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgICAgICBqc29uLmRhdGEucGFyZW50ID0gcGFyZW50SWQgPT09IG51bGwgPyB1bmRlZmluZWQgOiBwYXJlbnRJZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGN5LmFkZCgganNvbnMgKS5tZXJnZSggZGVzY3NFdGMucmVzdG9yZSgpICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGlmIG5vdGhpbmcgZG9uZVxuICB9O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIHNlYXJjaCwgc3Bhbm5pbmcgdHJlZXMsIGV0Y1xuICAkJC5mbi5lbGVzKHtcblxuICAgIC8vIHN0ZCBmdW5jdGlvbmFsIGVsZSBmaXJzdCBjYWxsYmFjayBzdHlsZVxuICAgIHN0ZEJyZWFkdGhGaXJzdFNlYXJjaDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIG9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCgge30sIG9wdGlvbnMsIHtcbiAgICAgICAgc3RkOiB0cnVlXG4gICAgICB9ICk7XG5cbiAgICAgIHJldHVybiB0aGlzLmJyZWFkdGhGaXJzdFNlYXJjaCggb3B0aW9ucyApO1xuICAgIH0sXG5cbiAgICAvLyBkbyBhIGJyZWFkdGggZmlyc3Qgc2VhcmNoIGZyb20gdGhlIG5vZGVzIGluIHRoZSBjb2xsZWN0aW9uXG4gICAgLy8gZnJvbSBwc2V1ZG9jb2RlIG9uIHdpa2lwZWRpYVxuICAgIGJyZWFkdGhGaXJzdFNlYXJjaDogZnVuY3Rpb24oIHJvb3RzLCBmbiwgZGlyZWN0ZWQgKXtcbiAgICAgIHZhciBvcHRpb25zO1xuICAgICAgdmFyIHN0ZDtcbiAgICAgIHZhciB0aGlzQXJnO1xuICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KHJvb3RzKSAmJiAhJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihyb290cykgKXtcbiAgICAgICAgb3B0aW9ucyA9IHJvb3RzO1xuICAgICAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gICAgICAgIGZuID0gb3B0aW9ucy52aXNpdDtcbiAgICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgICBzdGQgPSBvcHRpb25zLnN0ZDtcbiAgICAgICAgdGhpc0FyZyA9IG9wdGlvbnMudGhpc0FyZztcbiAgICAgIH1cblxuICAgICAgZGlyZWN0ZWQgPSBhcmd1bWVudHMubGVuZ3RoID09PSAyICYmICEkJC5pcy5mbihmbikgPyBmbiA6IGRpcmVjdGVkO1xuICAgICAgZm4gPSAkJC5pcy5mbihmbikgPyBmbiA6IGZ1bmN0aW9uKCl7fTtcbiAgICAgIFxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciB2ID0gJCQuaXMuc3RyaW5nKHJvb3RzKSA/IHRoaXMuZmlsdGVyKHJvb3RzKSA6IHJvb3RzO1xuICAgICAgdmFyIFEgPSBbXTtcbiAgICAgIHZhciBjb25uZWN0ZWROb2RlcyA9IFtdO1xuICAgICAgdmFyIGNvbm5lY3RlZEJ5ID0ge307XG4gICAgICB2YXIgaWQyZGVwdGggPSB7fTtcbiAgICAgIHZhciBWID0ge307XG4gICAgICB2YXIgaiA9IDA7XG4gICAgICB2YXIgZm91bmQ7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG5cbiAgICAgIC8vIGVucXVldWUgdlxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCB2W2ldLmlzTm9kZSgpICl7XG4gICAgICAgICAgUS51bnNoaWZ0KCB2W2ldICk7XG4gICAgICAgICAgVlsgdltpXS5pZCgpIF0gPSB0cnVlOyBcblxuICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHZbaV0gKTtcbiAgICAgICAgICBpZDJkZXB0aFsgdltpXS5pZCgpIF0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlKCBRLmxlbmd0aCAhPT0gMCApe1xuICAgICAgICB2YXIgdiA9IFEuc2hpZnQoKTtcbiAgICAgICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHYuaWQoKSBdO1xuICAgICAgICB2YXIgcHJldkVkZ2UgPSBjb25uZWN0ZWRCeVsgdi5pZCgpIF07XG4gICAgICAgIHZhciBwcmV2Tm9kZSA9IHByZXZFZGdlID09IG51bGwgPyB1bmRlZmluZWQgOiBwcmV2RWRnZS5jb25uZWN0ZWROb2RlcygpLm5vdCggdiApWzBdO1xuICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgIGlmKCBzdGQgKXtcbiAgICAgICAgICByZXQgPSBmbi5jYWxsKHRoaXNBcmcsIHYsIHByZXZFZGdlLCBwcmV2Tm9kZSwgaisrLCBkZXB0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gZm4uY2FsbCh2LCBqKyssIGRlcHRoLCB2LCBwcmV2RWRnZSwgcHJldk5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHJldCA9PT0gdHJ1ZSApe1xuICAgICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdndFZGdlcyA9IHYuY29ubmVjdGVkRWRnZXMoZGlyZWN0ZWQgPyBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhKCdzb3VyY2UnKSA9PT0gdi5pZCgpOyB9IDogdW5kZWZpbmVkKS5pbnRlcnNlY3QoIGVkZ2VzICk7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdndFZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlID0gdndFZGdlc1tpXTtcbiAgICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuaWQoKSAhPT0gdi5pZCgpOyB9KS5pbnRlcnNlY3QoIG5vZGVzICk7XG5cbiAgICAgICAgICBpZiggdy5sZW5ndGggIT09IDAgJiYgIVZbIHcuaWQoKSBdICl7XG4gICAgICAgICAgICB3ID0gd1swXTtcblxuICAgICAgICAgICAgUS5wdXNoKCB3ICk7XG4gICAgICAgICAgICBWWyB3LmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgICAgIGlkMmRlcHRoWyB3LmlkKCkgXSA9IGlkMmRlcHRoWyB2LmlkKCkgXSArIDE7XG5cbiAgICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHcgKTtcbiAgICAgICAgICAgIGNvbm5lY3RlZEJ5WyB3LmlkKCkgXSA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfVxuXG4gICAgICB2YXIgY29ubmVjdGVkRWxlcyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZE5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gY29ubmVjdGVkTm9kZXNbaV07XG4gICAgICAgIHZhciBlZGdlID0gY29ubmVjdGVkQnlbIG5vZGUuaWQoKSBdO1xuXG4gICAgICAgIGlmKCBlZGdlICl7XG4gICAgICAgICAgY29ubmVjdGVkRWxlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goIG5vZGUgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aDogbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBjb25uZWN0ZWRFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICksXG4gICAgICAgIGZvdW5kOiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGZvdW5kLCB7IHVuaXF1ZTogdHJ1ZSB9IClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIHN0ZCBmdW5jdGlvbmFsIGVsZSBmaXJzdCBjYWxsYmFjayBzdHlsZVxuICAgIHN0ZERlcHRoRmlyc3RTZWFyY2g6IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgICBvcHRpb25zID0gJCQudXRpbC5leHRlbmQoIHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHN0ZDogdHJ1ZVxuICAgICAgfSApO1xuXG4gICAgICByZXR1cm4gdGhpcy5kZXB0aEZpcnN0U2VhcmNoKCBvcHRpb25zICk7XG4gICAgfSxcblxuICAgIC8vIGRvIGEgZGVwdGggZmlyc3Qgc2VhcmNoIG9uIHRoZSBub2RlcyBpbiB0aGUgY29sbGVjdGlvblxuICAgIC8vIGZyb20gcHNldWRvY29kZSBvbiB3aWtpcGVkaWEgKGl0ZXJhdGl2ZSBpbXBsKVxuICAgIGRlcHRoRmlyc3RTZWFyY2g6IGZ1bmN0aW9uKCByb290cywgZm4sIGRpcmVjdGVkICl7XG4gICAgICB2YXIgb3B0aW9ucztcbiAgICAgIHZhciBzdGQ7XG4gICAgICB2YXIgdGhpc0FyZztcbiAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChyb290cykgJiYgISQkLmlzLmVsZW1lbnRPckNvbGxlY3Rpb24ocm9vdHMpICl7XG4gICAgICAgIG9wdGlvbnMgPSByb290cztcbiAgICAgICAgcm9vdHMgPSBvcHRpb25zLnJvb3RzO1xuICAgICAgICBmbiA9IG9wdGlvbnMudmlzaXQ7XG4gICAgICAgIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgICAgc3RkID0gb3B0aW9ucy5zdGQ7XG4gICAgICAgIHRoaXNBcmcgPSBvcHRpb25zLnRoaXNBcmc7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGRpcmVjdGVkID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMiAmJiAhJCQuaXMuZm4oZm4pID8gZm4gOiBkaXJlY3RlZDtcbiAgICAgIGZuID0gJCQuaXMuZm4oZm4pID8gZm4gOiBmdW5jdGlvbigpe307XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHYgPSAkJC5pcy5zdHJpbmcocm9vdHMpID8gdGhpcy5maWx0ZXIocm9vdHMpIDogcm9vdHM7XG4gICAgICB2YXIgUyA9IFtdO1xuICAgICAgdmFyIGNvbm5lY3RlZE5vZGVzID0gW107XG4gICAgICB2YXIgY29ubmVjdGVkQnkgPSB7fTtcbiAgICAgIHZhciBpZDJkZXB0aCA9IHt9O1xuICAgICAgdmFyIGRpc2NvdmVyZWQgPSB7fTtcbiAgICAgIHZhciBqID0gMDtcbiAgICAgIHZhciBmb3VuZDtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgLy8gcHVzaCB2XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHYubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIHZbaV0uaXNOb2RlKCkgKXtcbiAgICAgICAgICBTLnB1c2goIHZbaV0gKTtcblxuICAgICAgICAgIGNvbm5lY3RlZE5vZGVzLnB1c2goIHZbaV0gKTtcbiAgICAgICAgICBpZDJkZXB0aFsgdltpXS5pZCgpIF0gPSAwO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlKCBTLmxlbmd0aCAhPT0gMCApe1xuICAgICAgICB2YXIgdiA9IFMucG9wKCk7XG5cbiAgICAgICAgaWYoICFkaXNjb3ZlcmVkWyB2LmlkKCkgXSApe1xuICAgICAgICAgIGRpc2NvdmVyZWRbIHYuaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoWyB2LmlkKCkgXTtcbiAgICAgICAgICB2YXIgcHJldkVkZ2UgPSBjb25uZWN0ZWRCeVsgdi5pZCgpIF07XG4gICAgICAgICAgdmFyIHByZXZOb2RlID0gcHJldkVkZ2UgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHByZXZFZGdlLmNvbm5lY3RlZE5vZGVzKCkubm90KCB2IClbMF07XG4gICAgICAgICAgdmFyIHJldDtcblxuICAgICAgICAgIGlmKCBzdGQgKXtcbiAgICAgICAgICAgIHJldCA9IGZuLmNhbGwodGhpc0FyZywgdiwgcHJldkVkZ2UsIHByZXZOb2RlLCBqKyssIGRlcHRoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0ID0gZm4uY2FsbCh2LCBqKyssIGRlcHRoLCB2LCBwcmV2RWRnZSwgcHJldk5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCByZXQgPT09IHRydWUgKXtcbiAgICAgICAgICAgIGZvdW5kID0gdjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdndFZGdlcyA9IHYuY29ubmVjdGVkRWRnZXMoZGlyZWN0ZWQgPyBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhKCdzb3VyY2UnKSA9PT0gdi5pZCgpOyB9IDogdW5kZWZpbmVkKS5pbnRlcnNlY3QoIGVkZ2VzICk7XG4gICAgICAgICAgXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2d0VkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbaV07XG4gICAgICAgICAgICB2YXIgdyA9IGUuY29ubmVjdGVkTm9kZXMoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuaWQoKSAhPT0gdi5pZCgpOyB9KS5pbnRlcnNlY3QoIG5vZGVzICk7XG5cbiAgICAgICAgICAgIGlmKCB3Lmxlbmd0aCAhPT0gMCAmJiAhZGlzY292ZXJlZFsgdy5pZCgpIF0gKXtcbiAgICAgICAgICAgICAgdyA9IHdbMF07XG5cbiAgICAgICAgICAgICAgUy5wdXNoKCB3ICk7XG5cbiAgICAgICAgICAgICAgaWQyZGVwdGhbIHcuaWQoKSBdID0gaWQyZGVwdGhbIHYuaWQoKSBdICsgMTtcblxuICAgICAgICAgICAgICBjb25uZWN0ZWROb2Rlcy5wdXNoKCB3ICk7XG4gICAgICAgICAgICAgIGNvbm5lY3RlZEJ5WyB3LmlkKCkgXSA9IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb25uZWN0ZWRFbGVzID0gW107XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY29ubmVjdGVkTm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBjb25uZWN0ZWROb2Rlc1tpXTtcbiAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRCeVsgbm9kZS5pZCgpIF07XG5cbiAgICAgICAgaWYoIGVkZ2UgKXtcbiAgICAgICAgICBjb25uZWN0ZWRFbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbm5lY3RlZEVsZXMucHVzaCggbm9kZSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoOiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGNvbm5lY3RlZEVsZXMsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgICAgZm91bmQ6IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZm91bmQsIHsgdW5pcXVlOiB0cnVlIH0gKVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8ga3J1c2thbCdzIGFsZ29yaXRobSAoZmluZHMgbWluIHNwYW5uaW5nIHRyZWUsIGFzc3VtaW5nIHVuZGlyZWN0ZWQgZ3JhcGgpXG4gICAgLy8gaW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAga3J1c2thbDogZnVuY3Rpb24oIHdlaWdodEZuICl7XG4gICAgICB3ZWlnaHRGbiA9ICQkLmlzLmZuKHdlaWdodEZuKSA/IHdlaWdodEZuIDogZnVuY3Rpb24oKXsgcmV0dXJuIDE7IH07IC8vIGlmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcblxuICAgICAgZnVuY3Rpb24gZmluZFNldChlbGUpe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGZvcmVzdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGVzID0gZm9yZXN0W2ldO1xuXG4gICAgICAgICAgaWYoIGVsZXMuYW55U2FtZShlbGUpICl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBlbGVzOiBlbGVzLFxuICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIEEgPSBuZXcgJCQuQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCBbXSk7XG4gICAgICB2YXIgZm9yZXN0ID0gW107XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgZm9yZXN0LnB1c2goIG5vZGVzW2ldLmNvbGxlY3Rpb24oKSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCk7XG4gICAgICB2YXIgUyA9IGVkZ2VzLnRvQXJyYXkoKS5zb3J0KGZ1bmN0aW9uKGEsIGIpe1xuICAgICAgICB2YXIgd2VpZ2h0QSA9IHdlaWdodEZuLmNhbGwoYSwgYSk7XG4gICAgICAgIHZhciB3ZWlnaHRCID0gd2VpZ2h0Rm4uY2FsbChiLCBiKTtcblxuICAgICAgICByZXR1cm4gd2VpZ2h0QSAtIHdlaWdodEI7XG4gICAgICB9KTtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IFMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgZWRnZSA9IFNbaV07XG4gICAgICAgIHZhciB1ID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICAgICAgdmFyIHYgPSBlZGdlLnRhcmdldCgpWzBdO1xuICAgICAgICB2YXIgc2V0VSA9IGZpbmRTZXQodSk7XG4gICAgICAgIHZhciBzZXRWID0gZmluZFNldCh2KTtcblxuICAgICAgICBpZiggc2V0VS5pbmRleCAhPT0gc2V0Vi5pbmRleCApe1xuICAgICAgICAgIEEgPSBBLmFkZCggZWRnZSApO1xuXG4gICAgICAgICAgLy8gY29tYmluZSBmb3Jlc3RzIGZvciB1IGFuZCB2XG4gICAgICAgICAgZm9yZXN0WyBzZXRVLmluZGV4IF0gPSBzZXRVLmVsZXMuYWRkKCBzZXRWLmVsZXMgKTtcbiAgICAgICAgICBmb3Jlc3Quc3BsaWNlKCBzZXRWLmluZGV4LCAxICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5vZGVzLmFkZCggQSApO1xuXG4gICAgfSxcblxuICAgIGRpamtzdHJhOiBmdW5jdGlvbiggcm9vdCwgd2VpZ2h0Rm4sIGRpcmVjdGVkICl7XG4gICAgICB2YXIgb3B0aW9ucztcbiAgICAgIGlmKCAkJC5pcy5wbGFpbk9iamVjdChyb290KSAmJiAhJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihyb290KSApe1xuICAgICAgICBvcHRpb25zID0gcm9vdDtcbiAgICAgICAgcm9vdCA9IG9wdGlvbnMucm9vdDtcbiAgICAgICAgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgICAgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgd2VpZ2h0Rm4gPSAkJC5pcy5mbih3ZWlnaHRGbikgPyB3ZWlnaHRGbiA6IGZ1bmN0aW9uKCl7IHJldHVybiAxOyB9OyAvLyBpZiBub3Qgc3BlY2lmaWVkLCBhc3N1bWUgZWFjaCBlZGdlIGhhcyBlcXVhbCB3ZWlnaHQgKDEpXG5cbiAgICAgIHZhciBzb3VyY2UgPSAkJC5pcy5zdHJpbmcocm9vdCkgPyB0aGlzLmZpbHRlcihyb290KVswXSA6IHJvb3RbMF07XG4gICAgICB2YXIgZGlzdCA9IHt9O1xuICAgICAgdmFyIHByZXYgPSB7fTtcbiAgICAgIHZhciBrbm93bkRpc3QgPSB7fTtcblxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLmZpbHRlcihmdW5jdGlvbigpeyByZXR1cm4gIXRoaXMuaXNMb29wKCk7IH0pO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIFEgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBkaXN0WyBub2Rlc1tpXS5pZCgpIF0gPSBub2Rlc1tpXS5zYW1lKCBzb3VyY2UgKSA/IDAgOiBJbmZpbml0eTtcbiAgICAgICAgUS5wdXNoKCBub2Rlc1tpXSApO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVGbiA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGRpc3RbIG5vZGUuaWQoKSBdO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgUSA9IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBRKTtcbiAgICBcbiAgICAgIHZhciBoZWFwID0gJCQuTWluaGVhcChjeSwgUSwgdmFsdWVGbik7XG4gICAgXG4gICAgICB2YXIgZGlzdEJldHdlZW4gPSBmdW5jdGlvbih1LCB2KXtcbiAgICAgICAgdmFyIHV2cyA9ICggZGlyZWN0ZWQgPyB1LmVkZ2VzVG8odikgOiB1LmVkZ2VzV2l0aCh2KSApLmludGVyc2VjdChlZGdlcyk7XG4gICAgICAgIHZhciBzbWFsbGVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBzbWFsbGVzdEVkZ2U7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB1dnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IHV2c1tpXTtcbiAgICAgICAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4uYXBwbHkoIGVkZ2UsIFtlZGdlXSApO1xuXG4gICAgICAgICAgaWYoIHdlaWdodCA8IHNtYWxsZXN0RGlzdGFuY2UgfHwgIXNtYWxsZXN0RWRnZSApe1xuICAgICAgICAgICAgc21hbGxlc3REaXN0YW5jZSA9IHdlaWdodDtcbiAgICAgICAgICAgIHNtYWxsZXN0RWRnZSA9IGVkZ2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlZGdlOiBzbWFsbGVzdEVkZ2UsXG4gICAgICAgICAgZGlzdDogc21hbGxlc3REaXN0YW5jZVxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgd2hpbGUoaGVhcC5zaXplKCkgPiAwKXtcbiAgICAgICAgdmFyIHNtYWxsZXN0RWwgPSBoZWFwLnBvcCgpLFxuICAgICAgICBzbWFsbGV0c0Rpc3QgPSBzbWFsbGVzdEVsLnZhbHVlLFxuICAgICAgICB1aWQgPSBzbWFsbGVzdEVsLmlkLFxuICAgICAgICB1ID0gY3kuZ2V0RWxlbWVudEJ5SWQodWlkKTtcbiAgICBcbiAgICAgICAga25vd25EaXN0W3VpZF0gPSBzbWFsbGV0c0Rpc3Q7XG4gICAgICBcbiAgICAgICAgaWYoIHNtYWxsZXRzRGlzdCA9PT0gTWF0aC5JbmZpbml0ZSApe1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5laWdoYm9ycyA9IHUubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KG5vZGVzKTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuZWlnaGJvcnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgdiA9IG5laWdoYm9yc1tpXTtcbiAgICAgICAgICB2YXIgdmlkID0gdi5pZCgpO1xuICAgICAgICAgIHZhciB2RGlzdCA9IGRpc3RCZXR3ZWVuKHUsIHYpO1xuXG4gICAgICAgICAgdmFyIGFsdCA9IHNtYWxsZXRzRGlzdCArIHZEaXN0LmRpc3Q7XG5cbiAgICAgICAgICBpZiggYWx0IDwgaGVhcC5nZXRWYWx1ZUJ5SWQodmlkKSApe1xuICAgICAgICAgICAgaGVhcC5lZGl0KHZpZCwgYWx0KTtcbiAgICAgICAgICAgIHByZXZbIHZpZCBdID0ge1xuICAgICAgICAgICAgICBub2RlOiB1LFxuICAgICAgICAgICAgICBlZGdlOiB2RGlzdC5lZGdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBmb3IgXG4gICAgICB9IC8vIHdoaWxlXG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpc3RhbmNlVG86IGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgIHZhciB0YXJnZXQgPSAkJC5pcy5zdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSlbMF0gOiBub2RlWzBdO1xuXG4gICAgICAgICAgcmV0dXJuIGtub3duRGlzdFsgdGFyZ2V0LmlkKCkgXTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXRoVG86IGZ1bmN0aW9uKG5vZGUpe1xuICAgICAgICAgIHZhciB0YXJnZXQgPSAkJC5pcy5zdHJpbmcobm9kZSkgPyBub2Rlcy5maWx0ZXIobm9kZSlbMF0gOiBub2RlWzBdO1xuICAgICAgICAgIHZhciBTID0gW107XG4gICAgICAgICAgdmFyIHUgPSB0YXJnZXQ7XG5cbiAgICAgICAgICBpZiggdGFyZ2V0Lmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIFMudW5zaGlmdCggdGFyZ2V0ICk7XG5cbiAgICAgICAgICAgIHdoaWxlKCBwcmV2WyB1LmlkKCkgXSApe1xuICAgICAgICAgICAgICB2YXIgcCA9IHByZXZbIHUuaWQoKSBdO1xuXG4gICAgICAgICAgICAgIFMudW5zaGlmdCggcC5lZGdlICk7XG4gICAgICAgICAgICAgIFMudW5zaGlmdCggcC5ub2RlICk7XG5cbiAgICAgICAgICAgICAgdSA9IHAubm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBTICk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAgXG4gIH0pO1xuXG4gIC8vIG5pY2UsIHNob3J0IG1hdGhlbWF0aGljYWwgYWxpYXNcbiAgJCQuZWxlc2ZuLmJmcyA9ICQkLmVsZXNmbi5icmVhZHRoRmlyc3RTZWFyY2g7XG4gICQkLmVsZXNmbi5kZnMgPSAkJC5lbGVzZm4uZGVwdGhGaXJzdFNlYXJjaDtcbiAgJCQuZWxlc2ZuLnN0ZEJmcyA9ICQkLmVsZXNmbi5zdGRCcmVhZHRoRmlyc3RTZWFyY2g7XG4gICQkLmVsZXNmbi5zdGREZnMgPSAkJC5lbGVzZm4uc3RkRGVwdGhGaXJzdFNlYXJjaDtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpIHsgXG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBBZGRpdGlvbmFsIGdyYXBoIGFuYWx5c2lzIGFsZ29yaXRobXNcbiAgJCQuZm4uZWxlcyh7XG5cbiAgICAvLyBJbXBsZW1lbnRlZCBmcm9tIHBzZXVkb2NvZGUgZnJvbSB3aWtpcGVkaWFcblxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIHJvb3QgLy8gc3RhcnRpbmcgbm9kZSAoZWl0aGVyIGVsZW1lbnQgb3Igc2VsZWN0b3Igc3RyaW5nKVxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGhldXJpc3RpYzogZnVuY3Rpb24oIG5vZGUgKXt9IC8vIHNwZWNpZmllcyBoZXVyaXN0aWMgdmFsdWUgZm9yIGBub2RlYC9gdGhpc2BcbiAgICAvLyAgIGRpcmVjdGVkIC8vIGRlZmF1bHQgZmFsc2VcbiAgICAvLyAgIGdvYWwgLy8gdGFyZ2V0IG5vZGUgKGVpdGhlciBlbGVtZW50IG9yIHNlbGVjdG9yIHN0cmluZykuIE1hbmRhdG9yeS5cblxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgIGZvdW5kIDogdHJ1ZS9mYWxzZSAvLyB3aGV0aGVyIGEgcGF0aCBmcm9tIHJvb3QgdG8gZ29hbCBoYXMgYmVlbiBmb3VuZFxuICAgIC8vICAgZGlzdGFuY2UgLy8gRGlzdGFuY2UgZm9yIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gcm9vdCB0byBnb2FsXG4gICAgLy8gICBwYXRoIC8vIEFycmF5IG9mIGlkcyBvZiBub2RlcyBpbiBzaG9ydGVzdCBwYXRoXG4gICAgYVN0YXI6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgaWYgKGRlYnVnKSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfTtcblxuICAgICAgLy8gUmVjb25zdHJ1Y3RzIHRoZSBwYXRoIGZyb20gU3RhcnQgdG8gRW5kLCBhY3VtdWxhdGluZyB0aGUgcmVzdWx0IGluIHBhdGhBY3VtXG4gICAgICB2YXIgcmVjb25zdHJ1Y3RQYXRoID0gZnVuY3Rpb24oc3RhcnQsIGVuZCwgY2FtZUZyb21NYXAsIHBhdGhBY3VtKSB7XG4gICAgICAgIC8vIEJhc2UgY2FzZVxuICAgICAgICBpZiAoc3RhcnQgPT0gZW5kKSB7XG4gICAgICAgICAgcGF0aEFjdW0ucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQoZW5kKSApO1xuICAgICAgICAgIHJldHVybiBwYXRoQWN1bTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGVuZCBpbiBjYW1lRnJvbU1hcCkge1xuICAgICAgICAgIC8vIFdlIGtub3cgd2hpY2ggbm9kZSBpcyBiZWZvcmUgdGhlIGxhc3Qgb25lXG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gY2FtZUZyb21NYXBbZW5kXTtcbiAgICAgICAgICB2YXIgcHJldmlvdXNFZGdlID0gY2FtZUZyb21FZGdlW2VuZF07XG5cbiAgICAgICAgICBwYXRoQWN1bS5wdXNoKCBjeS5nZXRFbGVtZW50QnlJZChlbmQpICk7XG4gICAgICAgICAgcGF0aEFjdW0ucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQocHJldmlvdXNFZGdlKSApO1xuXG5cbiAgICAgICAgICByZXR1cm4gcmVjb25zdHJ1Y3RQYXRoKHN0YXJ0LCBcbiAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMsIFxuICAgICAgICAgICAgICAgICAgICAgICBjYW1lRnJvbU1hcCwgXG4gICAgICAgICAgICAgICAgICAgICAgIHBhdGhBY3VtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3QgcmVhY2ggaGVyZSFcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgICAgICAgXG4gICAgICB9O1xuXG4gICAgICAvLyBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiBvcGVuU2V0IHdoaWNoIGhhcyBtaW5pbXVtIGZTY29yZVxuICAgICAgdmFyIGZpbmRNaW4gPSBmdW5jdGlvbihvcGVuU2V0LCBmU2NvcmUpIHtcbiAgICAgICAgaWYgKG9wZW5TZXQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGJlIHRoZSBjYXNlXG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWluUG9zID0gMDtcbiAgICAgICAgdmFyIHRlbXBTY29yZSA9IGZTY29yZVtvcGVuU2V0WzBdXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBvcGVuU2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHMgPSBmU2NvcmVbb3BlblNldFtpXV07XG4gICAgICAgICAgaWYgKHMgPCB0ZW1wU2NvcmUpIHtcbiAgICAgICAgICAgIHRlbXBTY29yZSA9IHM7XG4gICAgICAgICAgICBtaW5Qb3MgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluUG9zO1xuICAgICAgfTtcblxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgLy8gaWYgKG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgYVN0YXIuLi5cIik7IFxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5yb290ICE9IG51bGwpIHsgICAgICAgIFxuICAgICAgICB2YXIgc291cmNlID0gJCQuaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkgPyBcbiAgICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgICB0aGlzLmZpbHRlcihvcHRpb25zLnJvb3QpWzBdIDogXG4gICAgICAgICAgb3B0aW9ucy5yb290WzBdO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlNvdXJjZSBub2RlOiAlc1wiLCBzb3VyY2UuaWQoKSk7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gZ29hbCAtIG1hbmRhdG9yeSFcbiAgICAgIGlmIChvcHRpb25zLmdvYWwgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgdmFyIHRhcmdldCA9ICQkLmlzLnN0cmluZyhvcHRpb25zLmdvYWwpID8gXG4gICAgICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjZ29hbElEXG4gICAgICAgICAgdGhpcy5maWx0ZXIob3B0aW9ucy5nb2FsKVswXSA6IFxuICAgICAgICAgIG9wdGlvbnMuZ29hbFswXTtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJUYXJnZXQgbm9kZTogJXNcIiwgdGFyZ2V0LmlkKCkpOyBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIEhldXJpc3RpYyBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy5oZXVyaXN0aWMgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLmhldXJpc3RpYykpIHsgICAgICAgXG4gICAgICAgIHZhciBoZXVyaXN0aWMgPSBvcHRpb25zLmhldXJpc3RpYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBoZXVyaXN0aWMgPSBmdW5jdGlvbigpeyByZXR1cm4gMDsgfTsgLy8gdXNlIGNvbnN0YW50IGlmIHVuc3BlY2lmaWVkXG4gICAgICAgIC8vICQkLnV0aWwuZXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlciAoaGV1cmlzdGljKSEgQWJvcnRpbmcuXCIpO1xuICAgICAgICAvLyByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLndlaWdodCkpIHsgICAgICAgXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbihlKSB7cmV0dXJuIDE7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gb3B0aW9ucy5kaXJlY3RlZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvc2VkU2V0ID0gW107XG4gICAgICB2YXIgb3BlblNldCA9IFtzb3VyY2UuaWQoKV07XG4gICAgICB2YXIgY2FtZUZyb20gPSB7fTtcbiAgICAgIHZhciBjYW1lRnJvbUVkZ2UgPSB7fTtcbiAgICAgIHZhciBnU2NvcmUgPSB7fTtcbiAgICAgIHZhciBmU2NvcmUgPSB7fTtcblxuICAgICAgZ1Njb3JlW3NvdXJjZS5pZCgpXSA9IDA7XG4gICAgICBmU2NvcmVbc291cmNlLmlkKCldID0gaGV1cmlzdGljKHNvdXJjZSk7XG4gICAgICBcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oZSl7IHJldHVybiAhZS5pc0xvb3AoKTsgfSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG5cbiAgICAgIC8vIENvdW50ZXJcbiAgICAgIHZhciBzdGVwcyA9IDA7XG5cbiAgICAgIC8vIE1haW4gbG9vcCBcbiAgICAgIHdoaWxlIChvcGVuU2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIG1pblBvcyA9IGZpbmRNaW4ob3BlblNldCwgZlNjb3JlKTtcbiAgICAgICAgdmFyIGNNaW4gPSBjeS5nZXRFbGVtZW50QnlJZCggb3BlblNldFttaW5Qb3NdICk7XG4gICAgICAgIHN0ZXBzKys7XG5cbiAgICAgICAgLy8gbG9nRGVidWcoXCJcXG5TdGVwOiAlc1wiLCBzdGVwcyk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiUHJvY2Vzc2luZyBub2RlOiAlcywgZlNjb3JlID0gJXNcIiwgY01pbi5pZCgpLCBmU2NvcmVbY01pbi5pZCgpXSk7XG4gICAgICAgIFxuICAgICAgICAvLyBJZiB3ZSd2ZSBmb3VuZCBvdXIgZ29hbCwgdGhlbiB3ZSBhcmUgZG9uZVxuICAgICAgICBpZiAoY01pbi5pZCgpID09IHRhcmdldC5pZCgpKSB7XG4gICAgICAgICAgLy8gbG9nRGVidWcoXCJGb3VuZCBnb2FsIG5vZGUhXCIpO1xuICAgICAgICAgIHZhciByUGF0aCA9IHJlY29uc3RydWN0UGF0aChzb3VyY2UuaWQoKSwgdGFyZ2V0LmlkKCksIGNhbWVGcm9tLCBbXSk7XG4gICAgICAgICAgclBhdGgucmV2ZXJzZSgpO1xuICAgICAgICAgIC8vIGxvZ0RlYnVnKFwiUGF0aDogJXNcIiwgclBhdGgpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3VuZCA6IHRydWUsXG4gICAgICAgICAgICBkaXN0YW5jZSA6IGdTY29yZVtjTWluLmlkKCldLFxuICAgICAgICAgICAgcGF0aCA6IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCByUGF0aCksXG4gICAgICAgICAgICBzdGVwcyA6IHN0ZXBzXG4gICAgICAgICAgfTsgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEFkZCBjTWluIHRvIHByb2Nlc3NlZCBub2Rlc1xuICAgICAgICBjbG9zZWRTZXQucHVzaChjTWluLmlkKCkpO1xuICAgICAgICAvLyBSZW1vdmUgY01pbiBmcm9tIGJvdW5kYXJ5IG5vZGVzXG4gICAgICAgIG9wZW5TZXQuc3BsaWNlKG1pblBvcywgMSk7XG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiQWRkZWQgbm9kZSB0byBjbG9zZWRTZXQsIHJlbW92ZWQgZnJvbSBvcGVuU2V0LlwiKTtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJQcm9jZXNzaW5nIG5laWdoYm9ycy4uLlwiKTtcblxuICAgICAgICAvLyBVcGRhdGUgc2NvcmVzIGZvciBuZWlnaGJvcnMgb2YgY01pblxuICAgICAgICAvLyBUYWtlIGludG8gYWNjb3VudCBpZiBncmFwaCBpcyBkaXJlY3RlZCBvciBub3RcbiAgICAgICAgdmFyIHZ3RWRnZXMgPSBjTWluLmNvbm5lY3RlZEVkZ2VzKCk7XG4gICAgICAgIGlmKCBkaXJlY3RlZCApeyB2d0VkZ2VzID0gdndFZGdlcy5zdGRGaWx0ZXIoZnVuY3Rpb24oZWxlKXsgcmV0dXJuIGVsZS5kYXRhKCdzb3VyY2UnKSA9PT0gY01pbi5pZCgpOyB9KTsgfVxuICAgICAgICB2d0VkZ2VzID0gdndFZGdlcy5pbnRlcnNlY3QoZWRnZXMpOyAgXG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZ3RWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZSA9IHZ3RWRnZXNbaV07XG4gICAgICAgICAgdmFyIHcgPSBlLmNvbm5lY3RlZE5vZGVzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKG4peyByZXR1cm4gbi5pZCgpICE9PSBjTWluLmlkKCk7IH0pLmludGVyc2VjdChub2Rlcyk7XG5cbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIiAgIHByb2Nlc3NpbmcgbmVpZ2hib3I6ICVzXCIsIHcuaWQoKSk7XG4gICAgICAgICAgLy8gaWYgbm9kZSBpcyBpbiBjbG9zZWRTZXQsIGlnbm9yZSBpdFxuICAgICAgICAgIGlmIChjbG9zZWRTZXQuaW5kZXhPZih3LmlkKCkpICE9IC0xKSB7XG4gICAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIiAgIGFscmVhZHkgaW4gY2xvc2VkU2V0LCBpZ25vcmluZyBpdC5cIik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gTmV3IHRlbnRhdGl2ZSBzY29yZSBmb3Igbm9kZSB3XG4gICAgICAgICAgdmFyIHRlbXBTY29yZSA9IGdTY29yZVtjTWluLmlkKCldICsgd2VpZ2h0Rm4uYXBwbHkoZSwgW2VdKTtcbiAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIiAgIHRlbnRhdGl2ZSBnU2NvcmU6ICVkXCIsIHRlbXBTY29yZSk7XG5cbiAgICAgICAgICAvLyBVcGRhdGUgZ1Njb3JlIGZvciBub2RlIHcgaWY6XG4gICAgICAgICAgLy8gICB3IG5vdCBwcmVzZW50IGluIG9wZW5TZXRcbiAgICAgICAgICAvLyBPUlxuICAgICAgICAgIC8vICAgdGVudGF0aXZlIGdTY29yZSBpcyBsZXNzIHRoYW4gcHJldmlvdXMgdmFsdWVcblxuICAgICAgICAgIC8vIHcgbm90IGluIG9wZW5TZXRcbiAgICAgICAgICBpZiAob3BlblNldC5pbmRleE9mKHcuaWQoKSkgPT0gLTEpIHtcbiAgICAgICAgICAgIGdTY29yZVt3LmlkKCldID0gdGVtcFNjb3JlO1xuICAgICAgICAgICAgZlNjb3JlW3cuaWQoKV0gPSB0ZW1wU2NvcmUgKyBoZXVyaXN0aWModyk7XG4gICAgICAgICAgICBvcGVuU2V0LnB1c2gody5pZCgpKTsgLy8gQWRkIG5vZGUgdG8gb3BlblNldFxuICAgICAgICAgICAgY2FtZUZyb21bdy5pZCgpXSA9IGNNaW4uaWQoKTtcbiAgICAgICAgICAgIGNhbWVGcm9tRWRnZVt3LmlkKCldID0gZS5pZCgpO1xuICAgICAgICAgICAgLy8gbG9nRGVidWcoXCIgICBub3QgaW4gb3BlblNldCwgYWRkaW5nIGl0LiBcIik7XG4gICAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIiAgIGZTY29yZSglcykgPSAlc1wiLCB3LmlkKCksIHRlbXBTY29yZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gdyBhbHJlYWR5IGluIG9wZW5TZXQsIGJ1dCB3aXRoIGdyZWF0ZXIgZ1Njb3JlXG4gICAgICAgICAgaWYgKHRlbXBTY29yZSA8IGdTY29yZVt3LmlkKCldKSB7XG4gICAgICAgICAgICBnU2NvcmVbdy5pZCgpXSA9IHRlbXBTY29yZTtcbiAgICAgICAgICAgIGZTY29yZVt3LmlkKCldID0gdGVtcFNjb3JlICsgaGV1cmlzdGljKHcpO1xuICAgICAgICAgICAgY2FtZUZyb21bdy5pZCgpXSA9IGNNaW4uaWQoKTtcbiAgICAgICAgICAgIC8vIGxvZ0RlYnVnKFwiICAgYmV0dGVyIHNjb3JlLCByZXBsYWNpbmcgZ1Njb3JlLiBcIik7XG4gICAgICAgICAgICAvLyBsb2dEZWJ1ZyhcIiAgIGZTY29yZSglcykgPSAlc1wiLCB3LmlkKCksIHRlbXBTY29yZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gLy8gRW5kIG9mIG5laWdoYm9ycyB1cGRhdGVcblxuICAgICAgfSAvLyBFbmQgb2YgbWFpbiBsb29wXG5cbiAgICAgIC8vIElmIHdlJ3ZlIHJlYWNoZWQgaGVyZSwgdGhlbiB3ZSd2ZSBub3QgcmVhY2hlZCBvdXIgZ29hbFxuICAgICAgLy8gbG9nRGVidWcoXCJSZWFjaGVkIGVuZCBvZiBjb21wdXRhdGlvbiB3aXRob3V0IGZpbmRpbmcgb3VyIGdvYWxcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3VuZCA6IGZhbHNlLFxuICAgICAgICBkaXN0YW5jZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgcGF0aCA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RlcHMgOiBzdGVwc1xuICAgICAgfTtcbiAgICB9LCAvLyBhU3RhcigpXG5cblxuICAgIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIHdlaWdodDogZnVuY3Rpb24oIGVkZ2UgKXt9IC8vIHNwZWNpZmllcyB3ZWlnaHQgdG8gdXNlIGZvciBgZWRnZWAvYHRoaXNgLiBJZiBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSBhc3VtZWQgYSB3ZWlnaHQgb2YgMSBmb3IgYWxsIGVkZ2VzXG4gICAgLy8gICBkaXJlY3RlZCAvLyBkZWZhdWx0IGZhbHNlXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vICAgcGF0aFRvIDogZnVuY3Rpb24oZnJvbUlkLCB0b0lkKSAvLyBSZXR1cm5zIHRoZSBzaG9ydGVzdCBwYXRoIGZyb20gbm9kZSB3aXRoIElEIFwiZnJvbUlEXCIgdG8gbm9kZSB3aXRoIElEIFwidG9JZFwiLCBhcyBhbiBhcnJheSBvZiBub2RlIElEc1xuICAgIC8vICAgZGlzdGFuY2VUbzogZnVuY3Rpb24oZnJvbUlkLCB0b0lkKSAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBvZiB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tIG5vZGUgd2l0aCBJRCBcImZyb21JRFwiIHRvIG5vZGUgd2l0aCBJRCBcInRvSWRcIlxuICAgIGZsb3lkV2Fyc2hhbGw6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgaWYgKGRlYnVnKSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfTtcblxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgLy8gaWYgKG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG4gICAgICAvLyBsb2dEZWJ1ZyhcIlN0YXJ0aW5nIGZsb3lkV2Fyc2hhbGwuLi5cIik7IFxuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgJCQuaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7ICAgICAgIFxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oZSkge3JldHVybiAxO307XG4gICAgICB9XG5cbiAgICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHsgICAgICAgXG4gICAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbihlKXsgcmV0dXJuICFlLmlzTG9vcCgpOyB9KTtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgICAgfSAgICAgXG5cbiAgICAgIC8vIEluaXRpYWxpemUgZGlzdGFuY2UgbWF0cml4XG4gICAgICB2YXIgZGlzdCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdSb3cgPSBuZXcgQXJyYXkobnVtTm9kZXMpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgICBpZiAoaSA9PSBqKSB7XG4gICAgICAgICAgICBuZXdSb3dbal0gPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdSb3dbal0gPSBJbmZpbml0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGlzdC5wdXNoKG5ld1Jvdyk7XG4gICAgICB9ICAgICAgICAgICBcblxuICAgICAgLy8gSW5pdGlhbGl6ZSBtYXRyaXggdXNlZCBmb3IgcGF0aCByZWNvbnN0cnVjdGlvblxuICAgICAgLy8gSW5pdGlhbGl6ZSBkaXN0YW5jZSBtYXRyaXhcbiAgICAgIHZhciBuZXh0ID0gW107XG4gICAgICB2YXIgZWRnZU5leHQgPSBbXTtcblxuICAgICAgdmFyIGluaXRNYXRyaXggPSBmdW5jdGlvbihuZXh0KXtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5ld1JvdyA9IG5ldyBBcnJheShudW1Ob2Rlcyk7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgICAgICBuZXdSb3dbal0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHQucHVzaChuZXdSb3cpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpbml0TWF0cml4KG5leHQpO1xuICAgICAgaW5pdE1hdHJpeChlZGdlTmV4dCk7XG4gICAgICBcbiAgICAgIC8vIFByb2Nlc3MgZWRnZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoIDsgaSsrKSB7ICAgICBcbiAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbaV0uc291cmNlKCkuaWQoKV07XG4gICAgICAgIHZhciB0YXJnZXRJbmRleCA9IGlkMnBvc2l0aW9uW2VkZ2VzW2ldLnRhcmdldCgpLmlkKCldOyAgICBcbiAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2ldLCBbZWRnZXNbaV1dKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGlmIGFscmVhZHkgcHJvY2VzcyBhbm90aGVyIGVkZ2UgYmV0d2VlbiBzYW1lIDIgbm9kZXNcbiAgICAgICAgaWYgKGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA+IHdlaWdodCkge1xuICAgICAgICAgIGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA9IHdlaWdodDtcbiAgICAgICAgICBuZXh0W3NvdXJjZUluZGV4XVt0YXJnZXRJbmRleF0gPSB0YXJnZXRJbmRleDtcbiAgICAgICAgICBlZGdlTmV4dFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gZWRnZXNbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgdW5kaXJlY3RlZCBncmFwaCwgcHJvY2VzcyAncmV2ZXJzZWQnIGVkZ2VzXG4gICAgICBpZiAoIWRpcmVjdGVkKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoIDsgaSsrKSB7ICAgICBcbiAgICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tpXS50YXJnZXQoKS5pZCgpXTsgICAgXG4gICAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbaV0uc291cmNlKCkuaWQoKV07XG4gICAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2ldLCBbZWRnZXNbaV1dKTtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBDaGVjayBpZiBhbHJlYWR5IHByb2Nlc3MgYW5vdGhlciBlZGdlIGJldHdlZW4gc2FtZSAyIG5vZGVzXG4gICAgICAgICAgaWYgKGRpc3Rbc291cmNlSW5kZXhdW3RhcmdldEluZGV4XSA+IHdlaWdodCkge1xuICAgICAgICAgICAgZGlzdFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gd2VpZ2h0O1xuICAgICAgICAgICAgbmV4dFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gdGFyZ2V0SW5kZXg7XG4gICAgICAgICAgICBlZGdlTmV4dFtzb3VyY2VJbmRleF1bdGFyZ2V0SW5kZXhdID0gZWRnZXNbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE1haW4gbG9vcFxuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBudW1Ob2RlczsgaysrKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykgeyAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGRpc3RbaV1ba10gKyBkaXN0W2tdW2pdIDwgZGlzdFtpXVtqXSkge1xuICAgICAgICAgICAgICBkaXN0W2ldW2pdID0gZGlzdFtpXVtrXSArIGRpc3Rba11bal07XG4gICAgICAgICAgICAgIG5leHRbaV1bal0gPSBuZXh0W2ldW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCdWlsZCByZXN1bHQgb2JqZWN0ICAgICAgIFxuICAgICAgdmFyIHBvc2l0aW9uMmlkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgcG9zaXRpb24yaWQucHVzaChub2Rlc1tpXS5pZCgpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcyA9IHtcbiAgICAgICAgZGlzdGFuY2U6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhmcm9tKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIGZyb21JZCA9IChjeS5maWx0ZXIoZnJvbSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgZnJvbUlkID0gZnJvbS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcodG8pKSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIHRvSWQgPSAoY3kuZmlsdGVyKHRvKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBub2RlXG4gICAgICAgICAgICB2YXIgdG9JZCA9IHRvLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGRpc3RbaWQycG9zaXRpb25bZnJvbUlkXV1baWQycG9zaXRpb25bdG9JZF1dO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhdGg6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgICAgICAgdmFyIHJlY29uc3RydWN0UGF0aEF1eCA9IGZ1bmN0aW9uKGZyb20sIHRvLCBuZXh0LCBwb3NpdGlvbjJpZCwgZWRnZU5leHQpIHtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgICAgICAgICByZXR1cm4gY3kuZ2V0RWxlbWVudEJ5SWQoIHBvc2l0aW9uMmlkW2Zyb21dICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dFtmcm9tXVt0b10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcGF0aCA9IFsgY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbZnJvbV0pIF07XG4gICAgICAgICAgICB2YXIgcHJldiA9IGZyb207XG4gICAgICAgICAgICB3aGlsZSAoZnJvbSAhPT0gdG8pIHtcbiAgICAgICAgICAgICAgcHJldiA9IGZyb207XG4gICAgICAgICAgICAgIGZyb20gPSBuZXh0W2Zyb21dW3RvXTtcblxuICAgICAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VOZXh0W3ByZXZdW2Zyb21dO1xuICAgICAgICAgICAgICBwYXRoLnB1c2goIGVkZ2UgKTtcblxuICAgICAgICAgICAgICBwYXRoLnB1c2goIGN5LmdldEVsZW1lbnRCeUlkKHBvc2l0aW9uMmlkW2Zyb21dKSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcoZnJvbSkpIHtcbiAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciBmcm9tSWQgPSAoY3kuZmlsdGVyKGZyb20pWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIGZyb21JZCA9IGZyb20uaWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlcih0bylbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgcGF0aEFyciA9IHJlY29uc3RydWN0UGF0aEF1eChpZDJwb3NpdGlvbltmcm9tSWRdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkMnBvc2l0aW9uW3RvSWRdLCBcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjJpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VOZXh0KTtcblxuICAgICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHBhdGhBcnIgKTtcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByZXM7XG5cbiAgICB9LCAvLyBmbG95ZFdhcnNoYWxsXG5cblxuICAgIC8vIEltcGxlbWVudGVkIGZyb20gcHNldWRvY29kZSBmcm9tIHdpa2lwZWRpYVxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIHJvb3Q6IHN0YXJ0aW5nIG5vZGUgKGVpdGhlciBlbGVtZW50IG9yIHNlbGVjdG9yIHN0cmluZylcbiAgICAvLyAgIHdlaWdodDogZnVuY3Rpb24oIGVkZ2UgKXt9IC8vIHNwZWNpZmllcyB3ZWlnaHQgdG8gdXNlIGZvciBgZWRnZWAvYHRoaXNgLiBJZiBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSBhc3VtZWQgYSB3ZWlnaHQgb2YgMSBmb3IgYWxsIGVkZ2VzXG4gICAgLy8gICBkaXJlY3RlZCAvLyBkZWZhdWx0IGZhbHNlXG4gICAgLy8gcmV0T2JqID0+IHJldHVybmVkIG9iamVjdCBieSBmdW5jdGlvblxuICAgIC8vICAgcGF0aFRvIDogZnVuY3Rpb24odG9JZCkgLy8gUmV0dXJucyB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tIHJvb3Qgbm9kZSB0byBub2RlIHdpdGggSUQgXCJ0b0lkXCIsIGFzIGFuIGFycmF5IG9mIG5vZGUgSURzXG4gICAgLy8gICBkaXN0YW5jZVRvOiBmdW5jdGlvbih0b0lkKSAvLyBSZXR1cm5zIHRoZSBkaXN0YW5jZSBvZiB0aGUgc2hvcnRlc3QgcGF0aCBmcm9tIHJvb3Qgbm9kZSB0byBub2RlIHdpdGggSUQgXCJ0b0lkXCJcbiAgICAvLyAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IHRydWUvZmFsc2UgKGlmIHRydWUsIHBhdGhUbyBhbmQgZGlzdGFuY2VUbyB3aWxsIGJlIHVuZGVmaW5lZClcbiAgICBiZWxsbWFuRm9yZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgYmVsbG1hbkZvcmQuLi5cIik7IFxuXG4gICAgICAvLyBXZWlnaHQgZnVuY3Rpb24gLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMud2VpZ2h0ICE9IG51bGwgJiYgJCQuaXMuZm4ob3B0aW9ucy53ZWlnaHQpKSB7ICAgICAgIFxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24oZSkge3JldHVybiAxO307XG4gICAgICB9XG5cbiAgICAgIC8vIGRpcmVjdGVkIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwpIHsgICAgICAgXG4gICAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICAgIGlmIChvcHRpb25zLnJvb3QgIT0gbnVsbCkgeyAgICAgICBcbiAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhvcHRpb25zLnJvb3QpKSB7XG4gICAgICAgICAgLy8gdXNlIGl0IGFzIGEgc2VsZWN0b3IsIGUuZy4gXCIjcm9vdElEXG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZmlsdGVyKG9wdGlvbnMucm9vdClbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IG9wdGlvbnMucm9vdFswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlNvdXJjZSBub2RlOiAlc1wiLCBzb3VyY2UuaWQoKSk7IFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCQudXRpbC5lcnJvcihcIm9wdGlvbnMucm9vdCByZXF1aXJlZFwiKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oZSl7IHJldHVybiAhZS5pc0xvb3AoKTsgfSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgICAgIH0gICAgIFxuXG4gICAgICAvLyBJbml0aWFsaXphdGlvbnNcbiAgICAgIHZhciBjb3N0ID0gW107XG4gICAgICB2YXIgcHJlZGVjZXNzb3IgPSBbXTtcbiAgICAgIHZhciBwcmVkRWRnZSA9IFtdO1xuICAgICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgaWYgKG5vZGVzW2ldLmlkKCkgPT09IHNvdXJjZS5pZCgpKSB7XG4gICAgICAgICAgY29zdFtpXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29zdFtpXSA9IEluZmluaXR5O1xuICAgICAgICB9IFxuICAgICAgICBwcmVkZWNlc3NvcltpXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gRWRnZXMgcmVsYXhhdGlvbiAgICAgIFxuICAgICAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIGUgPSAwOyBlIDwgZWRnZXMubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICB2YXIgc291cmNlSW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS5zb3VyY2UoKS5pZCgpXTtcbiAgICAgICAgICB2YXIgdGFyZ2V0SW5kZXggPSBpZDJwb3NpdGlvbltlZGdlc1tlXS50YXJnZXQoKS5pZCgpXTsgICAgXG4gICAgICAgICAgdmFyIHdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2VzW2VdLCBbZWRnZXNbZV1dKTtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgdGVtcCA9IGNvc3Rbc291cmNlSW5kZXhdICsgd2VpZ2h0O1xuICAgICAgICAgIGlmICh0ZW1wIDwgY29zdFt0YXJnZXRJbmRleF0pIHtcbiAgICAgICAgICAgIGNvc3RbdGFyZ2V0SW5kZXhdID0gdGVtcDtcbiAgICAgICAgICAgIHByZWRlY2Vzc29yW3RhcmdldEluZGV4XSA9IHNvdXJjZUluZGV4O1xuICAgICAgICAgICAgcHJlZEVkZ2VbdGFyZ2V0SW5kZXhdID0gZWRnZXNbZV07XG4gICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB1bmRpcmVjdGVkIGdyYXBoLCB3ZSBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IHRoZSAncmV2ZXJzZScgZWRnZVxuICAgICAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gY29zdFt0YXJnZXRJbmRleF0gKyB3ZWlnaHQ7XG4gICAgICAgICAgICBpZiAodGVtcCA8IGNvc3Rbc291cmNlSW5kZXhdKSB7XG4gICAgICAgICAgICAgIGNvc3Rbc291cmNlSW5kZXhdID0gdGVtcDtcbiAgICAgICAgICAgICAgcHJlZGVjZXNzb3Jbc291cmNlSW5kZXhdID0gdGFyZ2V0SW5kZXg7XG4gICAgICAgICAgICAgIHByZWRFZGdlW3NvdXJjZUluZGV4XSA9IGVkZ2VzW2VdO1xuICAgICAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWZsYWcpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAgICAgIFxuICAgICAgICAgICAgXG4gICAgICBpZiAoZmxhZykge1xuICAgICAgICAvLyBDaGVjayBmb3IgbmVnYXRpdmUgd2VpZ2h0IGN5Y2xlc1xuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IGVkZ2VzLmxlbmd0aDsgZSsrKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZUluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbZV0uc291cmNlKCkuaWQoKV07XG4gICAgICAgICAgdmFyIHRhcmdldEluZGV4ID0gaWQycG9zaXRpb25bZWRnZXNbZV0udGFyZ2V0KCkuaWQoKV07ICAgIFxuICAgICAgICAgIHZhciB3ZWlnaHQgPSB3ZWlnaHRGbi5hcHBseShlZGdlc1tlXSwgW2VkZ2VzW2VdXSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYgKGNvc3Rbc291cmNlSW5kZXhdICsgd2VpZ2h0IDwgY29zdFt0YXJnZXRJbmRleF0pIHtcbiAgICAgICAgICAgICQkLnV0aWwuZXJyb3IoXCJFcnJvcjogZ3JhcGggY29udGFpbnMgYSBuZWdhdGl2ZSB3ZWlndGggY3ljbGUhXCIpOyBcbiAgICAgICAgICAgIHJldHVybiB7IHBhdGhUbzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICBkaXN0YW5jZVRvOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgIGhhc05lZ2F0aXZlV2VpZ2h0Q3ljbGU6IHRydWV9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSAgICAgXG4gICAgICB9XG5cbiAgICAgIC8vIEJ1aWxkIHJlc3VsdCBvYmplY3QgICAgICAgXG4gICAgICB2YXIgcG9zaXRpb24yaWQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICBwb3NpdGlvbjJpZC5wdXNoKG5vZGVzW2ldLmlkKCkpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBcbiAgICAgIHZhciByZXMgPSB7ICAgICAgIFxuICAgICAgICBkaXN0YW5jZVRvIDogZnVuY3Rpb24odG8pIHtcbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKHRvKSkge1xuICAgICAgICAgICAgLy8gdG8gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgIHZhciB0b0lkID0gKGN5LmZpbHRlcih0bylbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIHRvSWQgPSB0by5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBjb3N0W2lkMnBvc2l0aW9uW3RvSWRdXTtcbiAgICAgICAgfSwgXG5cbiAgICAgICAgcGF0aFRvIDogZnVuY3Rpb24odG8pIHtcblxuICAgICAgICAgIHZhciByZWNvbnN0cnVjdFBhdGhBdXggPSBmdW5jdGlvbihwcmVkZWNlc3NvciwgZnJvbVBvcywgdG9Qb3MsIHBvc2l0aW9uMmlkLCBhY3VtUGF0aCwgcHJlZEVkZ2UpIHtcbiAgICAgICAgICAgIGZvcig7Oyl7XG4gICAgICAgICAgICAgIC8vIEFkZCB0b0lkIHRvIHBhdGhcbiAgICAgICAgICAgICAgYWN1bVBhdGgucHVzaCggY3kuZ2V0RWxlbWVudEJ5SWQocG9zaXRpb24yaWRbdG9Qb3NdKSApO1xuICAgICAgICAgICAgICBhY3VtUGF0aC5wdXNoKCBwcmVkRWRnZVt0b1Bvc10gKTtcblxuICAgICAgICAgICAgICBpZiAoZnJvbVBvcyA9PT0gdG9Qb3MpIHtcbiAgICAgICAgICAgICAgICAvLyByZWFjaGVkIHN0YXJ0aW5nIG5vZGVcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN1bVBhdGg7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBJZiBubyBwYXRoIGV4aXN0cywgZGlzY2FydCBhY3VtdWxhdGVkIHBhdGggYW5kIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgdmFyIHByZWRQb3MgPSBwcmVkZWNlc3Nvclt0b1Bvc107XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlZFBvcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0b1BvcyA9IHByZWRQb3M7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyh0bykpIHtcbiAgICAgICAgICAgIC8vIHRvIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgdG9JZCA9IChjeS5maWx0ZXIodG8pWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyB0byBpcyBhIG5vZGVcbiAgICAgICAgICAgIHZhciB0b0lkID0gdG8uaWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhdGggPSBbXTtcblxuICAgICAgICAgIC8vIFRoaXMgcmV0dXJucyBhIHJldmVyc2VkIHBhdGggXG4gICAgICAgICAgdmFyIHJlcyA9ICByZWNvbnN0cnVjdFBhdGhBdXgocHJlZGVjZXNzb3IsIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQycG9zaXRpb25bc291cmNlLmlkKCldLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQycG9zaXRpb25bdG9JZF0sIFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24yaWQsIFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWRFZGdlKTtcblxuICAgICAgICAgIC8vIEdldCBpdCBpbiB0aGUgY29ycmVjdCBvcmRlciBhbmQgcmV0dXJuIGl0XG4gICAgICAgICAgaWYgKHJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXMucmV2ZXJzZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgcmVzKTsgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9LCBcblxuICAgICAgICBoYXNOZWdhdGl2ZVdlaWdodEN5Y2xlOiBmYWxzZVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHJlcztcblxuICAgIH0sIC8vIGJlbGxtYW5Gb3JkXG5cblxuICAgIC8vIENvbXB1dGVzIHRoZSBtaW5pbXVtIGN1dCBvZiBhbiB1bmRpcmVjdGVkIGdyYXBoXG4gICAgLy8gUmV0dXJucyB0aGUgY29ycmVjdCBhbnN3ZXIgd2l0aCBoaWdoIHByb2JhYmlsaXR5XG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vIFxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgIGN1dCA6IGxpc3Qgb2YgSURzIG9mIGVkZ2VzIGluIHRoZSBjdXQsXG4gICAgLy8gICBwYXJ0aXRpb24xOiBsaXN0IG9mIElEcyBvZiBub2RlcyBpbiBvbmUgcGFydGl0aW9uXG4gICAgLy8gICBwYXJ0aXRpb24yOiBsaXN0IG9mIElEcyBvZiBub2RlcyBpbiB0aGUgb3RoZXIgcGFydGl0aW9uXG4gICAga2FyZ2VyU3RlaW46IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgXG4gICAgICAvLyB2YXIgbG9nRGVidWcgPSBmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgaWYgKGRlYnVnKSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfTtcblxuICAgICAgLy8gRnVuY3Rpb24gd2hpY2ggY29sYXBzZXMgMiAobWV0YSkgbm9kZXMgaW50byBvbmVcbiAgICAgIC8vIFVwZGF0ZXMgdGhlIHJlbWFpbmluZyBlZGdlIGxpc3RzXG4gICAgICAvLyBSZWNlaXZlcyBhcyBhIHBhcmFtYXRlciB0aGUgZWRnZSB3aGljaCBjYXVzZXMgdGhlIGNvbGxhcHNlXG4gICAgICB2YXIgY29sYXBzZSA9IGZ1bmN0aW9uKGVkZ2VJbmRleCwgbm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpIHtcbiAgICAgICAgdmFyIGVkZ2VJbmZvID0gcmVtYWluaW5nRWRnZXNbZWRnZUluZGV4XTtcbiAgICAgICAgdmFyIHNvdXJjZUluID0gZWRnZUluZm9bMV07XG4gICAgICAgIHZhciB0YXJnZXRJbiA9IGVkZ2VJbmZvWzJdO1xuICAgICAgICB2YXIgcGFydGl0aW9uMSA9IG5vZGVNYXBbc291cmNlSW5dO1xuICAgICAgICB2YXIgcGFydGl0aW9uMiA9IG5vZGVNYXBbdGFyZ2V0SW5dO1xuXG4gICAgICAgIC8vIERlbGV0ZSBhbGwgZWRnZXMgYmV0d2VlbiBwYXJ0aXRpb24xIGFuZCBwYXJ0aXRpb24yXG4gICAgICAgIHZhciBuZXdFZGdlcyA9IHJlbWFpbmluZ0VkZ2VzLmZpbHRlcihmdW5jdGlvbihlZGdlKSB7XG4gICAgICAgICAgaWYgKG5vZGVNYXBbZWRnZVsxXV0gPT09IHBhcnRpdGlvbjEgJiYgbm9kZU1hcFtlZGdlWzJdXSA9PT0gcGFydGl0aW9uMikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZU1hcFtlZGdlWzFdXSA9PT0gcGFydGl0aW9uMiAmJiBub2RlTWFwW2VkZ2VbMl1dID09PSBwYXJ0aXRpb24xKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIC8vIEFsbCBlZGdlcyBwb2ludGluZyB0byBwYXJ0aXRpb24yIHNob3VsZCBub3cgcG9pbnQgdG8gcGFydGl0aW9uMVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0VkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBuZXdFZGdlc1tpXTtcbiAgICAgICAgICBpZiAoZWRnZVsxXSA9PT0gcGFydGl0aW9uMikgeyAvLyBDaGVjayBzb3VyY2VcbiAgICAgICAgICAgIG5ld0VkZ2VzW2ldID0gZWRnZS5zbGljZSgwKTtcbiAgICAgICAgICAgIG5ld0VkZ2VzW2ldWzFdID0gcGFydGl0aW9uMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVkZ2VbMl0gPT09IHBhcnRpdGlvbjIpIHsgLy8gQ2hlY2sgdGFyZ2V0XG4gICAgICAgICAgICBuZXdFZGdlc1tpXSA9IGVkZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICBuZXdFZGdlc1tpXVsyXSA9IHBhcnRpdGlvbjE7XG4gICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICBcbiAgICAgICAgLy8gTW92ZSBhbGwgbm9kZXMgZnJvbSBwYXJ0aXRpb24yIHRvIHBhcnRpdGlvbjFcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlTWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5vZGVNYXBbaV0gPT09IHBhcnRpdGlvbjIpIHtcbiAgICAgICAgICAgIG5vZGVNYXBbaV0gPSBwYXJ0aXRpb24xO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5ld0VkZ2VzO1xuICAgICAgfTtcblxuXG4gICAgICAvLyBDb250cmFjdHMgYSBncmFwaCB1bnRpbCB3ZSByZWFjaCBhIGNlcnRhaW4gbnVtYmVyIG9mIG1ldGEgbm9kZXNcbiAgICAgIHZhciBjb250cmFjdFVudGlsID0gZnVuY3Rpb24obWV0YU5vZGVNYXAsIFxuICAgICAgICAgICAgICAgICAgICAgcmVtYWluaW5nRWRnZXMsXG4gICAgICAgICAgICAgICAgICAgICBzaXplLCBcbiAgICAgICAgICAgICAgICAgICAgIHNpemVMaW1pdCkge1xuICAgICAgICAvLyBTdG9wIGNvbmRpdGlvblxuICAgICAgICBpZiAoc2l6ZSA8PSBzaXplTGltaXQpIHtcbiAgICAgICAgICByZXR1cm4gcmVtYWluaW5nRWRnZXM7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIENob29zZSBhbiBlZGdlIHJhbmRvbWx5XG4gICAgICAgIHZhciBlZGdlSW5kZXggPSBNYXRoLmZsb29yKChNYXRoLnJhbmRvbSgpICogcmVtYWluaW5nRWRnZXMubGVuZ3RoKSk7XG5cbiAgICAgICAgLy8gQ29sYXBzZSBncmFwaCBiYXNlZCBvbiBlZGdlXG4gICAgICAgIHZhciBuZXdFZGdlcyA9IGNvbGFwc2UoZWRnZUluZGV4LCBtZXRhTm9kZU1hcCwgcmVtYWluaW5nRWRnZXMpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAsIFxuICAgICAgICAgICAgICAgICAgIG5ld0VkZ2VzLCBcbiAgICAgICAgICAgICAgICAgICBzaXplIC0gMSwgXG4gICAgICAgICAgICAgICAgICAgc2l6ZUxpbWl0KTsgICAgICAgIFxuICAgICAgfTtcblxuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG4gICAgICAvLyBsb2dEZWJ1ZyhcIlN0YXJ0aW5nIGthcmdlclN0ZWluLi4uXCIpOyBcblxuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBlZGdlcyA9IHRoaXMuZWRnZXMoKS5zdGRGaWx0ZXIoZnVuY3Rpb24oZSl7IHJldHVybiAhZS5pc0xvb3AoKTsgfSk7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgbnVtRWRnZXMgPSBlZGdlcy5sZW5ndGg7XG4gICAgICB2YXIgbnVtSXRlciA9IE1hdGguY2VpbChNYXRoLnBvdyhNYXRoLmxvZyhudW1Ob2RlcykgLyBNYXRoLkxOMiwgMikpO1xuICAgICAgdmFyIHN0b3BTaXplID0gTWF0aC5mbG9vcihudW1Ob2RlcyAvIE1hdGguc3FydCgyKSk7XG5cbiAgICAgIGlmIChudW1Ob2RlcyA8IDIpIHtcbiAgICAgICAgJCQudXRpbC5lcnJvcihcIkF0IGxlYXN0IDIgbm9kZXMgYXJlIHJlcXVpcmVkIGZvciBLYXJnZXJTdGVpbmcgYWxnb3JpdGhtIVwiKTsgXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBudW1lcmljYWwgaWRlbnRpZmllcnMgZm9yIGVhY2ggbm9kZVxuICAgICAgLy8gbWFwcGluZzogbm9kZSBpZCAtPiBwb3NpdGlvbiBpbiBub2RlcyBhcnJheVxuICAgICAgLy8gZm9yIHJldmVyc2UgbWFwcGluZywgc2ltcGx5IHVzZSBub2RlcyBhcnJheVxuICAgICAgdmFyIGlkMnBvc2l0aW9uID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgaWQycG9zaXRpb25bbm9kZXNbaV0uaWQoKV0gPSBpO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3cgc3RvcmUgZWRnZSBkZXN0aW5hdGlvbiBhcyBpbmRleGVzXG4gICAgICAvLyBGb3JtYXQgZm9yIGVhY2ggZWRnZSAoZWRnZSBpbmRleCwgc291cmNlIG5vZGUgaW5kZXgsIHRhcmdldCBub2RlIGluZGV4KVxuICAgICAgdmFyIGVkZ2VJbmRleGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bUVkZ2VzOyBpKyspIHtcbiAgICAgICAgdmFyIGUgPSBlZGdlc1tpXTtcbiAgICAgICAgZWRnZUluZGV4ZXMucHVzaChbaSwgaWQycG9zaXRpb25bZS5zb3VyY2UoKS5pZCgpXSwgaWQycG9zaXRpb25bZS50YXJnZXQoKS5pZCgpXV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBXZSB3aWxsIHN0b3JlIHRoZSBiZXN0IGN1dCBmb3VuZCBoZXJlXG4gICAgICB2YXIgbWluQ3V0U2l6ZSA9IEluZmluaXR5O1xuICAgICAgdmFyIG1pbkN1dDsgICAgIFxuXG4gICAgICAvLyBJbml0aWFsIG1ldGEgbm9kZSBwYXJ0aXRpb25cbiAgICAgIHZhciBvcmlnaW5hbE1ldGFOb2RlID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgb3JpZ2luYWxNZXRhTm9kZS5wdXNoKGkpO1xuICAgICAgfVxuXG4gICAgICAvLyBNYWluIGxvb3BcbiAgICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDw9IG51bUl0ZXI7IGl0ZXIrKykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IG1ldGEgbm9kZSBwYXJ0aXRpb25cbiAgICAgICAgdmFyIG1ldGFOb2RlTWFwID0gb3JpZ2luYWxNZXRhTm9kZS5zbGljZSgwKTtcblxuICAgICAgICAvLyBDb250cmFjdCB1bnRpbCBzdG9wIHBvaW50IChzdG9wU2l6ZSBub2RlcylcbiAgICAgICAgdmFyIGVkZ2VzU3RhdGUgPSBjb250cmFjdFVudGlsKG1ldGFOb2RlTWFwLCBlZGdlSW5kZXhlcywgbnVtTm9kZXMsIHN0b3BTaXplKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIGNvbGFwc2VkIG5vZGVzIHN0YXRlXG4gICAgICAgIHZhciBtZXRhTm9kZU1hcDIgPSBtZXRhTm9kZU1hcC5zbGljZSgwKTtcblxuICAgICAgICAvLyBSdW4gMiBpdGVyYXRpb25zIHN0YXJ0aW5nIGluIHRoZSBzdG9wIHN0YXRlXG4gICAgICAgIHZhciByZXMxID0gY29udHJhY3RVbnRpbChtZXRhTm9kZU1hcCwgZWRnZXNTdGF0ZSwgc3RvcFNpemUsIDIpO1xuICAgICAgICB2YXIgcmVzMiA9IGNvbnRyYWN0VW50aWwobWV0YU5vZGVNYXAyLCBlZGdlc1N0YXRlLCBzdG9wU2l6ZSwgMik7XG5cbiAgICAgICAgLy8gSXMgYW55IG9mIHRoZSAyIHJlc3VsdHMgdGhlIGJlc3QgY3V0IHNvIGZhcj9cbiAgICAgICAgaWYgKHJlczEubGVuZ3RoIDw9IHJlczIubGVuZ3RoICYmIHJlczEubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICAgIG1pbkN1dFNpemUgPSByZXMxLmxlbmd0aDtcbiAgICAgICAgICBtaW5DdXQgPSBbcmVzMSwgbWV0YU5vZGVNYXBdO1xuICAgICAgICB9IGVsc2UgaWYgKHJlczIubGVuZ3RoIDw9IHJlczEubGVuZ3RoICYmIHJlczIubGVuZ3RoIDwgbWluQ3V0U2l6ZSkge1xuICAgICAgICAgIG1pbkN1dFNpemUgPSByZXMyLmxlbmd0aDtcbiAgICAgICAgICBtaW5DdXQgPSBbcmVzMiwgbWV0YU5vZGVNYXAyXTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBlbmQgb2YgbWFpbiBsb29wXG5cbiAgICAgIFxuICAgICAgLy8gQ29uc3RydWN0IHJlc3VsdFxuICAgICAgdmFyIHJlc0VkZ2VzID0gKG1pbkN1dFswXSkubWFwKGZ1bmN0aW9uKGUpeyByZXR1cm4gZWRnZXNbZVswXV07IH0pO1xuICAgICAgdmFyIHBhcnRpdGlvbjEgPSBbXTtcbiAgICAgIHZhciBwYXJ0aXRpb24yID0gW107XG5cbiAgICAgIC8vIHRyYXZlcnNlIG1ldGFOb2RlTWFwIGZvciBiZXN0IGN1dFxuICAgICAgdmFyIHdpdG5lc3NOb2RlUGFydGl0aW9uID0gbWluQ3V0WzFdWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DdXRbMV0ubGVuZ3RoOyBpKyspIHsgXG4gICAgICAgIHZhciBwYXJ0aXRpb25JZCA9IG1pbkN1dFsxXVtpXTsgXG4gICAgICAgIGlmIChwYXJ0aXRpb25JZCA9PT0gd2l0bmVzc05vZGVQYXJ0aXRpb24pIHtcbiAgICAgICAgICBwYXJ0aXRpb24xLnB1c2gobm9kZXNbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhcnRpdGlvbjIucHVzaChub2Rlc1tpXSk7XG4gICAgICAgIH0gICAgICAgXG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciByZXQgPSB7XG4gICAgICAgIGN1dDogbmV3ICQkLkNvbGxlY3Rpb24oY3ksIHJlc0VkZ2VzKSxcbiAgICAgICAgcGFydGl0aW9uMTogbmV3ICQkLkNvbGxlY3Rpb24oY3ksIHBhcnRpdGlvbjEpLFxuICAgICAgICBwYXJ0aXRpb24yOiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgcGFydGl0aW9uMilcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuXG4gICAgLy8gXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgZGFtcGluZ0ZhY3Rvcjogb3B0aW9uYWxcbiAgICAvLyAgIHByZWNpc2lvbjogb3B0aW9uYWxcbiAgICAvLyAgIGl0ZXJhdGlvbnMgOiBvcHRpb25hbFxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgcmFuayA6IGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcGFnZVJhbmsgb2YgYSBnaXZlbiBub2RlIChvYmplY3Qgb3Igc2VsZWN0b3Igc3RyaW5nKVxuICAgIHBhZ2VSYW5rOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIFxuICAgICAgdmFyIG5vcm1hbGl6ZVZlY3RvciA9IGZ1bmN0aW9uKHZlY3Rvcikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdmVjdG9yLmxlbmd0aDtcblxuICAgICAgICAvLyBGaXJzdCwgZ2V0IHN1bSBvZiBhbGwgZWxlbWVudHNcbiAgICAgICAgdmFyIHRvdGFsID0gMDsgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0b3RhbCArPSB2ZWN0b3JbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb3csIGRpdmlkZSBlYWNoIGJ5IHRoZSBzdW0gb2YgYWxsIGVsZW1lbnRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2ZWN0b3JbaV0gPSB2ZWN0b3JbaV0gLyB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIGlmIChkZWJ1Zykge1xuICAgICAgLy8gICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH07XG4gICAgICBcbiAgICAgIC8vIFBhcnNlIG9wdGlvbnNcbiAgICAgIC8vIGRlYnVnIC0gb3B0aW9uYWxcbiAgICAgIC8vIGlmIChvcHRpb25zICE9IG51bGwgJiYgXG4gICAgICAvLyAgIG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG4gICAgICAvLyBsb2dEZWJ1ZyhcIlN0YXJ0aW5nIHBhZ2VSYW5rLi4uXCIpOyBcblxuICAgICAgLy8gZGFtcGluZ0ZhY3RvciAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIFxuICAgICAgICBvcHRpb25zLmRhbXBpbmdmYWN0b3IgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZGFtcGluZ0ZhY3RvciA9IG9wdGlvbnMuZGFtcGluZ0ZhY3RvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBkYW1waW5nRmFjdG9yID0gMC44OyAvLyBEZWZhdWx0IGRhbXBpbmcgZmFjdG9yXG4gICAgICB9XG5cbiAgICAgIC8vIGRlc2lyZWQgcHJlY2lzaW9uIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zICE9IG51bGwgJiYgXG4gICAgICAgIG9wdGlvbnMucHJlY2lzaW9uICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGVwc2lsb24gPSBvcHRpb25zLnByZWNpc2lvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlcHNpbG9uID0gMC4wMDAwMDE7IC8vIERlZmF1bHQgcHJlY2lzaW9uXG4gICAgICB9XG5cbiAgICAgIC8vIE1heCBudW1iZXIgb2YgaXRlcmF0aW9ucyAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIFxuICAgICAgICBvcHRpb25zLml0ZXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbnVtSXRlciA9IG9wdGlvbnMuaXRlcmF0aW9ucztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBudW1JdGVyID0gMjAwOyAvLyBEZWZhdWx0IG51bWJlciBvZiBpdGVyYXRpb25zXG4gICAgICB9XG5cbiAgICAgIC8vIFdlaWdodCBmdW5jdGlvbiAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIFxuICAgICAgICBvcHRpb25zLndlaWdodCAhPSBudWxsICYmIFxuICAgICAgICAkJC5pcy5mbihvcHRpb25zLndlaWdodCkpIHsgICAgICAgXG4gICAgICAgIHZhciB3ZWlnaHRGbiA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm90IHNwZWNpZmllZCwgYXNzdW1lIGVhY2ggZWRnZSBoYXMgZXF1YWwgd2VpZ2h0ICgxKVxuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBmdW5jdGlvbihlKSB7cmV0dXJuIDE7fTsgXG4gICAgICB9XG5cbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgZWRnZXMgPSB0aGlzLmVkZ2VzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKGUpeyByZXR1cm4gIWUuaXNMb29wKCk7IH0pO1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIG51bU5vZGVzID0gbm9kZXMubGVuZ3RoO1xuICAgICAgdmFyIG51bUVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuXG4gICAgICAvLyBDcmVhdGUgbnVtZXJpY2FsIGlkZW50aWZpZXJzIGZvciBlYWNoIG5vZGVcbiAgICAgIC8vIG1hcHBpbmc6IG5vZGUgaWQgLT4gcG9zaXRpb24gaW4gbm9kZXMgYXJyYXlcbiAgICAgIC8vIGZvciByZXZlcnNlIG1hcHBpbmcsIHNpbXBseSB1c2Ugbm9kZXMgYXJyYXlcbiAgICAgIHZhciBpZDJwb3NpdGlvbiA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGlkMnBvc2l0aW9uW25vZGVzW2ldLmlkKCldID0gaTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29uc3RydWN0IHRyYW5zcG9zZWQgYWRqYWNlbmN5IG1hdHJpeFxuICAgICAgLy8gRmlyc3QgbGV0cyBoYXZlIGEgemVyb2VkIG1hdHJpeCBvZiB0aGUgcmlnaHQgc2l6ZVxuICAgICAgLy8gV2UnbGwgYWxzbyBrZWVwIHRyYWNrIG9mIHRoZSBzdW0gb2YgZWFjaCBjb2x1bW5cbiAgICAgIHZhciBtYXRyaXggPSBbXTtcbiAgICAgIHZhciBjb2x1bW5TdW0gPSBbXTtcbiAgICAgIHZhciBhZGRpdGlvbmFsUHJvYiA9ICgxIC0gZGFtcGluZ0ZhY3RvcikgLyBudW1Ob2RlcztcblxuICAgICAgLy8gQ3JlYXRlIG51bGwgbWF0cmljXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHsgXG4gICAgICAgIHZhciBuZXdSb3cgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICAgICAgbmV3Um93LnB1c2goMC4wKTtcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXgucHVzaChuZXdSb3cpO1xuICAgICAgICBjb2x1bW5TdW0ucHVzaCgwLjApO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3csIHByb2Nlc3MgZWRnZXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRWRnZXM7IGkrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICB2YXIgcyA9IGlkMnBvc2l0aW9uW2VkZ2Uuc291cmNlKCkuaWQoKV07XG4gICAgICAgIHZhciB0ID0gaWQycG9zaXRpb25bZWRnZS50YXJnZXQoKS5pZCgpXTtcbiAgICAgICAgdmFyIHcgPSB3ZWlnaHRGbi5hcHBseShlZGdlLCBbZWRnZV0pO1xuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIG1hdHJpeFxuICAgICAgICBtYXRyaXhbdF1bc10gKz0gdztcblxuICAgICAgICAvLyBVcGRhdGUgY29sdW1uIHN1bVxuICAgICAgICBjb2x1bW5TdW1bc10gKz0gdzsgXG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBhZGRpdGlvbmFsIHByb2JhYmlsaXR5IGJhc2VkIG9uIGRhbXBpbmcgZmFjdG9yXG4gICAgICAvLyBBbHNvLCB0YWtlIGludG8gYWNjb3VudCBjb2x1bW5zIHRoYXQgaGF2ZSBzdW0gPSAwXG4gICAgICB2YXIgcCA9IDEuMCAvIG51bU5vZGVzICsgYWRkaXRpb25hbFByb2I7IC8vIFNob3J0aGFuZFxuICAgICAgLy8gVHJhdmVyc2UgbWF0cml4LCBjb2x1bW4gYnkgY29sdW1uXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHsgXG4gICAgICAgIGlmIChjb2x1bW5TdW1bal0gPT09IDApIHtcbiAgICAgICAgICAvLyBObyAnbGlua3MnIG91dCBmcm9tIG5vZGUganRoLCBhc3N1bWUgZXF1YWwgcHJvYmFiaWxpdHkgZm9yIGVhY2ggcG9zc2libGUgbm9kZVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm9kZSBqdGggaGFzIG91dGdvaW5nIGxpbmssIGNvbXB1dGUgbm9ybWFsaXplZCBwcm9iYWJpbGl0aWVzXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtYXRyaXhbaV1bal0gLyBjb2x1bW5TdW1bal0gKyBhZGRpdGlvbmFsUHJvYjtcbiAgICAgICAgICB9ICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ29tcHV0ZSBkb21pbmFudCBlaWdlbnZlY3RvciB1c2luZyBwb3dlciBtZXRob2RcbiAgICAgIHZhciBlaWdlbnZlY3RvciA9IFtdO1xuICAgICAgdmFyIG51bGxWZWN0b3IgPSBbXTtcbiAgICAgIHZhciBwcmV2aW91cztcblxuICAgICAgLy8gU3RhcnQgd2l0aCBhIHZlY3RvciBvZiBhbGwgMSdzXG4gICAgICAvLyBBbHNvLCBpbml0aWFsaXplIGEgbnVsbCB2ZWN0b3Igd2hpY2ggd2lsbCBiZSB1c2VkIGFzIHNob3J0aGFuZFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgIGVpZ2VudmVjdG9yLnB1c2goMS4wKTtcbiAgICAgICAgbnVsbFZlY3Rvci5wdXNoKDAuMCk7XG4gICAgICB9XG4gICAgICAgICAgICBcbiAgICAgIGZvciAodmFyIGl0ZXIgPSAwOyBpdGVyIDwgbnVtSXRlcjsgaXRlcisrKSB7XG4gICAgICAgIC8vIE5ldyBhcnJheSB3aXRoIGFsbCAwJ3NcbiAgICAgICAgdmFyIHRlbXAgPSBudWxsVmVjdG9yLnNsaWNlKDApO1xuICAgICAgICBcbiAgICAgICAgLy8gTXVsdGlwbHkgbWF0cml4IHdpdGggcHJldmlvdXMgcmVzdWx0XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtTm9kZXM7IGorKykgeyAgICAgICAgXG4gICAgICAgICAgICB0ZW1wW2ldICs9IG1hdHJpeFtpXVtqXSAqIGVpZ2VudmVjdG9yW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5vcm1hbGl6ZVZlY3Rvcih0ZW1wKTtcbiAgICAgICAgcHJldmlvdXMgPSBlaWdlbnZlY3RvcjtcbiAgICAgICAgZWlnZW52ZWN0b3IgPSB0ZW1wO1xuXG4gICAgICAgIHZhciBkaWZmID0gMDtcbiAgICAgICAgLy8gQ29tcHV0ZSBkaWZmZXJlbmNlIChzcXVhcmVkIG1vZHVsZSkgb2YgYm90aCB2ZWN0b3JzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTm9kZXM7IGkrKykge1xuICAgICAgICAgIGRpZmYgKz0gTWF0aC5wb3cocHJldmlvdXNbaV0gLSBlaWdlbnZlY3RvcltpXSwgMik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIElmIGRpZmZlcmVuY2UgaXMgbGVzcyB0aGFuIHRoZSBkZXNpcmVkIHRocmVzaG9sZCwgc3RvcCBpdGVyYXRpbmdcbiAgICAgICAgaWYgKGRpZmYgPCBlcHNpbG9uKSB7XG4gICAgICAgICAgLy8gbG9nRGVidWcoXCJTdG9wZWQgYXQgaXRlcmF0aW9uICVzXCIsIGl0ZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAgICAgICBcbiAgICAgIC8vIGxvZ0RlYnVnKFwiUmVzdWx0OlxcblwiICsgZWlnZW52ZWN0b3IpO1xuXG4gICAgICAvLyBDb25zdHJ1Y3QgcmVzdWx0XG4gICAgICB2YXIgcmVzID0ge1xuICAgICAgICByYW5rIDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgIC8vIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICB2YXIgbm9kZUlkID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXMgYSBub2RlIG9iamVjdFxuICAgICAgICAgICAgdmFyIG5vZGVJZCA9IG5vZGUuaWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGVpZ2VudmVjdG9yW2lkMnBvc2l0aW9uW25vZGVJZF1dO1xuICAgICAgICB9XG4gICAgICB9O1xuXG5cbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwgLy8gcGFnZVJhbmtcblxuXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGRpcmVjdGVkIC8vIGRlZmF1bHQgZmFsc2VcbiAgICAvLyByZXRPYmogPT4gcmV0dXJuZWQgb2JqZWN0IGJ5IGZ1bmN0aW9uXG4gICAgLy8gaWYgZGlyZWN0ZWRcbiAgICAvLyAgIGluZGVncmVlIDogZnVuY3Rpb24obm9kZSkgLy8gUmV0dXJucyB0aGUgbm9ybWFsaXplZCBpbmRlZ3JlZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vICAgb3V0ZGVncmVlOiBmdW5jdGlvbihub2RlKSAvLyBSZXR1cm5zIHRoZSBub3JtYWxpemVkIG91dGRlZ3JlZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vIGlmIHVuZGlyZWN0ZWRcbiAgICAvLyAgIGRlZ3JlZSA6IGZ1bmN0aW9uKG5vZGUpIC8vIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgZGVncmVlIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgZGVncmVlIGNlbnRyYWxpdHkuLi5cIik7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgbnVtTm9kZXMgPSBub2Rlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgdmFyIGRlZ3JlZXMgPSB7fTtcbiAgICAgICAgdmFyIG1heERlZ3JlZSA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Ob2RlczsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAvLyBhZGQgY3VycmVudCBub2RlIHRvIHRoZSBjdXJyZW50IG9wdGlvbnMgb2JqZWN0IGFuZCBjYWxsIGRlZ3JlZUNlbnRyYWxpdHkgXG4gICAgICAgICAgdmFyIGN1cnJEZWdyZWUgPSB0aGlzLmRlZ3JlZUNlbnRyYWxpdHkoJCQudXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtyb290OiBub2RlfSkpO1xuICAgICAgICAgIGlmIChtYXhEZWdyZWUgPCBjdXJyRGVncmVlLmRlZ3JlZSlcbiAgICAgICAgICAgIG1heERlZ3JlZSA9IGN1cnJEZWdyZWUuZGVncmVlO1xuXG4gICAgICAgICAgZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5kZWdyZWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRlZ3JlZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIGlmICgkJC5pcy5zdHJpbmcobm9kZSkpIHtcbiAgICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgICB2YXIgbm9kZSA9IG5vZGUuaWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGRlZ3JlZXNbbm9kZV0gLyBtYXhEZWdyZWU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGluZGVncmVlcyA9IHt9O1xuICAgICAgICB2YXIgb3V0ZGVncmVlcyA9IHt9O1xuICAgICAgICB2YXIgbWF4SW5kZWdyZWUgPSAwO1xuICAgICAgICB2YXIgbWF4T3V0ZGVncmVlID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bU5vZGVzOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIC8vIGFkZCBjdXJyZW50IG5vZGUgdG8gdGhlIGN1cnJlbnQgb3B0aW9ucyBvYmplY3QgYW5kIGNhbGwgZGVncmVlQ2VudHJhbGl0eSBcbiAgICAgICAgICB2YXIgY3VyckRlZ3JlZSA9IHRoaXMuZGVncmVlQ2VudHJhbGl0eSgkJC51dGlsLmV4dGVuZCh7fSwgb3B0aW9ucywge3Jvb3Q6IG5vZGV9KSk7XG5cbiAgICAgICAgICBpZiAobWF4SW5kZWdyZWUgPCBjdXJyRGVncmVlLmluZGVncmVlKVxuICAgICAgICAgICAgbWF4SW5kZWdyZWUgPSBjdXJyRGVncmVlLmluZGVncmVlO1xuXG4gICAgICAgICAgaWYgKG1heE91dGRlZ3JlZSA8IGN1cnJEZWdyZWUub3V0ZGVncmVlKVxuICAgICAgICAgICAgbWF4T3V0ZGVncmVlID0gY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG5cbiAgICAgICAgICBpbmRlZ3JlZXNbbm9kZS5pZCgpXSA9IGN1cnJEZWdyZWUuaW5kZWdyZWU7XG4gICAgICAgICAgb3V0ZGVncmVlc1tub2RlLmlkKCldID0gY3VyckRlZ3JlZS5vdXRkZWdyZWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGluZGVncmVlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgICAvLyBmcm9tIGlzIGEgc2VsZWN0b3Igc3RyaW5nXG4gICAgICAgICAgICAgIHZhciBub2RlID0gKGN5LmZpbHRlcihub2RlKVswXSkuaWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGZyb20gaXMgYSBub2RlXG4gICAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW5kZWdyZWVzW25vZGVdIC8gbWF4SW5kZWdyZWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBvdXRkZWdyZWU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICAgIC8vIGZyb20gaXMgYSBzZWxlY3RvciBzdHJpbmdcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSAoY3kuZmlsdGVyKG5vZGUpWzBdKS5pZCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gZnJvbSBpcyBhIG5vZGVcbiAgICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvdXRkZWdyZWVzW25vZGVdIC8gbWF4T3V0ZGVncmVlO1xuICAgICAgICAgIH1cblxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgfSwgLy8gZGVncmVlQ2VudHJhbGl0eU5vcm1hbGl6ZWRcblxuICAgIC8vIEltcGxlbWVudGVkIGZyb20gdGhlIGFsZ29yaXRobSBpbiBPcHNhaGwncyBwYXBlciBcIk5vZGUgY2VudHJhbGl0eSBpbiB3ZWlnaHRlZCBuZXR3b3JrczogR2VuZXJhbGl6aW5nIGRlZ3JlZSBhbmQgc2hvcnRlc3QgcGF0aHNcIiBjaGVjayB0aGUgaGVhZGluZyAyIFwiRGVncmVlXCJcbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gICBub2RlIDogZm9jYWwgbm9kZVxuICAgIC8vICAgd2VpZ2h0OiBmdW5jdGlvbiggZWRnZSApe30gLy8gc3BlY2lmaWVzIHdlaWdodCB0byB1c2UgZm9yIGBlZGdlYC9gdGhpc2AuIElmIG5vdCBwcmVzZW50LCBpdCB3aWxsIGJlIGFzdW1lZCBhIHdlaWdodCBvZiAxIGZvciBhbGwgZWRnZXNcbiAgICAvLyAgIGFscGhhIDogYWxwaGEgdmFsdWUgZm9yIHRoZSBhbGdvcml0aG0gKEJlbmNobWFyayB2YWx1ZXMgb2YgYWxwaGE6IDAgLT4gZGlzcmVnYXJkcyB0aGUgd2VpZ2h0cyBmb2N1c2VzIG9uIG51bWJlciBvZiBlZGdlc1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMSAtPiBkaXNyZWdhcmRzIHRoZSBudW1iZXIgb2YgZWRnZXMgZm9jdXNlcyBvbiB0b3RhbCBhbW91bnQgb2Ygd2VpZ2h0IFxuICAgIC8vICAgZGlyZWN0ZWQgLy8gZGVmYXVsdCBmYWxzZVxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyBpZiBkaXJlY3RlZFxuICAgIC8vICAgaW5kZWdyZWUgOiBpbmRlZ3JlZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vICAgb3V0ZGVncmVlOiBvdXRkZWdyZWUgb2YgdGhlIGdpdmVuIG5vZGVcbiAgICAvLyBpZiB1bmRpcmVjdGVkXG4gICAgLy8gICBkZWdyZWUgOiBkZWdyZWUgb2YgdGhlIGdpdmVuIG5vZGVcbiAgICBkZWdyZWVDZW50cmFsaXR5OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHZhciBjYWxsaW5nRWxlcyA9IHRoaXM7XG5cbiAgICAgIC8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vICAgaWYgKGRlYnVnKSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfTtcblxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgLy8gaWYgKG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgZGVncmVlIGNlbnRyYWxpdHkuLi5cIik7XG5cbiAgICAgIC8vIHJvb3QgLSBtYW5kYXRvcnkhXG4gICAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMucm9vdCAhPSBudWxsKSB7XG4gICAgICAgIHZhciByb290ID0gJCQuaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkgPyB0aGlzLmZpbHRlcihvcHRpb25zLnJvb3QpWzBdIDogb3B0aW9ucy5yb290WzBdO1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlNvdXJjZSBub2RlOiAlc1wiLCByb290LmlkKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gd2VpZ2h0IC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmICQkLmlzLmZuKG9wdGlvbnMud2VpZ2h0KSkge1xuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIG5vdCBzcGVjaWZpZWQsIGFzc3VtZSBlYWNoIGVkZ2UgaGFzIGVxdWFsIHdlaWdodCAoMSlcbiAgICAgICAgdmFyIHdlaWdodEZuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIGFscGhhIC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLmFscGhhICE9IG51bGwgJiYgJCQuaXMubnVtYmVyKG9wdGlvbnMuYWxwaGEpKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IG9wdGlvbnMuYWxwaGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbHBoYSA9IDA7XG4gICAgICB9XG5cblxuICAgICAgaWYgKCFkaXJlY3RlZCkge1xuICAgICAgICB2YXIgY29ubkVkZ2VzID0gcm9vdC5jb25uZWN0ZWRFZGdlcygpLmludGVyc2VjdGlvbiggY2FsbGluZ0VsZXMgKTtcbiAgICAgICAgdmFyIGsgPSBjb25uRWRnZXMubGVuZ3RoO1xuICAgICAgICB2YXIgcyA9IDA7XG5cbiAgICAgICAgLy8gTm93LCBzdW0gZWRnZSB3ZWlnaHRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ubkVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBjb25uRWRnZXNbaV07XG4gICAgICAgICAgcyArPSB3ZWlnaHRGbi5hcHBseShlZGdlLCBbZWRnZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkZWdyZWU6IE1hdGgucG93KGssIDEgLSBhbHBoYSkgKiBNYXRoLnBvdyhzLCBhbHBoYSlcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpbmNvbWluZyA9IHJvb3QuY29ubmVjdGVkRWRnZXMoJ2VkZ2VbdGFyZ2V0ID0gXCInICsgcm9vdC5pZCgpICsgJ1wiXScpLmludGVyc2VjdGlvbiggY2FsbGluZ0VsZXMgKTtcbiAgICAgICAgdmFyIG91dGdvaW5nID0gcm9vdC5jb25uZWN0ZWRFZGdlcygnZWRnZVtzb3VyY2UgPSBcIicgKyByb290LmlkKCkgKyAnXCJdJykuaW50ZXJzZWN0aW9uKCBjYWxsaW5nRWxlcyApO1xuICAgICAgICB2YXIga19pbiA9IGluY29taW5nLmxlbmd0aDtcbiAgICAgICAgdmFyIGtfb3V0ID0gb3V0Z29pbmcubGVuZ3RoO1xuICAgICAgICB2YXIgc19pbiA9IDA7XG4gICAgICAgIHZhciBzX291dCA9IDA7XG5cbiAgICAgICAgLy8gTm93LCBzdW0gaW5jb21pbmcgZWRnZSB3ZWlnaHRzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jb21pbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGluY29taW5nW2ldO1xuICAgICAgICAgIHNfaW4gKz0gd2VpZ2h0Rm4uYXBwbHkoZWRnZSwgW2VkZ2VdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5vdywgc3VtIG91dGdvaW5nIGVkZ2Ugd2VpZ2h0c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dGdvaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBvdXRnb2luZ1tpXTtcbiAgICAgICAgICBzX291dCArPSB3ZWlnaHRGbi5hcHBseShlZGdlLCBbZWRnZV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpbmRlZ3JlZTogTWF0aC5wb3coa19pbiwgMSAtIGFscGhhKSAqIE1hdGgucG93KHNfaW4sIGFscGhhKSxcbiAgICAgICAgICBvdXRkZWdyZWU6IE1hdGgucG93KGtfb3V0LCAxIC0gYWxwaGEpICogTWF0aC5wb3coc19vdXQsIGFscGhhKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIC8vIGRlZ3JlZUNlbnRyYWxpdHlcblxuICAgIC8vIG9wdGlvbnMgPT4gb3B0aW9ucyBvYmplY3RcbiAgICAvLyAgIHdlaWdodDogZnVuY3Rpb24oIGVkZ2UgKXt9IC8vIHNwZWNpZmllcyB3ZWlnaHQgdG8gdXNlIGZvciBgZWRnZWAvYHRoaXNgLiBJZiBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSBhc3VtZWQgYSB3ZWlnaHQgb2YgMSBmb3IgYWxsIGVkZ2VzXG4gICAgLy8gICBkaXJlY3RlZCAvLyBkZWZhdWx0IGZhbHNlXG4gICAgLy8gICBoYXJtb25pYyAvLyB1c2UgaGFybW9uaWMgbWVhbiBpbnN0ZWFkIG9mIGFyaXRobWV0aWMgbWVhblxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgIGNsb3NlbmVzcyA6IGZ1bmN0aW9uKG5vZGUpIC8vIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgY2xvc2VuZXNzIG9mIHRoZSBnaXZlbiBub2RlXG4gICAgY2xvc2VuZXNzQ2VudHJhbGl0eU5vcm1hbGl6ZWQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gbG9nRGVidWcoXCJTdGFydGluZyBjbG9zZW5lc3MgY2VudHJhbGl0eS4uLlwiKTtcblxuICAgICAgdmFyIGhhcm1vbmljID0gb3B0aW9ucy5oYXJtb25pYztcbiAgICAgIGlmKCBoYXJtb25pYyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIGhhcm1vbmljID0gdHJ1ZTtcbiAgICAgIH1cbiBcbiAgICAgIHZhciBjbG9zZW5lc3NlcyA9IHt9O1xuICAgICAgdmFyIG1heENsb3NlbmVzcyA9IDA7XG4gICAgICB2YXIgbm9kZXMgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgZncgPSB0aGlzLmZsb3lkV2Fyc2hhbGwoeyB3ZWlnaHQ6IG9wdGlvbnMud2VpZ2h0LCBkaXJlY3RlZDogb3B0aW9ucy5kaXJlY3RlZCB9KTtcblxuICAgICAgLy8gQ29tcHV0ZSBjbG9zZW5lc3MgZm9yIGV2ZXJ5IG5vZGUgYW5kIGZpbmQgdGhlIG1heGltdW0gY2xvc2VuZXNzXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICB2YXIgY3VyckNsb3NlbmVzcyA9IDA7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBpZiAoaSAhPSBqKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGZ3LmRpc3RhbmNlKG5vZGVzW2ldLCBub2Rlc1tqXSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBoYXJtb25pYyApe1xuICAgICAgICAgICAgICBjdXJyQ2xvc2VuZXNzICs9IDEgLyBkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VyckNsb3NlbmVzcyArPSBkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoICFoYXJtb25pYyApe1xuICAgICAgICAgIGN1cnJDbG9zZW5lc3MgPSAxIC8gY3VyckNsb3NlbmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXhDbG9zZW5lc3MgPCBjdXJyQ2xvc2VuZXNzKXtcbiAgICAgICAgICBtYXhDbG9zZW5lc3MgPSBjdXJyQ2xvc2VuZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xvc2VuZXNzZXNbbm9kZXNbaV0uaWQoKV0gPSBjdXJyQ2xvc2VuZXNzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjbG9zZW5lc3M6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgaWYgKCQkLmlzLnN0cmluZyhub2RlKSkge1xuICAgICAgICAgICAgLy8gZnJvbSBpcyBhIHNlbGVjdG9yIHN0cmluZ1xuICAgICAgICAgICAgdmFyIG5vZGUgPSAoY3kuZmlsdGVyKG5vZGUpWzBdKS5pZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBmcm9tIGlzIGEgbm9kZVxuICAgICAgICAgICAgdmFyIG5vZGUgPSBub2RlLmlkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGNsb3NlbmVzc2VzW25vZGVdIC8gbWF4Q2xvc2VuZXNzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSBwc2V1ZG9jb2RlIGZyb20gd2lraXBlZGlhXG4gICAgLy8gb3B0aW9ucyA9PiBvcHRpb25zIG9iamVjdFxuICAgIC8vICAgcm9vdCA6IGZvY2FsIG5vZGVcbiAgICAvLyAgIHdlaWdodDogZnVuY3Rpb24oIGVkZ2UgKXt9IC8vIHNwZWNpZmllcyB3ZWlnaHQgdG8gdXNlIGZvciBgZWRnZWAvYHRoaXNgLiBJZiBub3QgcHJlc2VudCwgaXQgd2lsbCBiZSBhc3VtZWQgYSB3ZWlnaHQgb2YgMSBmb3IgYWxsIGVkZ2VzXG4gICAgLy8gICBkaXJlY3RlZCAvLyBkZWZhdWx0IGZhbHNlXG4gICAgLy8gY2xvc2VuZXNzID0+IHJldHVybmVkIHZhbHVlIGJ5IHRoZSBmdW5jdGlvbi4gQ2xvc2VuZXNzIHZhbHVlIG9mIHRoZSBnaXZlbiBub2RlLlxuICAgIGNsb3NlbmVzc0NlbnRyYWxpdHk6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gdmFyIGxvZ0RlYnVnID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gICBpZiAoZGVidWcpIHtcbiAgICAgIC8vICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9O1xuXG4gICAgICAvLyBQYXJzZSBvcHRpb25zXG4gICAgICAvLyBkZWJ1ZyAtIG9wdGlvbmFsXG4gICAgICAvLyBpZiAob3B0aW9ucy5kZWJ1ZyAhPSBudWxsKSB7XG4gICAgICAvLyAgIHZhciBkZWJ1ZyA9IG9wdGlvbnMuZGVidWc7XG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBmYWxzZTtcbiAgICAgIC8vIH1cblxuICAgICAgLy8gbG9nRGVidWcoXCJTdGFydGluZyBjbG9zZW5lc3MgY2VudHJhbGl0eS4uLlwiKTtcblxuICAgICAgLy8gcm9vdCAtIG1hbmRhdG9yeSFcbiAgICAgIGlmIChvcHRpb25zLnJvb3QgIT0gbnVsbCkge1xuICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG9wdGlvbnMucm9vdCkpIHtcbiAgICAgICAgICAvLyB1c2UgaXQgYXMgYSBzZWxlY3RvciwgZS5nLiBcIiNyb290SURcbiAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuZmlsdGVyKG9wdGlvbnMucm9vdClbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBvcHRpb25zLnJvb3RbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9nRGVidWcoXCJTb3VyY2Ugbm9kZTogJXNcIiwgcm9vdC5pZCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQkLnV0aWwuZXJyb3IoXCJvcHRpb25zLnJvb3QgcmVxdWlyZWRcIik7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlaWdodCAtIG9wdGlvbmFsXG4gICAgICBpZiAob3B0aW9ucy53ZWlnaHQgIT0gbnVsbCAmJiAkJC5pcy5mbihvcHRpb25zLndlaWdodCkpIHtcbiAgICAgICAgdmFyIHdlaWdodCA9IG9wdGlvbnMud2VpZ2h0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHdlaWdodCA9IGZ1bmN0aW9uKCl7cmV0dXJuIDE7fTtcbiAgICAgIH1cblxuICAgICAgLy8gZGlyZWN0ZWQgLSBvcHRpb25hbFxuICAgICAgaWYgKG9wdGlvbnMuZGlyZWN0ZWQgIT0gbnVsbCAmJiAkJC5pcy5ib29sKG9wdGlvbnMuZGlyZWN0ZWQpKSB7XG4gICAgICAgIHZhciBkaXJlY3RlZCA9IG9wdGlvbnMuZGlyZWN0ZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGhhcm1vbmljID0gb3B0aW9ucy5oYXJtb25pYztcbiAgICAgIGlmKCBoYXJtb25pYyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIGhhcm1vbmljID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gd2UgbmVlZCBkaXN0YW5jZSBmcm9tIHRoaXMgbm9kZSB0byBldmVyeSBvdGhlciBub2RlXG4gICAgICB2YXIgZGlqa3N0cmEgPSB0aGlzLmRpamtzdHJhKHtcbiAgICAgICAgcm9vdDogcm9vdCxcbiAgICAgICAgd2VpZ2h0OiB3ZWlnaHQsXG4gICAgICAgIGRpcmVjdGVkOiBkaXJlY3RlZFxuICAgICAgfSk7XG4gICAgICB2YXIgdG90YWxEaXN0YW5jZSA9IDA7XG5cbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBpZiAobm9kZXNbaV0uaWQoKSAhPSByb290LmlkKCkpe1xuICAgICAgICAgIHZhciBkID0gZGlqa3N0cmEuZGlzdGFuY2VUbyhub2Rlc1tpXSk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGhhcm1vbmljICl7XG4gICAgICAgICAgICB0b3RhbERpc3RhbmNlICs9IDEgLyBkOyBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG90YWxEaXN0YW5jZSArPSBkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaGFybW9uaWMgPyB0b3RhbERpc3RhbmNlIDogMSAvIHRvdGFsRGlzdGFuY2U7XG4gICAgfSwgLy8gY2xvc2VuZXNzQ2VudHJhbGl0eVxuXG4gICAgLy8gSW1wbGVtZW50ZWQgZnJvbSB0aGUgYWxnb3JpdGhtIGluIHRoZSBwYXBlciBcIk9uIFZhcmlhbnRzIG9mIFNob3J0ZXN0LVBhdGggQmV0d2Vlbm5lc3MgQ2VudHJhbGl0eSBhbmQgdGhlaXIgR2VuZXJpYyBDb21wdXRhdGlvblwiIGJ5IFVscmlrIEJyYW5kZXNcbiAgICAvLyBvcHRpb25zID0+IG9wdGlvbnMgb2JqZWN0XG4gICAgLy8gICB3ZWlnaHQ6IGZ1bmN0aW9uKCBlZGdlICl7fSAvLyBzcGVjaWZpZXMgd2VpZ2h0IHRvIHVzZSBmb3IgYGVkZ2VgL2B0aGlzYC4gSWYgbm90IHByZXNlbnQsIGl0IHdpbGwgYmUgYXN1bWVkIGEgd2VpZ2h0IG9mIDEgZm9yIGFsbCBlZGdlc1xuICAgIC8vICAgZGlyZWN0ZWQgLy8gZGVmYXVsdCBmYWxzZVxuICAgIC8vIHJldE9iaiA9PiByZXR1cm5lZCBvYmplY3QgYnkgZnVuY3Rpb25cbiAgICAvLyAgIGJldHdlZW5uZXNzIDogZnVuY3Rpb24obm9kZSkgLy8gUmV0dXJucyB0aGUgYmV0d2Vlbm5lc3MgY2VudHJhbGl0eSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIC8vICAgYmV0d2Vlbm5lc3NOb3JtYWxpemVkIDogZnVuY3Rpb24obm9kZSkgLy8gUmV0dXJucyB0aGUgbm9ybWFsaXplZCBiZXR3ZWVubmVzcyBjZW50cmFsaXR5IG9mIHRoZSBnaXZlbiBub2RlXG4gICAgYmV0d2Vlbm5lc3NDZW50cmFsaXR5OiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vICAgaWYgKGRlYnVnKSB7XG4gICAgICAvLyAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfTtcblxuICAgICAgLy8gUGFyc2Ugb3B0aW9uc1xuICAgICAgLy8gZGVidWcgLSBvcHRpb25hbFxuICAgICAgLy8gaWYgKG9wdGlvbnMuZGVidWcgIT0gbnVsbCkge1xuICAgICAgLy8gICB2YXIgZGVidWcgPSBvcHRpb25zLmRlYnVnO1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgIC8vICAgdmFyIGRlYnVnID0gZmFsc2U7XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGxvZ0RlYnVnKFwiU3RhcnRpbmcgYmV0d2Vlbm5lc3MgY2VudHJhbGl0eS4uLlwiKTtcblxuICAgICAgLy8gV2VpZ2h0IC0gb3B0aW9uYWxcbiAgICAgIGlmIChvcHRpb25zLndlaWdodCAhPSBudWxsICYmICQkLmlzLmZuKG9wdGlvbnMud2VpZ2h0KSkge1xuICAgICAgICB2YXIgd2VpZ2h0Rm4gPSBvcHRpb25zLndlaWdodDtcbiAgICAgICAgdmFyIHdlaWdodGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB3ZWlnaHRlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBEaXJlY3RlZCAtIGRlZmF1bHQgZmFsc2VcbiAgICAgIGlmIChvcHRpb25zLmRpcmVjdGVkICE9IG51bGwgJiYgJCQuaXMuYm9vbChvcHRpb25zLmRpcmVjdGVkKSkge1xuICAgICAgICB2YXIgZGlyZWN0ZWQgPSBvcHRpb25zLmRpcmVjdGVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRpcmVjdGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmlvcml0eUluc2VydCA9IGZ1bmN0aW9uIChxdWV1ZSwgZWxlKSB7XG4gICAgICAgIHF1ZXVlLnVuc2hpZnQoZWxlKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGRbcXVldWVbaV1dIDwgZFtxdWV1ZVtpICsgMV1dICYmIGkgPCBxdWV1ZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICB2YXIgdG1wID0gcXVldWVbaV07XG4gICAgICAgICAgcXVldWVbaV0gPSBxdWV1ZVtpICsgMV07XG4gICAgICAgICAgcXVldWVbaSArIDFdID0gdG1wO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICAvLyBzdGFydGluZ1xuICAgICAgdmFyIFYgPSB0aGlzLm5vZGVzKCk7XG4gICAgICB2YXIgQSA9IHt9O1xuICAgICAgdmFyIEMgPSB7fTtcblxuICAgICAgLy8gQSBjb250YWlucyB0aGUgbmVpZ2hib3Job29kcyBvZiBldmVyeSBub2RlXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGRpcmVjdGVkKSB7XG4gICAgICAgICAgQVtWW2ldLmlkKCldID0gVltpXS5vdXRnb2VycyhcIm5vZGVcIik7IC8vIGdldCBvdXRnb2VycyBvZiBldmVyeSBub2RlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQVtWW2ldLmlkKCldID0gVltpXS5vcGVuTmVpZ2hib3Job29kKFwibm9kZVwiKTsgLy8gZ2V0IG5laWdoYm9ycyBvZiBldmVyeSBub2RlICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEMgY29udGFpbnMgdGhlIGJldHdlZW5uZXNzIHZhbHVlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENbVltpXS5pZCgpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHMgPSAwOyBzIDwgVi5sZW5ndGg7IHMrKykge1xuICAgICAgICB2YXIgUyA9IFtdOyAvLyBzdGFja1xuICAgICAgICB2YXIgUCA9IHt9O1xuICAgICAgICB2YXIgZyA9IHt9O1xuICAgICAgICB2YXIgZCA9IHt9O1xuICAgICAgICB2YXIgUSA9IFtdOyAvLyBxdWV1ZVxuXG4gICAgICAgIC8vIGluaXQgZGljdGlvbmFyaWVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgVi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIFBbVltpXS5pZCgpXSA9IFtdO1xuICAgICAgICAgIGdbVltpXS5pZCgpXSA9IDA7XG4gICAgICAgICAgZFtWW2ldLmlkKCldID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB9XG5cbiAgICAgICAgZ1tWW3NdLmlkKCldID0gMTsgLy8gc2lnbWFcbiAgICAgICAgZFtWW3NdLmlkKCldID0gMDsgLy8gZGlzdGFuY2UgdG8gc1xuXG4gICAgICAgIFEudW5zaGlmdChWW3NdLmlkKCkpO1xuXG4gICAgICAgIHdoaWxlIChRLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgdiA9IFEucG9wKCk7XG4gICAgICAgICAgUy5wdXNoKHYpO1xuICAgICAgICAgIGlmICh3ZWlnaHRlZCkge1xuICAgICAgICAgICAgQVt2XS5mb3JFYWNoKGZ1bmN0aW9uICh3KSB7XG4gICAgICAgICAgICAgIGlmIChjeS4kKCcjJyArIHYpLmVkZ2VzVG8odykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBlZGdlID0gY3kuJCgnIycgKyB2KS5lZGdlc1RvKHcpWzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBlZGdlID0gdy5lZGdlc1RvKCcjJyArIHYpWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodEZuLmFwcGx5KGVkZ2UsIFtlZGdlXSk7XG5cbiAgICAgICAgICAgICAgaWYgKGRbdy5pZCgpXSA+IGRbdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZFt3LmlkKCldID0gZFt2XSArIGVkZ2VXZWlnaHQ7XG4gICAgICAgICAgICAgICAgaWYgKFEuaW5kZXhPZih3LmlkKCkpIDwgMCkgeyAvL2lmIHcgaXMgbm90IGluIFFcbiAgICAgICAgICAgICAgICAgIHByaW9yaXR5SW5zZXJ0KFEsIHcuaWQoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gdXBkYXRlIHBvc2l0aW9uIGlmIHcgaXMgaW4gUVxuICAgICAgICAgICAgICAgICAgUS5zcGxpY2UoUS5pbmRleE9mKHcuaWQoKSksIDEpO1xuICAgICAgICAgICAgICAgICAgcHJpb3JpdHlJbnNlcnQoUSwgdy5pZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ1t3LmlkKCldID0gMDtcbiAgICAgICAgICAgICAgICBQW3cuaWQoKV0gPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZFt3LmlkKCldID09IGRbdl0gKyBlZGdlV2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZ1t3LmlkKCldID0gZ1t3LmlkKCldICsgZ1t2XTtcbiAgICAgICAgICAgICAgICBQW3cuaWQoKV0ucHVzaCh2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIEFbdl0uZm9yRWFjaChmdW5jdGlvbiAodykge1xuICAgICAgICAgICAgICBpZiAoZFt3LmlkKCldID09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkge1xuICAgICAgICAgICAgICAgIFEudW5zaGlmdCh3LmlkKCkpO1xuICAgICAgICAgICAgICAgIGRbdy5pZCgpXSA9IGRbdl0gKyAxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkW3cuaWQoKV0gPT0gZFt2XSArIDEpIHtcbiAgICAgICAgICAgICAgICBnW3cuaWQoKV0gPSBnW3cuaWQoKV0gKyBnW3ZdO1xuICAgICAgICAgICAgICAgIFBbdy5pZCgpXS5wdXNoKHYpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlW1ZbaV0uaWQoKV0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKFMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciB3ID0gUy5wb3AoKTtcbiAgICAgICAgICBQW3ddLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIGVbdl0gPSBlW3ZdICsgKGdbdl0gLyBnW3ddKSAqICgxICsgZVt3XSk7XG4gICAgICAgICAgICBpZiAodyAhPSBWW3NdLmlkKCkpXG4gICAgICAgICAgICAgIENbd10gPSBDW3ddICsgZVt3XTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbWF4ID0gMDtcbiAgICAgIGZvciAodmFyIGtleSBpbiBDKSB7XG4gICAgICAgIGlmIChtYXggPCBDW2tleV0pXG4gICAgICAgICAgbWF4ID0gQ1trZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmV0ID0ge1xuICAgICAgICBiZXR3ZWVubmVzczogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBDW25vZGVdO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJldHdlZW5uZXNzTm9ybWFsaXplZDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICBpZiAoJCQuaXMuc3RyaW5nKG5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IChjeS5maWx0ZXIobm9kZSlbMF0pLmlkKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbm9kZS5pZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBDW25vZGVdIC8gbWF4O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBhbGlhc1xuICAgICAgcmV0LmJldHdlZW5uZXNzTm9ybWFsaXNlZCA9IHJldC5iZXR3ZWVubmVzc05vcm1hbGl6ZWQ7XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBiZXR3ZWVubmVzc0NlbnRyYWxpdHlcbiAgfSk7IC8vICQkLmZuLmVsZXNcblxuICAvLyBuaWNlLCBzaG9ydCBtYXRoZW1hdGhpY2FsIGFsaWFzXG4gICQkLmVsZXNmbi5kYyA9ICQkLmVsZXNmbi5kZWdyZWVDZW50cmFsaXR5O1xuICAkJC5lbGVzZm4uZGNuID0gJCQuZWxlc2ZuLmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpc2VkID0gJCQuZWxlc2ZuLmRlZ3JlZUNlbnRyYWxpdHlOb3JtYWxpemVkO1xuICAkJC5lbGVzZm4uY2MgPSAkJC5lbGVzZm4uY2xvc2VuZXNzQ2VudHJhbGl0eTtcbiAgJCQuZWxlc2ZuLmNjbiA9ICQkLmVsZXNmbi5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXNlZCA9ICQkLmVsZXNmbi5jbG9zZW5lc3NDZW50cmFsaXR5Tm9ybWFsaXplZDtcbiAgJCQuZWxlc2ZuLmJjID0gJCQuZWxlc2ZuLmJldHdlZW5uZXNzQ2VudHJhbGl0eTtcbn0pIChjeXRvc2NhcGUpO1xuXG47KGZ1bmN0aW9uKCAkJCApeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgYW5pbWF0ZWQ6ICQkLmRlZmluZS5hbmltYXRlZCgpLFxuICAgIGNsZWFyUXVldWU6ICQkLmRlZmluZS5jbGVhclF1ZXVlKCksXG4gICAgZGVsYXk6ICQkLmRlZmluZS5kZWxheSgpLFxuICAgIGFuaW1hdGU6ICQkLmRlZmluZS5hbmltYXRlKCksXG4gICAgc3RvcDogJCQuZGVmaW5lLnN0b3AoKVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7ICBcblxuOyhmdW5jdGlvbiggJCQgKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzZXMpe1xuICAgICAgY2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoL1xccysvKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjaGFuZ2VkID0gW107XG4gICAgICBcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgY2xzID0gY2xhc3Nlc1tpXTtcbiAgICAgICAgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGNscykgKXsgY29udGludWU7IH1cbiAgICAgICAgXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgc2VsZi5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBzZWxmW2pdO1xuICAgICAgICAgIHZhciBoYXNDbGFzcyA9IGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2Nsc107XG4gICAgICAgICAgZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXSA9IHRydWU7XG5cbiAgICAgICAgICBpZiggIWhhc0NsYXNzICl7IC8vIGlmIGRpZG4ndCBhbHJlYWR5IGhhdmUsIGFkZCB0byBsaXN0IG9mIGNoYW5nZWRcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuICAgICAgaWYoIGNoYW5nZWQubGVuZ3RoID4gMCApe1xuICAgICAgICBuZXcgJCQuQ29sbGVjdGlvbih0aGlzLl9wcml2YXRlLmN5LCBjaGFuZ2VkKVxuICAgICAgICAgIC51cGRhdGVTdHlsZSgpXG4gICAgICAgICAgLnRyaWdnZXIoJ2NsYXNzJylcbiAgICAgICAgO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzTmFtZSl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHJldHVybiAoIGVsZSAhPSBudWxsICYmIGVsZS5fcHJpdmF0ZS5jbGFzc2VzW2NsYXNzTmFtZV0gKSA/IHRydWUgOiBmYWxzZTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKGNsYXNzZXNTdHIsIHRvZ2dsZSl7XG4gICAgICB2YXIgY2xhc3NlcyA9IGNsYXNzZXNTdHIuc3BsaXQoL1xccysvKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBjaGFuZ2VkID0gW107IC8vIGVsZXMgd2hvIGhhZCBjbGFzc2VzIGNoYW5nZWRcbiAgICAgIFxuICAgICAgZm9yKCB2YXIgaSA9IDAsIGlsID0gc2VsZi5sZW5ndGg7IGkgPCBpbDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSBzZWxmW2ldO1xuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY2xhc3Nlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBjbHMgPSBjbGFzc2VzW2pdO1xuXG4gICAgICAgICAgaWYoICQkLmlzLmVtcHR5U3RyaW5nKGNscykgKXsgY29udGludWU7IH1cbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgaGFzQ2xhc3MgPSBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdO1xuICAgICAgICAgIHZhciBzaG91bGRBZGQgPSB0b2dnbGUgfHwgKHRvZ2dsZSA9PT0gdW5kZWZpbmVkICYmICFoYXNDbGFzcyk7XG5cbiAgICAgICAgICBpZiggc2hvdWxkQWRkICl7XG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYoICFoYXNDbGFzcyApeyBjaGFuZ2VkLnB1c2goZWxlKTsgfVxuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gcmVtb3ZlXG4gICAgICAgICAgICBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmKCBoYXNDbGFzcyApeyBjaGFuZ2VkLnB1c2goZWxlKTsgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IC8vIGZvciBqIGNsYXNzZXNcbiAgICAgIH0gLy8gZm9yIGkgZWxlc1xuICAgICAgXG4gICAgICAvLyB0cmlnZ2VyIHVwZGF0ZSBzdHlsZSBvbiB0aG9zZSBlbGVzIHRoYXQgaGFkIGNsYXNzIGNoYW5nZXNcbiAgICAgIGlmKCBjaGFuZ2VkLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgbmV3ICQkLkNvbGxlY3Rpb24odGhpcy5fcHJpdmF0ZS5jeSwgY2hhbmdlZClcbiAgICAgICAgICAudXBkYXRlU3R5bGUoKVxuICAgICAgICAgIC50cmlnZ2VyKCdjbGFzcycpXG4gICAgICAgIDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfSxcblxuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihjbGFzc2VzKXtcbiAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KC9cXHMrLyk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY2hhbmdlZCA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGYubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHNlbGZbaV07XG5cbiAgICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBjbGFzc2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGNscyA9IGNsYXNzZXNbal07XG4gICAgICAgICAgaWYoICFjbHMgfHwgY2xzID09PSAnJyApeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgdmFyIGhhc0NsYXNzID0gZWxlLl9wcml2YXRlLmNsYXNzZXNbY2xzXTtcbiAgICAgICAgICBlbGUuX3ByaXZhdGUuY2xhc3Nlc1tjbHNdID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYoIGhhc0NsYXNzICl7IC8vIHRoZW4gd2UgY2hhbmdlZCBpdHMgc2V0IG9mIGNsYXNzZXNcbiAgICAgICAgICAgIGNoYW5nZWQucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIHRyaWdnZXIgdXBkYXRlIHN0eWxlIG9uIHRob3NlIGVsZXMgdGhhdCBoYWQgY2xhc3MgY2hhbmdlc1xuICAgICAgaWYoIGNoYW5nZWQubGVuZ3RoID4gMCApe1xuICAgICAgICBuZXcgJCQuQ29sbGVjdGlvbihzZWxmLl9wcml2YXRlLmN5LCBjaGFuZ2VkKS51cGRhdGVTdHlsZSgpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnRyaWdnZXIoJ2NsYXNzJyk7XG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9LFxuXG4gICAgZmxhc2hDbGFzczogZnVuY3Rpb24oY2xhc3NlcywgZHVyYXRpb24pe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiggZHVyYXRpb24gPT0gbnVsbCApe1xuICAgICAgICBkdXJhdGlvbiA9IDI1MDtcbiAgICAgIH0gZWxzZSBpZiggZHVyYXRpb24gPT09IDAgKXtcbiAgICAgICAgcmV0dXJuIHNlbGY7IC8vIG5vdGhpbmcgdG8gZG8gcmVhbGx5XG4gICAgICB9XG5cbiAgICAgIHNlbGYuYWRkQ2xhc3MoIGNsYXNzZXMgKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5yZW1vdmVDbGFzcyggY2xhc3NlcyApO1xuICAgICAgfSwgZHVyYXRpb24pO1xuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG4gIH0pO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5lbGVzKHtcbiAgICBhbGxBcmU6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHNlbGVjdG9yKS5sZW5ndGggPT09IHRoaXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBpczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoc2VsZWN0b3IpLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIHNvbWU6IGZ1bmN0aW9uKCBmbiwgdGhpc0FyZyApe1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciByZXQgPSAhdGhpc0FyZyA/IGZuKCB0aGlzW2ldLCBpLCB0aGlzICkgOiBmbi5hcHBseSggdGhpc0FyZywgWyB0aGlzW2ldLCBpLCB0aGlzIF0gKTtcblxuICAgICAgICBpZiggcmV0ICl7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBldmVyeTogZnVuY3Rpb24oIGZuLCB0aGlzQXJnICl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHJldCA9ICF0aGlzQXJnID8gZm4oIHRoaXNbaV0sIGksIHRoaXMgKSA6IGZuLmFwcGx5KCB0aGlzQXJnLCBbIHRoaXNbaV0sIGksIHRoaXMgXSApO1xuXG4gICAgICAgIGlmKCAhcmV0ICl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBzYW1lOiBmdW5jdGlvbiggY29sbGVjdGlvbiApe1xuICAgICAgY29sbGVjdGlvbiA9IHRoaXMuY3koKS5jb2xsZWN0aW9uKCBjb2xsZWN0aW9uICk7XG5cbiAgICAgIC8vIGNoZWFwIGV4dHJhIGNoZWNrXG4gICAgICBpZiggdGhpcy5sZW5ndGggIT09IGNvbGxlY3Rpb24ubGVuZ3RoICl7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0KCBjb2xsZWN0aW9uICkubGVuZ3RoID09PSB0aGlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgYW55U2FtZTogZnVuY3Rpb24oIGNvbGxlY3Rpb24gKXtcbiAgICAgIGNvbGxlY3Rpb24gPSB0aGlzLmN5KCkuY29sbGVjdGlvbiggY29sbGVjdGlvbiApO1xuXG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3QoIGNvbGxlY3Rpb24gKS5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICBhbGxBcmVOZWlnaGJvcnM6IGZ1bmN0aW9uKCBjb2xsZWN0aW9uICl7XG4gICAgICBjb2xsZWN0aW9uID0gdGhpcy5jeSgpLmNvbGxlY3Rpb24oIGNvbGxlY3Rpb24gKTtcblxuICAgICAgcmV0dXJuIHRoaXMubmVpZ2hib3Job29kKCkuaW50ZXJzZWN0KCBjb2xsZWN0aW9uICkubGVuZ3RoID09PSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuXG4gICQkLmVsZXNmbi5hbGxBcmVOZWlnaGJvdXJzID0gJCQuZWxlc2ZuLmFsbEFyZU5laWdoYm9ycztcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgLy8gQ29tcG91bmQgZnVuY3Rpb25zXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIHBhcmVudDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICB2YXIgcGFyZW50ID0gY3kuZ2V0RWxlbWVudEJ5SWQoIGVsZS5fcHJpdmF0ZS5kYXRhLnBhcmVudCApO1xuXG4gICAgICAgIGlmKCBwYXJlbnQuc2l6ZSgpID4gMCApe1xuICAgICAgICAgIHBhcmVudHMucHVzaCggcGFyZW50ICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcGFyZW50cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgcGFyZW50czogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgcGFyZW50cyA9IFtdO1xuXG4gICAgICB2YXIgZWxlcyA9IHRoaXMucGFyZW50KCk7XG4gICAgICB3aGlsZSggZWxlcy5ub25lbXB0eSgpICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgICAgIHBhcmVudHMucHVzaCggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCksIHBhcmVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIGNvbW1vbkFuY2VzdG9yczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgYW5jZXN0b3JzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBwYXJlbnRzID0gZWxlLnBhcmVudHMoKTtcbiAgICAgICAgXG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycyB8fCBwYXJlbnRzO1xuXG4gICAgICAgIGFuY2VzdG9ycyA9IGFuY2VzdG9ycy5pbnRlcnNlY3QoIHBhcmVudHMgKTsgLy8gY3VycmVudCBsaXN0IG11c3QgYmUgY29tbW9uIHdpdGggY3VycmVudCBlbGUgcGFyZW50cyBzZXRcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFuY2VzdG9ycy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIG9ycGhhbnM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMuc3RkRmlsdGVyKGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5pc05vZGUoKSAmJiBlbGUucGFyZW50KCkuZW1wdHkoKTtcbiAgICAgIH0pLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgbm9ub3JwaGFuczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICByZXR1cm4gdGhpcy5zdGRGaWx0ZXIoZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLmlzTm9kZSgpICYmIGVsZS5wYXJlbnQoKS5ub25lbXB0eSgpO1xuICAgICAgfSkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBjaGlsZHJlbjogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmNvbmNhdCggZWxlLl9wcml2YXRlLmNoaWxkcmVuICk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpLCBjaGlsZHJlbiwgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgc2libGluZ3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5ub3QoIHRoaXMgKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIGlzUGFyZW50OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5jaGlsZHJlbi5sZW5ndGggIT09IDA7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGlzQ2hpbGQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEucGFyZW50ICE9PSB1bmRlZmluZWQgJiYgZWxlLnBhcmVudCgpLmxlbmd0aCAhPT0gMDtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVzY2VuZGFudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGFkZCggZWxlcyApe1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZSApO1xuXG4gICAgICAgICAgaWYoIGVsZS5jaGlsZHJlbigpLm5vbmVtcHR5KCkgKXtcbiAgICAgICAgICAgIGFkZCggZWxlLmNoaWxkcmVuKCkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWRkKCB0aGlzLmNoaWxkcmVuKCkgKTtcblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCksIGVsZW1lbnRzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWxpYXNlc1xuICAkJC5lbGVzZm4uYW5jZXN0b3JzID0gJCQuZWxlc2ZuLnBhcmVudHM7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgYm9yZGVyV2lkdGhNdWx0aXBsaWVyID0gMiAqIDAuNTtcbiAgdmFyIGJvcmRlcldpZHRoQWRqdXN0bWVudCA9IDA7XG5cbiAgJCQuZm4uZWxlcyh7XG5cbiAgICBkYXRhOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ2RhdGEnLFxuICAgICAgYmluZGluZ0V2ZW50OiAnZGF0YScsXG4gICAgICBhbGxvd0JpbmRpbmc6IHRydWUsXG4gICAgICBhbGxvd1NldHRpbmc6IHRydWUsXG4gICAgICBzZXR0aW5nRXZlbnQ6ICdkYXRhJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgICAnaWQnOiB0cnVlLFxuICAgICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgICB9LFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcblxuICAgIHJlbW92ZURhdGE6ICQkLmRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAnZGF0YScsXG4gICAgICBldmVudDogJ2RhdGEnLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgdHJpZ2dlckV2ZW50OiB0cnVlLFxuICAgICAgaW1tdXRhYmxlS2V5czoge1xuICAgICAgICAnaWQnOiB0cnVlLFxuICAgICAgICAnc291cmNlJzogdHJ1ZSxcbiAgICAgICAgJ3RhcmdldCc6IHRydWUsXG4gICAgICAgICdwYXJlbnQnOiB0cnVlXG4gICAgICB9LFxuICAgICAgdXBkYXRlU3R5bGU6IHRydWVcbiAgICB9KSxcblxuICAgIHNjcmF0Y2g6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAnc2NyYXRjaCcsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdzY3JhdGNoJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ3NjcmF0Y2gnLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IHRydWUsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICBhbGxvd0dldHRpbmc6IHRydWUsXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVtb3ZlU2NyYXRjaDogJCQuZGVmaW5lLnJlbW92ZURhdGEoe1xuICAgICAgZmllbGQ6ICdzY3JhdGNoJyxcbiAgICAgIGV2ZW50OiAnc2NyYXRjaCcsXG4gICAgICB0cmlnZ2VyRm5OYW1lOiAndHJpZ2dlcicsXG4gICAgICB0cmlnZ2VyRXZlbnQ6IHRydWUsXG4gICAgICB1cGRhdGVTdHlsZTogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcnNjcmF0Y2g6ICQkLmRlZmluZS5kYXRhKHtcbiAgICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgICAgYWxsb3dCaW5kaW5nOiBmYWxzZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiBmYWxzZSxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZVxuICAgIH0pLFxuXG4gICAgcmVtb3ZlUnNjcmF0Y2g6ICQkLmRlZmluZS5yZW1vdmVEYXRhKHtcbiAgICAgIGZpZWxkOiAncnNjcmF0Y2gnLFxuICAgICAgdHJpZ2dlckV2ZW50OiBmYWxzZVxuICAgIH0pLFxuXG4gICAgaWQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHBvc2l0aW9uOiAkJC5kZWZpbmUuZGF0YSh7XG4gICAgICBmaWVsZDogJ3Bvc2l0aW9uJyxcbiAgICAgIGJpbmRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICAgIGFsbG93QmluZGluZzogdHJ1ZSxcbiAgICAgIGFsbG93U2V0dGluZzogdHJ1ZSxcbiAgICAgIHNldHRpbmdFdmVudDogJ3Bvc2l0aW9uJyxcbiAgICAgIHNldHRpbmdUcmlnZ2Vyc0V2ZW50OiB0cnVlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3J0cmlnZ2VyJyxcbiAgICAgIGFsbG93R2V0dGluZzogdHJ1ZSxcbiAgICAgIHZhbGlkS2V5czogWyd4JywgJ3knXSxcbiAgICAgIG9uU2V0OiBmdW5jdGlvbiggZWxlcyApe1xuICAgICAgICB2YXIgdXBkYXRlZEVsZXMgPSBlbGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgIHVwZGF0ZWRFbGVzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgICAgfSxcbiAgICAgIGNhblNldDogZnVuY3Rpb24oIGVsZSApe1xuICAgICAgICByZXR1cm4gIWVsZS5sb2NrZWQoKTtcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIC8vIHBvc2l0aW9uIGJ1dCBubyBub3RpZmljYXRpb24gdG8gcmVuZGVyZXJcbiAgICBzaWxlbnRQb3NpdGlvbjogJCQuZGVmaW5lLmRhdGEoe1xuICAgICAgZmllbGQ6ICdwb3NpdGlvbicsXG4gICAgICBiaW5kaW5nRXZlbnQ6ICdwb3NpdGlvbicsXG4gICAgICBhbGxvd0JpbmRpbmc6IGZhbHNlLFxuICAgICAgYWxsb3dTZXR0aW5nOiB0cnVlLFxuICAgICAgc2V0dGluZ0V2ZW50OiAncG9zaXRpb24nLFxuICAgICAgc2V0dGluZ1RyaWdnZXJzRXZlbnQ6IGZhbHNlLFxuICAgICAgdHJpZ2dlckZuTmFtZTogJ3RyaWdnZXInLFxuICAgICAgYWxsb3dHZXR0aW5nOiB0cnVlLFxuICAgICAgdmFsaWRLZXlzOiBbJ3gnLCAneSddLFxuICAgICAgb25TZXQ6IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgICAgIGVsZXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgIH0sXG4gICAgICBjYW5TZXQ6IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgICAgcmV0dXJuICFlbGUubG9ja2VkKCk7XG4gICAgICB9XG4gICAgfSksXG5cbiAgICBwb3NpdGlvbnM6IGZ1bmN0aW9uKCBwb3MsIHNpbGVudCApe1xuICAgICAgaWYoICQkLmlzLnBsYWluT2JqZWN0KHBvcykgKXtcbiAgICAgICAgdGhpcy5wb3NpdGlvbihwb3MpO1xuXG4gICAgICB9IGVsc2UgaWYoICQkLmlzLmZuKHBvcykgKXtcbiAgICAgICAgdmFyIGZuID0gcG9zO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgdmFyIHBvcyA9IGZuLmFwcGx5KGVsZSwgW2ksIGVsZV0pO1xuXG4gICAgICAgICAgaWYoIHBvcyAmJiAhZWxlLmxvY2tlZCgpICl7XG4gICAgICAgICAgICB2YXIgZWxlUG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgICAgZWxlUG9zLnggPSBwb3MueDtcbiAgICAgICAgICAgIGVsZVBvcy55ID0gcG9zLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVwZGF0ZWRFbGVzID0gdGhpcy51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICB2YXIgdG9UcmlnZ2VyID0gdXBkYXRlZEVsZXMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkRWxlcyApIDogdGhpcztcblxuICAgICAgICBpZiggc2lsZW50ICl7XG4gICAgICAgICAgdG9UcmlnZ2VyLnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9UcmlnZ2VyLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBzaWxlbnRQb3NpdGlvbnM6IGZ1bmN0aW9uKCBwb3MgKXtcbiAgICAgIHJldHVybiB0aGlzLnBvc2l0aW9ucyggcG9zLCB0cnVlICk7XG4gICAgfSxcblxuICAgIHVwZGF0ZUNvbXBvdW5kQm91bmRzOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpIHx8ICFjeS5oYXNDb21wb3VuZE5vZGVzKCkgKXsgcmV0dXJuIGN5LmNvbGxlY3Rpb24oKTsgfSAvLyBzYXZlIGN5Y2xlcyBmb3Igbm9uIGNvbXBvdW5kIGdyYXBocyBvciB3aGVuIHN0eWxlIGRpc2FibGVkXG5cbiAgICAgIHZhciB1cGRhdGVkID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZSggcGFyZW50ICl7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbigpO1xuICAgICAgICB2YXIgc3R5bGUgPSBwYXJlbnQuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgIHZhciBpbmNsdWRlTGFiZWxzID0gc3R5bGVbJ2NvbXBvdW5kLXNpemluZy13cnQtbGFiZWxzJ10udmFsdWUgPT09ICdpbmNsdWRlJztcbiAgICAgICAgdmFyIGJiID0gY2hpbGRyZW4uYm91bmRpbmdCb3goeyBpbmNsdWRlTGFiZWxzOiBpbmNsdWRlTGFiZWxzLCBpbmNsdWRlRWRnZXM6IHRydWUgfSk7XG4gICAgICAgIHZhciBwYWRkaW5nID0ge1xuICAgICAgICAgIHRvcDogc3R5bGVbJ3BhZGRpbmctdG9wJ10ucHhWYWx1ZSxcbiAgICAgICAgICBib3R0b206IHN0eWxlWydwYWRkaW5nLWJvdHRvbSddLnB4VmFsdWUsXG4gICAgICAgICAgbGVmdDogc3R5bGVbJ3BhZGRpbmctbGVmdCddLnB4VmFsdWUsXG4gICAgICAgICAgcmlnaHQ6IHN0eWxlWydwYWRkaW5nLXJpZ2h0J10ucHhWYWx1ZVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcG9zID0gcGFyZW50Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgZGlkVXBkYXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYoIHN0eWxlWyd3aWR0aCddLnZhbHVlID09PSAnYXV0bycgKXtcbiAgICAgICAgICBwYXJlbnQuX3ByaXZhdGUuYXV0b1dpZHRoID0gYmIudyArIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQ7XG4gICAgICAgICAgcG9zLnggPSAoYmIueDEgKyBiYi54MiAtIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQpLzI7XG4gICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBzdHlsZVsnaGVpZ2h0J10udmFsdWUgPT09ICdhdXRvJyApe1xuICAgICAgICAgIHBhcmVudC5fcHJpdmF0ZS5hdXRvSGVpZ2h0ID0gYmIuaCArIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b207XG4gICAgICAgICAgcG9zLnkgPSAoYmIueTEgKyBiYi55MiAtIHBhZGRpbmcudG9wICsgcGFkZGluZy5ib3R0b20pLzI7XG4gICAgICAgICAgZGlkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBkaWRVcGRhdGUgKXtcbiAgICAgICAgICB1cGRhdGVkLnB1c2goIHBhcmVudCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGdvIHVwLCBsZXZlbCBieSBsZXZlbFxuICAgICAgdmFyIGVsZXMgPSB0aGlzLnBhcmVudCgpO1xuICAgICAgd2hpbGUoIGVsZXMubm9uZW1wdHkoKSApe1xuXG4gICAgICAgIC8vIHVwZGF0ZSBlYWNoIHBhcmVudCBub2RlIGluIHRoaXMgbGV2ZWxcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgICAgICB1cGRhdGUoIGVsZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbmV4dCBsZXZlbFxuICAgICAgICBlbGVzID0gZWxlcy5wYXJlbnQoKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmV0dXJuIGNoYW5nZWRcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHVwZGF0ZWQgKTtcbiAgICB9LFxuXG4gICAgLy8gZ2V0L3NldCB0aGUgcmVuZGVyZWQgKGkuZS4gb24gc2NyZWVuKSBwb3NpdG9uIG9mIHRoZSBlbGVtZW50XG4gICAgcmVuZGVyZWRQb3NpdGlvbjogZnVuY3Rpb24oIGRpbSwgdmFsICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuICAgICAgdmFyIHJwb3MgPSAkJC5pcy5wbGFpbk9iamVjdCggZGltICkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc2V0dGluZyA9IHJwb3MgIT09IHVuZGVmaW5lZCB8fCAoIHZhbCAhPT0gdW5kZWZpbmVkICYmICQkLmlzLnN0cmluZyhkaW0pICk7XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLmlzTm9kZSgpICl7IC8vIG11c3QgaGF2ZSBhbiBlbGVtZW50IGFuZCBtdXN0IGJlIGEgbm9kZSB0byByZXR1cm4gcG9zaXRpb25cbiAgICAgICAgaWYoIHNldHRpbmcgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uW2RpbV0gPSAoIHZhbCAtIHBhbltkaW1dICkvem9vbTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiggcnBvcyAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogKCBycG9zLnggLSBwYW4ueCApIC96b29tLFxuICAgICAgICAgICAgICAgIHk6ICggcnBvcy55IC0gcGFuLnkgKSAvem9vbVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucnRyaWdnZXIoJ3Bvc2l0aW9uJyk7XG4gICAgICAgIH0gZWxzZSB7IC8vIGdldHRpbmdcbiAgICAgICAgICB2YXIgcG9zID0gZWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgIHJwb3MgPSB7XG4gICAgICAgICAgICB4OiBwb3MueCAqIHpvb20gKyBwYW4ueCxcbiAgICAgICAgICAgIHk6IHBvcy55ICogem9vbSArIHBhbi55XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmKCBkaW0gPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICAgIHJldHVybiBycG9zO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgICByZXR1cm4gcnBvc1sgZGltIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoICFzZXR0aW5nICl7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIGdldC9zZXQgdGhlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnRcbiAgICByZWxhdGl2ZVBvc2l0aW9uOiBmdW5jdGlvbiggZGltLCB2YWwgKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgdmFyIHBwb3MgPSAkJC5pcy5wbGFpbk9iamVjdCggZGltICkgPyBkaW0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgc2V0dGluZyA9IHBwb3MgIT09IHVuZGVmaW5lZCB8fCAoIHZhbCAhPT0gdW5kZWZpbmVkICYmICQkLmlzLnN0cmluZyhkaW0pICk7XG4gICAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcblxuICAgICAgaWYoIGVsZSAmJiBlbGUuaXNOb2RlKCkgKXsgLy8gbXVzdCBoYXZlIGFuIGVsZW1lbnQgYW5kIG11c3QgYmUgYSBub2RlIHRvIHJldHVybiBwb3NpdGlvblxuICAgICAgICBpZiggc2V0dGluZyApe1xuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgICAgICB2YXIgaGFzUGFyZW50ID0gcGFyZW50ICYmIHBhcmVudC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlVG9QYXJlbnQgPSBoYXNQYXJlbnQ7XG5cbiAgICAgICAgICAgIGlmKCBoYXNQYXJlbnQgKXtcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5fcHJpdmF0ZS5wb3NpdGlvbiA6IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgICAgICBpZiggdmFsICE9PSB1bmRlZmluZWQgKXsgLy8gc2V0IG9uZSBkaW1lbnNpb25cbiAgICAgICAgICAgICAgZWxlLl9wcml2YXRlLnBvc2l0aW9uW2RpbV0gPSB2YWwgKyBvcmlnaW5bZGltXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiggcHBvcyAhPT0gdW5kZWZpbmVkICl7IC8vIHNldCB3aG9sZSBwb3NpdGlvblxuICAgICAgICAgICAgICBlbGUuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogcHBvcy54ICsgb3JpZ2luLngsXG4gICAgICAgICAgICAgICAgeTogcHBvcy55ICsgb3JpZ2luLnksXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcblxuICAgICAgICB9IGVsc2UgeyAvLyBnZXR0aW5nXG4gICAgICAgICAgdmFyIHBvcyA9IGVsZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gaGFzQ29tcG91bmROb2RlcyA/IGVsZS5wYXJlbnQoKSA6IG51bGw7XG4gICAgICAgICAgdmFyIGhhc1BhcmVudCA9IHBhcmVudCAmJiBwYXJlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgICB2YXIgcmVsYXRpdmVUb1BhcmVudCA9IGhhc1BhcmVudDtcblxuICAgICAgICAgIGlmKCBoYXNQYXJlbnQgKXtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb3JpZ2luID0gcmVsYXRpdmVUb1BhcmVudCA/IHBhcmVudC5fcHJpdmF0ZS5wb3NpdGlvbiA6IHsgeDogMCwgeTogMCB9O1xuXG4gICAgICAgICAgcHBvcyA9IHtcbiAgICAgICAgICAgIHg6IHBvcy54IC0gb3JpZ2luLngsXG4gICAgICAgICAgICB5OiBwb3MueSAtIG9yaWdpbi55XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmKCBkaW0gPT09IHVuZGVmaW5lZCApeyAvLyB0aGVuIHJldHVybiB0aGUgd2hvbGUgcmVuZGVyZWQgcG9zaXRpb25cbiAgICAgICAgICAgIHJldHVybiBwcG9zO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIHRoZW4gcmV0dXJuIHRoZSBzcGVjaWZpZWQgZGltZW5zaW9uXG4gICAgICAgICAgICByZXR1cm4gcHBvc1sgZGltIF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoICFzZXR0aW5nICl7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIGZvciBlbXB0eSBjb2xsZWN0aW9uIGNhc2VcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8vIGNvbnZlbmllbmNlIGZ1bmN0aW9uIHRvIGdldCBhIG51bWVyaWNhbCB2YWx1ZSBmb3IgdGhlIHdpZHRoIG9mIHRoZSBub2RlL2VkZ2VcbiAgICB3aWR0aDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgICAgdmFyIHcgPSBlbGUuX3ByaXZhdGUuc3R5bGUud2lkdGg7XG4gICAgICAgICAgcmV0dXJuIHcuc3RyVmFsdWUgPT09ICdhdXRvJyA/IGVsZS5fcHJpdmF0ZS5hdXRvV2lkdGggOiB3LnB4VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb3V0ZXJXaWR0aDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGN5ID0gZWxlLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5Ll9wcml2YXRlLnN0eWxlRW5hYmxlZDtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgICAgIHZhciB3aWR0aCA9IHN0eWxlLndpZHRoLnN0clZhbHVlID09PSAnYXV0bycgPyBlbGUuX3ByaXZhdGUuYXV0b1dpZHRoIDogc3R5bGUud2lkdGgucHhWYWx1ZTtcbiAgICAgICAgICB2YXIgYm9yZGVyID0gc3R5bGVbJ2JvcmRlci13aWR0aCddID8gc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWUgKiBib3JkZXJXaWR0aE11bHRpcGxpZXIgKyBib3JkZXJXaWR0aEFkanVzdG1lbnQgOiAwO1xuXG4gICAgICAgICAgcmV0dXJuIHdpZHRoICsgYm9yZGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcmVkV2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICB2YXIgd2lkdGggPSBlbGUud2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyZWRPdXRlcldpZHRoOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgdmFyIG93aWR0aCA9IGVsZS5vdXRlcldpZHRoKCk7XG4gICAgICAgIHJldHVybiBvd2lkdGggKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBjb252ZW5pZW5jZSBmdW5jdGlvbiB0byBnZXQgYSBudW1lcmljYWwgdmFsdWUgZm9yIHRoZSBoZWlnaHQgb2YgdGhlIG5vZGVcbiAgICBoZWlnaHQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBjeSA9IGVsZS5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBzdHlsZUVuYWJsZWQgPSBjeS5fcHJpdmF0ZS5zdHlsZUVuYWJsZWQ7XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICB2YXIgaCA9IGVsZS5fcHJpdmF0ZS5zdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgcmV0dXJuIGguc3RyVmFsdWUgPT09ICdhdXRvJyA/IGVsZS5fcHJpdmF0ZS5hdXRvSGVpZ2h0IDogaC5weFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIG91dGVySGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICB2YXIgY3kgPSBlbGUuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgc3R5bGVFbmFibGVkID0gY3kuX3ByaXZhdGUuc3R5bGVFbmFibGVkO1xuXG4gICAgICBpZiggZWxlICYmIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICBpZiggc3R5bGVFbmFibGVkICl7XG4gICAgICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgICAgIHZhciBoZWlnaHQgPSBzdHlsZS5oZWlnaHQuc3RyVmFsdWUgPT09ICdhdXRvJyA/IGVsZS5fcHJpdmF0ZS5hdXRvSGVpZ2h0IDogc3R5bGUuaGVpZ2h0LnB4VmFsdWU7XG4gICAgICAgICAgdmFyIGJvcmRlciA9IHN0eWxlWydib3JkZXItd2lkdGgnXSA/IHN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlICogYm9yZGVyV2lkdGhNdWx0aXBsaWVyICsgYm9yZGVyV2lkdGhBZGp1c3RtZW50IDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBoZWlnaHQgKyBib3JkZXI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlcmVkSGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIHZhciBoZWlnaHQgPSBlbGUuaGVpZ2h0KCk7XG4gICAgICAgIHJldHVybiBoZWlnaHQgKiB0aGlzLmN5KCkuem9vbSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICByZW5kZXJlZE91dGVySGVpZ2h0OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgJiYgZWxlLl9wcml2YXRlLmdyb3VwID09PSAnbm9kZXMnICl7XG4gICAgICAgIHZhciBvaGVpZ2h0ID0gZWxlLm91dGVySGVpZ2h0KCk7XG4gICAgICAgIHJldHVybiBvaGVpZ2h0ICogdGhpcy5jeSgpLnpvb20oKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVuZGVyZWRCb3VuZGluZ0JveDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBiYiA9IHRoaXMuYm91bmRpbmdCb3goIG9wdGlvbnMgKTtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIHBhbiA9IGN5LnBhbigpO1xuXG4gICAgICB2YXIgeDEgPSBiYi54MSAqIHpvb20gKyBwYW4ueDtcbiAgICAgIHZhciB4MiA9IGJiLngyICogem9vbSArIHBhbi54O1xuICAgICAgdmFyIHkxID0gYmIueTEgKiB6b29tICsgcGFuLnk7XG4gICAgICB2YXIgeTIgPSBiYi55MiAqIHpvb20gKyBwYW4ueTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeTI6IHkyLFxuICAgICAgICB3OiB4MiAtIHgxLFxuICAgICAgICBoOiB5MiAtIHkxXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBnZXQgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgZWxlbWVudHMgKGluIHJhdyBtb2RlbCBwb3NpdGlvbilcbiAgICBib3VuZGluZ0JveDogZnVuY3Rpb24oIG9wdGlvbnMgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBjeSA9IGVsZXMuX3ByaXZhdGUuY3k7XG4gICAgICB2YXIgY3lfcCA9IGN5Ll9wcml2YXRlO1xuICAgICAgdmFyIHN0eWxlRW5hYmxlZCA9IGN5X3Auc3R5bGVFbmFibGVkO1xuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgdmFyIGluY2x1ZGVOb2RlcyA9IG9wdGlvbnMuaW5jbHVkZU5vZGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5pbmNsdWRlTm9kZXM7XG4gICAgICB2YXIgaW5jbHVkZUVkZ2VzID0gb3B0aW9ucy5pbmNsdWRlRWRnZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmluY2x1ZGVFZGdlcztcbiAgICAgIHZhciBpbmNsdWRlTGFiZWxzID0gb3B0aW9ucy5pbmNsdWRlTGFiZWxzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5pbmNsdWRlTGFiZWxzO1xuXG4gICAgICAvLyByZWNhbGN1bGF0ZSBwcm9qZWN0aW9ucyBldGNcbiAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgY3lfcC5yZW5kZXJlci5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUoIHRoaXMgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHgxID0gSW5maW5pdHk7XG4gICAgICB2YXIgeDIgPSAtSW5maW5pdHk7XG4gICAgICB2YXIgeTEgPSBJbmZpbml0eTtcbiAgICAgIHZhciB5MiA9IC1JbmZpbml0eTtcblxuICAgICAgLy8gZmluZCBib3VuZHMgb2YgZWxlbWVudHNcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgICAgICAgdmFyIGRpc3BsYXkgPSBzdHlsZUVuYWJsZWQgPyBfcC5zdHlsZVsnZGlzcGxheSddLnZhbHVlIDogJ2VsZW1lbnQnO1xuICAgICAgICB2YXIgaXNOb2RlID0gX3AuZ3JvdXAgPT09ICdub2Rlcyc7XG4gICAgICAgIHZhciBleDEsIGV4MiwgZXkxLCBleTIsIHgsIHk7XG4gICAgICAgIHZhciBpbmNsdWRlZEVsZSA9IGZhbHNlO1xuXG4gICAgICAgIGlmKCBkaXNwbGF5ID09PSAnbm9uZScgKXsgY29udGludWU7IH0gLy8gdGhlbiBlbGUgZG9lc24ndCB0YWtlIHVwIHNwYWNlXG5cbiAgICAgICAgaWYoIGlzTm9kZSAmJiBpbmNsdWRlTm9kZXMgKXtcbiAgICAgICAgICBpbmNsdWRlZEVsZSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG4gICAgICAgICAgeCA9IHBvcy54O1xuICAgICAgICAgIHkgPSBwb3MueTtcbiAgICAgICAgICB2YXIgdyA9IGVsZS5vdXRlcldpZHRoKCk7XG4gICAgICAgICAgdmFyIGhhbGZXID0gdy8yO1xuICAgICAgICAgIHZhciBoID0gZWxlLm91dGVySGVpZ2h0KCk7XG4gICAgICAgICAgdmFyIGhhbGZIID0gaC8yO1xuXG4gICAgICAgICAgLy8gaGFuZGxlIG5vZGUgZGltZW5zaW9uc1xuICAgICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgIGV4MSA9IHggLSBoYWxmVztcbiAgICAgICAgICBleDIgPSB4ICsgaGFsZlc7XG4gICAgICAgICAgZXkxID0geSAtIGhhbGZIO1xuICAgICAgICAgIGV5MiA9IHkgKyBoYWxmSDtcblxuICAgICAgICAgIHgxID0gZXgxIDwgeDEgPyBleDEgOiB4MTtcbiAgICAgICAgICB4MiA9IGV4MiA+IHgyID8gZXgyIDogeDI7XG4gICAgICAgICAgeTEgPSBleTEgPCB5MSA/IGV5MSA6IHkxO1xuICAgICAgICAgIHkyID0gZXkyID4geTIgPyBleTIgOiB5MjtcblxuICAgICAgICB9IGVsc2UgaWYoIGVsZS5pc0VkZ2UoKSAmJiBpbmNsdWRlRWRnZXMgKXtcbiAgICAgICAgICBpbmNsdWRlZEVsZSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgbjEgPSBfcC5zb3VyY2U7XG4gICAgICAgICAgdmFyIG4xX3AgPSBuMS5fcHJpdmF0ZTtcbiAgICAgICAgICB2YXIgbjFwb3MgPSBuMV9wLnBvc2l0aW9uO1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBuMiA9IF9wLnRhcmdldDtcbiAgICAgICAgICB2YXIgbjJfcCA9IG4yLl9wcml2YXRlO1xuICAgICAgICAgIHZhciBuMnBvcyA9IG4yX3AucG9zaXRpb247XG4gICAgICAgICAgXG5cbiAgICAgICAgICAvLyBoYW5kbGUgZWRnZSBkaW1lbnNpb25zIChyb3VnaCBib3ggZXN0aW1hdGUpXG4gICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZSB8fCB7fTtcblxuICAgICAgICAgIGV4MSA9IG4xcG9zLng7XG4gICAgICAgICAgZXgyID0gbjJwb3MueDtcbiAgICAgICAgICBleTEgPSBuMXBvcy55O1xuICAgICAgICAgIGV5MiA9IG4ycG9zLnk7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGV4MSA+IGV4MiApe1xuICAgICAgICAgICAgdmFyIHRlbXAgPSBleDE7XG4gICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICBleDIgPSB0ZW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBleTEgPiBleTIgKXtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gZXkxO1xuICAgICAgICAgICAgZXkxID0gZXkyO1xuICAgICAgICAgICAgZXkyID0gdGVtcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MSA9IGV4MSA8IHgxID8gZXgxIDogeDE7XG4gICAgICAgICAgeDIgPSBleDIgPiB4MiA/IGV4MiA6IHgyO1xuICAgICAgICAgIHkxID0gZXkxIDwgeTEgPyBleTEgOiB5MTtcbiAgICAgICAgICB5MiA9IGV5MiA+IHkyID8gZXkyIDogeTI7XG5cbiAgICAgICAgICAvLyBoYW5kbGUgcG9pbnRzIGFsb25nIGVkZ2UgKHNhbml0eSBjaGVjaylcbiAgICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAgIGlmKCBzdHlsZUVuYWJsZWQgKXtcbiAgICAgICAgICAgIHZhciBicHRzID0gcnN0eWxlLmJlemllclB0cyB8fCBbXTtcblxuICAgICAgICAgICAgdmFyIHcgPSBzdHlsZVsnd2lkdGgnXS5weFZhbHVlO1xuICAgICAgICAgICAgdmFyIHdIYWxmID0gdy8yO1xuXG4gICAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGJwdHMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgICAgdmFyIGJwdCA9IGJwdHNbal07XG5cbiAgICAgICAgICAgICAgZXgxID0gYnB0LnggLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXgyID0gYnB0LnggKyB3SGFsZjtcbiAgICAgICAgICAgICAgZXkxID0gYnB0LnkgLSB3SGFsZjtcbiAgICAgICAgICAgICAgZXkyID0gYnB0LnkgKyB3SGFsZjtcblxuICAgICAgICAgICAgICB4MSA9IGV4MSA8IHgxID8gZXgxIDogeDE7XG4gICAgICAgICAgICAgIHgyID0gZXgyID4geDIgPyBleDIgOiB4MjtcbiAgICAgICAgICAgICAgeTEgPSBleTEgPCB5MSA/IGV5MSA6IHkxO1xuICAgICAgICAgICAgICB5MiA9IGV5MiA+IHkyID8gZXkyIDogeTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIHByZWNpc2UgaGF5c3RhY2tzIChzYW5pdHkgY2hlY2spXG4gICAgICAgICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgICBcbiAgICAgICAgICBpZiggc3R5bGVFbmFibGVkICYmIHN0eWxlWydjdXJ2ZS1zdHlsZSddLnN0clZhbHVlID09PSAnaGF5c3RhY2snICl7XG4gICAgICAgICAgICB2YXIgaHB0cyA9IF9wLnJzY3JhdGNoLmhheXN0YWNrUHRzO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleDEgPSBocHRzWzBdO1xuICAgICAgICAgICAgZXkxID0gaHB0c1sxXTtcbiAgICAgICAgICAgIGV4MiA9IGhwdHNbMl07XG4gICAgICAgICAgICBleTIgPSBocHRzWzNdO1xuXG4gICAgICAgICAgICBpZiggZXgxID4gZXgyICl7XG4gICAgICAgICAgICAgIHZhciB0ZW1wID0gZXgxO1xuICAgICAgICAgICAgICBleDEgPSBleDI7XG4gICAgICAgICAgICAgIGV4MiA9IHRlbXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBleTEgPiBleTIgKXtcbiAgICAgICAgICAgICAgdmFyIHRlbXAgPSBleTE7XG4gICAgICAgICAgICAgIGV5MSA9IGV5MjtcbiAgICAgICAgICAgICAgZXkyID0gdGVtcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeDEgPSBleDEgPCB4MSA/IGV4MSA6IHgxO1xuICAgICAgICAgICAgeDIgPSBleDIgPiB4MiA/IGV4MiA6IHgyO1xuICAgICAgICAgICAgeTEgPSBleTEgPCB5MSA/IGV5MSA6IHkxO1xuICAgICAgICAgICAgeTIgPSBleTIgPiB5MiA/IGV5MiA6IHkyOyAgXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gLy8gZWRnZXNcbiAgICAgICAgICAgIFxuXG4gICAgICAgIC8vIGhhbmRsZSBsYWJlbCBkaW1lbnNpb25zXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAgICAgaWYoIHN0eWxlRW5hYmxlZCApe1xuXG4gICAgICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuICAgICAgICAgIHZhciByc3R5bGUgPSBlbGUuX3ByaXZhdGUucnN0eWxlO1xuICAgICAgICAgIHZhciBsYWJlbCA9IHN0eWxlWydjb250ZW50J10uc3RyVmFsdWU7XG4gICAgICAgICAgdmFyIGZvbnRTaXplID0gc3R5bGVbJ2ZvbnQtc2l6ZSddO1xuICAgICAgICAgIHZhciBoYWxpZ24gPSBzdHlsZVsndGV4dC1oYWxpZ24nXTtcbiAgICAgICAgICB2YXIgdmFsaWduID0gc3R5bGVbJ3RleHQtdmFsaWduJ107XG4gICAgICAgICAgdmFyIGxhYmVsV2lkdGggPSByc3R5bGUubGFiZWxXaWR0aDtcbiAgICAgICAgICB2YXIgbGFiZWxIZWlnaHQgPSByc3R5bGUubGFiZWxIZWlnaHQ7XG4gICAgICAgICAgdmFyIGxhYmVsWCA9IHJzdHlsZS5sYWJlbFg7XG4gICAgICAgICAgdmFyIGxhYmVsWSA9IHJzdHlsZS5sYWJlbFk7XG5cbiAgICAgICAgICBpZiggaW5jbHVkZWRFbGUgJiYgaW5jbHVkZUxhYmVscyAmJiBsYWJlbCAmJiBmb250U2l6ZSAmJiBsYWJlbEhlaWdodCAhPSBudWxsICYmIGxhYmVsV2lkdGggIT0gbnVsbCAmJiBsYWJlbFggIT0gbnVsbCAmJiBsYWJlbFkgIT0gbnVsbCAmJiBoYWxpZ24gJiYgdmFsaWduICl7XG4gICAgICAgICAgICB2YXIgbGggPSBsYWJlbEhlaWdodDtcbiAgICAgICAgICAgIHZhciBsdyA9IGxhYmVsV2lkdGg7XG4gICAgICAgICAgICB2YXIgbHgxLCBseDIsIGx5MSwgbHkyO1xuXG4gICAgICAgICAgICBpZiggZWxlLmlzRWRnZSgpICl7XG4gICAgICAgICAgICAgIGx4MSA9IGxhYmVsWCAtIGx3LzI7XG4gICAgICAgICAgICAgIGx4MiA9IGxhYmVsWCArIGx3LzI7XG4gICAgICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoLzI7XG4gICAgICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoLzI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzd2l0Y2goIGhhbGlnbi52YWx1ZSApe1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgICAgbHgxID0gbGFiZWxYIC0gbHc7XG4gICAgICAgICAgICAgICAgICBseDIgPSBsYWJlbFg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICAgICAgICBseDEgPSBsYWJlbFggLSBsdy8yO1xuICAgICAgICAgICAgICAgICAgbHgyID0gbGFiZWxYICsgbHcvMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgbHgxID0gbGFiZWxYO1xuICAgICAgICAgICAgICAgICAgbHgyID0gbGFiZWxYICsgbHc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN3aXRjaCggdmFsaWduLnZhbHVlICl7XG4gICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgICAgIGx5MSA9IGxhYmVsWSAtIGxoO1xuICAgICAgICAgICAgICAgICAgbHkyID0gbGFiZWxZO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgbHkxID0gbGFiZWxZIC0gbGgvMjtcbiAgICAgICAgICAgICAgICAgIGx5MiA9IGxhYmVsWSArIGxoLzI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICBseTEgPSBsYWJlbFk7XG4gICAgICAgICAgICAgICAgICBseTIgPSBsYWJlbFkgKyBsaDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHgxID0gbHgxIDwgeDEgPyBseDEgOiB4MTtcbiAgICAgICAgICAgIHgyID0gbHgyID4geDIgPyBseDIgOiB4MjtcbiAgICAgICAgICAgIHkxID0gbHkxIDwgeTEgPyBseTEgOiB5MTtcbiAgICAgICAgICAgIHkyID0gbHkyID4geTIgPyBseTIgOiB5MjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gc3R5bGUgZW5hYmxlZFxuICAgICAgfSAvLyBmb3JcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHgxLFxuICAgICAgICB4MjogeDIsXG4gICAgICAgIHkxOiB5MSxcbiAgICAgICAgeTI6IHkyLFxuICAgICAgICB3OiB4MiAtIHgxLFxuICAgICAgICBoOiB5MiAtIHkxXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWxpYXNlc1xuICB2YXIgZm4gPSAkJC5lbGVzZm47XG4gIGZuLmF0dHIgPSBmbi5kYXRhO1xuICBmbi5yZW1vdmVBdHRyID0gZm4ucmVtb3ZlRGF0YTtcbiAgZm4ubW9kZWxQb3NpdGlvbiA9IGZuLnBvaW50ID0gZm4ucG9zaXRpb247XG4gIGZuLm1vZGVsUG9zaXRpb25zID0gZm4ucG9pbnRzID0gZm4ucG9zaXRpb25zO1xuICBmbi5yZW5kZXJlZFBvaW50ID0gZm4ucmVuZGVyZWRQb3NpdGlvbjtcbiAgZm4ucmVsYXRpdmVQb2ludCA9IGZuLnJlbGF0aXZlUG9zaXRpb247XG4gIGZuLmJvdW5kaW5nYm94ID0gZm4uYm91bmRpbmdCb3g7XG4gIGZuLnJlbmRlcmVkQm91bmRpbmdib3ggPSBmbi5yZW5kZXJlZEJvdW5kaW5nQm94O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oICQkICl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIFJlZ3VsYXIgZGVncmVlIGZ1bmN0aW9ucyAod29ya3Mgb24gc2luZ2xlIGVsZW1lbnQpXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgXG4gIGZ1bmN0aW9uIGRlZmluZURlZ3JlZUZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oIGluY2x1ZGVMb29wcyApe1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICBpZiggaW5jbHVkZUxvb3BzID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgaW5jbHVkZUxvb3BzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIHNlbGYubGVuZ3RoID09PSAwICl7IHJldHVybjsgfVxuXG4gICAgICBpZiggc2VsZi5pc05vZGUoKSAmJiAhc2VsZi5yZW1vdmVkKCkgKXtcbiAgICAgICAgdmFyIGRlZ3JlZSA9IDA7XG4gICAgICAgIHZhciBub2RlID0gc2VsZlswXTtcbiAgICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5fcHJpdmF0ZS5lZGdlcztcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbm5lY3RlZEVkZ2VzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBjb25uZWN0ZWRFZGdlc1tpXTtcblxuICAgICAgICAgIGlmKCAhaW5jbHVkZUxvb3BzICYmIGVkZ2UuaXNMb29wKCkgKXtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZ3JlZSArPSBjYWxsYmFjayggbm9kZSwgZWRnZSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZGVncmVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgXG4gICQkLmZuLmVsZXMoe1xuICAgIGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24obm9kZSwgZWRnZSl7XG4gICAgICBpZiggZWRnZS5zb3VyY2UoKS5zYW1lKCBlZGdlLnRhcmdldCgpICkgKXtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIGluZGVncmVlOiBkZWZpbmVEZWdyZWVGdW5jdGlvbihmdW5jdGlvbihub2RlLCBlZGdlKXtcbiAgICAgIGlmKCBlZGdlLnRhcmdldCgpLnNhbWUobm9kZSkgKXtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9KSxcblxuICAgIG91dGRlZ3JlZTogZGVmaW5lRGVncmVlRnVuY3Rpb24oZnVuY3Rpb24obm9kZSwgZWRnZSl7XG4gICAgICBpZiggZWRnZS5zb3VyY2UoKS5zYW1lKG5vZGUpICl7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSlcbiAgfSk7XG4gIFxuICBcbiAgLy8gQ29sbGVjdGlvbiBkZWdyZWUgc3RhdHNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgZnVuY3Rpb24gZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oZGVncmVlRm4sIGNhbGxiYWNrKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oIGluY2x1ZGVMb29wcyApe1xuICAgICAgdmFyIHJldDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBkZWdyZWUgPSBlbGVbZGVncmVlRm5dKCBpbmNsdWRlTG9vcHMgKTtcbiAgICAgICAgaWYoIGRlZ3JlZSAhPT0gdW5kZWZpbmVkICYmIChyZXQgPT09IHVuZGVmaW5lZCB8fCBjYWxsYmFjayhkZWdyZWUsIHJldCkpICl7XG4gICAgICAgICAgcmV0ID0gZGVncmVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfVxuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgbWluRGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtaW4pe1xuICAgICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgICB9KSxcblxuICAgIG1heERlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2RlZ3JlZScsIGZ1bmN0aW9uKGRlZ3JlZSwgbWF4KXtcbiAgICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gICAgfSksXG5cbiAgICBtaW5JbmRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ2luZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtaW4pe1xuICAgICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgICB9KSxcblxuICAgIG1heEluZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignaW5kZWdyZWUnLCBmdW5jdGlvbihkZWdyZWUsIG1heCl7XG4gICAgICByZXR1cm4gZGVncmVlID4gbWF4O1xuICAgIH0pLFxuXG4gICAgbWluT3V0ZGVncmVlOiBkZWZpbmVEZWdyZWVCb3VuZHNGdW5jdGlvbignb3V0ZGVncmVlJywgZnVuY3Rpb24oZGVncmVlLCBtaW4pe1xuICAgICAgcmV0dXJuIGRlZ3JlZSA8IG1pbjtcbiAgICB9KSxcblxuICAgIG1heE91dGRlZ3JlZTogZGVmaW5lRGVncmVlQm91bmRzRnVuY3Rpb24oJ291dGRlZ3JlZScsIGZ1bmN0aW9uKGRlZ3JlZSwgbWF4KXtcbiAgICAgIHJldHVybiBkZWdyZWUgPiBtYXg7XG4gICAgfSlcbiAgfSk7XG4gIFxuICAkJC5mbi5lbGVzKHtcbiAgICB0b3RhbERlZ3JlZTogZnVuY3Rpb24oIGluY2x1ZGVMb29wcyApe1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIHZhciBub2RlcyA9IHRoaXMubm9kZXMoKTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB0b3RhbCArPSBub2Rlc1tpXS5kZWdyZWUoIGluY2x1ZGVMb29wcyApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG90YWw7XG4gICAgfVxuICB9KTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbiAgXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgLy8gRnVuY3Rpb25zIGZvciBiaW5kaW5nICYgdHJpZ2dlcmluZyBldmVudHNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgb246ICQkLmRlZmluZS5vbigpLCAvLyAub24oIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgZGF0YV0sIGhhbmRsZXIpXG4gICAgb25lOiAkJC5kZWZpbmUub24oeyB1bmJpbmRTZWxmT25UcmlnZ2VyOiB0cnVlIH0pLFxuICAgIG9uY2U6ICQkLmRlZmluZS5vbih7IHVuYmluZEFsbEJpbmRlcnNPblRyaWdnZXI6IHRydWUgfSksXG4gICAgb2ZmOiAkJC5kZWZpbmUub2ZmKCksIC8vIC5vZmYoIGV2ZW50cyBbLCBzZWxlY3Rvcl0gWywgaGFuZGxlcl0gKVxuICAgIHRyaWdnZXI6ICQkLmRlZmluZS50cmlnZ2VyKCksIC8vIC50cmlnZ2VyKCBldmVudHMgWywgZXh0cmFQYXJhbXNdIClcblxuICAgIHJ0cmlnZ2VyOiBmdW5jdGlvbihldmVudCwgZXh0cmFQYXJhbXMpeyAvLyBmb3IgaW50ZXJuYWwgdXNlIG9ubHlcbiAgICAgIGlmKCB0aGlzLmxlbmd0aCA9PT0gMCApeyByZXR1cm47IH0gLy8gZW1wdHkgY29sbGVjdGlvbnMgZG9uJ3QgbmVlZCB0byBub3RpZnkgYW55dGhpbmdcblxuICAgICAgLy8gbm90aWZ5IHJlbmRlcmVyXG4gICAgICB0aGlzLmN5KCkubm90aWZ5KHtcbiAgICAgICAgdHlwZTogZXZlbnQsXG4gICAgICAgIGNvbGxlY3Rpb246IHRoaXNcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB0aGlzLnRyaWdnZXIoZXZlbnQsIGV4dHJhUGFyYW1zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWxpYXNlczpcbiAgJCQuZGVmaW5lLmV2ZW50QWxpYXNlc09uKCAkJC5lbGVzZm4gKTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgbm9kZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKGksIGVsZW1lbnQpe1xuICAgICAgICByZXR1cm4gZWxlbWVudC5pc05vZGUoKTtcbiAgICAgIH0pLmZpbHRlcihzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIGVkZ2VzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHJldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbihpLCBlbGVtZW50KXtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuaXNFZGdlKCk7XG4gICAgICB9KS5maWx0ZXIoc2VsZWN0b3IpO1xuICAgIH0sXG5cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKCBmaWx0ZXIgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG4gICAgICBcbiAgICAgIGlmKCAkJC5pcy5mbihmaWx0ZXIpICl7XG4gICAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgaWYoIGZpbHRlci5hcHBseShlbGUsIFtpLCBlbGVdKSApe1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBlbGVtZW50cyk7XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiggJCQuaXMuc3RyaW5nKGZpbHRlcikgfHwgJCQuaXMuZWxlbWVudE9yQ29sbGVjdGlvbihmaWx0ZXIpICl7XG4gICAgICAgIHJldHVybiBuZXcgJCQuU2VsZWN0b3IoZmlsdGVyKS5maWx0ZXIodGhpcyk7XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiggZmlsdGVyID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3kgKTsgLy8gaWYgbm90IGhhbmRsZWQgYnkgYWJvdmUsIGdpdmUgJ2VtIGFuIGVtcHR5IGNvbGxlY3Rpb25cbiAgICB9LFxuXG4gICAgbm90OiBmdW5jdGlvbiggdG9SZW1vdmUgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGlmKCAhdG9SZW1vdmUgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgXG4gICAgICAgIGlmKCAkJC5pcy5zdHJpbmcoIHRvUmVtb3ZlICkgKXtcbiAgICAgICAgICB0b1JlbW92ZSA9IHRoaXMuZmlsdGVyKCB0b1JlbW92ZSApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpc1tpXTtcblxuICAgICAgICAgIHZhciByZW1vdmUgPSB0b1JlbW92ZS5fcHJpdmF0ZS5pZHNbIGVsZW1lbnQuaWQoKSBdO1xuICAgICAgICAgIGlmKCAhcmVtb3ZlICl7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKCBlbGVtZW50ICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBlbGVtZW50cyApO1xuICAgICAgfVxuICAgICAgXG4gICAgfSxcblxuICAgIGFic29sdXRlQ29tcGxlbWVudDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIHJldHVybiBjeS5lbGVtZW50cygpLm5vdCggdGhpcyApO1xuICAgIH0sXG5cbiAgICBpbnRlcnNlY3Q6IGZ1bmN0aW9uKCBvdGhlciApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIFxuICAgICAgLy8gaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWQsIHRoZW4gZmlsdGVyIGJ5IGl0IGluc3RlYWRcbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcob3RoZXIpICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IG90aGVyO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgICAgdmFyIGNvbDIgPSBvdGhlcjtcbiAgICAgIHZhciBjb2wxU21hbGxlciA9IHRoaXMubGVuZ3RoIDwgb3RoZXIubGVuZ3RoO1xuICAgICAgLy8gdmFyIGlkczEgPSBjb2wxU21hbGxlciA/IGNvbDEuX3ByaXZhdGUuaWRzIDogY29sMi5fcHJpdmF0ZS5pZHM7XG4gICAgICB2YXIgaWRzMiA9IGNvbDFTbWFsbGVyID8gY29sMi5fcHJpdmF0ZS5pZHMgOiBjb2wxLl9wcml2YXRlLmlkcztcbiAgICAgIHZhciBjb2wgPSBjb2wxU21hbGxlciA/IGNvbDEgOiBjb2wyO1xuICAgICAgXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgaWQgPSBjb2xbaV0uX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgdmFyIGVsZSA9IGlkczJbIGlkIF07XG5cbiAgICAgICAgaWYoIGVsZSApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzICk7XG4gICAgfSxcblxuICAgIHhvcjogZnVuY3Rpb24oIG90aGVyICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKG90aGVyKSApe1xuICAgICAgICBvdGhlciA9IGN5LiQoIG90aGVyICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGNvbDEgPSB0aGlzO1xuICAgICAgdmFyIGNvbDIgPSBvdGhlcjtcbiAgICAgIFxuICAgICAgdmFyIGFkZCA9IGZ1bmN0aW9uKCBjb2wsIG90aGVyICl7XG5cbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjb2wubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gY29sW2ldO1xuICAgICAgICAgIHZhciBpZCA9IGVsZS5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICAgIHZhciBpbk90aGVyID0gb3RoZXIuX3ByaXZhdGUuaWRzWyBpZCBdO1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCAhaW5PdGhlciApe1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH07XG5cbiAgICAgIGFkZCggY29sMSwgY29sMiApO1xuICAgICAgYWRkKCBjb2wyLCBjb2wxICk7XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGVsZW1lbnRzICk7XG4gICAgfSwgIFxuXG4gICAgZGlmZjogZnVuY3Rpb24oIG90aGVyICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBpZiggJCQuaXMuc3RyaW5nKG90aGVyKSApe1xuICAgICAgICBvdGhlciA9IGN5LiQoIG90aGVyICk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZWZ0ID0gW107XG4gICAgICB2YXIgcmlnaHQgPSBbXTtcbiAgICAgIHZhciBib3RoID0gW107XG4gICAgICB2YXIgY29sMSA9IHRoaXM7XG4gICAgICB2YXIgY29sMiA9IG90aGVyO1xuXG4gICAgICB2YXIgYWRkID0gZnVuY3Rpb24oIGNvbCwgb3RoZXIsIHJldEVsZXMgKXtcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBjb2xbaV07XG4gICAgICAgICAgdmFyIGlkID0gZWxlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgICAgdmFyIGluT3RoZXIgPSBvdGhlci5fcHJpdmF0ZS5pZHNbIGlkIF07XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGluT3RoZXIgKXtcbiAgICAgICAgICAgIGJvdGgucHVzaCggZWxlICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldEVsZXMucHVzaCggZWxlICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH07XG5cbiAgICAgIGFkZCggY29sMSwgY29sMiwgbGVmdCApO1xuICAgICAgYWRkKCBjb2wyLCBjb2wxLCByaWdodCApO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGxlZnQsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgICAgcmlnaHQ6IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgcmlnaHQsIHsgdW5pcXVlOiB0cnVlIH0gKSxcbiAgICAgICAgYm90aDogbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBib3RoLCB7IHVuaXF1ZTogdHJ1ZSB9IClcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24oIHRvQWRkICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5OyAgICBcbiAgICAgIFxuICAgICAgaWYoICF0b0FkZCApe1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoICQkLmlzLnN0cmluZyh0b0FkZCkgKXtcbiAgICAgICAgdmFyIHNlbGVjdG9yID0gdG9BZGQ7XG4gICAgICAgIHRvQWRkID0gY3kuZWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZWxlbWVudHMgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGVsZW1lbnRzLnB1c2goIHRoaXNbaV0gKTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKyApe1xuXG4gICAgICAgIHZhciBhZGQgPSAhdGhpcy5fcHJpdmF0ZS5pZHNbIHRvQWRkW2ldLmlkKCkgXTtcbiAgICAgICAgaWYoIGFkZCApe1xuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIHRvQWRkW2ldICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBlbGVtZW50cyk7XG4gICAgfSxcblxuICAgIC8vIGluIHBsYWNlIG1lcmdlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICAgIG1lcmdlOiBmdW5jdGlvbiggdG9BZGQgKXtcbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgY3kgPSBfcC5jeTsgICAgXG4gICAgICBcbiAgICAgIGlmKCAhdG9BZGQgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcodG9BZGQpICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRvQWRkO1xuICAgICAgICB0b0FkZCA9IGN5LmVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0b0FkZC5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgdG9BZGRFbGUgPSB0b0FkZFtpXTtcbiAgICAgICAgdmFyIGlkID0gdG9BZGRFbGUuaWQoKTtcbiAgICAgICAgdmFyIGFkZCA9ICFfcC5pZHNbIGlkIF07XG5cbiAgICAgICAgaWYoIGFkZCApe1xuICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMubGVuZ3RoKys7XG5cbiAgICAgICAgICB0aGlzWyBpbmRleCBdID0gdG9BZGRFbGU7XG4gICAgICAgICAgX3AuaWRzWyBpZCBdID0gdG9BZGRFbGU7XG4gICAgICAgICAgX3AuaW5kZXhlc1sgaWQgXSA9IGluZGV4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICAvLyByZW1vdmUgc2luZ2xlIGVsZSBpbiBwbGFjZSBpbiBjYWxsaW5nIGNvbGxlY3Rpb25cbiAgICB1bm1lcmdlT25lOiBmdW5jdGlvbiggZWxlICl7XG4gICAgICBlbGUgPSBlbGVbMF07XG5cbiAgICAgIHZhciBfcCA9IHRoaXMuX3ByaXZhdGU7XG4gICAgICB2YXIgaWQgPSBlbGUuaWQoKTtcbiAgICAgIHZhciBpID0gX3AuaW5kZXhlc1sgaWQgXTtcblxuICAgICAgaWYoIGkgPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gdGhpczsgLy8gbm8gbmVlZCB0byByZW1vdmVcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGVsZVxuICAgICAgdGhpc1tpXSA9IHVuZGVmaW5lZDtcbiAgICAgIF9wLmlkc1sgaWQgXSA9IHVuZGVmaW5lZDtcbiAgICAgIF9wLmluZGV4ZXNbIGlkIF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciB1bm1lcmdlZExhc3RFbGUgPSBpID09PSB0aGlzLmxlbmd0aCAtIDE7XG5cbiAgICAgIC8vIHJlcGxhY2UgZW1wdHkgc3BvdCB3aXRoIGxhc3QgZWxlIGluIGNvbGxlY3Rpb25cbiAgICAgIGlmKCB0aGlzLmxlbmd0aCA+IDEgJiYgIXVubWVyZ2VkTGFzdEVsZSApe1xuICAgICAgICB2YXIgbGFzdEVsZUkgPSB0aGlzLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBsYXN0RWxlID0gdGhpc1sgbGFzdEVsZUkgXTtcblxuICAgICAgICB0aGlzWyBsYXN0RWxlSSBdID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzW2ldID0gbGFzdEVsZTtcbiAgICAgICAgX3AuaW5kZXhlc1sgbGFzdEVsZS5pZCgpIF0gPSBpO1xuICAgICAgfVxuXG4gICAgICAvLyB0aGUgY29sbGVjdGlvbiBpcyBub3cgMSBlbGUgc21hbGxlclxuICAgICAgdGhpcy5sZW5ndGgtLTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIHJlbW92ZSBlbGVzIGluIHBsYWNlIG9uIGNhbGxpbmcgY29sbGVjdGlvblxuICAgIHVubWVyZ2U6IGZ1bmN0aW9uKCB0b1JlbW92ZSApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTsgICAgXG4gICAgICBcbiAgICAgIGlmKCAhdG9SZW1vdmUgKXtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcodG9SZW1vdmUpICl7XG4gICAgICAgIHZhciBzZWxlY3RvciA9IHRvUmVtb3ZlO1xuICAgICAgICB0b1JlbW92ZSA9IGN5LmVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgIH1cblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0b1JlbW92ZS5sZW5ndGg7IGkrKyApe1xuICAgICAgICB0aGlzLnVubWVyZ2VPbmUoIHRvUmVtb3ZlW2ldICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBtYXA6IGZ1bmN0aW9uKCBtYXBGbiwgdGhpc0FyZyApe1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciByZXQgPSB0aGlzQXJnID8gbWFwRm4uYXBwbHkoIHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdICkgOiBtYXBGbiggZWxlLCBpLCBlbGVzICk7XG5cbiAgICAgICAgYXJyLnB1c2goIHJldCApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0sXG5cbiAgICBzdGRGaWx0ZXI6IGZ1bmN0aW9uKCBmbiwgdGhpc0FyZyApe1xuICAgICAgdmFyIGZpbHRlckVsZXMgPSBbXTtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBjeSA9IHRoaXMuX3ByaXZhdGUuY3k7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIGluY2x1ZGUgPSB0aGlzQXJnID8gZm4uYXBwbHkoIHRoaXNBcmcsIFtlbGUsIGksIGVsZXNdICkgOiBmbiggZWxlLCBpLCBlbGVzICk7XG5cbiAgICAgICAgaWYoIGluY2x1ZGUgKXtcbiAgICAgICAgICBmaWx0ZXJFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIGZpbHRlckVsZXMgKTtcbiAgICB9LFxuXG4gICAgbWF4OiBmdW5jdGlvbiggdmFsRm4sIHRoaXNBcmcgKXtcbiAgICAgIHZhciBtYXggPSAtSW5maW5pdHk7XG4gICAgICB2YXIgbWF4RWxlO1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciB2YWwgPSB0aGlzQXJnID8gdmFsRm4uYXBwbHkoIHRoaXNBcmcsIFsgZWxlLCBpLCBlbGVzIF0gKSA6IHZhbEZuKCBlbGUsIGksIGVsZXMgKTtcblxuICAgICAgICBpZiggdmFsID4gbWF4ICl7XG4gICAgICAgICAgbWF4ID0gdmFsO1xuICAgICAgICAgIG1heEVsZSA9IGVsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogbWF4LFxuICAgICAgICBlbGU6IG1heEVsZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgbWluOiBmdW5jdGlvbiggdmFsRm4sIHRoaXNBcmcgKXtcbiAgICAgIHZhciBtaW4gPSBJbmZpbml0eTtcbiAgICAgIHZhciBtaW5FbGU7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXNBcmcgPyB2YWxGbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIGVsZXMgXSApIDogdmFsRm4oIGVsZSwgaSwgZWxlcyApO1xuXG4gICAgICAgIGlmKCB2YWwgPCBtaW4gKXtcbiAgICAgICAgICBtaW4gPSB2YWw7XG4gICAgICAgICAgbWluRWxlID0gZWxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBtaW4sXG4gICAgICAgIGVsZTogbWluRWxlXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWxpYXNlc1xuICB2YXIgZm4gPSAkJC5lbGVzZm47XG4gIGZuWyd1J10gPSBmblsnfCddID0gZm5bJysnXSA9IGZuLnVuaW9uID0gZm4ub3IgPSBmbi5hZGQ7XG4gIGZuWydcXFxcJ10gPSBmblsnISddID0gZm5bJy0nXSA9IGZuLmRpZmZlcmVuY2UgPSBmbi5yZWxhdGl2ZUNvbXBsZW1lbnQgPSBmbi5ub3Q7XG4gIGZuWyduJ10gPSBmblsnJiddID0gZm5bJy4nXSA9IGZuLmFuZCA9IGZuLmludGVyc2VjdGlvbiA9IGZuLmludGVyc2VjdDtcbiAgZm5bJ14nXSA9IGZuWycoKyknXSA9IGZuWycoLSknXSA9IGZuLnN5bW1ldHJpY0RpZmZlcmVuY2UgPSBmbi5zeW1kaWZmID0gZm4ueG9yO1xuICBmbi5mbkZpbHRlciA9IGZuLmZpbHRlckZuID0gZm4uc3RkRmlsdGVyO1xuICBmbi5jb21wbGVtZW50ID0gZm4uYWJzY29tcCA9IGZuLmFic29sdXRlQ29tcGxlbWVudDtcbiAgXG59KSggY3l0b3NjYXBlICk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIGlzTm9kZTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdub2Rlcyc7XG4gICAgfSxcblxuICAgIGlzRWRnZTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmdyb3VwKCkgPT09ICdlZGdlcyc7XG4gICAgfSxcblxuICAgIGlzTG9vcDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKCkuaWQoKSA9PT0gdGhpcy50YXJnZXQoKS5pZCgpO1xuICAgIH0sXG5cbiAgICBpc1NpbXBsZTogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmlzRWRnZSgpICYmIHRoaXMuc291cmNlKCkuaWQoKSAhPT0gdGhpcy50YXJnZXQoKS5pZCgpO1xuICAgIH0sXG5cbiAgICBncm91cDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuZ3JvdXA7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIEZ1bmN0aW9ucyBmb3IgaXRlcmF0aW5nIG92ZXIgY29sbGVjdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgJCQuZm4uZWxlcyh7XG4gICAgZWFjaDogZnVuY3Rpb24oZm4pe1xuICAgICAgaWYoICQkLmlzLmZuKGZuKSApe1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIHJldCA9IGZuLmFwcGx5KCBlbGUsIFsgaSwgZWxlIF0gKTtcblxuICAgICAgICAgIGlmKCByZXQgPT09IGZhbHNlICl7IGJyZWFrOyB9IC8vIGV4aXQgZWFjaCBlYXJseSBvbiByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGZuLCB0aGlzQXJnKXtcbiAgICAgIGlmKCAkJC5pcy5mbihmbikgKXtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIHJldCA9IHRoaXNBcmcgPyBmbi5hcHBseSggdGhpc0FyZywgWyBlbGUsIGksIHRoaXMgXSApIDogZm4oIGVsZSwgaSwgdGhpcyApO1xuXG4gICAgICAgICAgaWYoIHJldCA9PT0gZmFsc2UgKXsgYnJlYWs7IH0gLy8gZXhpdCBlYWNoIGVhcmx5IG9uIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0FycmF5OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGFycmF5ID0gW107XG4gICAgICBcbiAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgYXJyYXkucHVzaCggdGhpc1tpXSApO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfSxcblxuICAgIHNsaWNlOiBmdW5jdGlvbihzdGFydCwgZW5kKXtcbiAgICAgIHZhciBhcnJheSA9IFtdO1xuICAgICAgdmFyIHRoaXNTaXplID0gdGhpcy5sZW5ndGg7XG4gICAgICBcbiAgICAgIGlmKCBlbmQgPT0gbnVsbCApe1xuICAgICAgICBlbmQgPSB0aGlzU2l6ZTtcbiAgICAgIH1cblxuICAgICAgaWYoIHN0YXJ0ID09IG51bGwgKXtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggc3RhcnQgPCAwICl7XG4gICAgICAgIHN0YXJ0ID0gdGhpc1NpemUgKyBzdGFydDtcbiAgICAgIH1cblxuICAgICAgaWYoIGVuZCA8IDAgKXtcbiAgICAgICAgZW5kID0gdGhpc1NpemUgKyBlbmQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvcih2YXIgaSA9IHN0YXJ0OyBpID49IDAgJiYgaSA8IGVuZCAmJiBpIDwgdGhpc1NpemU7IGkrKyl7XG4gICAgICAgIGFycmF5LnB1c2goIHRoaXNbaV0gKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKHRoaXMuY3koKSwgYXJyYXkpO1xuICAgIH0sXG5cbiAgICBzaXplOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBlcTogZnVuY3Rpb24oaSl7XG4gICAgICByZXR1cm4gdGhpc1tpXSB8fCBuZXcgJCQuQ29sbGVjdGlvbiggdGhpcy5jeSgpICk7XG4gICAgfSxcblxuICAgIGZpcnN0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXNbMF0gfHwgbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuY3koKSApO1xuICAgIH0sXG5cbiAgICBsYXN0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXNbIHRoaXMubGVuZ3RoIC0gMSBdIHx8IG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLmN5KCkgKTtcbiAgICB9LFxuXG4gICAgZW1wdHk6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gICAgfSxcblxuICAgIG5vbmVtcHR5OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuICF0aGlzLmVtcHR5KCk7XG4gICAgfSxcblxuICAgIHNvcnQ6IGZ1bmN0aW9uKCBzb3J0Rm4gKXtcbiAgICAgIGlmKCAhJCQuaXMuZm4oIHNvcnRGbiApICl7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7ICAgICAgXG4gICAgICB2YXIgc29ydGVkID0gdGhpcy50b0FycmF5KCkuc29ydCggc29ydEZuICk7XG5cbiAgICAgIHJldHVybiBuZXcgJCQuQ29sbGVjdGlvbihjeSwgc29ydGVkKTtcbiAgICB9LFxuXG4gICAgc29ydEJ5WkluZGV4OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuc29ydCggJCQuQ29sbGVjdGlvbi56SW5kZXhTb3J0ICk7XG4gICAgfSxcblxuICAgIHpEZXB0aDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgaWYoICFlbGUgKXsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gICAgICAvLyB2YXIgY3kgPSBlbGUuY3koKTtcbiAgICAgIHZhciBfcCA9IGVsZS5fcHJpdmF0ZTtcbiAgICAgIHZhciBncm91cCA9IF9wLmdyb3VwO1xuXG4gICAgICBpZiggZ3JvdXAgPT09ICdub2RlcycgKXtcbiAgICAgICAgdmFyIGRlcHRoID0gX3AuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpLnNpemUoKSA6IDA7XG4gICAgICAgIFxuICAgICAgICBpZiggIWVsZS5pc1BhcmVudCgpICl7XG4gICAgICAgICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7IC8vIGNoaWxkbGVzcyBub2RlcyBhbHdheXMgb24gdG9wXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSBfcC50YXJnZXQ7XG4gICAgICAgIHZhciBzcmNEZXB0aCA9IHNyYy56RGVwdGgoKTtcbiAgICAgICAgdmFyIHRndERlcHRoID0gdGd0LnpEZXB0aCgpO1xuXG4gICAgICAgIHJldHVybiBNYXRoLm1heCggc3JjRGVwdGgsIHRndERlcHRoLCAwICk7IC8vIGRlcHRoIG9mIGRlZXBlc3QgcGFyZW50XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAkJC5Db2xsZWN0aW9uLnpJbmRleFNvcnQgPSBmdW5jdGlvbihhLCBiKXtcbiAgICB2YXIgY3kgPSBhLmN5KCk7XG4gICAgdmFyIGFfcCA9IGEuX3ByaXZhdGU7XG4gICAgdmFyIGJfcCA9IGIuX3ByaXZhdGU7XG4gICAgdmFyIHpEaWZmID0gYV9wLnN0eWxlWyd6LWluZGV4J10udmFsdWUgLSBiX3Auc3R5bGVbJ3otaW5kZXgnXS52YWx1ZTtcbiAgICB2YXIgZGVwdGhBID0gMDtcbiAgICB2YXIgZGVwdGhCID0gMDtcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgYUlzTm9kZSA9IGFfcC5ncm91cCA9PT0gJ25vZGVzJztcbiAgICB2YXIgYUlzRWRnZSA9IGFfcC5ncm91cCA9PT0gJ2VkZ2VzJztcbiAgICB2YXIgYklzTm9kZSA9IGJfcC5ncm91cCA9PT0gJ25vZGVzJztcbiAgICB2YXIgYklzRWRnZSA9IGJfcC5ncm91cCA9PT0gJ2VkZ2VzJztcblxuICAgIC8vIG5vIG5lZWQgdG8gY2FsY3VsYXRlIGVsZW1lbnQgZGVwdGggaWYgdGhlcmUgaXMgbm8gY29tcG91bmQgbm9kZVxuICAgIGlmKCBoYXNDb21wb3VuZE5vZGVzICl7XG4gICAgICBkZXB0aEEgPSBhLnpEZXB0aCgpO1xuICAgICAgZGVwdGhCID0gYi56RGVwdGgoKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwdGhEaWZmID0gZGVwdGhBIC0gZGVwdGhCO1xuICAgIHZhciBzYW1lRGVwdGggPSBkZXB0aERpZmYgPT09IDA7XG5cbiAgICBpZiggc2FtZURlcHRoICl7XG4gICAgICBcbiAgICAgIGlmKCBhSXNOb2RlICYmIGJJc0VkZ2UgKXsgICAgICBcbiAgICAgICAgcmV0dXJuIDE7IC8vICdhJyBpcyBhIG5vZGUsIGl0IHNob3VsZCBiZSBkcmF3biBsYXRlciAgICAgICBcbiAgICAgIFxuICAgICAgfSBlbHNlIGlmKCBhSXNFZGdlICYmIGJJc05vZGUgKXtcbiAgICAgICAgcmV0dXJuIC0xOyAvLyAnYScgaXMgYW4gZWRnZSwgaXQgc2hvdWxkIGJlIGRyYXduIGZpcnN0XG5cbiAgICAgIH0gZWxzZSB7IC8vIGJvdGggbm9kZXMgb3IgYm90aCBlZGdlcyAgICAgICAgXG4gICAgICAgIGlmKCB6RGlmZiA9PT0gMCApeyAvLyBzYW1lIHotaW5kZXggPT4gY29tcGFyZSBpbmRpY2VzIGluIHRoZSBjb3JlIChvcmRlciBhZGRlZCB0byBncmFwaCB3LyBsYXN0IG9uIHRvcClcbiAgICAgICAgICByZXR1cm4gYV9wLmluZGV4IC0gYl9wLmluZGV4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB6RGlmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIFxuICAgIC8vIGVsZW1lbnRzIG9uIGRpZmZlcmVudCBsZXZlbFxuICAgIH0gZWxzZSB7ICAgICAgXG4gICAgICByZXR1cm4gZGVwdGhEaWZmOyAvLyBkZWVwZXIgZWxlbWVudCBzaG91bGQgYmUgZHJhd24gbGF0ZXJcbiAgICB9XG5cbiAgfTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICAvLyBGdW5jdGlvbnMgZm9yIGxheW91dHMgb24gbm9kZXNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICBcbiAgJCQuZm4uZWxlcyh7XG5cbiAgICAvLyB1c2luZyBzdGFuZGFyZCBsYXlvdXQgb3B0aW9ucywgYXBwbHkgcG9zaXRpb24gZnVuY3Rpb24gKHcvIG9yIHcvbyBhbmltYXRpb24pXG4gICAgbGF5b3V0UG9zaXRpb25zOiBmdW5jdGlvbiggbGF5b3V0LCBvcHRpb25zLCBmbiApe1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICBpZiggb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIHZhciBsYXN0Tm9kZSA9IGkgPT09IG5vZGVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICB2YXIgbmV3UG9zID0gZm4uY2FsbCggbm9kZSwgaSwgbm9kZSApO1xuICAgICAgICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgICBpZiggISQkLmlzLm51bWJlcihwb3MueCkgfHwgISQkLmlzLm51bWJlcihwb3MueSkgKXtcbiAgICAgICAgICAgIG5vZGUuc2lsZW50UG9zaXRpb24oeyB4OiAwLCB5OiAwIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGUuYW5pbWF0ZSh7XG4gICAgICAgICAgICBwb3NpdGlvbjogbmV3UG9zXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgZHVyYXRpb246IG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sXG4gICAgICAgICAgICBzdGVwOiAhbGFzdE5vZGUgPyB1bmRlZmluZWQgOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICAgICAgICBjeS5maXQoIG9wdGlvbnMuZWxlcywgb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29tcGxldGU6ICFsYXN0Tm9kZSA/IHVuZGVmaW5lZCA6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGlmKCBvcHRpb25zLnpvb20gIT0gbnVsbCApe1xuICAgICAgICAgICAgICAgIGN5Lnpvb20oIG9wdGlvbnMuem9vbSApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYoIG9wdGlvbnMucGFuICl7XG4gICAgICAgICAgICAgICAgY3kucGFuKCBvcHRpb25zLnBhbiApO1xuICAgICAgICAgICAgICB9IFxuXG4gICAgICAgICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucG9zaXRpb25zKCBmbiApO1xuXG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5lbGVzLCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRpb25zLnpvb20gIT0gbnVsbCApe1xuICAgICAgICAgIGN5Lnpvb20oIG9wdGlvbnMuem9vbSApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdGlvbnMucGFuICl7XG4gICAgICAgICAgY3kucGFuKCBvcHRpb25zLnBhbiApO1xuICAgICAgICB9IFxuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICAgIFxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgbGF5b3V0OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICBjeS5sYXlvdXQoICQkLnV0aWwuZXh0ZW5kKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIGVsZXM6IHRoaXNcbiAgICAgIH0pICk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtYWtlTGF5b3V0OiBmdW5jdGlvbiggb3B0aW9ucyApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuXG4gICAgICByZXR1cm4gY3kubWFrZUxheW91dCggJCQudXRpbC5leHRlbmQoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgZWxlczogdGhpc1xuICAgICAgfSkgKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gYWxpYXNlczpcbiAgJCQuZWxlc2ZuLmNyZWF0ZUxheW91dCA9ICQkLmVsZXNmbi5tYWtlTGF5b3V0O1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5lbGVzKHtcblxuICAgIC8vIGZ1bGx5IHVwZGF0ZXMgKHJlY2FsY3VsYXRlcykgdGhlIHN0eWxlIGZvciB0aGUgZWxlbWVudHNcbiAgICB1cGRhdGVTdHlsZTogZnVuY3Rpb24oIG5vdGlmeVJlbmRlcmVyICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIGlmKCBjeS5fcHJpdmF0ZS5iYXRjaGluZ1N0eWxlICl7XG4gICAgICAgIHZhciBiRWxlcyA9IGN5Ll9wcml2YXRlLmJhdGNoU3R5bGVFbGVzO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSB0aGlzW2ldO1xuXG4gICAgICAgICAgaWYoICFiRWxlcy5pZHNbIGVsZS5fcHJpdmF0ZS5pZCBdICl7XG4gICAgICAgICAgICBiRWxlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmcgYW5kIGV4aXQgZWFybHkgd2hlbiBiYXRjaGluZ1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuICAgICAgbm90aWZ5UmVuZGVyZXIgPSBub3RpZnlSZW5kZXJlciB8fCBub3RpZnlSZW5kZXJlciA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICBzdHlsZS5hcHBseSggdGhpcyApO1xuXG4gICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgIHZhciB0b05vdGlmeSA9IHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkQ29tcG91bmRzICkgOiB0aGlzO1xuXG4gICAgICBpZiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvTm90aWZ5LnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGp1c3QgZmlyZSB0aGUgZXZlbnRcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICAvLyBqdXN0IHVwZGF0ZSB0aGUgbWFwcGVycyBpbiB0aGUgZWxlbWVudHMnIHN0eWxlczsgY2hlYXBlciB0aGFuIGVsZXMudXBkYXRlU3R5bGUoKVxuICAgIHVwZGF0ZU1hcHBlcnM6IGZ1bmN0aW9uKCBub3RpZnlSZW5kZXJlciApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgICBub3RpZnlSZW5kZXJlciA9IG5vdGlmeVJlbmRlcmVyIHx8IG5vdGlmeVJlbmRlcmVyID09PSB1bmRlZmluZWQgPyB0cnVlIDogZmFsc2U7XG5cbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgc3R5bGUudXBkYXRlTWFwcGVycyggdGhpcyApO1xuXG4gICAgICB2YXIgdXBkYXRlZENvbXBvdW5kcyA9IHRoaXMudXBkYXRlQ29tcG91bmRCb3VuZHMoKTtcbiAgICAgIHZhciB0b05vdGlmeSA9IHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkQ29tcG91bmRzICkgOiB0aGlzO1xuXG4gICAgICBpZiggbm90aWZ5UmVuZGVyZXIgKXtcbiAgICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCByZW5kZXJlciBrbm93IHdlIGNoYW5nZWQgc3R5bGVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvTm90aWZ5LnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGp1c3QgZmlyZSB0aGUgZXZlbnRcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICAvLyBnZXQgdGhlIHNwZWNpZmllZCBjc3MgcHJvcGVydHkgYXMgYSByZW5kZXJlZCB2YWx1ZSAoaS5lLiBvbi1zY3JlZW4gdmFsdWUpXG4gICAgLy8gb3IgZ2V0IHRoZSB3aG9sZSByZW5kZXJlZCBzdHlsZSBpZiBubyBwcm9wZXJ0eSBzcGVjaWZpZWQgKE5CIGRvZXNuJ3QgYWxsb3cgc2V0dGluZylcbiAgICByZW5kZXJlZENzczogZnVuY3Rpb24oIHByb3BlcnR5ICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIHZhciByZW5zdHlsZSA9IGVsZS5jeSgpLnN0eWxlKCkuZ2V0UmVuZGVyZWRTdHlsZSggZWxlICk7XG5cbiAgICAgICAgaWYoIHByb3BlcnR5ID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICByZXR1cm4gcmVuc3R5bGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJlbnN0eWxlWyBwcm9wZXJ0eSBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIHJlYWQgdGhlIGNhbGN1bGF0ZWQgY3NzIHN0eWxlIG9mIHRoZSBlbGVtZW50IG9yIG92ZXJyaWRlIHRoZSBzdHlsZSAodmlhIGEgYnlwYXNzKVxuICAgIGNzczogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBcbiAgICAgIGlmKCAhY3kuc3R5bGVFbmFibGVkKCkgKXsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgdmFyIHVwZGF0ZVRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICB2YXIgc3R5bGUgPSBjeS5zdHlsZSgpO1xuXG4gICAgICBpZiggJCQuaXMucGxhaW5PYmplY3QobmFtZSkgKXsgLy8gdGhlbiBleHRlbmQgdGhlIGJ5cGFzc1xuICAgICAgICB2YXIgcHJvcHMgPSBuYW1lO1xuICAgICAgICBzdHlsZS5hcHBseUJ5cGFzcyggdGhpcywgcHJvcHMsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG5cbiAgICAgICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgIHZhciB0b05vdGlmeSA9IHVwZGF0ZWRDb21wb3VuZHMubGVuZ3RoID4gMCA/IHRoaXMuYWRkKCB1cGRhdGVkQ29tcG91bmRzICkgOiB0aGlzO1xuICAgICAgICB0b05vdGlmeS5ydHJpZ2dlcignc3R5bGUnKTsgLy8gbGV0IHRoZSByZW5kZXJlciBrbm93IHdlJ3ZlIHVwZGF0ZWQgc3R5bGVcblxuICAgICAgfSBlbHNlIGlmKCAkJC5pcy5zdHJpbmcobmFtZSkgKXtcbiAgXG4gICAgICAgIGlmKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICl7IC8vIHRoZW4gZ2V0IHRoZSBwcm9wZXJ0eSBmcm9tIHRoZSBzdHlsZVxuICAgICAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICAgICAgaWYoIGVsZSApe1xuICAgICAgICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5zdHlsZVsgbmFtZSBdLnN0clZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgeyAvLyB0aGVuIHNldCB0aGUgYnlwYXNzIHdpdGggdGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAgc3R5bGUuYXBwbHlCeXBhc3MoIHRoaXMsIG5hbWUsIHZhbHVlLCB1cGRhdGVUcmFuc2l0aW9ucyApO1xuXG4gICAgICAgICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgdmFyIHRvTm90aWZ5ID0gdXBkYXRlZENvbXBvdW5kcy5sZW5ndGggPiAwID8gdGhpcy5hZGQoIHVwZGF0ZWRDb21wb3VuZHMgKSA6IHRoaXM7XG4gICAgICAgICAgdG9Ob3RpZnkucnRyaWdnZXIoJ3N0eWxlJyk7IC8vIGxldCB0aGUgcmVuZGVyZXIga25vdyB3ZSd2ZSB1cGRhdGVkIHN0eWxlXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmKCBuYW1lID09PSB1bmRlZmluZWQgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgICAgaWYoIGVsZSApe1xuICAgICAgICAgIHJldHVybiBzdHlsZS5nZXRSYXdTdHlsZSggZWxlICk7XG4gICAgICAgIH0gZWxzZSB7IC8vIGVtcHR5IGNvbGxlY3Rpb24gPT4gY2FuJ3QgZ2V0IGFueSB2YWx1ZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgcmVtb3ZlQ3NzOiBmdW5jdGlvbiggbmFtZXMgKXtcbiAgICAgIHZhciBjeSA9IHRoaXMuY3koKTtcbiAgICAgIFxuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gdGhpczsgfVxuXG4gICAgICB2YXIgdXBkYXRlVHJhbnNpdGlvbnMgPSBmYWxzZTtcbiAgICAgIHZhciBzdHlsZSA9IGN5LnN0eWxlKCk7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG5cbiAgICAgIGlmKCBuYW1lcyA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICAgICAgc3R5bGUucmVtb3ZlQWxsQnlwYXNzZXMoIGVsZSwgdXBkYXRlVHJhbnNpdGlvbnMgKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZXMgPSBuYW1lcy5zcGxpdCgvXFxzKy8pO1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuXG4gICAgICAgICAgc3R5bGUucmVtb3ZlQnlwYXNzZXMoIGVsZSwgbmFtZXMsIHVwZGF0ZVRyYW5zaXRpb25zICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHVwZGF0ZWRDb21wb3VuZHMgPSB0aGlzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICB2YXIgdG9Ob3RpZnkgPSB1cGRhdGVkQ29tcG91bmRzLmxlbmd0aCA+IDAgPyB0aGlzLmFkZCggdXBkYXRlZENvbXBvdW5kcyApIDogdGhpcztcbiAgICAgIHRvTm90aWZ5LnJ0cmlnZ2VyKCdzdHlsZScpOyAvLyBsZXQgdGhlIHJlbmRlcmVyIGtub3cgd2UndmUgdXBkYXRlZCBzdHlsZVxuXG4gICAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgICB9LFxuXG4gICAgc2hvdzogZnVuY3Rpb24oKXtcbiAgICAgIHRoaXMuY3NzKCdkaXNwbGF5JywgJ2VsZW1lbnQnKTtcbiAgICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIH0sXG5cbiAgICBoaWRlOiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gICAgfSxcblxuICAgIHZpc2libGU6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgICAgdmFyIGhhc0NvbXBvdW5kTm9kZXMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgdmFyIHN0eWxlID0gZWxlLl9wcml2YXRlLnN0eWxlO1xuXG4gICAgICAgIGlmKFxuICAgICAgICAgIHN0eWxlWyd2aXNpYmlsaXR5J10udmFsdWUgIT09ICd2aXNpYmxlJ1xuICAgICAgICAgIHx8IHN0eWxlWydkaXNwbGF5J10udmFsdWUgIT09ICdlbGVtZW50J1xuICAgICAgICApe1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICAgIGlmKCAhaGFzQ29tcG91bmROb2RlcyApeyByZXR1cm4gdHJ1ZTsgfVxuXG4gICAgICAgICAgdmFyIHBhcmVudHMgPSBlbGUuX3ByaXZhdGUuZGF0YS5wYXJlbnQgPyBlbGUucGFyZW50cygpIDogbnVsbDtcblxuICAgICAgICAgIGlmKCBwYXJlbnRzICl7XG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudHNbaV07XG4gICAgICAgICAgICAgIHZhciBwU3R5bGUgPSBwYXJlbnQuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgICAgICAgIHZhciBwVmlzID0gcFN0eWxlWyd2aXNpYmlsaXR5J10udmFsdWU7XG4gICAgICAgICAgICAgIHZhciBwRGlzID0gcFN0eWxlWydkaXNwbGF5J10udmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYoIHBWaXMgIT09ICd2aXNpYmxlJyB8fCBwRGlzICE9PSAnZWxlbWVudCcgKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3JjID0gZWxlLl9wcml2YXRlLnNvdXJjZTtcbiAgICAgICAgICB2YXIgdGd0ID0gZWxlLl9wcml2YXRlLnRhcmdldDtcblxuICAgICAgICAgIHJldHVybiBzcmMudmlzaWJsZSgpICYmIHRndC52aXNpYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH0sXG5cbiAgICBoaWRkZW46IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgaWYoIGVsZSApe1xuICAgICAgICByZXR1cm4gIWVsZS52aXNpYmxlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGVmZmVjdGl2ZU9wYWNpdHk6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiAxOyB9XG5cbiAgICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gY3kuaGFzQ29tcG91bmROb2RlcygpO1xuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgICB2YXIgcGFyZW50T3BhY2l0eSA9IF9wLnN0eWxlLm9wYWNpdHkudmFsdWU7XG5cbiAgICAgICAgaWYoICFoYXNDb21wb3VuZE5vZGVzICl7IHJldHVybiBwYXJlbnRPcGFjaXR5OyB9XG5cbiAgICAgICAgdmFyIHBhcmVudHMgPSAhX3AuZGF0YS5wYXJlbnQgPyBudWxsIDogZWxlLnBhcmVudHMoKTtcbiAgICAgICAgXG4gICAgICAgIGlmKCBwYXJlbnRzICl7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50c1tpXTtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gcGFyZW50Ll9wcml2YXRlLnN0eWxlLm9wYWNpdHkudmFsdWU7XG5cbiAgICAgICAgICAgIHBhcmVudE9wYWNpdHkgPSBvcGFjaXR5ICogcGFyZW50T3BhY2l0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyZW50T3BhY2l0eTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdHJhbnNwYXJlbnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBoYXNDb21wb3VuZE5vZGVzID0gZWxlLmN5KCkuaGFzQ29tcG91bmROb2RlcygpO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIGlmKCAhaGFzQ29tcG91bmROb2RlcyApe1xuICAgICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGUuc3R5bGUub3BhY2l0eS52YWx1ZSA9PT0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZWxlLmVmZmVjdGl2ZU9wYWNpdHkoKSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBpc0Z1bGxBdXRvUGFyZW50OiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGN5ID0gdGhpcy5jeSgpO1xuICAgICAgaWYoICFjeS5zdHlsZUVuYWJsZWQoKSApeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgdmFyIGF1dG9XID0gZWxlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnZhbHVlID09PSAnYXV0byc7XG4gICAgICAgIHZhciBhdXRvSCA9IGVsZS5fcHJpdmF0ZS5zdHlsZVsnaGVpZ2h0J10udmFsdWUgPT09ICdhdXRvJztcblxuICAgICAgICByZXR1cm4gZWxlLmlzUGFyZW50KCkgJiYgYXV0b1cgJiYgYXV0b0g7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGJhY2tncm91bmRpbmc6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgY3kgPSB0aGlzLmN5KCk7XG4gICAgICBpZiggIWN5LnN0eWxlRW5hYmxlZCgpICl7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcblxuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5iYWNrZ3JvdW5kaW5nID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cblxuICB9KTtcblxuXG4gICQkLmVsZXNmbi5ieXBhc3MgPSAkJC5lbGVzZm4uc3R5bGUgPSAkJC5lbGVzZm4uY3NzO1xuICAkJC5lbGVzZm4ucmVuZGVyZWRTdHlsZSA9ICQkLmVsZXNmbi5yZW5kZXJlZENzcztcbiAgJCQuZWxlc2ZuLnJlbW92ZUJ5cGFzcyA9ICQkLmVsZXNmbi5yZW1vdmVTdHlsZSA9ICQkLmVsZXNmbi5yZW1vdmVDc3M7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIC8vIENvbGxlY3Rpb24gZnVuY3Rpb25zIHRoYXQgdG9nZ2xlIGEgYm9vbGVhbiB2YWx1ZVxuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIFxuICBcbiAgZnVuY3Rpb24gZGVmaW5lU3dpdGNoRnVuY3Rpb24ocGFyYW1zKXtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGNoYW5nZWRFbGVzID0gW107XG4gICAgICBcbiAgICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoIGRhdGEsIGhhbmRsZXIgKVxuICAgICAgaWYoIGFyZ3MubGVuZ3RoID09PSAyICl7XG4gICAgICAgIHZhciBkYXRhID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBhcmdzWzFdO1xuICAgICAgICB0aGlzLmJpbmQoIHBhcmFtcy5ldmVudCwgZGF0YSwgaGFuZGxlciApO1xuICAgICAgfSBcbiAgICAgIFxuICAgICAgLy8gZS5nLiBjeS5ub2RlcygpLnNlbGVjdCggaGFuZGxlciApXG4gICAgICBlbHNlIGlmKCBhcmdzLmxlbmd0aCA9PT0gMSApe1xuICAgICAgICB2YXIgaGFuZGxlciA9IGFyZ3NbMF07XG4gICAgICAgIHRoaXMuYmluZCggcGFyYW1zLmV2ZW50LCBoYW5kbGVyICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIGUuZy4gY3kubm9kZXMoKS5zZWxlY3QoKVxuICAgICAgZWxzZSBpZiggYXJncy5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgICAgdmFyIGFibGUgPSAhcGFyYW1zLmFibGVGaWVsZCB8fCBlbGUuX3ByaXZhdGVbcGFyYW1zLmFibGVGaWVsZF07XG4gICAgICAgICAgdmFyIGNoYW5nZWQgPSBlbGUuX3ByaXZhdGVbcGFyYW1zLmZpZWxkXSAhPSBwYXJhbXMudmFsdWU7XG5cbiAgICAgICAgICBpZiggcGFyYW1zLm92ZXJyaWRlQWJsZSApe1xuICAgICAgICAgICAgdmFyIG92ZXJyaWRlQWJsZSA9IHBhcmFtcy5vdmVycmlkZUFibGUoZWxlKTtcblxuICAgICAgICAgICAgaWYoIG92ZXJyaWRlQWJsZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICAgIGFibGUgPSBvdmVycmlkZUFibGU7XG5cbiAgICAgICAgICAgICAgaWYoICFvdmVycmlkZUFibGUgKXsgcmV0dXJuIHRoaXM7IH0gLy8gdG8gc2F2ZSBjeWNsZXMgYXNzdW1lIG5vdCBhYmxlIGZvciBhbGwgb24gb3ZlcnJpZGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggYWJsZSApe1xuICAgICAgICAgICAgZWxlLl9wcml2YXRlW3BhcmFtcy5maWVsZF0gPSBwYXJhbXMudmFsdWU7XG5cbiAgICAgICAgICAgIGlmKCBjaGFuZ2VkICl7XG4gICAgICAgICAgICAgIGNoYW5nZWRFbGVzLnB1c2goIGVsZSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaGFuZ2VkQ29sbCA9ICQkLkNvbGxlY3Rpb24oIHRoaXMuY3koKSwgY2hhbmdlZEVsZXMgKTtcbiAgICAgICAgY2hhbmdlZENvbGwudXBkYXRlU3R5bGUoKTsgLy8gY2hhbmdlIG9mIHN0YXRlID0+IHBvc3NpYmxlIGNoYW5nZSBvZiBzdHlsZVxuICAgICAgICBjaGFuZ2VkQ29sbC50cmlnZ2VyKCBwYXJhbXMuZXZlbnQgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuICBcbiAgZnVuY3Rpb24gZGVmaW5lU3dpdGNoU2V0KCBwYXJhbXMgKXtcbiAgICAkJC5lbGVzZm5bIHBhcmFtcy5maWVsZCBdID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuXG4gICAgICBpZiggZWxlICl7XG4gICAgICAgIGlmKCBwYXJhbXMub3ZlcnJpZGVGaWVsZCApe1xuICAgICAgICAgIHZhciB2YWwgPSBwYXJhbXMub3ZlcnJpZGVGaWVsZChlbGUpO1xuXG4gICAgICAgICAgaWYoIHZhbCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGUuX3ByaXZhdGVbIHBhcmFtcy5maWVsZCBdO1xuICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgJCQuZWxlc2ZuWyBwYXJhbXMub24gXSA9IGRlZmluZVN3aXRjaEZ1bmN0aW9uKHtcbiAgICAgIGV2ZW50OiBwYXJhbXMub24sXG4gICAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgICAgdmFsdWU6IHRydWVcbiAgICB9KTtcblxuICAgICQkLmVsZXNmblsgcGFyYW1zLm9mZiBdID0gZGVmaW5lU3dpdGNoRnVuY3Rpb24oe1xuICAgICAgZXZlbnQ6IHBhcmFtcy5vZmYsXG4gICAgICBmaWVsZDogcGFyYW1zLmZpZWxkLFxuICAgICAgYWJsZUZpZWxkOiBwYXJhbXMuYWJsZUZpZWxkLFxuICAgICAgb3ZlcnJpZGVBYmxlOiBwYXJhbXMub3ZlcnJpZGVBYmxlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgXG4gIGRlZmluZVN3aXRjaFNldCh7XG4gICAgZmllbGQ6ICdsb2NrZWQnLFxuICAgIG92ZXJyaWRlRmllbGQ6IGZ1bmN0aW9uKGVsZSl7XG4gICAgICByZXR1cm4gZWxlLmN5KCkuYXV0b2xvY2soKSA/IHRydWUgOiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICBvbjogJ2xvY2snLFxuICAgIG9mZjogJ3VubG9jaydcbiAgfSk7XG4gIFxuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnZ3JhYmJhYmxlJyxcbiAgICBvdmVycmlkZUZpZWxkOiBmdW5jdGlvbihlbGUpe1xuICAgICAgcmV0dXJuIGVsZS5jeSgpLmF1dG91bmdyYWJpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb246ICdncmFiaWZ5JyxcbiAgICBvZmY6ICd1bmdyYWJpZnknXG4gIH0pO1xuICBcbiAgZGVmaW5lU3dpdGNoU2V0KHtcbiAgICBmaWVsZDogJ3NlbGVjdGVkJyxcbiAgICBhYmxlRmllbGQ6ICdzZWxlY3RhYmxlJyxcbiAgICBvdmVycmlkZUFibGU6IGZ1bmN0aW9uKGVsZSl7XG4gICAgICByZXR1cm4gZWxlLmN5KCkuYXV0b3Vuc2VsZWN0aWZ5KCkgPyBmYWxzZSA6IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIG9uOiAnc2VsZWN0JyxcbiAgICBvZmY6ICd1bnNlbGVjdCdcbiAgfSk7XG4gIFxuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnc2VsZWN0YWJsZScsXG4gICAgb3ZlcnJpZGVGaWVsZDogZnVuY3Rpb24oZWxlKXtcbiAgICAgIHJldHVybiBlbGUuY3koKS5hdXRvdW5zZWxlY3RpZnkoKSA/IGZhbHNlIDogdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgb246ICdzZWxlY3RpZnknLFxuICAgIG9mZjogJ3Vuc2VsZWN0aWZ5J1xuICB9KTtcblxuICAkJC5lbGVzZm4uZGVzZWxlY3QgPSAkJC5lbGVzZm4udW5zZWxlY3Q7XG4gIFxuICAkJC5lbGVzZm4uZ3JhYmJlZCA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgaWYoIGVsZSApe1xuICAgICAgcmV0dXJuIGVsZS5fcHJpdmF0ZS5ncmFiYmVkO1xuICAgIH1cbiAgfTtcblxuICBkZWZpbmVTd2l0Y2hTZXQoe1xuICAgIGZpZWxkOiAnYWN0aXZlJyxcbiAgICBvbjogJ2FjdGl2YXRlJyxcbiAgICBvZmY6ICd1bmFjdGl2YXRlJ1xuICB9KTtcblxuICAkJC5lbGVzZm4uaW5hY3RpdmUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBlbGUgPSB0aGlzWzBdO1xuICAgIGlmKCBlbGUgKXtcbiAgICAgIHJldHVybiAhZWxlLl9wcml2YXRlLmFjdGl2ZTtcbiAgICB9XG4gIH07XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERBRyBmdW5jdGlvbnNcbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAkJC5mbi5lbGVzKHtcbiAgICAvLyBnZXQgdGhlIHJvb3Qgbm9kZXMgaW4gdGhlIERBR1xuICAgIHJvb3RzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciByb290cyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFzRWRnZXNQb2ludGluZ0luID0gZWxlLmNvbm5lY3RlZEVkZ2VzKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgndGFyZ2V0JykgPT09IGVsZS5pZCgpICYmIHRoaXMuZGF0YSgnc291cmNlJykgIT09IGVsZS5pZCgpO1xuICAgICAgICB9KS5sZW5ndGggPiAwO1xuXG4gICAgICAgIGlmKCAhaGFzRWRnZXNQb2ludGluZ0luICl7XG4gICAgICAgICAgcm9vdHMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCByb290cywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgLy8gZ2V0IHRoZSBsZWFmIG5vZGVzIGluIHRoZSBEQUdcbiAgICBsZWF2ZXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgdmFyIGxlYXZlcyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaGFzRWRnZXNQb2ludGluZ091dCA9IGVsZS5jb25uZWN0ZWRFZGdlcyhmdW5jdGlvbigpe1xuICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEoJ3NvdXJjZScpID09PSBlbGUuaWQoKSAmJiB0aGlzLmRhdGEoJ3RhcmdldCcpICE9PSBlbGUuaWQoKTtcbiAgICAgICAgfSkubGVuZ3RoID4gMDtcblxuICAgICAgICBpZiggIWhhc0VkZ2VzUG9pbnRpbmdPdXQgKXtcbiAgICAgICAgICBsZWF2ZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCB0aGlzLl9wcml2YXRlLmN5LCBsZWF2ZXMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIC8vIG5vcm1hbGx5IGNhbGxlZCBjaGlsZHJlbiBpbiBncmFwaCB0aGVvcnlcbiAgICAvLyB0aGVzZSBub2RlcyA9ZWRnZXM9PiBvdXRnb2luZyBub2Rlc1xuICAgIG91dGdvZXJzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBvRWxlcyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciBlbGVJZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIGVkZ2VzID0gZWxlLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgICB2YXIgc3JjSWQgPSBlZGdlLl9wcml2YXRlLmRhdGEuc291cmNlO1xuICAgICAgICAgIHZhciB0Z3RJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS50YXJnZXQ7XG5cbiAgICAgICAgICBpZiggc3JjSWQgPT09IGVsZUlkICYmIHRndElkICE9PSBlbGVJZCApe1xuICAgICAgICAgICAgb0VsZXMucHVzaCggZWRnZSApO1xuICAgICAgICAgICAgb0VsZXMucHVzaCggZWRnZS50YXJnZXQoKVswXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIG9FbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICAvLyBha2EgREFHIGRlc2NlbmRhbnRzXG4gICAgc3VjY2Vzc29yczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgc0VsZXMgPSBbXTtcbiAgICAgIHZhciBzRWxlc0lkcyA9IHt9O1xuXG4gICAgICBmb3IoOzspe1xuICAgICAgICB2YXIgb3V0Z29lcnMgPSBlbGVzLm91dGdvZXJzKCk7XG5cbiAgICAgICAgaWYoIG91dGdvZXJzLmxlbmd0aCA9PT0gMCApeyBicmVhazsgfSAvLyBkb25lIGlmIG5vIG91dGdvZXJzIGxlZnRcblxuICAgICAgICB2YXIgbmV3T3V0Z29lcnMgPSBmYWxzZTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvdXRnb2Vycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBvdXRnb2VyID0gb3V0Z29lcnNbaV07XG4gICAgICAgICAgdmFyIG91dGdvZXJJZCA9IG91dGdvZXIuaWQoKTtcblxuICAgICAgICAgIGlmKCAhc0VsZXNJZHNbIG91dGdvZXJJZCBdICl7XG4gICAgICAgICAgICBzRWxlc0lkc1sgb3V0Z29lcklkIF0gPSB0cnVlO1xuICAgICAgICAgICAgc0VsZXMucHVzaCggb3V0Z29lciApO1xuICAgICAgICAgICAgbmV3T3V0Z29lcnMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhbmV3T3V0Z29lcnMgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiB0b3VjaGVkIGFsbCBvdXRnb2VycyBhbHJlYWR5XG5cbiAgICAgICAgZWxlcyA9IG91dGdvZXJzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIHNFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICAvLyBub3JtYWxseSBjYWxsZWQgcGFyZW50cyBpbiBncmFwaCB0aGVvcnlcbiAgICAvLyB0aGVzZSBub2RlcyA8PWVkZ2VzPSBpbmNvbWluZyBub2Rlc1xuICAgIGluY29tZXJzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBlbGVzID0gdGhpcztcbiAgICAgIHZhciBvRWxlcyA9IFtdO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG4gICAgICAgIHZhciBlbGVJZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgIGlmKCAhZWxlLmlzTm9kZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgdmFyIGVkZ2VzID0gZWxlLl9wcml2YXRlLmVkZ2VzO1xuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVkZ2VzLmxlbmd0aDsgaisrICl7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tqXTtcbiAgICAgICAgICB2YXIgc3JjSWQgPSBlZGdlLl9wcml2YXRlLmRhdGEuc291cmNlO1xuICAgICAgICAgIHZhciB0Z3RJZCA9IGVkZ2UuX3ByaXZhdGUuZGF0YS50YXJnZXQ7XG5cbiAgICAgICAgICBpZiggdGd0SWQgPT09IGVsZUlkICYmIHNyY0lkICE9PSBlbGVJZCApe1xuICAgICAgICAgICAgb0VsZXMucHVzaCggZWRnZSApO1xuICAgICAgICAgICAgb0VsZXMucHVzaCggZWRnZS5zb3VyY2UoKVswXSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIG9FbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICAvLyBha2EgREFHIGFuY2VzdG9yc1xuICAgIHByZWRlY2Vzc29yczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICB2YXIgcEVsZXMgPSBbXTtcbiAgICAgIHZhciBwRWxlc0lkcyA9IHt9O1xuXG4gICAgICBmb3IoOzspe1xuICAgICAgICB2YXIgaW5jb21lcnMgPSBlbGVzLmluY29tZXJzKCk7XG5cbiAgICAgICAgaWYoIGluY29tZXJzLmxlbmd0aCA9PT0gMCApeyBicmVhazsgfSAvLyBkb25lIGlmIG5vIGluY29tZXJzIGxlZnRcblxuICAgICAgICB2YXIgbmV3SW5jb21lcnMgPSBmYWxzZTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBpbmNvbWVycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBpbmNvbWVyID0gaW5jb21lcnNbaV07XG4gICAgICAgICAgdmFyIGluY29tZXJJZCA9IGluY29tZXIuaWQoKTtcblxuICAgICAgICAgIGlmKCAhcEVsZXNJZHNbIGluY29tZXJJZCBdICl7XG4gICAgICAgICAgICBwRWxlc0lkc1sgaW5jb21lcklkIF0gPSB0cnVlO1xuICAgICAgICAgICAgcEVsZXMucHVzaCggaW5jb21lciApO1xuICAgICAgICAgICAgbmV3SW5jb21lcnMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhbmV3SW5jb21lcnMgKXsgYnJlYWs7IH0gLy8gZG9uZSBpZiB0b3VjaGVkIGFsbCBpbmNvbWVycyBhbHJlYWR5XG5cbiAgICAgICAgZWxlcyA9IGluY29tZXJzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIHRoaXMuX3ByaXZhdGUuY3ksIHBFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH1cbiAgfSk7XG5cblxuICAvLyBOZWlnaGJvdXJob29kIGZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIG5laWdoYm9yaG9vZDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xuICAgICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgdmFyIG5vZGVzID0gdGhpcy5ub2RlcygpO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7IC8vIGZvciBhbGwgbm9kZXNcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIGNvbm5lY3RlZEVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcygpO1xuXG4gICAgICAgIC8vIGZvciBlYWNoIGNvbm5lY3RlZCBlZGdlLCBhZGQgdGhlIGVkZ2UgYW5kIHRoZSBvdGhlciBub2RlXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgY29ubmVjdGVkRWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IGNvbm5lY3RlZEVkZ2VzW2pdO1xuICAgICAgICAgIHZhciBvdGhlck5vZGUgPSBlZGdlLmNvbm5lY3RlZE5vZGVzKCkubm90KG5vZGUpO1xuXG4gICAgICAgICAgLy8gbmVlZCBjaGVjayBpbiBjYXNlIG9mIGxvb3BcbiAgICAgICAgICBpZiggb3RoZXJOb2RlLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goIG90aGVyTm9kZVswXSApOyAvLyBhZGQgbm9kZSAxIGhvcCBhd2F5XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGFkZCBjb25uZWN0ZWQgZWRnZVxuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVkZ2VbMF0gKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiAoIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9LFxuXG4gICAgY2xvc2VkTmVpZ2hib3Job29kOiBmdW5jdGlvbihzZWxlY3Rvcil7XG4gICAgICByZXR1cm4gdGhpcy5uZWlnaGJvcmhvb2QoKS5hZGQoIHRoaXMgKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfSxcblxuICAgIG9wZW5OZWlnaGJvcmhvb2Q6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcbiAgICAgIHJldHVybiB0aGlzLm5laWdoYm9yaG9vZCggc2VsZWN0b3IgKTtcbiAgICB9XG4gIH0pOyAgXG5cbiAgLy8gYWxpYXNlc1xuICAkJC5lbGVzZm4ubmVpZ2hib3VyaG9vZCA9ICQkLmVsZXNmbi5uZWlnaGJvcmhvb2Q7XG4gICQkLmVsZXNmbi5jbG9zZWROZWlnaGJvdXJob29kID0gJCQuZWxlc2ZuLmNsb3NlZE5laWdoYm9yaG9vZDtcbiAgJCQuZWxlc2ZuLm9wZW5OZWlnaGJvdXJob29kID0gJCQuZWxlc2ZuLm9wZW5OZWlnaGJvcmhvb2Q7XG5cblxuICAvLyBFZGdlIGZ1bmN0aW9uc1xuICAvLy8vLy8vLy8vLy8vLy8vL1xuXG4gICQkLmZuLmVsZXMoe1xuICAgIHNvdXJjZTogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciBzcmM7XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgc3JjID0gZWxlLl9wcml2YXRlLnNvdXJjZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNyYyAmJiBzZWxlY3RvciA/IHNyYy5maWx0ZXIoIHNlbGVjdG9yICkgOiBzcmM7XG4gICAgfSxcblxuICAgIHRhcmdldDogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgZWxlID0gdGhpc1swXTtcbiAgICAgIHZhciB0Z3Q7XG5cbiAgICAgIGlmKCBlbGUgKXtcbiAgICAgICAgdGd0ID0gZWxlLl9wcml2YXRlLnRhcmdldDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRndCAmJiBzZWxlY3RvciA/IHRndC5maWx0ZXIoIHNlbGVjdG9yICkgOiB0Z3Q7XG4gICAgfSxcblxuICAgIHNvdXJjZXM6IGRlZmluZVNvdXJjZUZ1bmN0aW9uKHtcbiAgICAgIGF0dHI6ICdzb3VyY2UnXG4gICAgfSksXG5cbiAgICB0YXJnZXRzOiBkZWZpbmVTb3VyY2VGdW5jdGlvbih7XG4gICAgICBhdHRyOiAndGFyZ2V0J1xuICAgIH0pXG4gIH0pO1xuICBcbiAgZnVuY3Rpb24gZGVmaW5lU291cmNlRnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIHJldHVybiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciBzb3VyY2VzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbaV07XG4gICAgICAgIHZhciBzcmMgPSBlbGUuX3ByaXZhdGVbIHBhcmFtcy5hdHRyIF07XG5cbiAgICAgICAgaWYoIHNyYyApe1xuICAgICAgICAgIHNvdXJjZXMucHVzaCggc3JjICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgc291cmNlcywgeyB1bmlxdWU6IHRydWUgfSApLmZpbHRlciggc2VsZWN0b3IgKTtcbiAgICB9O1xuICB9XG5cbiAgJCQuZm4uZWxlcyh7XG4gICAgZWRnZXNXaXRoOiBkZWZpbmVFZGdlc1dpdGhGdW5jdGlvbigpLFxuXG4gICAgZWRnZXNUbzogZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oe1xuICAgICAgdGhpc0lzOiAnc291cmNlJ1xuICAgIH0pXG4gIH0pO1xuICBcbiAgZnVuY3Rpb24gZGVmaW5lRWRnZXNXaXRoRnVuY3Rpb24oIHBhcmFtcyApe1xuICAgIFxuICAgIHJldHVybiBmdW5jdGlvbihvdGhlck5vZGVzKXtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBwID0gcGFyYW1zIHx8IHt9O1xuXG4gICAgICAvLyBnZXQgZWxlbWVudHMgaWYgYSBzZWxlY3RvciBpcyBzcGVjaWZpZWRcbiAgICAgIGlmKCAkJC5pcy5zdHJpbmcob3RoZXJOb2RlcykgKXtcbiAgICAgICAgb3RoZXJOb2RlcyA9IGN5LiQoIG90aGVyTm9kZXMgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHRoaXNJZHMgPSB0aGlzLl9wcml2YXRlLmlkcztcbiAgICAgIHZhciBvdGhlcklkcyA9IG90aGVyTm9kZXMuX3ByaXZhdGUuaWRzO1xuICAgICAgXG4gICAgICBmb3IoIHZhciBoID0gMDsgaCA8IG90aGVyTm9kZXMubGVuZ3RoOyBoKysgKXtcbiAgICAgICAgdmFyIGVkZ2VzID0gb3RoZXJOb2Rlc1toXS5fcHJpdmF0ZS5lZGdlcztcbiAgICAgICAgXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgICAgIHZhciBmb3VuZElkO1xuICAgICAgICAgIHZhciBlZGdlRGF0YSA9IGVkZ2UuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgICB2YXIgdGhpc1RvT3RoZXIgPSB0aGlzSWRzWyBlZGdlRGF0YS5zb3VyY2UgXSAmJiBvdGhlcklkc1sgZWRnZURhdGEudGFyZ2V0IF07XG4gICAgICAgICAgdmFyIG90aGVyVG9UaGlzID0gb3RoZXJJZHNbIGVkZ2VEYXRhLnNvdXJjZSBdICYmIHRoaXNJZHNbIGVkZ2VEYXRhLnRhcmdldCBdO1xuICAgICAgICAgIHZhciBlZGdlQ29ubmVjdHNUaGlzQW5kT3RoZXIgPSB0aGlzVG9PdGhlciB8fCBvdGhlclRvVGhpcztcblxuICAgICAgICAgIGlmKCAhZWRnZUNvbm5lY3RzVGhpc0FuZE90aGVyICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgICBpZiggcC50aGlzSXMgKXtcbiAgICAgICAgICAgIGlmKCBwLnRoaXNJcyA9PT0gJ3NvdXJjZScgJiYgIXRoaXNUb090aGVyICl7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCBwLnRoaXNJcyA9PT0gJ3RhcmdldCcgJiYgIW90aGVyVG9UaGlzICl7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIGVsZW1lbnRzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBlbGVtZW50cywgeyB1bmlxdWU6IHRydWUgfSApO1xuICAgIH07XG4gIH1cbiAgXG4gICQkLmZuLmVsZXMoe1xuICAgIGNvbm5lY3RlZEVkZ2VzOiBmdW5jdGlvbiggc2VsZWN0b3IgKXtcbiAgICAgIHZhciByZXRFbGVzID0gW107XG4gICAgICB2YXIgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgICAgXG4gICAgICB2YXIgZWxlcyA9IHRoaXM7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIG5vZGUgPSBlbGVzW2ldO1xuICAgICAgICBpZiggIW5vZGUuaXNOb2RlKCkgKXsgY29udGludWU7IH1cblxuICAgICAgICB2YXIgZWRnZXMgPSBub2RlLl9wcml2YXRlLmVkZ2VzO1xuXG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgZWRnZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2pdOyAgICAgICAgICBcbiAgICAgICAgICByZXRFbGVzLnB1c2goIGVkZ2UgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCByZXRFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBjb25uZWN0ZWROb2RlczogZnVuY3Rpb24oIHNlbGVjdG9yICl7XG4gICAgICB2YXIgcmV0RWxlcyA9IFtdO1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcblxuICAgICAgdmFyIGVsZXMgPSB0aGlzO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlbGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBlZGdlID0gZWxlc1tpXTtcbiAgICAgICAgaWYoICFlZGdlLmlzRWRnZSgpICl7IGNvbnRpbnVlOyB9XG5cbiAgICAgICAgcmV0RWxlcy5wdXNoKCBlZGdlLnNvdXJjZSgpWzBdICk7XG4gICAgICAgIHJldEVsZXMucHVzaCggZWRnZS50YXJnZXQoKVswXSApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCByZXRFbGVzLCB7IHVuaXF1ZTogdHJ1ZSB9ICkuZmlsdGVyKCBzZWxlY3RvciApO1xuICAgIH0sXG5cbiAgICBwYXJhbGxlbEVkZ2VzOiBkZWZpbmVQYXJhbGxlbEVkZ2VzRnVuY3Rpb24oKSxcblxuICAgIGNvZGlyZWN0ZWRFZGdlczogZGVmaW5lUGFyYWxsZWxFZGdlc0Z1bmN0aW9uKHtcbiAgICAgIGNvZGlyZWN0ZWQ6IHRydWVcbiAgICB9KVxuICB9KTtcbiAgXG4gIGZ1bmN0aW9uIGRlZmluZVBhcmFsbGVsRWRnZXNGdW5jdGlvbihwYXJhbXMpe1xuICAgIHZhciBkZWZhdWx0cyA9IHtcbiAgICAgIGNvZGlyZWN0ZWQ6IGZhbHNlXG4gICAgfTtcbiAgICBwYXJhbXMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIHBhcmFtcyk7XG4gICAgXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCBzZWxlY3RvciApe1xuICAgICAgdmFyIGN5ID0gdGhpcy5fcHJpdmF0ZS5jeTtcbiAgICAgIHZhciBlbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGVkZ2VzID0gdGhpcy5lZGdlcygpO1xuICAgICAgdmFyIHAgPSBwYXJhbXM7XG5cbiAgICAgIC8vIGxvb2sgYXQgYWxsIHRoZSBlZGdlcyBpbiB0aGUgY29sbGVjdGlvblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZTEgPSBlZGdlc1tpXTtcbiAgICAgICAgdmFyIHNyYzEgPSBlZGdlMS5zb3VyY2UoKVswXTtcbiAgICAgICAgdmFyIHNyY2lkMSA9IHNyYzEuaWQoKTtcbiAgICAgICAgdmFyIHRndDEgPSBlZGdlMS50YXJnZXQoKVswXTtcbiAgICAgICAgdmFyIHRndGlkMSA9IHRndDEuaWQoKTtcbiAgICAgICAgdmFyIHNyY0VkZ2VzMSA9IHNyYzEuX3ByaXZhdGUuZWRnZXM7XG5cbiAgICAgICAgLy8gbG9vayBhdCBlZGdlcyBjb25uZWN0ZWQgdG8gdGhlIHNyYyBub2RlIG9mIHRoaXMgZWRnZVxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNyY0VkZ2VzMS5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIHZhciBlZGdlMiA9IHNyY0VkZ2VzMVtqXTtcbiAgICAgICAgICB2YXIgZWRnZTJkYXRhID0gZWRnZTIuX3ByaXZhdGUuZGF0YTtcbiAgICAgICAgICB2YXIgdGd0aWQyID0gZWRnZTJkYXRhLnRhcmdldDtcbiAgICAgICAgICB2YXIgc3JjaWQyID0gZWRnZTJkYXRhLnNvdXJjZTtcblxuICAgICAgICAgIHZhciBjb2RpcmVjdGVkID0gdGd0aWQyID09PSB0Z3RpZDEgJiYgc3JjaWQyID09PSBzcmNpZDE7XG4gICAgICAgICAgdmFyIG9wcGRpcmVjdGVkID0gc3JjaWQxID09PSB0Z3RpZDIgJiYgdGd0aWQxID09PSBzcmNpZDI7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIChwLmNvZGlyZWN0ZWQgJiYgY29kaXJlY3RlZCkgfHwgKCFwLmNvZGlyZWN0ZWQgJiYgKGNvZGlyZWN0ZWQgfHwgb3BwZGlyZWN0ZWQpKSApe1xuICAgICAgICAgICAgZWxlbWVudHMucHVzaCggZWRnZTIgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgZWxlbWVudHMsIHsgdW5pcXVlOiB0cnVlIH0gKS5maWx0ZXIoIHNlbGVjdG9yICk7XG4gICAgfTtcbiAgXG4gIH1cblxuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAkJC5mbi5lbGVzKHtcblxuICAgIGZpdDogZnVuY3Rpb24oKXt9LFxuICAgIGNlbnRlcjogZnVuY3Rpb24oKXt9XG5cbiAgfSk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbiAoJCQpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgLyogIE1pbiBhbmQgTWF4IGhlYXAgcHJlZGVmYXVsdHMgKi9cbiAgXG4gICQkLk1pbmhlYXAgPSBmdW5jdGlvbiAoY3ksIGVsZXMsIHZhbHVlRm4pIHtcbiAgICByZXR1cm4gbmV3ICQkLkhlYXAoY3ksIGVsZXMsICQkLkhlYXAubWluSGVhcENvbXBhcmF0b3IsIHZhbHVlRm4pO1xuICB9O1xuXG4gICQkLk1heGhlYXAgPSBmdW5jdGlvbiAoY3ksIGVsZXMsIHZhbHVlRm4pIHtcbiAgICByZXR1cm4gbmV3ICQkLkhlYXAoY3ksIGVsZXMsICQkLkhlYXAubWF4SGVhcENvbXBhcmF0b3IsIHZhbHVlRm4pO1xuICB9O1xuICBcbiAgJCQuSGVhcCA9IGZ1bmN0aW9uIChjeSwgZWxlcywgY29tcGFyYXRvciwgdmFsdWVGbikge1xuICAgIGlmICh0eXBlb2YgY29tcGFyYXRvciA9PT0gXCJ1bmRlZmluZWRcIiB8fCB0eXBlb2YgZWxlcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAodHlwZW9mIHZhbHVlRm4gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHZhbHVlRm4gPSAkJC5IZWFwLmlkRm47XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUhlYXAgPSBbXSxcbiAgICAgIHBvaW50ZXJzID0ge30sXG4gICAgICBlbGVtZW50cyA9IFtdLFxuICAgICAgaSA9IDAsXG4gICAgICBpZCxcbiAgICAgIGhlYXAsXG4gICAgICBlbGVzTGVuO1xuXG4gICAgZWxlcyA9IHRoaXMuZ2V0QXJndW1lbnRBc0NvbGxlY3Rpb24oZWxlcywgY3kpO1xuICAgIGVsZXNMZW4gPSBlbGVzLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBlbGVzTGVuOyBpICs9IDEpIHtcbiAgICAgIHNvdXJjZUhlYXAucHVzaCh2YWx1ZUZuLmNhbGwoY3ksIGVsZXNbaV0sIGksIGVsZXMpKTtcblxuICAgICAgaWQgPSBlbGVzW2ldLmlkKCk7XG4gICAgICBcbiAgICAgIGlmIChwb2ludGVycy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgdGhyb3cgXCJFUlJPUjogTXVsdGlwbGUgaXRlbXMgd2l0aCB0aGUgc2FtZSBpZCBmb3VuZDogXCIgKyBpZDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcG9pbnRlcnNbaWRdID0gaTtcbiAgICAgIGVsZW1lbnRzLnB1c2goaWQpO1xuICAgIH1cblxuICAgIHRoaXMuX3ByaXZhdGUgPSB7XG4gICAgICBjeTogY3ksXG4gICAgICBoZWFwOiBzb3VyY2VIZWFwLFxuICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgICAgZWxlbWVudHM6IGVsZW1lbnRzLFxuICAgICAgY29tcGFyYXRvcjogY29tcGFyYXRvcixcbiAgICAgIGV4dHJhY3RvcjogdmFsdWVGbixcbiAgICAgIGxlbmd0aDogZWxlc0xlblxuICAgIH07XG5cbiAgICBmb3IgKGkgPSBNYXRoLmZsb29yKGVsZXNMZW4gLyAyKTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGhlYXAgPSB0aGlzLmhlYXBpZnkoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhlYXA7XG4gIH07XG5cbiAgLyogc3RhdGljIG1ldGhvZHMgKi9cbiAgJCQuSGVhcC5pZEZuID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5pZCgpO1xuICB9O1xuXG4gICQkLkhlYXAubWluSGVhcENvbXBhcmF0b3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhID49IGI7XG4gIH07XG5cbiAgJCQuSGVhcC5tYXhIZWFwQ29tcGFyYXRvciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPD0gYjtcbiAgfTtcblxuICAkJC5mbi5oZWFwID0gZnVuY3Rpb24oIGZuTWFwLCBvcHRpb25zICl7XG4gICAgZm9yKCB2YXIgbmFtZSBpbiBmbk1hcCApe1xuICAgICAgdmFyIGZuID0gZm5NYXBbbmFtZV07XG4gICAgICAkJC5IZWFwLnByb3RvdHlwZVsgbmFtZSBdID0gZm47XG4gICAgfVxuICB9O1xuXG4gICQkLmhlYXBmbiA9ICQkLkhlYXAucHJvdG90eXBlOyAvLyBzaG9ydCBhbGlhc1xuXG4gIC8qIG9iamVjdCBtZXRob2RzICovXG4gICQkLmhlYXBmbi5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmxlbmd0aDtcbiAgfTtcblxuICAkJC5oZWFwZm4uZ2V0QXJndW1lbnRBc0NvbGxlY3Rpb24gPSBmdW5jdGlvbiAoZWxlcywgY3kpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGlmKHR5cGVvZiBjeSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY3kgPSB0aGlzLl9wcml2YXRlLmN5O1xuICAgIH1cblxuICAgIGlmICgkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKGVsZXMpKSB7XG4gICAgICByZXN1bHQgPSBlbGVzO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHRBcnJheSA9IFtdLFxuICAgICAgICBzb3VyY2VFbGVzID0gW10uY29uY2F0LmFwcGx5KFtdLCBbZWxlc10pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZUVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGlkID0gc291cmNlRWxlc1tpXSxcbiAgICAgICAgICBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAgICAgaWYoZWxlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICByZXN1bHRBcnJheS5wdXNoKGVsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVzdWx0ID0gbmV3ICQkLkNvbGxlY3Rpb24oY3ksIHJlc3VsdEFycmF5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICQkLmhlYXBmbi5pc0hlYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gdGhpcy5fcHJpdmF0ZS5oZWFwLFxuICAgICAgYXJybGVuID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaSxcbiAgICAgIGxlZnQsXG4gICAgICByaWdodCxcbiAgICAgIGxDaGVjayxcbiAgICAgIHJDaGVjayxcbiAgICAgIGNvbXBhcmF0b3IgPSB0aGlzLl9wcml2YXRlLmNvbXBhcmF0b3I7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXJybGVuOyBpICs9IDEpIHtcbiAgICAgIGxlZnQgPSAyICogaSArIDE7XG4gICAgICByaWdodCA9IGxlZnQgKyAxO1xuICAgICAgbENoZWNrID0gbGVmdCA8IGFycmxlbiA/IGNvbXBhcmF0b3IoYXJyYXlbbGVmdF0sIGFycmF5W2ldKSA6IHRydWU7XG4gICAgICByQ2hlY2sgPSByaWdodCA8IGFycmxlbiA/IGNvbXBhcmF0b3IoYXJyYXlbcmlnaHRdLCBhcnJheVtpXSkgOiB0cnVlO1xuXG4gICAgICBpZiAoIWxDaGVjayB8fCAhckNoZWNrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAkJC5oZWFwZm4uaGVhcFN3YXAgPSBmdW5jdGlvbiAoaSwgaikge1xuICAgIHZhciBoZWFwID0gdGhpcy5fcHJpdmF0ZS5oZWFwLFxuICAgICAgcG9pbnRlcnMgPSB0aGlzLl9wcml2YXRlLnBvaW50ZXJzLFxuICAgICAgZWxlbWVudHMgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLFxuICAgICAgc3dhcFZhbHVlID0gaGVhcFtpXSxcbiAgICAgIHN3YXBFbGVtcyA9IGVsZW1lbnRzW2ldLFxuICAgICAgaWRJID0gZWxlbWVudHNbaV0sXG4gICAgICBpZEogPSBlbGVtZW50c1tqXTtcblxuICAgIGhlYXBbaV0gPSBoZWFwW2pdO1xuICAgIGVsZW1lbnRzW2ldID0gZWxlbWVudHNbal07XG5cbiAgICBwb2ludGVyc1tpZEldID0gajtcbiAgICBwb2ludGVyc1tpZEpdID0gaTtcblxuICAgIGhlYXBbal0gPSBzd2FwVmFsdWU7XG4gICAgZWxlbWVudHNbal0gPSBzd2FwRWxlbXM7XG4gIH07XG5cbiAgJCQuaGVhcGZuLmhlYXBpZnkgPSBmdW5jdGlvbiAoaSwgcm9vdFRvTGVhZikge1xuICAgIHZhciB0cmVlTGVuID0gMCxcbiAgICAgIGNvbmRIZWFwID0gZmFsc2UsXG4gICAgICBhcnJheSxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBsZWZ0LFxuICAgICAgcmlnaHQsXG4gICAgICBiZXN0LFxuICAgICAgY29tcGFyYXRvcixcbiAgICAgIHBhcmVudDtcbiAgICBcbiAgICBpZiAodHlwZW9mIHJvb3RUb0xlYWYgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJvb3RUb0xlYWYgPSB0cnVlO1xuICAgIH1cblxuICAgIGFycmF5ID0gdGhpcy5fcHJpdmF0ZS5oZWFwO1xuICAgIHRyZWVMZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgY29tcGFyYXRvciA9IHRoaXMuX3ByaXZhdGUuY29tcGFyYXRvcjtcbiAgICBjdXJyZW50ID0gaTtcblxuICAgIHdoaWxlICghY29uZEhlYXApIHtcblxuICAgICAgaWYgKHJvb3RUb0xlYWYpIHtcbiAgICAgICAgbGVmdCA9IDIgKiBjdXJyZW50ICsgMTtcbiAgICAgICAgcmlnaHQgPSBsZWZ0ICsgMTtcbiAgICAgICAgYmVzdCA9IGN1cnJlbnQ7XG4gICAgICAgIFxuICAgICAgICBpZiAobGVmdCA8IHRyZWVMZW4gJiYgIWNvbXBhcmF0b3IoYXJyYXlbbGVmdF0sIGFycmF5W2Jlc3RdKSkge1xuICAgICAgICAgIGJlc3QgPSBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAocmlnaHQgPCB0cmVlTGVuICYmICFjb21wYXJhdG9yKGFycmF5W3JpZ2h0XSwgYXJyYXlbYmVzdF0pKSB7XG4gICAgICAgICAgYmVzdCA9IHJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb25kSGVhcCA9IGJlc3QgPT09IGN1cnJlbnQ7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWNvbmRIZWFwKSB7XG4gICAgICAgICAgdGhpcy5oZWFwU3dhcChiZXN0LCBjdXJyZW50KTtcbiAgICAgICAgICBjdXJyZW50ID0gYmVzdDtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBNYXRoLmZsb29yKChjdXJyZW50IC0gMSkgLyAyKTtcbiAgICAgICAgYmVzdCA9IGN1cnJlbnQ7XG4gICAgICAgIGNvbmRIZWFwID0gcGFyZW50IDwgMCB8fCBjb21wYXJhdG9yKGFycmF5W2Jlc3RdLCBhcnJheVtwYXJlbnRdKTtcblxuICAgICAgICBpZiAoIWNvbmRIZWFwKSB7XG4gICAgICAgICAgdGhpcy5oZWFwU3dhcChiZXN0LCBwYXJlbnQpO1xuICAgICAgICAgIGN1cnJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0gLy8gd2hpbGVcbiAgfTtcblxuICAvKiBjb2xsZWN0aW9uT3JFbGVtZW50ICovXG4gICQkLmhlYXBmbi5pbnNlcnQgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZ2V0QXJndW1lbnRBc0NvbGxlY3Rpb24oZWxlcyksXG4gICAgICBlbHNpemUgPSBlbGVtZW50cy5sZW5ndGgsXG4gICAgICBlbGVtZW50LFxuICAgICAgZWxpbmRleCxcbiAgICAgIGVsdmFsdWUsXG4gICAgICBlbGlkLFxuICAgICAgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBlbHNpemU7IGkgKz0gMSkge1xuICAgICAgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgZWxpbmRleCA9IHRoaXMuX3ByaXZhdGUuaGVhcC5sZW5ndGg7XG4gICAgICBlbHZhbHVlID0gdGhpcy5fcHJpdmF0ZS5leHRyYWN0b3IoZWxlbWVudCk7XG4gICAgICBlbGlkID0gZWxlbWVudC5pZCgpO1xuXG4gICAgICBpZiAodGhpcy5fcHJpdmF0ZS5wb2ludGVycy5oYXNPd25Qcm9wZXJ0eShlbGlkKSkge1xuICAgICAgICB0aHJvdyBcIkVSUk9SOiBNdWx0aXBsZSBpdGVtcyB3aXRoIHRoZSBzYW1lIGlkIGZvdW5kOiBcIiArIGVsaWQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUuaGVhcC5wdXNoKGVsdmFsdWUpO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5lbGVtZW50cy5wdXNoKGVsaWQpO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wb2ludGVyc1tlbGlkXSA9IGVsaW5kZXg7XG4gICAgICB0aGlzLmhlYXBpZnkoZWxpbmRleCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMuX3ByaXZhdGUubGVuZ3RoID0gdGhpcy5fcHJpdmF0ZS5oZWFwLmxlbmd0aDtcbiAgfTtcblxuICAkJC5oZWFwZm4uZ2V0VmFsdWVCeUlkID0gZnVuY3Rpb24gKGVsZW1lbnRJZCkge1xuICAgIGlmICh0aGlzLl9wcml2YXRlLnBvaW50ZXJzLmhhc093blByb3BlcnR5KGVsZW1lbnRJZCkpIHtcbiAgICAgIHZhciBlbGVtZW50SW5kZXggPSB0aGlzLl9wcml2YXRlLnBvaW50ZXJzW2VsZW1lbnRJZF07XG5cbiAgICAgIHJldHVybiB0aGlzLl9wcml2YXRlLmhlYXBbZWxlbWVudEluZGV4XTtcbiAgICB9XG4gIH07XG4gIFxuICAkJC5oZWFwZm4uY29udGFpbnMgPSBmdW5jdGlvbiAoZWxlcykge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZ2V0QXJndW1lbnRBc0NvbGxlY3Rpb24oZWxlcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgZWxlbWVudElkID0gZWxlbWVudHNbaV0uaWQoKTtcblxuICAgICAgaWYoIXRoaXMuX3ByaXZhdGUucG9pbnRlcnMuaGFzT3duUHJvcGVydHkoZWxlbWVudElkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIFxuICAkJC5oZWFwZm4udG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9wcml2YXRlLmxlbmd0aCA+IDApIHtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHRoaXMuX3ByaXZhdGUuaGVhcFswXSxcbiAgICAgICAgaWQ6IHRoaXMuX3ByaXZhdGUuZWxlbWVudHNbMF1cbiAgICAgIH07XG5cbiAgICB9XG4gIH07XG5cbiAgJCQuaGVhcGZuLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcHJpdmF0ZS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdG9wID0gdGhpcy50b3AoKSxcbiAgICAgICAgbGFzdEluZGV4ID0gdGhpcy5fcHJpdmF0ZS5sZW5ndGggLSAxLFxuICAgICAgICByZW1vdmVDYW5kaWRhdGUsXG4gICAgICAgIHJlbW92ZVZhbHVlLFxuICAgICAgICByZW1JZDtcblxuICAgICAgdGhpcy5oZWFwU3dhcCgwLCBsYXN0SW5kZXgpO1xuXG4gICAgICByZW1vdmVDYW5kaWRhdGUgPSB0aGlzLl9wcml2YXRlLmVsZW1lbnRzW2xhc3RJbmRleF07XG4gICAgICByZW1vdmVWYWx1ZSA9IHRoaXMuX3ByaXZhdGUuaGVhcFtsYXN0SW5kZXhdO1xuICAgICAgcmVtSWQgPSByZW1vdmVDYW5kaWRhdGU7XG5cbiAgICAgIHRoaXMuX3ByaXZhdGUuaGVhcC5wb3AoKTtcbiAgICAgIHRoaXMuX3ByaXZhdGUuZWxlbWVudHMucG9wKCk7XG4gICAgICB0aGlzLl9wcml2YXRlLmxlbmd0aCA9IHRoaXMuX3ByaXZhdGUuaGVhcC5sZW5ndGg7XG4gICAgICB0aGlzLl9wcml2YXRlLnBvaW50ZXJzW3JlbUlkXSA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy5oZWFwaWZ5KDApO1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG4gIH07XG5cbiAgJCQuaGVhcGZuLmZpbmREaXJlY3Rpb25IZWFwaWZ5ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIHBhcmVudCA9IE1hdGguZmxvb3IoKGluZGV4IC0gMSkgLyAyKSxcbiAgICAgIGFycmF5ID0gdGhpcy5fcHJpdmF0ZS5oZWFwLFxuICAgICAgY29uZEhlYXAgPSBwYXJlbnQgPCAwIHx8IHRoaXMuX3ByaXZhdGUuY29tcGFyYXRvcihhcnJheVtpbmRleF0sIGFycmF5W3BhcmVudF0pO1xuXG4gICAgdGhpcy5oZWFwaWZ5KGluZGV4LCBjb25kSGVhcCk7XG4gIH07XG5cbiAgLyogZWRpdCBpcyBhIG5ldyB2YWx1ZSBvciBmdW5jdGlvbiAqL1xuICAvLyBvbmx5IHZhbHVlcyBpbiBoZWFwIGFyZSB1cGRhdGVkLiBlbGVtZW50cyB0aGVtc2VsdmVzIGFyZSBub3QhXG4gICQkLmhlYXBmbi5lZGl0ID0gZnVuY3Rpb24gKGVsZXMsIGVkaXQpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmdldEFyZ3VtZW50QXNDb2xsZWN0aW9uKGVsZXMpO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBlbGVtZW50SWQgPSBlbGVtZW50c1tpXS5pZCgpLFxuICAgICAgICBlbGVtZW50SW5kZXggPSB0aGlzLl9wcml2YXRlLnBvaW50ZXJzW2VsZW1lbnRJZF0sXG4gICAgICAgIGVsZW1lbnRWYWx1ZSA9IHRoaXMuX3ByaXZhdGUuaGVhcFtlbGVtZW50SW5kZXhdO1xuICAgICAgXG4gICAgICBpZiAoJCQuaXMubnVtYmVyKGVkaXQpKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuaGVhcFtlbGVtZW50SW5kZXhdID0gZWRpdDtcbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYgKCQkLmlzLmZuKGVkaXQpKSB7XG4gICAgICAgIHRoaXMuX3ByaXZhdGUuaGVhcFtlbGVtZW50SW5kZXhdID0gZWRpdC5jYWxsKHRoaXMuX3ByaXZhdGUuY3ksIGVsZW1lbnRWYWx1ZSwgZWxlbWVudEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maW5kRGlyZWN0aW9uSGVhcGlmeShlbGVtZW50SW5kZXgpO1xuICAgIH1cbiAgfTtcblxuICAkJC5oZWFwZm4ucmVtb3ZlID0gZnVuY3Rpb24gKGVsZXMpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmdldEFyZ3VtZW50QXNDb2xsZWN0aW9uKGVsZXMpO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZhciBlbGVtZW50SWQgPSBlbGVtZW50c1tpXS5pZCgpLFxuICAgICAgICBlbGVtZW50SW5kZXggPSB0aGlzLl9wcml2YXRlLnBvaW50ZXJzW2VsZW1lbnRJZF0sXG4gICAgICAgIGxhc3RJbmRleCA9IHRoaXMuX3ByaXZhdGUubGVuZ3RoIC0gMSxcbiAgICAgICAgcmVtb3ZlQ2FuZGlkYXRlLFxuICAgICAgICByZW1vdmVWYWx1ZSxcbiAgICAgICAgcmVtSWQ7XG5cbiAgICAgIGlmIChlbGVtZW50SW5kZXggIT09IGxhc3RJbmRleCkge1xuICAgICAgICB0aGlzLmhlYXBTd2FwKGVsZW1lbnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgcmVtb3ZlQ2FuZGlkYXRlID0gdGhpcy5fcHJpdmF0ZS5lbGVtZW50c1tsYXN0SW5kZXhdO1xuICAgICAgcmVtb3ZlVmFsdWUgPSB0aGlzLl9wcml2YXRlLmhlYXBbbGFzdEluZGV4XTtcbiAgICAgIHJlbUlkID0gcmVtb3ZlQ2FuZGlkYXRlO1xuXG4gICAgICB0aGlzLl9wcml2YXRlLmhlYXAucG9wKCk7XG4gICAgICB0aGlzLl9wcml2YXRlLmVsZW1lbnRzLnBvcCgpO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5sZW5ndGggPSB0aGlzLl9wcml2YXRlLmhlYXAubGVuZ3RoO1xuICAgICAgdGhpcy5fcHJpdmF0ZS5wb2ludGVyc1tyZW1JZF0gPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuZmluZERpcmVjdGlvbkhlYXBpZnkoZWxlbWVudEluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVtb3ZlVmFsdWU7XG4gIH07XG5cbn0pKGN5dG9zY2FwZSk7XG4vKlxuICBUaGUgY2FudmFzIHJlbmRlcmVyIHdhcyB3cml0dGVuIGJ5IFl1ZSBEb25nLlxuXG4gIE1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xuXG4oZnVuY3Rpb24oJCQpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlMgPSAzO1xuICAvL1xuICBDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YID0gMDtcbiAgQ2FudmFzUmVuZGVyZXIuRFJBRyA9IDE7XG4gIENhbnZhc1JlbmRlcmVyLk5PREUgPSAyO1xuXG4gIENhbnZhc1JlbmRlcmVyLkJVRkZFUl9DT1VOVCA9IDM7XG4gIC8vXG4gIENhbnZhc1JlbmRlcmVyLlRFWFRVUkVfQlVGRkVSID0gMDtcbiAgQ2FudmFzUmVuZGVyZXIuTU9USU9OQkxVUl9CVUZGRVJfTk9ERSA9IDE7XG4gIENhbnZhc1JlbmRlcmVyLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgPSAyO1xuXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKG9wdGlvbnMpIHsgIFxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgXG4gICAgICBzZWxlY3Q6IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIDBdLCAvLyBDb29yZGluYXRlcyBmb3Igc2VsZWN0aW9uIGJveCwgcGx1cyBlbmFibGVkIGZsYWcgXG4gICAgICByZW5kZXJlcjogdGhpcywgY3k6IG9wdGlvbnMuY3ksIGNvbnRhaW5lcjogb3B0aW9ucy5jeS5jb250YWluZXIoKSxcbiAgICAgIFxuICAgICAgY2FudmFzZXM6IG5ldyBBcnJheShDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTKSxcbiAgICAgIGNvbnRleHRzOiBuZXcgQXJyYXkoQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUyksXG4gICAgICBjYW52YXNOZWVkc1JlZHJhdzogbmV3IEFycmF5KENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlMpLFxuICAgICAgXG4gICAgICBidWZmZXJDYW52YXNlczogbmV3IEFycmF5KENhbnZhc1JlbmRlcmVyLkJVRkZFUl9DT1VOVCksXG4gICAgICBidWZmZXJDb250ZXh0czogbmV3IEFycmF5KENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlMpXG5cbiAgICB9O1xuICAgIFxuICAgIC8vLS1Qb2ludGVyLXJlbGF0ZWQgZGF0YVxuICAgIHRoaXMuaG92ZXJEYXRhID0ge2Rvd246IG51bGwsIGxhc3Q6IG51bGwsIFxuICAgICAgICBkb3duVGltZTogbnVsbCwgdHJpZ2dlck1vZGU6IG51bGwsIFxuICAgICAgICBkcmFnZ2luZzogZmFsc2UsIFxuICAgICAgICBpbml0aWFsUGFuOiBbbnVsbCwgbnVsbF0sIGNhcHR1cmU6IGZhbHNlfTtcbiAgICBcbiAgICB0aGlzLnRpbWVvdXREYXRhID0ge3BhblRpbWVvdXQ6IG51bGx9O1xuICAgIFxuICAgIHRoaXMuZHJhZ0RhdGEgPSB7cG9zc2libGVEcmFnRWxlbWVudHM6IFtdfTtcbiAgICBcbiAgICB0aGlzLnRvdWNoRGF0YSA9IHtzdGFydDogbnVsbCwgY2FwdHVyZTogZmFsc2UsXG4gICAgICAgIC8vIFRoZXNlIDMgZmllbGRzIHJlbGF0ZWQgdG8gdGFwLCB0YXBob2xkIGV2ZW50c1xuICAgICAgICBzdGFydFBvc2l0aW9uOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF0sXG4gICAgICAgIHNpbmdsZVRvdWNoU3RhcnRUaW1lOiBudWxsLFxuICAgICAgICBzaW5nbGVUb3VjaE1vdmVkOiB0cnVlLFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIG5vdzogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdLCBcbiAgICAgICAgZWFybGllcjogW251bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGxdIH07XG4gICAgLy8tLVxuICAgIFxuICAgIC8vLS1XaGVlbC1yZWxhdGVkIGRhdGEgXG4gICAgdGhpcy56b29tRGF0YSA9IHtmcmVlVG9ab29tOiBmYWxzZSwgbGFzdFBvaW50ZXJYOiBudWxsfTtcbiAgICAvLy0tXG4gICAgXG4gICAgdGhpcy5yZWRyYXdzID0gMDtcbiAgICB0aGlzLnNob3dGcHMgPSBvcHRpb25zLnNob3dGcHM7XG5cbiAgICB0aGlzLmJpbmRpbmdzID0gW107XG4gICAgXG4gICAgdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBjb250YWluZXJTdHlsZSA9IHRoaXMuZGF0YS5jYW52YXNDb250YWluZXIuc3R5bGU7XG4gICAgY29udGFpbmVyU3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGNvbnRhaW5lclN0eWxlLnpJbmRleCA9ICcwJztcbiAgICBjb250YWluZXJTdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuXG4gICAgdGhpcy5kYXRhLmNvbnRhaW5lci5hcHBlbmRDaGlsZCggdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lciApO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDYW52YXNSZW5kZXJlci5DQU5WQVNfTEFZRVJTOyBpKyspIHtcbiAgICAgIHRoaXMuZGF0YS5jYW52YXNlc1tpXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgdGhpcy5kYXRhLmNvbnRleHRzW2ldID0gdGhpcy5kYXRhLmNhbnZhc2VzW2ldLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB0aGlzLmRhdGEuY2FudmFzZXNbaV0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgdGhpcy5kYXRhLmNhbnZhc2VzW2ldLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBpKTtcbiAgICAgIHRoaXMuZGF0YS5jYW52YXNlc1tpXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoQ2FudmFzUmVuZGVyZXIuQ0FOVkFTX0xBWUVSUyAtIGkpO1xuICAgICAgdGhpcy5kYXRhLmNhbnZhc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmRhdGEuY2FudmFzZXNbaV0pO1xuICAgICAgXG4gICAgICB0aGlzLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbaV0gPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5kYXRhLnRvcENhbnZhcyA9IHRoaXMuZGF0YS5jYW52YXNlc1swXTtcblxuICAgIHRoaXMuZGF0YS5jYW52YXNlc1tDYW52YXNSZW5kZXJlci5OT0RFXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ2FudmFzUmVuZGVyZXIuTk9ERSArICctbm9kZScpO1xuICAgIHRoaXMuZGF0YS5jYW52YXNlc1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtaWQnLCAnbGF5ZXInICsgQ2FudmFzUmVuZGVyZXIuU0VMRUNUX0JPWCArICctc2VsZWN0Ym94Jyk7XG4gICAgdGhpcy5kYXRhLmNhbnZhc2VzW0NhbnZhc1JlbmRlcmVyLkRSQUddLnNldEF0dHJpYnV0ZSgnZGF0YS1pZCcsICdsYXllcicgKyBDYW52YXNSZW5kZXJlci5EUkFHICsgJy1kcmFnJyk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDYW52YXNSZW5kZXJlci5CVUZGRVJfQ09VTlQ7IGkrKykge1xuICAgICAgdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB0aGlzLmRhdGEuYnVmZmVyQ29udGV4dHNbaV0gPSB0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICB0aGlzLmRhdGEuYnVmZmVyQ2FudmFzZXNbaV0uc2V0QXR0cmlidXRlKCdkYXRhLWlkJywgJ2J1ZmZlcicgKyBpKTtcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS56SW5kZXggPSBTdHJpbmcoLWkgLSAxKTtcbiAgICAgIHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tpXS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAvL3RoaXMuZGF0YS5jYW52YXNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLmhpZGVFZGdlc09uVmlld3BvcnQgPSBvcHRpb25zLmhpZGVFZGdlc09uVmlld3BvcnQ7XG4gICAgdGhpcy5oaWRlTGFiZWxzT25WaWV3cG9ydCA9IG9wdGlvbnMuaGlkZUxhYmVsc09uVmlld3BvcnQ7XG4gICAgdGhpcy50ZXh0dXJlT25WaWV3cG9ydCA9IG9wdGlvbnMudGV4dHVyZU9uVmlld3BvcnQ7XG4gICAgdGhpcy53aGVlbFNlbnNpdGl2aXR5ID0gb3B0aW9ucy53aGVlbFNlbnNpdGl2aXR5O1xuICAgIHRoaXMubW90aW9uQmx1ckVuYWJsZWQgPSBvcHRpb25zLm1vdGlvbkJsdXI7IC8vIG9uIGJ5IGRlZmF1bHRcbiAgICB0aGlzLmZvcmNlZFBpeGVsUmF0aW8gPSBvcHRpb25zLnBpeGVsUmF0aW87XG4gICAgdGhpcy5tb3Rpb25CbHVyID0gdHJ1ZTsgLy8gZm9yIGluaXRpYWwga2ljayBvZmZcbiAgICB0aGlzLm1vdGlvbkJsdXJPcGFjaXR5ID0gb3B0aW9ucy5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgICB0aGlzLm1vdGlvbkJsdXJUcmFuc3BhcmVuY3kgPSAxIC0gdGhpcy5tb3Rpb25CbHVyT3BhY2l0eTtcbiAgICB0aGlzLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgICB0aGlzLm1iUHhSQmx1cnJ5ID0gMTsgLy8wLjg7XG4gICAgdGhpcy5taW5NYkxvd1F1YWxGcmFtZXMgPSA0O1xuICAgIHRoaXMuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICAgIHRoaXMuY2xlYXJlZEZvck1vdGlvbkJsdXIgPSBbXTtcbiAgICB0aGlzLmRlc2t0b3BUYXBUaHJlc2hvbGQgPSBvcHRpb25zLmRlc2t0b3BUYXBUaHJlc2hvbGQ7XG4gICAgdGhpcy5kZXNrdG9wVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZCAqIG9wdGlvbnMuZGVza3RvcFRhcFRocmVzaG9sZDtcbiAgICB0aGlzLnRvdWNoVGFwVGhyZXNob2xkID0gb3B0aW9ucy50b3VjaFRhcFRocmVzaG9sZDtcbiAgICB0aGlzLnRvdWNoVGFwVGhyZXNob2xkMiA9IG9wdGlvbnMudG91Y2hUYXBUaHJlc2hvbGQgKiBvcHRpb25zLnRvdWNoVGFwVGhyZXNob2xkO1xuICAgIHRoaXMudGFwaG9sZER1cmF0aW9uID0gNTAwO1xuXG4gICAgdGhpcy5sb2FkKCk7XG4gIH1cblxuICBDYW52YXNSZW5kZXJlci5wYW5PckJveFNlbGVjdERlbGF5ID0gNDAwO1xuXG4gIC8vIHdoZXRoZXIgdG8gdXNlIFBhdGgyRCBjYWNoaW5nIGZvciBkcmF3aW5nXG4gIHZhciBwYXRoc0ltcGxkID0gdHlwZW9mIFBhdGgyRCAhPT0gJ3VuZGVmaW5lZCc7XG4gIENhbnZhc1JlbmRlcmVyLnVzZVBhdGhzID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gcGF0aHNJbXBsZDtcbiAgfTtcblxuICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgdmFyIHR5cGVzO1xuXG4gICAgaWYoICQkLmlzLmFycmF5KCBwYXJhbXMudHlwZSApICl7XG4gICAgICB0eXBlcyA9IHBhcmFtcy50eXBlO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVzID0gWyBwYXJhbXMudHlwZSBdO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciB0eXBlID0gdHlwZXNbaV07XG5cbiAgICAgIHN3aXRjaCggdHlwZSApe1xuICAgICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgY2FzZSAncmVtb3ZlJzpcbiAgICAgICAgY2FzZSAnbG9hZCc6XG4gICAgICAgICAgdGhpcy51cGRhdGVOb2Rlc0NhY2hlKCk7XG4gICAgICAgICAgdGhpcy51cGRhdGVFZGdlc0NhY2hlKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndmlld3BvcnQnOlxuICAgICAgICAgIHRoaXMuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3R5bGUnOlxuICAgICAgICAgIHRoaXMudXBkYXRlQ2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGUgPT09ICdsb2FkJyB8fCB0eXBlID09PSAncmVzaXplJyApe1xuICAgICAgICB0aGlzLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgICB0aGlzLm1hdGNoQ2FudmFzU2l6ZSh0aGlzLmRhdGEuY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICB9IC8vIGZvclxuICAgIFxuICAgIHRoaXMuZGF0YS5jYW52YXNOZWVkc1JlZHJhd1tDYW52YXNSZW5kZXJlci5OT0RFXSA9IHRydWU7XG4gICAgdGhpcy5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddID0gdHJ1ZTtcblxuICAgIHRoaXMucmVkcmF3KCk7XG4gIH07XG5cbiAgQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5iaW5kaW5ncy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW2ldO1xuICAgICAgdmFyIGIgPSBiaW5kaW5nO1xuXG4gICAgICBiLnRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGIuZXZlbnQsIGIuaGFuZGxlciwgYi51c2VDYXB0dXJlKTtcbiAgICB9XG5cbiAgICBpZiggdGhpcy5yZW1vdmVPYnNlcnZlciApe1xuICAgICAgdGhpcy5yZW1vdmVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgfVxuXG4gICAgaWYoIHRoaXMubGFiZWxDYWxjRGl2ICl7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMubGFiZWxDYWxjRGl2KTtcbiAgICB9XG4gIH07XG5cbiAgXG5cbiAgLy8gY29weSB0aGUgbWF0aCBmdW5jdGlvbnMgaW50byB0aGUgcmVuZGVyZXIgcHJvdG90eXBlXG4gIC8vIHVuZm9ydHVuYXRlbHkgdGhlc2UgZnVuY3Rpb25zIGFyZSB1c2VkIGludGVyc3BlcnNlZCB0L28gdGhlIGNvZGVcbiAgLy8gYW5kIHRoaXMgbWFrZXMgc3VyZSB0aGluZ3Mgd29yayBqdXN0IGluIGNhc2UgYSByZWYgd2FzIG1pc3NlZCBpbiByZWZhY3RvcmluZ1xuICAvLyBUT0RPIHJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbiAgZm9yKCB2YXIgZm5OYW1lIGluICQkLm1hdGggKXtcbiAgICBDYW52YXNSZW5kZXJlci5wcm90b3R5cGVbIGZuTmFtZSBdID0gJCQubWF0aFsgZm5OYW1lIF07XG4gIH1cbiAgXG4gIFxuICAkJCgncmVuZGVyZXInLCAnY2FudmFzJywgQ2FudmFzUmVuZGVyZXIpO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciByZW5kRnVuYyA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcbiAgdmFyIGFycm93U2hhcGVzID0gQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXMgPSB7fTtcblxuICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlSGVpZ2h0ID0gMC4zO1xuXG4gIC8vIENvbnRyYWN0IGZvciBhcnJvdyBzaGFwZXM6XG4gIC8vIDAsIDAgaXMgYXJyb3cgdGlwXG4gIC8vICgwLCAxKSBpcyBkaXJlY3Rpb24gdG93YXJkcyBub2RlXG4gIC8vICgxLCAwKSBpcyByaWdodFxuICAvL1xuICAvLyBmdW5jdGlvbmFsIGFwaTpcbiAgLy8gY29sbGlkZTogY2hlY2sgeCwgeSBpbiBzaGFwZVxuICAvLyByb3VnaENvbGxpZGU6IGNhbGxlZCBiZWZvcmUgY29sbGlkZSwgbm8gZmFsc2UgbmVnYXRpdmVzXG4gIC8vIGRyYXc6IGRyYXdcbiAgLy8gc3BhY2luZzogZGlzdChhcnJvd1RpcCwgbm9kZUJvdW5kYXJ5KVxuICAvLyBnYXA6IGRpc3QoZWRnZVRpcCwgbm9kZUJvdW5kYXJ5KSwgZWRnZVRpcCBtYXkgIT0gYXJyb3dUaXBcblxuICB2YXIgYmJDb2xsaWRlID0gZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKXtcbiAgICB2YXIgeDEgPSBjZW50ZXJYIC0gd2lkdGgvMjtcbiAgICB2YXIgeDIgPSBjZW50ZXJYICsgd2lkdGgvMjtcbiAgICB2YXIgeTEgPSBjZW50ZXJZIC0gaGVpZ2h0LzI7XG4gICAgdmFyIHkyID0gY2VudGVyWSArIGhlaWdodC8yO1xuXG4gICAgcmV0dXJuICh4MSA8PSB4ICYmIHggPD0geDIpICYmICh5MSA8PSB5ICYmIHkgPD0geTIpO1xuICB9O1xuXG4gIHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbih4LCB5LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pe1xuICAgIGFuZ2xlID0gLWFuZ2xlOyAvLyBiL2Mgb2Ygbm90YXRpb24gdXNlZCBpbiBhcnJvdyBkcmF3IGZuXG5cbiAgICB2YXIgeFJvdGF0ZWQgPSB4ICogTWF0aC5jb3MoYW5nbGUpIC0geSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICB2YXIgeVJvdGF0ZWQgPSB4ICogTWF0aC5zaW4oYW5nbGUpICsgeSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICBcbiAgICB2YXIgeFNjYWxlZCA9IHhSb3RhdGVkICogc2l6ZTtcbiAgICB2YXIgeVNjYWxlZCA9IHlSb3RhdGVkICogc2l6ZTtcblxuICAgIHZhciB4VHJhbnNsYXRlZCA9IHhTY2FsZWQgKyB0cmFuc2xhdGlvbi54O1xuICAgIHZhciB5VHJhbnNsYXRlZCA9IHlTY2FsZWQgKyB0cmFuc2xhdGlvbi55O1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB4OiB4VHJhbnNsYXRlZCxcbiAgICAgIHk6IHlUcmFuc2xhdGVkXG4gICAgfTtcbiAgfTtcblxuICBhcnJvd1NoYXBlc1snYXJyb3cnXSA9IHtcbiAgICBfcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMyxcbiAgICAgIDAsIDAsXG4gICAgICAwLjE1LCAtMC4zXG4gICAgXSxcbiAgICBcbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snYXJyb3cnXS5fcG9pbnRzO1xuICAgICAgXG4vLyAgICAgIGNvbnNvbGUubG9nKFwiY29sbGlkZSgpOiBcIiArIGRpcmVjdGlvbik7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgICAgeCwgeSwgcG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ2Fycm93J10uX3BvaW50cztcbiAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cblxuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiBlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUgKiAyO1xuICAgIH1cbiAgfTtcblxuICBhcnJvd1NoYXBlc1sndHJpYW5nbGUnXSA9IGFycm93U2hhcGVzWydhcnJvdyddO1xuICBcbiAgYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlLWJhY2tjdXJ2ZSddID0ge1xuICAgIF9jdHJsUHQ6IFsgMCwgLTAuMTUgXSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWyd0cmlhbmdsZSddLl9wb2ludHM7XG4gICAgICBcbi8vICAgICAgY29uc29sZS5sb2coXCJjb2xsaWRlKCk6IFwiICsgZGlyZWN0aW9uKTtcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgICB4LCB5LCBwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1sndHJpYW5nbGUnXS5fcG9pbnRzO1xuICAgICAgdmFyIGZpcnN0UHQ7XG4gICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCBwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgICAgaWYoIGkgPT09IDAgKXtcbiAgICAgICAgICBmaXJzdFB0ID0gcHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0cmxQdCA9IHRoaXMuX2N0cmxQdDtcbiAgICAgIHZhciBjdHJsUHRUcmFucyA9IHRyYW5zZm9ybSggY3RybFB0WzBdLCBjdHJsUHRbMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oIGN0cmxQdFRyYW5zLngsIGN0cmxQdFRyYW5zLnksIGZpcnN0UHQueCwgZmlyc3RQdC55ICk7XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSAqIDI7XG4gICAgfVxuICB9O1xuICBcblxuICBhcnJvd1NoYXBlc1sndHJpYW5nbGUtdGVlJ10gPSB7XG4gICAgX3BvaW50czogW1xuICAgICAgLTAuMTUsIC0wLjMsXG4gICAgICAwLCAwLFxuICAgICAgMC4xNSwgLTAuMyxcbiAgICAgIC0wLjE1LCAtMC4zXG4gICAgXSxcblxuICAgIF9wb2ludHNUZWU6IFtcbiAgICAgIC0wLjE1LCAtMC40LFxuICAgICAgLTAuMTUsIC0wLjUsXG4gICAgICAwLjE1LCAtMC41LFxuICAgICAgMC4xNSwgLTAuNFxuICAgIF0sXG4gICAgXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgdHJpUHRzID0gYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlLXRlZSddLl9wb2ludHM7XG4gICAgICB2YXIgdGVlUHRzID0gYXJyb3dTaGFwZXNbJ3RyaWFuZ2xlLXRlZSddLl9wb2ludHNUZWU7XG4gICAgICBcbiAgICAgIHZhciBpbnNpZGUgPSAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbih4LCB5LCB0ZWVQdHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykgXG4gICAgICAgIHx8ICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIHRyaVB0cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKTtcblxuICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHRyaVB0cyA9IGFycm93U2hhcGVzWyd0cmlhbmdsZS10ZWUnXS5fcG9pbnRzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmlQdHMubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCB0cmlQdHNbIGkgKiAyIF0sICB0cmlQdHNbIGkgKiAyICsgMSBdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZWVQdHMgPSBhcnJvd1NoYXBlc1sndHJpYW5nbGUtdGVlJ10uX3BvaW50c1RlZTtcbiAgICAgIHZhciBmaXJzdFRlZVB0ID0gdHJhbnNmb3JtKCB0ZWVQdHNbMF0sIHRlZVB0c1sxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG4gICAgICBjb250ZXh0Lm1vdmVUbyggZmlyc3RUZWVQdC54LCBmaXJzdFRlZVB0LnkgKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZWVQdHMubGVuZ3RoIC8gMjsgaSsrKXtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCB0ZWVQdHNbIGkgKiAyIF0sICB0ZWVQdHNbIGkgKiAyICsgMSBdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnRleHQubGluZVRvKCBwdC54LCBwdC55ICk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10ucHhWYWx1ZSAqIDI7XG4gICAgfVxuICB9O1xuXG4gIGFycm93U2hhcGVzWydoYWxmLXRyaWFuZ2xlLW92ZXJzaG90J10gPSB7XG4gICAgX3BvaW50czogW1xuICAgICAgMCwgLTAuMjUsXG4gICAgICAtMC41LCAtMC4yNSxcbiAgICAgIDAuNSwgMC4yNVxuICAgIF0sXG4gICAgXG4gICAgbGVhdmVQYXRoT3BlbjogdHJ1ZSxcbiAgICBtYXRjaEVkZ2VXaWR0aDogdHJ1ZSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3BvaW50cztcbiAgICAgIFxuLy8gICAgICBjb25zb2xlLmxvZyhcImNvbGxpZGUoKTogXCIgKyBkaXJlY3Rpb24pO1xuICAgICAgXG4gICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oXG4gICAgICAgIHgsIHksIHBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogYmJDb2xsaWRlLFxuICAgIFxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHBvaW50cyA9IHRoaXMuX3BvaW50cztcbiAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICogMjtcbiAgICB9XG4gIH07XG5cbiAgYXJyb3dTaGFwZXNbJ25vbmUnXSA9IHtcbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIFxuICAgIHJvdWdoQ29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIFxuICAgIGdhcDogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9O1xuICBcbiAgYXJyb3dTaGFwZXNbJ2NpcmNsZSddID0ge1xuICAgIF9iYXNlUmFkaXVzOiAwLjE1LFxuICAgIFxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgLy8gVHJhbnNmb3JtIHgsIHkgdG8gZ2V0IG5vbi1yb3RhdGVkIGVsbGlwc2VcbiAgICAgIFxuICAgICAgaWYgKHdpZHRoICE9IGhlaWdodCkgeyAgICAgICAgICAgICAgICAgIFxuICAgICAgICB2YXIgYXNwZWN0UmF0aW8gPSAoaGVpZ2h0ICsgcGFkZGluZykgLyAod2lkdGggKyBwYWRkaW5nKTtcbiAgICAgICAgeSAvPSBhc3BlY3RSYXRpbztcbiAgICAgICAgY2VudGVyWSAvPSBhc3BlY3RSYXRpbztcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAoTWF0aC5wb3coY2VudGVyWCAtIHgsIDIpIFxuICAgICAgICAgICsgTWF0aC5wb3coY2VudGVyWSAtIHksIDIpIDw9IE1hdGgucG93KCh3aWR0aCArIHBhZGRpbmcpXG4gICAgICAgICAgICAqIGFycm93U2hhcGVzWydjaXJjbGUnXS5fYmFzZVJhZGl1cywgMikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdyhjZW50ZXJYIC0geCwgMikgXG4gICAgICAgICAgKyBNYXRoLnBvdyhjZW50ZXJZIC0geSwgMikgPD0gTWF0aC5wb3coKHdpZHRoICsgcGFkZGluZylcbiAgICAgICAgICAgICogYXJyb3dTaGFwZXNbJ2NpcmNsZSddLl9iYXNlUmFkaXVzLCAyKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIGNvbnRleHQuYXJjKHRyYW5zbGF0aW9uLngsIHRyYW5zbGF0aW9uLnksIGFycm93U2hhcGVzWydjaXJjbGUnXS5fYmFzZVJhZGl1cyAqIHNpemUsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gcmVuZEZ1bmMuZ2V0QXJyb3dXaWR0aChlZGdlLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpXG4gICAgICAgICogYXJyb3dTaGFwZXNbJ2NpcmNsZSddLl9iYXNlUmFkaXVzO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICogMjtcbiAgICB9XG4gIH07XG4gIFxuICBhcnJvd1NoYXBlc1snaW5oaWJpdG9yJ10gPSB7XG4gICAgX3BvaW50czogW1xuICAgICAgLTAuMjUsIDAsXG4gICAgICAtMC4yNSwgLTAuMSxcbiAgICAgIDAuMjUsIC0wLjEsXG4gICAgICAwLjI1LCAwXG4gICAgXSxcbiAgICBcbiAgICBjb2xsaWRlOiBmdW5jdGlvbih4LCB5LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snaW5oaWJpdG9yJ10uX3BvaW50cztcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKFxuICAgICAgICB4LCB5LCBwb2ludHMsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZyk7XG4gICAgfSxcbiAgICBcbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24pIHtcbiAgICAgIHZhciBwb2ludHMgPSBhcnJvd1NoYXBlc1snaW5oaWJpdG9yJ10uX3BvaW50cztcbiAgICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC8gMjsgaSsrKSB7XG4gICAgICAgIHZhciBwdCA9IHRyYW5zZm9ybSggcG9pbnRzW2kgKiAyXSwgcG9pbnRzW2kgKiAyICsgMV0sIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbiApO1xuXG4gICAgICAgIGNvbnRleHQubGluZVRvKHB0LngsIHB0LnkpO1xuICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3BhY2luZzogZnVuY3Rpb24oZWRnZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSxcbiAgICBcbiAgICBnYXA6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfTtcblxuICBhcnJvd1NoYXBlc1sndGVlJ10gPSBhcnJvd1NoYXBlc1snaW5oaWJpdG9yJ107XG5cbiAgYXJyb3dTaGFwZXNbJ3NxdWFyZSddID0ge1xuICAgIF9wb2ludHM6IFtcbiAgICAgIC0wLjE1LCAwLjAwLFxuICAgICAgMC4xNSwgMC4wMCxcbiAgICAgIDAuMTUsIC0wLjMsXG4gICAgICAtMC4xNSwgLTAuM1xuICAgIF0sXG4gICAgXG4gICAgY29sbGlkZTogZnVuY3Rpb24oeCwgeSwgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgZGlyZWN0aW9uLCBwYWRkaW5nKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ3NxdWFyZSddLl9wb2ludHM7XG4gICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgICAgeCwgeSwgcG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgcm91Z2hDb2xsaWRlOiBiYkNvbGxpZGUsXG4gICAgXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKSB7XG4gICAgICB2YXIgcG9pbnRzID0gYXJyb3dTaGFwZXNbJ3NxdWFyZSddLl9wb2ludHM7XG4gICAgXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLyAyOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gdHJhbnNmb3JtKCBwb2ludHNbaSAqIDJdLCBwb2ludHNbaSAqIDIgKyAxXSwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uICk7XG5cbiAgICAgICAgY29udGV4dC5saW5lVG8ocHQueCwgcHQueSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzcGFjaW5nOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICogMjtcbiAgICB9XG4gIH07XG5cbiAgYXJyb3dTaGFwZXNbJ2RpYW1vbmQnXSA9IHtcbiAgICBfcG9pbnRzOiBbXG4gICAgICAtMC4xNSwgLTAuMTUsXG4gICAgICAwLCAtMC4zLFxuICAgICAgMC4xNSwgLTAuMTUsXG4gICAgICAwLCAwXG4gICAgXSxcblxuICAgIGNvbGxpZGU6IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIGRpcmVjdGlvbiwgcGFkZGluZykge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydkaWFtb25kJ10uX3BvaW50cztcbiAgICAgICAgICBcbiAgICAgIHJldHVybiAkJC5tYXRoLnBvaW50SW5zaWRlUG9seWdvbihcbiAgICAgICAgeCwgeSwgcG9pbnRzLCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0LCBkaXJlY3Rpb24sIHBhZGRpbmcpO1xuICAgIH0sXG5cbiAgICByb3VnaENvbGxpZGU6IGJiQ29sbGlkZSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIHNpemUsIGFuZ2xlLCB0cmFuc2xhdGlvbikge1xuICAgICAgdmFyIHBvaW50cyA9IGFycm93U2hhcGVzWydkaWFtb25kJ10uX3BvaW50cztcbiAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSB0cmFuc2Zvcm0oIHBvaW50c1tpICogMl0sIHBvaW50c1tpICogMiArIDFdLCBzaXplLCBhbmdsZSwgdHJhbnNsYXRpb24gKTtcblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdC54LCBwdC55KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFxuICAgIHNwYWNpbmc6IGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgXG4gICAgZ2FwOiBmdW5jdGlvbihlZGdlKSB7XG4gICAgICByZXR1cm4gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlO1xuICAgIH1cbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgQ1JwLmdldENhY2hlZE5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7IHZhciBjeSA9IHRoaXMuZGF0YS5jeTtcbiAgICBcbiAgICBpZiAoZGF0YS5jYWNoZSA9PSBudWxsKSB7XG4gICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgfVxuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlLmNhY2hlZE5vZGVzID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUuY2FjaGVkTm9kZXMgPSBjeS5ub2RlcygpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZGF0YS5jYWNoZS5jYWNoZWROb2RlcztcbiAgfTtcbiAgXG4gIENScC51cGRhdGVOb2Rlc0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7IHZhciBjeSA9IHRoaXMuZGF0YS5jeTtcbiAgICBcbiAgICBpZiAoZGF0YS5jYWNoZSA9PSBudWxsKSB7XG4gICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgfVxuICAgIFxuICAgIGRhdGEuY2FjaGUuY2FjaGVkTm9kZXMgPSBjeS5ub2RlcygpO1xuICB9O1xuICBcbiAgQ1JwLmdldENhY2hlZEVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7IHZhciBjeSA9IHRoaXMuZGF0YS5jeTtcbiAgICBcbiAgICBpZiAoZGF0YS5jYWNoZSA9PSBudWxsKSB7XG4gICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgfVxuICAgIFxuICAgIGlmIChkYXRhLmNhY2hlLmNhY2hlZEVkZ2VzID09IG51bGwpIHtcbiAgICAgIGRhdGEuY2FjaGUuY2FjaGVkRWRnZXMgPSBjeS5lZGdlcygpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZGF0YS5jYWNoZS5jYWNoZWRFZGdlcztcbiAgfTtcbiAgXG4gIENScC51cGRhdGVFZGdlc0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7IHZhciBjeSA9IHRoaXMuZGF0YS5jeTtcbiAgICBcbiAgICBpZiAoZGF0YS5jYWNoZSA9PSBudWxsKSB7XG4gICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgfVxuICAgIFxuICAgIGRhdGEuY2FjaGUuY2FjaGVkRWRnZXMgPSBjeS5lZGdlcygpO1xuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIC8vIFByb2plY3QgbW91c2VcbiAgQ1JwLnByb2plY3RJbnRvVmlld3BvcnQgPSBmdW5jdGlvbihjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgdmFyIG9mZnNldHMgPSB0aGlzLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMoKTtcbiAgICB2YXIgb2Zmc2V0TGVmdCA9IG9mZnNldHNbMF07XG4gICAgdmFyIG9mZnNldFRvcCA9IG9mZnNldHNbMV07XG4gICAgXG4gICAgdmFyIHggPSBjbGllbnRYIC0gb2Zmc2V0TGVmdDsgXG4gICAgdmFyIHkgPSBjbGllbnRZIC0gb2Zmc2V0VG9wO1xuICAgIFxuICAgIHggLT0gdGhpcy5kYXRhLmN5LnBhbigpLng7IHkgLT0gdGhpcy5kYXRhLmN5LnBhbigpLnk7IHggLz0gdGhpcy5kYXRhLmN5Lnpvb20oKTsgeSAvPSB0aGlzLmRhdGEuY3kuem9vbSgpO1xuICAgIHJldHVybiBbeCwgeV07XG4gIH07XG5cbiAgQ1JwLmZpbmRDb250YWluZXJDbGllbnRDb29yZHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5kYXRhLmNvbnRhaW5lcjtcblxuICAgIHZhciBiYiA9IHRoaXMuY29udGFpbmVyQkIgPSB0aGlzLmNvbnRhaW5lckJCIHx8IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgIHJldHVybiBbYmIubGVmdCwgYmIudG9wLCBiYi5yaWdodCAtIGJiLmxlZnQsIGJiLmJvdHRvbSAtIGJiLnRvcF07XG4gIH07XG5cbiAgQ1JwLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5jb250YWluZXJCQiA9IG51bGw7XG4gIH07XG5cbiAgLy8gRmluZCBuZWFyZXN0IGVsZW1lbnRcbiAgQ1JwLmZpbmROZWFyZXN0RWxlbWVudCA9IGZ1bmN0aW9uKHgsIHksIHZpc2libGVFbGVtZW50c09ubHksIGlzVG91Y2gpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZWxlcyA9IHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoKTtcbiAgICB2YXIgbmVhciA9IFtdO1xuICAgIHZhciB6b29tID0gdGhpcy5kYXRhLmN5Lnpvb20oKTtcbiAgICB2YXIgaGFzQ29tcG91bmRzID0gdGhpcy5kYXRhLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgZWRnZVRocmVzaG9sZCA9IChpc1RvdWNoID8gMjQgOiA4KSAvIHpvb207XG4gICAgdmFyIG5vZGVUaHJlc2hvbGQgPSAoaXNUb3VjaCA/IDggOiAyKSAvIHpvb207XG5cbiAgICBmdW5jdGlvbiBjaGVja05vZGUobm9kZSl7XG4gICAgICB2YXIgd2lkdGggPSBub2RlLm91dGVyV2lkdGgoKSArIDIqbm9kZVRocmVzaG9sZDtcbiAgICAgIHZhciBoZWlnaHQgPSBub2RlLm91dGVySGVpZ2h0KCkgKyAyKm5vZGVUaHJlc2hvbGQ7XG4gICAgICB2YXIgaHcgPSB3aWR0aC8yO1xuICAgICAgdmFyIGhoID0gaGVpZ2h0LzI7XG4gICAgICB2YXIgcG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgaWYoXG4gICAgICAgIHBvcy54IC0gaHcgPD0geCAmJiB4IDw9IHBvcy54ICsgaHcgLy8gYmIgY2hlY2sgeFxuICAgICAgICAgICYmXG4gICAgICAgIHBvcy55IC0gaGggPD0geSAmJiB5IDw9IHBvcy55ICsgaGggLy8gYmIgY2hlY2sgeVxuICAgICAgKXtcbiAgICAgICAgdmFyIHZpc2libGUgPSAhdmlzaWJsZUVsZW1lbnRzT25seSB8fCAoIG5vZGUudmlzaWJsZSgpICYmICFub2RlLnRyYW5zcGFyZW50KCkgKTtcblxuICAgICAgICAvLyBleGl0IGVhcmx5IGlmIGludmlzaWJsZSBlZGdlIGFuZCBtdXN0IGJlIHZpc2libGVcbiAgICAgICAgaWYoIHZpc2libGVFbGVtZW50c09ubHkgJiYgIXZpc2libGUgKXtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2hhcGUgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzWyBzZWxmLmdldE5vZGVTaGFwZShub2RlKSBdO1xuICAgICAgICB2YXIgYm9yZGVyV08gPSBub2RlLl9wcml2YXRlLnN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlIC8gMjtcblxuICAgICAgICBpZihcbiAgICAgICAgICBzaGFwZS5jaGVja1BvaW50KHgsIHksIDAsIHdpZHRoLCBoZWlnaHQsIHBvcy54LCBwb3MueSlcbiAgICAgICAgKXtcbiAgICAgICAgICBuZWFyLnB1c2goIG5vZGUgKTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tFZGdlKGVkZ2Upe1xuICAgICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gICAgICB2YXIgd2lkdGggPSBzdHlsZVsnd2lkdGgnXS5weFZhbHVlLzIgKyBlZGdlVGhyZXNob2xkOyAvLyBtb3JlIGxpa2UgYSBkaXN0YW5jZSByYWRpdXMgZnJvbSBjZW50cmVcbiAgICAgIHZhciB3aWR0aFNxID0gd2lkdGggKiB3aWR0aDtcbiAgICAgIHZhciB3aWR0aDIgPSB3aWR0aCAqIDI7XG4gICAgICB2YXIgc3JjID0gZWRnZS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gZWRnZS5fcHJpdmF0ZS50YXJnZXQ7XG4gICAgICB2YXIgaW5FZGdlQkIgPSBmYWxzZTtcbiAgICAgIHZhciBzcURpc3Q7XG5cbiAgICAgIC8vIGV4aXQgZWFybHkgaWYgaW52aXNpYmxlIGVkZ2UgYW5kIG11c3QgYmUgdmlzaWJsZVxuICAgICAgdmFyIHBhc3NlZFZpc2liaWxpdHlDaGVjaztcbiAgICAgIHZhciBwYXNzZXNWaXNpYmlsaXR5Q2hlY2sgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggcGFzc2VkVmlzaWJpbGl0eUNoZWNrICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICByZXR1cm4gcGFzc2VkVmlzaWJpbGl0eUNoZWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICF2aXNpYmxlRWxlbWVudHNPbmx5ICl7XG4gICAgICAgICAgcGFzc2VkVmlzaWJpbGl0eUNoZWNrID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB2aXNpYmxlID0gZWRnZS52aXNpYmxlKCkgJiYgIWVkZ2UudHJhbnNwYXJlbnQoKTtcbiAgICAgICAgaWYoIHZpc2libGUgKXtcbiAgICAgICAgICBwYXNzZWRWaXNpYmlsaXR5Q2hlY2sgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFzc2VkVmlzaWJpbGl0eUNoZWNrID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICAgIGlmKFxuICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAoaW5FZGdlQkIgPSAkJC5tYXRoLmluQmV6aWVyVmljaW5pdHkoeCwgeSwgcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmNwMmF4LCBycy5jcDJheSwgcnMuc2VsZkVkZ2VNaWRYLCBycy5zZWxmRWRnZU1pZFksIHdpZHRoU3EpKVxuICAgICAgICAgICAgICAgICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmXG4gICAgICAgICAgICAgICggd2lkdGhTcSA+IChzcURpc3QgPSAkJC5tYXRoLnNxRGlzdGFuY2VUb1F1YWRyYXRpY0Jlemllcih4LCB5LCBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuY3AyYXgsIHJzLmNwMmF5LCBycy5zZWxmRWRnZU1pZFgsIHJzLnNlbGZFZGdlTWlkWSkpIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfHxcbiAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgKGluRWRnZUJCID0gJCQubWF0aC5pbkJlemllclZpY2luaXR5KHgsIHksIHJzLnNlbGZFZGdlTWlkWCwgcnMuc2VsZkVkZ2VNaWRZLCBycy5jcDJjeCwgcnMuY3AyY3ksIHJzLmVuZFgsIHJzLmVuZFksIHdpZHRoU3EpKVxuICAgICAgICAgICAgICAgICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmXG4gICAgICAgICAgICAgICggd2lkdGhTcSA+IChzcURpc3QgPSAkJC5tYXRoLnNxRGlzdGFuY2VUb1F1YWRyYXRpY0Jlemllcih4LCB5LCBycy5zZWxmRWRnZU1pZFgsIHJzLnNlbGZFZGdlTWlkWSwgcnMuY3AyY3gsIHJzLmNwMmN5LCBycy5lbmRYLCBycy5lbmRZKSkgKVxuICAgICAgICAgICAgKVxuICAgICAgICApe1xuICAgICAgICAgIG5lYXIucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdoYXlzdGFjaycpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHN0eWxlWydoYXlzdGFjay1yYWRpdXMnXS52YWx1ZTtcbiAgICAgICAgdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMvMjsgLy8gYi9jIGhhdmUgdG8gaGFsZiB3aWR0aC9oZWlnaHRcblxuICAgICAgICB2YXIgdGd0UG9zID0gdGd0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgdGd0VyA9IHRndC53aWR0aCgpO1xuICAgICAgICB2YXIgdGd0SCA9IHRndC5oZWlnaHQoKTtcbiAgICAgICAgdmFyIHNyY1BvcyA9IHNyYy5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNyY1cgPSBzcmMud2lkdGgoKTtcbiAgICAgICAgdmFyIHNyY0ggPSBzcmMuaGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIHN0YXJ0WCA9IHNyY1Bvcy54ICsgcnMuc291cmNlLnggKiBzcmNXICogaGFsZlJhZGl1cztcbiAgICAgICAgdmFyIHN0YXJ0WSA9IHNyY1Bvcy55ICsgcnMuc291cmNlLnkgKiBzcmNIICogaGFsZlJhZGl1cztcbiAgICAgICAgdmFyIGVuZFggPSB0Z3RQb3MueCArIHJzLnRhcmdldC54ICogdGd0VyAqIGhhbGZSYWRpdXM7XG4gICAgICAgIHZhciBlbmRZID0gdGd0UG9zLnkgKyBycy50YXJnZXQueSAqIHRndEggKiBoYWxmUmFkaXVzO1xuXG4gICAgICAgIGlmKCBcbiAgICAgICAgICAoaW5FZGdlQkIgPSAkJC5tYXRoLmluTGluZVZpY2luaXR5KHgsIHksIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCB3aWR0aDIpKVxuICAgICAgICAgICAgJiYgcGFzc2VzVmlzaWJpbGl0eUNoZWNrKCkgJiZcbiAgICAgICAgICB3aWR0aFNxID4gKCBzcURpc3QgPSAkJC5tYXRoLnNxRGlzdGFuY2VUb0Zpbml0ZUxpbmUoIHgsIHksIHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZICkgKVxuICAgICAgICApe1xuICAgICAgICAgIG5lYXIucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICBcbiAgICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcpIHtcbiAgICAgICAgaWYoXG4gICAgICAgICAgKGluRWRnZUJCID0gJCQubWF0aC5pbkxpbmVWaWNpbml0eSh4LCB5LCBycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuZW5kWCwgcnMuZW5kWSwgd2lkdGgyKSlcbiAgICAgICAgICAgICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmXG4gICAgICAgICAgd2lkdGhTcSA+ICggc3FEaXN0ID0gJCQubWF0aC5zcURpc3RhbmNlVG9GaW5pdGVMaW5lKHgsIHksIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5lbmRYLCBycy5lbmRZKSApXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ2JlemllcicpIHtcbiAgICAgICAgaWYoXG4gICAgICAgICAgKGluRWRnZUJCID0gJCQubWF0aC5pbkJlemllclZpY2luaXR5KHgsIHksIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5jcDJ4LCBycy5jcDJ5LCBycy5lbmRYLCBycy5lbmRZLCB3aWR0aFNxKSlcbiAgICAgICAgICAgICYmIHBhc3Nlc1Zpc2liaWxpdHlDaGVjaygpICYmXG4gICAgICAgICAgKHdpZHRoU3EgPiAoc3FEaXN0ID0gJCQubWF0aC5zcURpc3RhbmNlVG9RdWFkcmF0aWNCZXppZXIoeCwgeSwgcnMuc3RhcnRYLCBycy5zdGFydFksIHJzLmNwMngsIHJzLmNwMnksIHJzLmVuZFgsIHJzLmVuZFkpKSApXG4gICAgICAgICl7XG4gICAgICAgICAgbmVhci5wdXNoKCBlZGdlICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gaWYgd2UncmUgY2xvc2UgdG8gdGhlIGVkZ2UgYnV0IGRpZG4ndCBoaXQgaXQsIG1heWJlIHdlIGhpdCBpdHMgYXJyb3dzXG4gICAgICBpZiggaW5FZGdlQkIgJiYgcGFzc2VzVmlzaWJpbGl0eUNoZWNrKCkgJiYgbmVhci5sZW5ndGggPT09IDAgfHwgbmVhcltuZWFyLmxlbmd0aCAtIDFdICE9PSBlZGdlICl7XG4gICAgICAgIHZhciBzcmNTaGFwZSA9IENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzWyBzdHlsZVsnc291cmNlLWFycm93LXNoYXBlJ10udmFsdWUgXTtcbiAgICAgICAgdmFyIHRndFNoYXBlID0gQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbIHN0eWxlWyd0YXJnZXQtYXJyb3ctc2hhcGUnXS52YWx1ZSBdO1xuXG4gICAgICAgIHZhciBzcmMgPSBzcmMgfHwgZWRnZS5fcHJpdmF0ZS5zb3VyY2U7XG4gICAgICAgIHZhciB0Z3QgPSB0Z3QgfHwgZWRnZS5fcHJpdmF0ZS50YXJnZXQ7XG5cbiAgICAgICAgdmFyIHRndFBvcyA9IHRndC5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgICAgdmFyIHNyY1BvcyA9IHNyYy5fcHJpdmF0ZS5wb3NpdGlvbjtcblxuICAgICAgICB2YXIgc3JjQXJXID0gc2VsZi5nZXRBcnJvd1dpZHRoKCBzdHlsZVsnd2lkdGgnXS5weFZhbHVlICk7XG4gICAgICAgIHZhciBzcmNBckggPSBzZWxmLmdldEFycm93SGVpZ2h0KCBzdHlsZVsnd2lkdGgnXS5weFZhbHVlICk7XG5cbiAgICAgICAgdmFyIHRndEFyVyA9IHNyY0FyVztcbiAgICAgICAgdmFyIHRndEFySCA9IHNyY0FySDtcblxuICAgICAgICBpZihcbiAgICAgICAgICAoXG4gICAgICAgICAgICBzcmNTaGFwZS5yb3VnaENvbGxpZGUoeCwgeSwgcnMuYXJyb3dTdGFydFgsIHJzLmFycm93U3RhcnRZLCBzcmNBclcsIHNyY0FySCwgW3JzLmFycm93U3RhcnRYIC0gc3JjUG9zLngsIHJzLmFycm93U3RhcnRZIC0gc3JjUG9zLnldLCBlZGdlVGhyZXNob2xkKVxuICAgICAgICAgICAgICAmJiBcbiAgICAgICAgICAgIHNyY1NoYXBlLmNvbGxpZGUoeCwgeSwgcnMuYXJyb3dTdGFydFgsIHJzLmFycm93U3RhcnRZLCBzcmNBclcsIHNyY0FySCwgW3JzLmFycm93U3RhcnRYIC0gc3JjUG9zLngsIHJzLmFycm93U3RhcnRZIC0gc3JjUG9zLnldLCBlZGdlVGhyZXNob2xkKVxuICAgICAgICAgIClcbiAgICAgICAgICAgIHx8XG4gICAgICAgICAgKFxuICAgICAgICAgICAgdGd0U2hhcGUucm91Z2hDb2xsaWRlKHgsIHksIHJzLmFycm93RW5kWCwgcnMuYXJyb3dFbmRZLCB0Z3RBclcsIHRndEFySCwgW3JzLmFycm93RW5kWCAtIHRndFBvcy54LCBycy5hcnJvd0VuZFkgLSB0Z3RQb3MueV0sIGVkZ2VUaHJlc2hvbGQpXG4gICAgICAgICAgICAgICYmXG4gICAgICAgICAgICB0Z3RTaGFwZS5jb2xsaWRlKHgsIHksIHJzLmFycm93RW5kWCwgcnMuYXJyb3dFbmRZLCB0Z3RBclcsIHRndEFySCwgW3JzLmFycm93RW5kWCAtIHRndFBvcy54LCBycy5hcnJvd0VuZFkgLSB0Z3RQb3MueV0sIGVkZ2VUaHJlc2hvbGQpXG4gICAgICAgICAgKVxuICAgICAgICApe1xuICAgICAgICAgIG5lYXIucHVzaCggZWRnZSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGZvciBjb21wb3VuZCBncmFwaHMsIGhpdHRpbmcgZWRnZSBtYXkgYWN0dWFsbHkgd2FudCBhIGNvbm5lY3RlZCBub2RlIGluc3RlYWQgKGIvYyBlZGdlIG1heSBoYXZlIGdyZWF0ZXIgei1pbmRleCBwcmVjZWRlbmNlKVxuICAgICAgaWYoIGhhc0NvbXBvdW5kcyAmJiAgbmVhci5sZW5ndGggPiAwICYmIG5lYXJbIG5lYXIubGVuZ3RoIC0gMSBdID09PSBlZGdlICl7XG4gICAgICAgIGNoZWNrTm9kZSggc3JjICk7XG4gICAgICAgIGNoZWNrTm9kZSggdGd0ICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IGVsZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKXsgLy8gcmV2ZXJzZSBvcmRlciBmb3IgcHJlY2VkZW5jZVxuICAgICAgdmFyIGVsZSA9IGVsZXNbaV07XG5cbiAgICAgIGlmKCBuZWFyLmxlbmd0aCA+IDAgKXsgYnJlYWs7IH0gLy8gc2luY2Ugd2UgY2hlY2sgaW4gei1vcmRlciwgZmlyc3QgZm91bmQgaXMgdG9wIGFuZCBiZXN0IHJlc3VsdCA9PiBleGl0IGVhcmx5XG5cbiAgICAgIGlmKCBlbGUuX3ByaXZhdGUuZ3JvdXAgPT09ICdub2RlcycgKXsgXG4gICAgICAgIGNoZWNrTm9kZSggZWxlc1tpXSApO1xuXG4gICAgICB9IGVsc2UgIHsgLy8gdGhlbiBlZGdlXG4gICAgICAgIGNoZWNrRWRnZSggZWxlc1tpXSApO1xuICAgICAgfVxuXG4gICAgfVxuICBcbiAgICBcbiAgICBpZiggbmVhci5sZW5ndGggPiAwICl7XG4gICAgICByZXR1cm4gbmVhclsgbmVhci5sZW5ndGggLSAxIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfTsgXG5cbiAgLy8gJ0dpdmUgbWUgZXZlcnl0aGluZyBmcm9tIHRoaXMgYm94J1xuICBDUnAuZ2V0QWxsSW5Cb3ggPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mikge1xuICAgIHZhciBub2RlcyA9IHRoaXMuZ2V0Q2FjaGVkTm9kZXMoKTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmdldENhY2hlZEVkZ2VzKCk7XG4gICAgdmFyIGJveCA9IFtdO1xuICAgIFxuICAgIHZhciB4MWMgPSBNYXRoLm1pbih4MSwgeDIpO1xuICAgIHZhciB4MmMgPSBNYXRoLm1heCh4MSwgeDIpO1xuICAgIHZhciB5MWMgPSBNYXRoLm1pbih5MSwgeTIpO1xuICAgIHZhciB5MmMgPSBNYXRoLm1heCh5MSwgeTIpOyBcblxuICAgIHgxID0geDFjOyBcbiAgICB4MiA9IHgyYzsgXG4gICAgeTEgPSB5MWM7IFxuICAgIHkyID0geTJjOyBcblxuICAgIHZhciBoZXVyO1xuICAgIFxuICAgIGZvciAoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgcG9zID0gbm9kZXNbaV0uX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB2YXIgblNoYXBlID0gdGhpcy5nZXROb2RlU2hhcGUobm9kZXNbaV0pO1xuICAgICAgdmFyIHcgPSB0aGlzLmdldE5vZGVXaWR0aChub2Rlc1tpXSk7XG4gICAgICB2YXIgaCA9IHRoaXMuZ2V0Tm9kZUhlaWdodChub2Rlc1tpXSk7XG4gICAgICB2YXIgYm9yZGVyID0gbm9kZXNbaV0uX3ByaXZhdGUuc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWUgLyAyO1xuICAgICAgdmFyIHNoYXBlT2JqID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1sgblNoYXBlIF07XG5cbiAgICAgIGlmICggc2hhcGVPYmouaW50ZXJzZWN0Qm94KHgxLCB5MSwgeDIsIHkyLCB3LCBoLCBwb3MueCwgcG9zLnksIGJvcmRlcikgKXtcbiAgICAgICAgYm94LnB1c2gobm9kZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHJzID0gZWRnZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2g7XG5cbiAgICAgIGlmIChlZGdlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5lZGdlVHlwZSA9PSAnc2VsZicpIHtcbiAgICAgICAgaWYgKChoZXVyID0gJCQubWF0aC5ib3hJbkJlemllclZpY2luaXR5KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICBycy5jcDJheCwgcnMuY3AyYXksXG4gICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSlcbiAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgIChoZXVyID09IDIgfHwgKGhldXIgPT0gMSAmJiAkJC5tYXRoLmNoZWNrQmV6aWVySW5Cb3goeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgICBycy5jcDJheCwgcnMuY3AyYXksXG4gICAgICAgICAgICAgIHJzLmVuZFgsIHJzLmVuZFksIGVkZ2VzW2ldLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpKSlcbiAgICAgICAgICAgICAgICB8fFxuICAgICAgICAgIChoZXVyID0gJCQubWF0aC5ib3hJbkJlemllclZpY2luaXR5KHgxLCB5MSwgeDIsIHkyLFxuICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICBycy5jcDJjeCwgcnMuY3AyY3ksXG4gICAgICAgICAgICBycy5lbmRYLCBycy5lbmRZLCBlZGdlc1tpXS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlKSlcbiAgICAgICAgICAgICAgJiZcbiAgICAgICAgICAgIChoZXVyID09IDIgfHwgKGhldXIgPT0gMSAmJiAkJC5tYXRoLmNoZWNrQmV6aWVySW5Cb3goeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgICBycy5jcDJjeCwgcnMuY3AyY3ksXG4gICAgICAgICAgICAgIHJzLmVuZFgsIHJzLmVuZFksIGVkZ2VzW2ldLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpKSlcbiAgICAgICAgICApXG4gICAgICAgIHsgYm94LnB1c2goZWRnZXNbaV0pOyB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmIChycy5lZGdlVHlwZSA9PSAnYmV6aWVyJyAmJlxuICAgICAgICAoaGV1ciA9ICQkLm1hdGguYm94SW5CZXppZXJWaWNpbml0eSh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgcnMuY3AyeCwgcnMuY3AyeSxcbiAgICAgICAgICAgIHJzLmVuZFgsIHJzLmVuZFksIGVkZ2VzW2ldLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpKVxuICAgICAgICAgICAgICAmJlxuICAgICAgICAgICAgKGhldXIgPT0gMiB8fCAoaGV1ciA9PSAxICYmICQkLm1hdGguY2hlY2tCZXppZXJJbkJveCh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICAgIHJzLmNwMngsIHJzLmNwMnksXG4gICAgICAgICAgICAgIHJzLmVuZFgsIHJzLmVuZFksIGVkZ2VzW2ldLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpKSkpXG4gICAgICAgIHsgYm94LnB1c2goZWRnZXNbaV0pOyB9XG4gICAgXG4gICAgICBpZiAocnMuZWRnZVR5cGUgPT0gJ3N0cmFpZ2h0JyAmJlxuICAgICAgICAoaGV1ciA9ICQkLm1hdGguYm94SW5CZXppZXJWaWNpbml0eSh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgIHJzLnN0YXJ0WCwgcnMuc3RhcnRZLFxuICAgICAgICAgICAgcnMuc3RhcnRYICogMC41ICsgcnMuZW5kWCAqIDAuNSwgXG4gICAgICAgICAgICBycy5zdGFydFkgKiAwLjUgKyBycy5lbmRZICogMC41LCBcbiAgICAgICAgICAgIHJzLmVuZFgsIHJzLmVuZFksIGVkZ2VzW2ldLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpKVxuICAgICAgICAgICAgICAmJiAvKiBjb25zb2xlLmxvZygndGVzdCcsIGhldXIpID09IHVuZGVmaW5lZCAmJiAqL1xuICAgICAgICAgICAgKGhldXIgPT0gMiB8fCAoaGV1ciA9PSAxICYmICQkLm1hdGguY2hlY2tTdHJhaWdodEVkZ2VJbkJveCh4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgICAgICAgcnMuc3RhcnRYLCBycy5zdGFydFksXG4gICAgICAgICAgICAgIHJzLmVuZFgsIHJzLmVuZFksIGVkZ2VzW2ldLl9wcml2YXRlLnN0eWxlWyd3aWR0aCddLnB4VmFsdWUpKSkpXG4gICAgICAgIHsgYm94LnB1c2goZWRnZXNbaV0pOyB9XG5cblxuICAgICAgaWYgKHJzLmVkZ2VUeXBlID09ICdoYXlzdGFjaycpe1xuICAgICAgICB2YXIgdGd0ID0gZWRnZXNbaV0udGFyZ2V0KClbMF07XG4gICAgICAgIHZhciB0Z3RQb3MgPSB0Z3QucG9zaXRpb24oKTtcbiAgICAgICAgdmFyIHNyYyA9IGVkZ2VzW2ldLnNvdXJjZSgpWzBdO1xuICAgICAgICB2YXIgc3JjUG9zID0gc3JjLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgdmFyIHN0YXJ0WCA9IHNyY1Bvcy54ICsgcnMuc291cmNlLng7XG4gICAgICAgIHZhciBzdGFydFkgPSBzcmNQb3MueSArIHJzLnNvdXJjZS55O1xuICAgICAgICB2YXIgZW5kWCA9IHRndFBvcy54ICsgcnMudGFyZ2V0Lng7XG4gICAgICAgIHZhciBlbmRZID0gdGd0UG9zLnkgKyBycy50YXJnZXQueTtcblxuICAgICAgICB2YXIgc3RhcnRJbkJveCA9ICh4MSA8PSBzdGFydFggJiYgc3RhcnRYIDw9IHgyKSAmJiAoeTEgPD0gc3RhcnRZICYmIHN0YXJ0WSA8PSB5Mik7XG4gICAgICAgIHZhciBlbmRJbkJveCA9ICh4MSA8PSBlbmRYICYmIGVuZFggPD0geDIpICYmICh5MSA8PSBlbmRZICYmIGVuZFkgPD0geTIpO1xuXG4gICAgICAgIGlmKCBzdGFydEluQm94ICYmIGVuZEluQm94ICl7XG4gICAgICAgICAgYm94LnB1c2goIGVkZ2VzW2ldICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gYm94O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBnaXZlbiBub2RlLiBJZiB0aGUgd2lkdGggaXMgc2V0IHRvIGF1dG8sXG4gICAqIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBhdXRvV2lkdGggZmllbGQuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlICAgICAgICAgIGEgbm9kZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICB3aWR0aCBvZiB0aGUgbm9kZVxuICAgKi9cbiAgQ1JwLmdldE5vZGVXaWR0aCA9IGZ1bmN0aW9uKG5vZGUpXG4gIHtcbiAgICByZXR1cm4gbm9kZS53aWR0aCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBoZWlnaHQgb2YgdGhlIGdpdmVuIG5vZGUuIElmIHRoZSBoZWlnaHQgaXMgc2V0IHRvIGF1dG8sXG4gICAqIHJldHVybnMgdGhlIHZhbHVlIG9mIHRoZSBhdXRvSGVpZ2h0IGZpZWxkLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSAgICAgICAgICBhIG5vZGVcbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgd2lkdGggb2YgdGhlIG5vZGVcbiAgICovXG4gIENScC5nZXROb2RlSGVpZ2h0ID0gZnVuY3Rpb24obm9kZSlcbiAge1xuICAgIHJldHVybiBub2RlLmhlaWdodCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzaGFwZSBvZiB0aGUgZ2l2ZW4gbm9kZS4gSWYgdGhlIGhlaWdodCBvciB3aWR0aCBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgKiBpcyBzZXQgdG8gYXV0bywgdGhlIG5vZGUgaXMgY29uc2lkZXJlZCB0byBiZSBhIGNvbXBvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gbm9kZSAgICAgICAgICBhIG5vZGVcbiAgICogQHJldHVybiB7U3RyaW5nfSAgICAgc2hhcGUgb2YgdGhlIG5vZGVcbiAgICovXG4gIENScC5nZXROb2RlU2hhcGUgPSBmdW5jdGlvbihub2RlKVxuICB7XG4gICAgLy8gVE9ETyBvbmx5IGFsbG93IHJlY3RhbmdsZSBmb3IgYSBjb21wb3VuZCBub2RlP1xuLy8gICAgaWYgKG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3dpZHRoJ10udmFsdWUgPT0gJ2F1dG8nIHx8XG4vLyAgICAgICAgbm9kZS5fcHJpdmF0ZS5zdHlsZVsnaGVpZ2h0J10udmFsdWUgPT0gJ2F1dG8nKVxuLy8gICAge1xuLy8gICAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4vLyAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBub2RlLl9wcml2YXRlLnN0eWxlWydzaGFwZSddLnZhbHVlO1xuXG4gICAgaWYoIG5vZGUuaXNQYXJlbnQoKSApe1xuICAgICAgaWYoIHNoYXBlID09PSAncmVjdGFuZ2xlJyB8fCBzaGFwZSA9PT0gJ3JvdW5kcmVjdGFuZ2xlJyApe1xuICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ3JlY3RhbmdsZSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG5cbiAgQ1JwLmdldE5vZGVQYWRkaW5nID0gZnVuY3Rpb24obm9kZSlcbiAge1xuICAgIHZhciBsZWZ0ID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsncGFkZGluZy1sZWZ0J10ucHhWYWx1ZTtcbiAgICB2YXIgcmlnaHQgPSBub2RlLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLXJpZ2h0J10ucHhWYWx1ZTtcbiAgICB2YXIgdG9wID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsncGFkZGluZy10b3AnXS5weFZhbHVlO1xuICAgIHZhciBib3R0b20gPSBub2RlLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLWJvdHRvbSddLnB4VmFsdWU7XG5cbiAgICBpZiAoaXNOYU4obGVmdCkpXG4gICAge1xuICAgICAgbGVmdCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKHJpZ2h0KSlcbiAgICB7XG4gICAgICByaWdodCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGlzTmFOKHRvcCkpXG4gICAge1xuICAgICAgdG9wID0gMDtcbiAgICB9XG5cbiAgICBpZiAoaXNOYU4oYm90dG9tKSlcbiAgICB7XG4gICAgICBib3R0b20gPSAwO1xuICAgIH1cblxuICAgIHJldHVybiB7bGVmdCA6IGxlZnQsXG4gICAgICByaWdodCA6IHJpZ2h0LFxuICAgICAgdG9wIDogdG9wLFxuICAgICAgYm90dG9tIDogYm90dG9tfTtcbiAgfTtcblxuICBDUnAuek9yZGVyU29ydCA9ICQkLkNvbGxlY3Rpb24uekluZGV4U29ydDtcblxuICBDUnAudXBkYXRlQ2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMoIHRydWUgKTtcbiAgfTtcblxuICBDUnAuZ2V0Q2FjaGVkWlNvcnRlZEVsZXMgPSBmdW5jdGlvbiggZm9yY2VSZWNhbGMgKXtcbiAgICB2YXIgbGFzdE5vZGVzID0gdGhpcy5sYXN0Wk9yZGVyQ2FjaGVkTm9kZXM7XG4gICAgdmFyIGxhc3RFZGdlcyA9IHRoaXMubGFzdFpPcmRlckNhY2hlZEVkZ2VzO1xuICAgIHZhciBub2RlcyA9IHRoaXMuZ2V0Q2FjaGVkTm9kZXMoKTtcbiAgICB2YXIgZWRnZXMgPSB0aGlzLmdldENhY2hlZEVkZ2VzKCk7XG4gICAgdmFyIGVsZXMgPSBbXTtcblxuICAgIGlmKCBmb3JjZVJlY2FsYyB8fCAhbGFzdE5vZGVzIHx8ICFsYXN0RWRnZXMgfHwgbGFzdE5vZGVzICE9PSBub2RlcyB8fCBsYXN0RWRnZXMgIT09IGVkZ2VzICl7IFxuICAgICAgLy9jb25zb2xlLnRpbWUoJ2NhY2hlem9yZGVyJylcbiAgICAgIFxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICBpZiggbm9kZXNbaV0udmlzaWJsZSgpICYmICFub2Rlc1tpXS50cmFuc3BhcmVudCgpICl7XG4gICAgICAgICAgZWxlcy5wdXNoKCBub2Rlc1tpXSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgaWYoIGVkZ2VzW2ldLnZpc2libGUoKSAmJiAhZWRnZXNbaV0udHJhbnNwYXJlbnQoKSApe1xuICAgICAgICAgIGVsZXMucHVzaCggZWRnZXNbaV0gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbGVzLnNvcnQoIHRoaXMuek9yZGVyU29ydCApO1xuICAgICAgdGhpcy5jYWNoZWRaU29ydGVkRWxlcyA9IGVsZXM7XG4gICAgICAvL2NvbnNvbGUubG9nKCdtYWtlIGNhY2hlJylcblxuICAgICAgLy9jb25zb2xlLnRpbWVFbmQoJ2NhY2hlem9yZGVyJylcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlcyA9IHRoaXMuY2FjaGVkWlNvcnRlZEVsZXM7XG4gICAgICAvL2NvbnNvbGUubG9nKCdyZWFkIGNhY2hlJylcbiAgICB9XG5cbiAgICB0aGlzLmxhc3RaT3JkZXJDYWNoZWROb2RlcyA9IG5vZGVzO1xuICAgIHRoaXMubGFzdFpPcmRlckNhY2hlZEVkZ2VzID0gZWRnZXM7XG5cbiAgICByZXR1cm4gZWxlcztcbiAgfTtcblxuICBDUnAucHJvamVjdEJlemllciA9IGZ1bmN0aW9uKGVkZ2Upe1xuICAgIHZhciBxYmV6aWVyQXQgPSAkJC5tYXRoLnFiZXppZXJBdDtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBicHRzID0gZWRnZS5fcHJpdmF0ZS5yc3R5bGUuYmV6aWVyUHRzID0gW107XG5cbiAgICBmdW5jdGlvbiBwdXNoQmV6aWVyUHRzKHB0cyl7XG4gICAgICBicHRzLnB1c2goe1xuICAgICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuMDUgKSxcbiAgICAgICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjA1IClcbiAgICAgIH0pO1xuXG4gICAgICBicHRzLnB1c2goe1xuICAgICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuMjUgKSxcbiAgICAgICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjI1IClcbiAgICAgIH0pO1xuXG4gICAgICBicHRzLnB1c2goe1xuICAgICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuNCApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuNCApXG4gICAgICB9KTtcblxuICAgICAgdmFyIG1pZCA9IHtcbiAgICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjUgKSxcbiAgICAgICAgeTogcWJlemllckF0KCBwdHNbMV0sIHB0c1szXSwgcHRzWzVdLCAwLjUgKVxuICAgICAgfTtcblxuICAgICAgYnB0cy5wdXNoKCBtaWQgKTtcblxuICAgICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnc2VsZicgfHwgcnMuZWRnZVR5cGUgPT09ICdjb21wb3VuZCcgKXtcbiAgICAgICAgcnMubWlkWCA9IHJzLnNlbGZFZGdlTWlkWDtcbiAgICAgICAgcnMubWlkWSA9IHJzLnNlbGZFZGdlTWlkWTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLm1pZFggPSBtaWQueDtcbiAgICAgICAgcnMubWlkWSA9IG1pZC55O1xuICAgICAgfVxuXG4gICAgICBicHRzLnB1c2goe1xuICAgICAgICB4OiBxYmV6aWVyQXQoIHB0c1swXSwgcHRzWzJdLCBwdHNbNF0sIDAuNiApLFxuICAgICAgICB5OiBxYmV6aWVyQXQoIHB0c1sxXSwgcHRzWzNdLCBwdHNbNV0sIDAuNiApXG4gICAgICB9KTtcblxuICAgICAgYnB0cy5wdXNoKHtcbiAgICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjc1ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC43NSApXG4gICAgICB9KTtcblxuICAgICAgYnB0cy5wdXNoKHtcbiAgICAgICAgeDogcWJlemllckF0KCBwdHNbMF0sIHB0c1syXSwgcHRzWzRdLCAwLjk1ICksXG4gICAgICAgIHk6IHFiZXppZXJBdCggcHRzWzFdLCBwdHNbM10sIHB0c1s1XSwgMC45NSApXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiggcnMuZWRnZVR5cGUgPT09ICdzZWxmJyApe1xuICAgICAgcHVzaEJlemllclB0cyggW3JzLnN0YXJ0WCwgcnMuc3RhcnRZLCBycy5jcDJheCwgcnMuY3AyYXksIHJzLnNlbGZFZGdlTWlkWCwgcnMuc2VsZkVkZ2VNaWRZXSApO1xuICAgICAgcHVzaEJlemllclB0cyggW3JzLnNlbGZFZGdlTWlkWCwgcnMuc2VsZkVkZ2VNaWRZLCBycy5jcDJjeCwgcnMuY3AyY3ksIHJzLmVuZFgsIHJzLmVuZFldICk7XG4gICAgfSBlbHNlIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2JlemllcicgKXtcbiAgICAgIHB1c2hCZXppZXJQdHMoIFtycy5zdGFydFgsIHJzLnN0YXJ0WSwgcnMuY3AyeCwgcnMuY3AyeSwgcnMuZW5kWCwgcnMuZW5kWV0gKTtcbiAgICB9XG4gIH07XG5cbiAgQ1JwLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiA9IGZ1bmN0aW9uKCBub2RlICl7IFxuICAgIHZhciBjb250ZW50ID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuICAgIGlmKCAhY29udGVudCB8fCBjb250ZW50Lm1hdGNoKC9eXFxzKyQvKSApeyByZXR1cm47IH1cblxuICAgIHZhciB0ZXh0WCwgdGV4dFk7XG4gICAgdmFyIG5vZGVXaWR0aCA9IG5vZGUub3V0ZXJXaWR0aCgpO1xuICAgIHZhciBub2RlSGVpZ2h0ID0gbm9kZS5vdXRlckhlaWdodCgpO1xuICAgIHZhciBub2RlUG9zID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICB2YXIgdGV4dEhhbGlnbiA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ3RleHQtaGFsaWduJ10uc3RyVmFsdWU7XG4gICAgdmFyIHRleHRWYWxpZ24gPSBub2RlLl9wcml2YXRlLnN0eWxlWyd0ZXh0LXZhbGlnbiddLnN0clZhbHVlO1xuICAgIHZhciBycyA9IG5vZGUuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgdmFyIHJzdHlsZSA9IG5vZGUuX3ByaXZhdGUucnN0eWxlO1xuXG4gICAgc3dpdGNoKCB0ZXh0SGFsaWduICl7XG4gICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgdGV4dFggPSBub2RlUG9zLnggLSBub2RlV2lkdGggLyAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICB0ZXh0WCA9IG5vZGVQb3MueCArIG5vZGVXaWR0aCAvIDI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OiAvLyBlLmcuIGNlbnRlclxuICAgICAgICB0ZXh0WCA9IG5vZGVQb3MueDtcbiAgICB9XG5cbiAgICBzd2l0Y2goIHRleHRWYWxpZ24gKXtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIHRleHRZID0gbm9kZVBvcy55IC0gbm9kZUhlaWdodCAvIDI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICB0ZXh0WSA9IG5vZGVQb3MueSArIG5vZGVIZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDogLy8gZS5nLiBtaWRkbGVcbiAgICAgICAgdGV4dFkgPSBub2RlUG9zLnk7XG4gICAgfVxuICBcbiAgICBycy5sYWJlbFggPSB0ZXh0WDtcbiAgICBycy5sYWJlbFkgPSB0ZXh0WTtcbiAgICByc3R5bGUubGFiZWxYID0gdGV4dFg7XG4gICAgcnN0eWxlLmxhYmVsWSA9IHRleHRZO1xuXG4gICAgdGhpcy5hcHBseUxhYmVsRGltZW5zaW9ucyggbm9kZSApO1xuICB9O1xuXG4gIENScC5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb24gPSBmdW5jdGlvbiggZWRnZSApe1xuICAgIHZhciBjb250ZW50ID0gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnY29udGVudCddLnN0clZhbHVlO1xuICAgIGlmKCAhY29udGVudCB8fCBjb250ZW50Lm1hdGNoKC9eXFxzKyQvKSApeyByZXR1cm47IH1cblxuICAgIHZhciB0ZXh0WCwgdGV4dFk7ICBcbiAgICB2YXIgZWRnZUNlbnRlclgsIGVkZ2VDZW50ZXJZO1xuICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgdmFyIHJzID0gX3AucnNjcmF0Y2g7XG4gICAgLy92YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgICB2YXIgcnN0eWxlID0gX3AucnN0eWxlO1xuICAgIFxuICAgIGlmIChycy5lZGdlVHlwZSA9PSAnc2VsZicpIHtcbiAgICAgIGVkZ2VDZW50ZXJYID0gcnMuc2VsZkVkZ2VNaWRYO1xuICAgICAgZWRnZUNlbnRlclkgPSBycy5zZWxmRWRnZU1pZFk7XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PSAnc3RyYWlnaHQnKSB7XG4gICAgICBlZGdlQ2VudGVyWCA9IChycy5zdGFydFggKyBycy5lbmRYKSAvIDI7XG4gICAgICBlZGdlQ2VudGVyWSA9IChycy5zdGFydFkgKyBycy5lbmRZKSAvIDI7XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PSAnYmV6aWVyJykge1xuICAgICAgZWRnZUNlbnRlclggPSAkJC5tYXRoLnFiZXppZXJBdCggcnMuc3RhcnRYLCBycy5jcDJ4LCBycy5lbmRYLCAwLjUgKTtcbiAgICAgIGVkZ2VDZW50ZXJZID0gJCQubWF0aC5xYmV6aWVyQXQoIHJzLnN0YXJ0WSwgcnMuY3AyeSwgcnMuZW5kWSwgMC41ICk7XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PSAnaGF5c3RhY2snKSB7XG4gICAgICAvLyB2YXIgc3JjID0gX3Auc291cmNlO1xuICAgICAgLy8gdmFyIHRndCA9IF9wLnRhcmdldDtcbiAgICAgIC8vIHZhciBzcmNQb3MgPSBzcmMuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAvLyB2YXIgdGd0UG9zID0gdGd0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgdmFyIHB0cyA9IHJzLmhheXN0YWNrUHRzO1xuXG4gICAgICBlZGdlQ2VudGVyWCA9ICggcHRzWzBdICsgcHRzWzJdICkvMjtcbiAgICAgIGVkZ2VDZW50ZXJZID0gKCBwdHNbMV0gKyBwdHNbM10gKS8yO1xuICAgIH1cbiAgICBcbiAgICB0ZXh0WCA9IGVkZ2VDZW50ZXJYO1xuICAgIHRleHRZID0gZWRnZUNlbnRlclk7XG5cbiAgICAvLyBhZGQgY2VudGVyIHBvaW50IHRvIHN0eWxlIHNvIGJvdW5kaW5nIGJveCBjYWxjdWxhdGlvbnMgY2FuIHVzZSBpdFxuICAgIHJzLmxhYmVsWCA9IHRleHRYO1xuICAgIHJzLmxhYmVsWSA9IHRleHRZO1xuICAgIHJzdHlsZS5sYWJlbFggPSB0ZXh0WDtcbiAgICByc3R5bGUubGFiZWxZID0gdGV4dFk7XG5cbiAgICB0aGlzLmFwcGx5TGFiZWxEaW1lbnNpb25zKCBlZGdlICk7XG4gIH07XG5cbiAgQ1JwLmFwcGx5TGFiZWxEaW1lbnNpb25zID0gZnVuY3Rpb24oIGVsZSApe1xuICAgIHZhciBycyA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgcnN0eWxlID0gZWxlLl9wcml2YXRlLnJzdHlsZTtcblxuICAgIHZhciB0ZXh0ID0gdGhpcy5nZXRMYWJlbFRleHQoIGVsZSApO1xuICAgIHZhciBsYWJlbERpbXMgPSB0aGlzLmNhbGN1bGF0ZUxhYmVsRGltZW5zaW9ucyggZWxlLCB0ZXh0ICk7XG4gXG4gICAgcnN0eWxlLmxhYmVsV2lkdGggPSBsYWJlbERpbXMud2lkdGg7XG4gICAgcnMubGFiZWxXaWR0aCA9IGxhYmVsRGltcy53aWR0aDtcbiBcbiAgICByc3R5bGUubGFiZWxIZWlnaHQgPSBsYWJlbERpbXMuaGVpZ2h0O1xuICAgIHJzLmxhYmVsSGVpZ2h0ID0gbGFiZWxEaW1zLmhlaWdodDtcbiAgfTtcblxuICBDUnAuZ2V0TGFiZWxUZXh0ID0gZnVuY3Rpb24oIGVsZSApeyBcbiAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIHRleHQgPSBlbGUuX3ByaXZhdGUuc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcbiAgICB2YXIgdGV4dFRyYW5zZm9ybSA9IHN0eWxlWyd0ZXh0LXRyYW5zZm9ybSddLnZhbHVlO1xuICAgIHZhciByc2NyYXRjaCA9IGVsZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICBcbiAgICBpZiAodGV4dFRyYW5zZm9ybSA9PSAnbm9uZScpIHtcbiAgICB9IGVsc2UgaWYgKHRleHRUcmFuc2Zvcm0gPT0gJ3VwcGVyY2FzZScpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRvVXBwZXJDYXNlKCk7XG4gICAgfSBlbHNlIGlmICh0ZXh0VHJhbnNmb3JtID09ICdsb3dlcmNhc2UnKSB7XG4gICAgICB0ZXh0ID0gdGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmKCBzdHlsZVsndGV4dC13cmFwJ10udmFsdWUgPT09ICd3cmFwJyApe1xuICAgICAgLy9jb25zb2xlLmxvZygnd3JhcCcpOyBcbiAgICAgIFxuICAgICAgLy8gc2F2ZSByZWNhbGMgaWYgdGhlIGxhYmVsIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxuICAgICAgaWYoIHJzY3JhdGNoLmxhYmVsV3JhcEtleSA9PT0gcnNjcmF0Y2gubGFiZWxLZXkgKXsgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd3cmFwIGNhY2hlIGhpdCcpO1xuICAgICAgICByZXR1cm4gcnNjcmF0Y2gubGFiZWxXcmFwQ2FjaGVkVGV4dDtcbiAgICAgIH1cbiAgICAgIC8vIGNvbnNvbGUubG9nKCd3cmFwIGNhY2hlIG1pc3MnKTtcblxuICAgICAgdmFyIGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgbWF4VyA9IHN0eWxlWyd0ZXh0LW1heC13aWR0aCddLnB4VmFsdWU7XG4gICAgICB2YXIgd3JhcHBlZExpbmVzID0gW107XG5cbiAgICAgIGZvciggdmFyIGwgPSAwOyBsIDwgbGluZXMubGVuZ3RoOyBsKysgKXtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tsXTtcbiAgICAgICAgdmFyIGxpbmVEaW1zID0gdGhpcy5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMoIGVsZSwgbGluZSwgJ2xpbmU9JyArIGxpbmUgKTtcbiAgICAgICAgdmFyIGxpbmVXID0gbGluZURpbXMud2lkdGg7XG5cbiAgICAgICAgaWYoIGxpbmVXID4gbWF4VyApeyAvLyBsaW5lIGlzIHRvbyBsb25nXG4gICAgICAgICAgdmFyIHdvcmRzID0gbGluZS5zcGxpdCgvXFxzKy8pOyAvLyBOQjogYXNzdW1lIGNvbGxhcHNlZCB3aGl0ZXNwYWNlIGludG8gc2luZ2xlIHNwYWNlXG4gICAgICAgICAgdmFyIHN1YmxpbmUgPSAnJztcblxuICAgICAgICAgIGZvciggdmFyIHcgPSAwOyB3IDwgd29yZHMubGVuZ3RoOyB3KysgKXtcbiAgICAgICAgICAgIHZhciB3b3JkID0gd29yZHNbd107XG4gICAgICAgICAgICB2YXIgdGVzdExpbmUgPSBzdWJsaW5lLmxlbmd0aCA9PT0gMCA/IHdvcmQgOiBzdWJsaW5lICsgJyAnICsgd29yZDtcbiAgICAgICAgICAgIHZhciB0ZXN0RGltcyA9IHRoaXMuY2FsY3VsYXRlTGFiZWxEaW1lbnNpb25zKCBlbGUsIHRlc3RMaW5lLCAndGVzdExpbmU9JyArIHRlc3RMaW5lICk7XG4gICAgICAgICAgICB2YXIgdGVzdFcgPSB0ZXN0RGltcy53aWR0aDtcblxuICAgICAgICAgICAgaWYoIHRlc3RXIDw9IG1heFcgKXsgLy8gd29yZCBmaXRzIG9uIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICBzdWJsaW5lICs9IHdvcmQgKyAnICc7XG4gICAgICAgICAgICB9IGVsc2UgeyAvLyB3b3JkIHN0YXJ0cyBuZXcgbGluZVxuICAgICAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaCggc3VibGluZSApO1xuICAgICAgICAgICAgICBzdWJsaW5lID0gd29yZCArICcgJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGVyZSdzIHJlbWFpbmluZyB0ZXh0LCBwdXQgaXQgaW4gYSB3cmFwcGVkIGxpbmVcbiAgICAgICAgICBpZiggIXN1YmxpbmUubWF0Y2goL15cXHMrJC8pICl7XG4gICAgICAgICAgICB3cmFwcGVkTGluZXMucHVzaCggc3VibGluZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gbGluZSBpcyBhbHJlYWR5IHNob3J0IGVub3VnaFxuICAgICAgICAgIHdyYXBwZWRMaW5lcy5wdXNoKCBsaW5lICk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gZm9yXG5cbiAgICAgIHJzY3JhdGNoLmxhYmVsV3JhcENhY2hlZExpbmVzID0gd3JhcHBlZExpbmVzO1xuICAgICAgcnNjcmF0Y2gubGFiZWxXcmFwQ2FjaGVkVGV4dCA9IHRleHQgPSB3cmFwcGVkTGluZXMuam9pbignXFxuJyk7XG4gICAgICByc2NyYXRjaC5sYWJlbFdyYXBLZXkgPSByc2NyYXRjaC5sYWJlbEtleTtcblxuICAgICAgLy8gY29uc29sZS5sb2codGV4dClcbiAgICB9IC8vIGlmIHdyYXBcblxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuXG4gIENScC5jYWxjdWxhdGVMYWJlbERpbWVuc2lvbnMgPSBmdW5jdGlvbiggZWxlLCB0ZXh0LCBleHRyYUtleSApe1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgc3R5bGUgPSBlbGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIGZTdHlsZSA9IHN0eWxlWydmb250LXN0eWxlJ10uc3RyVmFsdWU7XG4gICAgdmFyIHNpemUgPSBzdHlsZVsnZm9udC1zaXplJ10ucHhWYWx1ZSArICdweCc7XG4gICAgdmFyIGZhbWlseSA9IHN0eWxlWydmb250LWZhbWlseSddLnN0clZhbHVlO1xuICAgIC8vIHZhciB2YXJpYW50ID0gc3R5bGVbJ2ZvbnQtdmFyaWFudCddLnN0clZhbHVlO1xuICAgIHZhciB3ZWlnaHQgPSBzdHlsZVsnZm9udC13ZWlnaHQnXS5zdHJWYWx1ZTtcblxuICAgIHZhciBjYWNoZUtleSA9IGVsZS5fcHJpdmF0ZS5sYWJlbEtleTtcblxuICAgIGlmKCBleHRyYUtleSApe1xuICAgICAgY2FjaGVLZXkgKz0gJyRAJCcgKyBleHRyYUtleTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGUgPSByLmxhYmVsRGltQ2FjaGUgfHwgKHIubGFiZWxEaW1DYWNoZSA9IHt9KTtcblxuICAgIGlmKCBjYWNoZVtjYWNoZUtleV0gKXtcbiAgICAgIHJldHVybiBjYWNoZVtjYWNoZUtleV07XG4gICAgfVxuXG4gICAgdmFyIGRpdiA9IHRoaXMubGFiZWxDYWxjRGl2O1xuXG4gICAgaWYoICFkaXYgKXtcbiAgICAgIGRpdiA9IHRoaXMubGFiZWxDYWxjRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKCBkaXYgKTtcbiAgICB9XG5cbiAgICB2YXIgZHMgPSBkaXYuc3R5bGU7XG5cbiAgICAvLyBmcm9tIGVsZSBzdHlsZVxuICAgIGRzLmZvbnRGYW1pbHkgPSBmYW1pbHk7XG4gICAgZHMuZm9udFN0eWxlID0gZlN0eWxlO1xuICAgIGRzLmZvbnRTaXplID0gc2l6ZTtcbiAgICAvLyBkcy5mb250VmFyaWFudCA9IHZhcmlhbnQ7XG4gICAgZHMuZm9udFdlaWdodCA9IHdlaWdodDtcblxuICAgIC8vIGZvcmNlZCBzdHlsZVxuICAgIGRzLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBkcy5sZWZ0ID0gJy05OTk5cHgnO1xuICAgIGRzLnRvcCA9ICctOTk5OXB4JztcbiAgICBkcy56SW5kZXggPSAnLTEnO1xuICAgIGRzLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICBkcy5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIGRzLnBhZGRpbmcgPSAnMCc7XG4gICAgZHMubGluZUhlaWdodCA9ICcxJztcblxuICAgIGlmKCBzdHlsZVsndGV4dC13cmFwJ10udmFsdWUgPT09ICd3cmFwJyApe1xuICAgICAgZHMud2hpdGVTcGFjZSA9ICdwcmUnOyAvLyBzbyBuZXdsaW5lcyBhcmUgdGFrZW4gaW50byBhY2NvdW50XG4gICAgfSBlbHNlIHtcbiAgICAgIGRzLndoaXRlU3BhY2UgPSAnbm9ybWFsJztcbiAgICB9XG5cbiAgICAvLyBwdXQgbGFiZWwgY29udGVudCBpbiBkaXZcbiAgICBkaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuXG4gICAgY2FjaGVbY2FjaGVLZXldID0ge1xuICAgICAgd2lkdGg6IGRpdi5jbGllbnRXaWR0aCxcbiAgICAgIGhlaWdodDogZGl2LmNsaWVudEhlaWdodFxuICAgIH07XG5cbiAgICByZXR1cm4gY2FjaGVbY2FjaGVLZXldO1xuICB9OyAgXG5cbiAgQ1JwLnJlY2FsY3VsYXRlUmVuZGVyZWRTdHlsZSA9IGZ1bmN0aW9uKCBlbGVzICl7XG4gICAgdmFyIGVkZ2VzID0gW107XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgdmFyIGhhbmRsZWRFZGdlID0ge307XG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBlbGVzW2ldO1xuICAgICAgdmFyIF9wID0gZWxlLl9wcml2YXRlO1xuICAgICAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gICAgICB2YXIgcnMgPSBfcC5yc2NyYXRjaDtcbiAgICAgIHZhciByc3R5bGUgPSBfcC5yc3R5bGU7XG4gICAgICB2YXIgaWQgPSBfcC5kYXRhLmlkO1xuICAgICAgdmFyIGJiU3R5bGVTYW1lID0gcnMuYm91bmRpbmdCb3hLZXkgIT0gbnVsbCAmJiBfcC5ib3VuZGluZ0JveEtleSA9PT0gcnMuYm91bmRpbmdCb3hLZXk7XG4gICAgICB2YXIgbGFiZWxTdHlsZVNhbWUgPSBycy5sYWJlbEtleSAhPSBudWxsICYmIF9wLmxhYmVsS2V5ID09PSBycy5sYWJlbEtleTtcbiAgICAgIHZhciBzdHlsZVNhbWUgPSBiYlN0eWxlU2FtZSAmJiBsYWJlbFN0eWxlU2FtZTtcblxuICAgICAgaWYoIGVsZS5fcHJpdmF0ZS5ncm91cCA9PT0gJ25vZGVzJyApe1xuICAgICAgICB2YXIgcG9zID0gX3AucG9zaXRpb247XG4gICAgICAgIHZhciBwb3NTYW1lID0gcnN0eWxlLm5vZGVYICE9IG51bGwgJiYgcnN0eWxlLm5vZGVZICE9IG51bGwgJiYgcG9zLnggPT09IHJzdHlsZS5ub2RlWCAmJiBwb3MueSA9PT0gcnN0eWxlLm5vZGVZO1xuICAgICAgICB2YXIgd1NhbWUgPSByc3R5bGUubm9kZVcgIT0gbnVsbCAmJiByc3R5bGUubm9kZVcgPT09IHN0eWxlWyd3aWR0aCddLnB4VmFsdWU7XG4gICAgICAgIHZhciBoU2FtZSA9IHJzdHlsZS5ub2RlSCAhPSBudWxsICYmIHJzdHlsZS5ub2RlSCA9PT0gc3R5bGVbJ2hlaWdodCddLnB4VmFsdWU7XG5cbiAgICAgICAgaWYoICFwb3NTYW1lIHx8ICFzdHlsZVNhbWUgfHwgIXdTYW1lIHx8ICFoU2FtZSApe1xuICAgICAgICAgIG5vZGVzLnB1c2goIGVsZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcnN0eWxlLm5vZGVYID0gcG9zLng7XG4gICAgICAgIHJzdHlsZS5ub2RlWSA9IHBvcy55O1xuICAgICAgICByc3R5bGUubm9kZVcgPSBzdHlsZVsnd2lkdGgnXS5weFZhbHVlO1xuICAgICAgICByc3R5bGUubm9kZUggPSBzdHlsZVsnaGVpZ2h0J10ucHhWYWx1ZTtcbiAgICAgIH0gZWxzZSB7IC8vIGVkZ2VzXG5cbiAgICAgICAgdmFyIHNyY1BvcyA9IGVsZS5fcHJpdmF0ZS5zb3VyY2UuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgIHZhciB0Z3RQb3MgPSBlbGUuX3ByaXZhdGUudGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgc3JjU2FtZSA9IHJzdHlsZS5zcmNYICE9IG51bGwgJiYgcnN0eWxlLnNyY1kgIT0gbnVsbCAmJiBzcmNQb3MueCA9PT0gcnN0eWxlLnNyY1ggJiYgc3JjUG9zLnkgPT09IHJzdHlsZS5zcmNZO1xuICAgICAgICB2YXIgdGd0U2FtZSA9IHJzdHlsZS50Z3RYICE9IG51bGwgJiYgcnN0eWxlLnRndFkgIT0gbnVsbCAmJiB0Z3RQb3MueCA9PT0gcnN0eWxlLnRndFggJiYgdGd0UG9zLnkgPT09IHJzdHlsZS50Z3RZO1xuICAgICAgICB2YXIgcG9zaXRpb25zU2FtZSA9IHNyY1NhbWUgJiYgdGd0U2FtZTtcblxuICAgICAgICBpZiggIXBvc2l0aW9uc1NhbWUgfHwgIXN0eWxlU2FtZSApe1xuICAgICAgICAgIHZhciBjdXJ2ZVR5cGUgPSBfcC5zdHlsZVsnY3VydmUtc3R5bGUnXS52YWx1ZTtcblxuICAgICAgICAgIGlmKCBjdXJ2ZVR5cGUgPT09ICdiZXppZXInICl7XG4gICAgICAgICAgICBpZiggIWhhbmRsZWRFZGdlWyBpZCBdICl7XG4gICAgICAgICAgICAgIGVkZ2VzLnB1c2goIGVsZSApO1xuICAgICAgICAgICAgICBoYW5kbGVkRWRnZVsgaWQgXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgdmFyIHBhcmFsbGVsRWRnZXMgPSBlbGUucGFyYWxsZWxFZGdlcygpO1xuICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHBhcmFsbGVsRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgICB2YXIgcEVkZ2UgPSBwYXJhbGxlbEVkZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBwSWQgPSBwRWRnZS5fcHJpdmF0ZS5kYXRhLmlkO1xuXG4gICAgICAgICAgICAgICAgaWYoICFoYW5kbGVkRWRnZVsgcElkIF0gKXtcbiAgICAgICAgICAgICAgICAgIGVkZ2VzLnB1c2goIHBFZGdlICk7XG4gICAgICAgICAgICAgICAgICBoYW5kbGVkRWRnZVsgcElkIF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGdlcy5wdXNoKCBlbGUgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gaWYgcG9zaXRpb25zIGRpZmZcblxuICAgICAgICAvLyB1cGRhdGUgcnN0eWxlIHBvc2l0aW9uc1xuICAgICAgICByc3R5bGUuc3JjWCA9IHNyY1Bvcy54O1xuICAgICAgICByc3R5bGUuc3JjWSA9IHNyY1Bvcy55O1xuICAgICAgICByc3R5bGUudGd0WCA9IHRndFBvcy54O1xuICAgICAgICByc3R5bGUudGd0WSA9IHRndFBvcy55O1xuXG4gICAgICB9IC8vIGlmIGVkZ2VzXG5cbiAgICAgIHJzLmJvdW5kaW5nQm94S2V5ID0gX3AuYm91bmRpbmdCb3hLZXk7XG4gICAgICBycy5sYWJlbEtleSA9IF9wLmxhYmVsS2V5O1xuICAgIH1cblxuICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlUHJvamVjdGlvbnMoIGVkZ2VzICk7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZUxhYmVsUHJvamVjdGlvbnMoIG5vZGVzLCBlZGdlcyApO1xuICB9O1xuXG4gIENScC5yZWNhbGN1bGF0ZUxhYmVsUHJvamVjdGlvbnMgPSBmdW5jdGlvbiggbm9kZXMsIGVkZ2VzICl7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZU5vZGVMYWJlbFByb2plY3Rpb24oIG5vZGVzW2ldICk7XG4gICAgfVxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb24oIGVkZ2VzW2ldICk7XG4gICAgfVxuICB9O1xuXG4gIENScC5yZWNhbGN1bGF0ZUVkZ2VQcm9qZWN0aW9ucyA9IGZ1bmN0aW9uKCBlZGdlcyApe1xuICAgIHRoaXMuZmluZEVkZ2VDb250cm9sUG9pbnRzKCBlZGdlcyApO1xuICB9O1xuXG5cbiAgLy8gRmluZCBlZGdlIGNvbnRyb2wgcG9pbnRzXG4gIENScC5maW5kRWRnZUNvbnRyb2xQb2ludHMgPSBmdW5jdGlvbihlZGdlcykge1xuICAgIGlmKCAhZWRnZXMgfHwgZWRnZXMubGVuZ3RoID09PSAwICl7IHJldHVybjsgfVxuXG4gICAgdmFyIGN5ID0gdGhpcy5kYXRhLmN5O1xuICAgIHZhciBoYXNDb21wb3VuZHMgPSBjeS5oYXNDb21wb3VuZE5vZGVzKCk7XG4gICAgdmFyIGhhc2hUYWJsZSA9IHt9O1xuICAgIHZhciBwYWlySWRzID0gW107XG4gICAgdmFyIGhheXN0YWNrRWRnZXMgPSBbXTtcblxuICAgIC8vIGNyZWF0ZSBhIHRhYmxlIG9mIGVkZ2UgKHNyYywgdGd0KSA9PiBsaXN0IG9mIGVkZ2VzIGJldHdlZW4gdGhlbVxuICAgIHZhciBwYWlySWQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyl7XG4gICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIHN0eWxlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZTtcbiAgICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBzdHlsZVsnY3VydmUtc3R5bGUnXS52YWx1ZSA9PT0gJ3VuYnVuZGxlZC1iZXppZXInO1xuXG4gICAgICAvLyBpZ25vcmUgZWRnZXMgd2hvIGFyZSBub3QgdG8gYmUgZGlzcGxheWVkXG4gICAgICAvLyB0aGV5IHNob3VsZG4ndCB0YWtlIHVwIHNwYWNlXG4gICAgICBpZiggc3R5bGUuZGlzcGxheS52YWx1ZSA9PT0gJ25vbmUnICl7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiggc3R5bGVbJ2N1cnZlLXN0eWxlJ10udmFsdWUgPT09ICdoYXlzdGFjaycgKXtcbiAgICAgICAgaGF5c3RhY2tFZGdlcy5wdXNoKCBlZGdlICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3JjSWQgPSBlZGdlLl9wcml2YXRlLmRhdGEuc291cmNlO1xuICAgICAgdmFyIHRndElkID0gZWRnZS5fcHJpdmF0ZS5kYXRhLnRhcmdldDtcblxuICAgICAgcGFpcklkID0gc3JjSWQgPiB0Z3RJZCA/XG4gICAgICAgIHRndElkICsgJy0nICsgc3JjSWQgOlxuICAgICAgICBzcmNJZCArICctJyArIHRndElkIDtcblxuICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICBwYWlySWQgPSAndW5idW5kbGVkJyArIGVkZ2UuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc2hUYWJsZVtwYWlySWRdID09IG51bGwpIHtcbiAgICAgICAgaGFzaFRhYmxlW3BhaXJJZF0gPSBbXTtcbiAgICAgICAgcGFpcklkcy5wdXNoKCBwYWlySWQgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaGFzaFRhYmxlW3BhaXJJZF0ucHVzaCggZWRnZSApO1xuXG4gICAgICBpZiggZWRnZUlzVW5idW5kbGVkICl7XG4gICAgICAgIGhhc2hUYWJsZVtwYWlySWRdLmhhc1VuYnVuZGxlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNyYywgdGd0LCBzcmNQb3MsIHRndFBvcywgc3JjVywgc3JjSCwgdGd0VywgdGd0SCwgc3JjU2hhcGUsIHRndFNoYXBlLCBzcmNCb3JkZXIsIHRndEJvcmRlcjtcbiAgICB2YXIgdmVjdG9yTm9ybUludmVyc2U7XG4gICAgdmFyIGJhZEJlemllcjtcbiAgICBcbiAgICAvLyBmb3IgZWFjaCBwYWlyIChzcmMsIHRndCksIGNyZWF0ZSB0aGUgY3RybCBwdHNcbiAgICAvLyBOZXN0ZWQgZm9yIGxvb3AgaXMgT0s7IHRvdGFsIG51bWJlciBvZiBpdGVyYXRpb25zIGZvciBib3RoIGxvb3BzID0gZWRnZUNvdW50ICBcbiAgICBmb3IgKHZhciBwID0gMDsgcCA8IHBhaXJJZHMubGVuZ3RoOyBwKyspIHtcbiAgICAgIHBhaXJJZCA9IHBhaXJJZHNbcF07XG4gICAgICB2YXIgcGFpckVkZ2VzID0gaGFzaFRhYmxlW3BhaXJJZF07XG4gICAgXG4gICAgICAvLyBmb3IgZWFjaCBwYWlyIGlkLCB0aGUgZWRnZXMgc2hvdWxkIGJlIHNvcnRlZCBieSBpbmRleFxuICAgICAgcGFpckVkZ2VzLnNvcnQoZnVuY3Rpb24oZWRnZTEsIGVkZ2UyKXtcbiAgICAgICAgcmV0dXJuIGVkZ2UxLl9wcml2YXRlLmluZGV4IC0gZWRnZTIuX3ByaXZhdGUuaW5kZXg7XG4gICAgICB9KTtcblxuICAgICAgc3JjID0gcGFpckVkZ2VzWzBdLl9wcml2YXRlLnNvdXJjZTtcbiAgICAgIHRndCA9IHBhaXJFZGdlc1swXS5fcHJpdmF0ZS50YXJnZXQ7XG5cbiAgICAgIC8vIG1ha2Ugc3VyZSBzcmMvdGd0IGRpc3RpbmN0aW9uIGlzIGNvbnNpc3RlbnRcbiAgICAgIC8vIChzcmMvdGd0IGluIHRoaXMgY2FzZSBhcmUganVzdCBmb3IgY3RybHB0cyBhbmQgZG9uJ3QgYWN0dWFsbHkgaGF2ZSB0byBiZSB0cnVlIHNyYy90Z3QpXG4gICAgICBpZiggc3JjLl9wcml2YXRlLmRhdGEuaWQgPiB0Z3QuX3ByaXZhdGUuZGF0YS5pZCApe1xuICAgICAgICB2YXIgdGVtcCA9IHNyYztcbiAgICAgICAgc3JjID0gdGd0O1xuICAgICAgICB0Z3QgPSB0ZW1wO1xuICAgICAgfVxuXG4gICAgICBzcmNQb3MgPSBzcmMuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB0Z3RQb3MgPSB0Z3QuX3ByaXZhdGUucG9zaXRpb247XG5cbiAgICAgIHNyY1cgPSB0aGlzLmdldE5vZGVXaWR0aChzcmMpO1xuICAgICAgc3JjSCA9IHRoaXMuZ2V0Tm9kZUhlaWdodChzcmMpO1xuXG4gICAgICB0Z3RXID0gdGhpcy5nZXROb2RlV2lkdGgodGd0KTtcbiAgICAgIHRndEggPSB0aGlzLmdldE5vZGVIZWlnaHQodGd0KTtcblxuICAgICAgc3JjU2hhcGUgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzWyB0aGlzLmdldE5vZGVTaGFwZShzcmMpIF07XG4gICAgICB0Z3RTaGFwZSA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbIHRoaXMuZ2V0Tm9kZVNoYXBlKHRndCkgXTtcblxuICAgICAgc3JjQm9yZGVyID0gc3JjLl9wcml2YXRlLnN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlO1xuICAgICAgdGd0Qm9yZGVyID0gdGd0Ll9wcml2YXRlLnN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlO1xuXG4gICAgICBiYWRCZXppZXIgPSBmYWxzZTtcbiAgICAgIFxuXG4gICAgICBpZiggKHBhaXJFZGdlcy5sZW5ndGggPiAxICYmIHNyYyAhPT0gdGd0KSB8fCBwYWlyRWRnZXMuaGFzVW5idW5kbGVkICl7XG5cbiAgICAgICAgLy8gcHQgb3V0c2lkZSBzcmMgc2hhcGUgdG8gY2FsYyBkaXN0YW5jZS9kaXNwbGFjZW1lbnQgZnJvbSBzcmMgdG8gdGd0XG4gICAgICAgIHZhciBzcmNPdXRzaWRlID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICBzcmNQb3MueCxcbiAgICAgICAgICBzcmNQb3MueSxcbiAgICAgICAgICBzcmNXLFxuICAgICAgICAgIHNyY0gsXG4gICAgICAgICAgdGd0UG9zLngsXG4gICAgICAgICAgdGd0UG9zLnksXG4gICAgICAgICAgc3JjQm9yZGVyIC8gMlxuICAgICAgICApO1xuXG4gICAgICAgIC8vIHB0IG91dHNpZGUgdGd0IHNoYXBlIHRvIGNhbGMgZGlzdGFuY2UvZGlzcGxhY2VtZW50IGZyb20gc3JjIHRvIHRndFxuICAgICAgICB2YXIgdGd0T3V0c2lkZSA9IHRndFNoYXBlLmludGVyc2VjdExpbmUoXG4gICAgICAgICAgdGd0UG9zLngsXG4gICAgICAgICAgdGd0UG9zLnksXG4gICAgICAgICAgdGd0VyxcbiAgICAgICAgICB0Z3RILFxuICAgICAgICAgIHNyY1Bvcy54LFxuICAgICAgICAgIHNyY1Bvcy55LFxuICAgICAgICAgIHRndEJvcmRlciAvIDJcbiAgICAgICAgKTtcblxuICAgICAgICB2YXIgbWlkcHRTcmNQdHMgPSB7XG4gICAgICAgICAgeDE6IHNyY091dHNpZGVbMF0sXG4gICAgICAgICAgeDI6IHRndE91dHNpZGVbMF0sXG4gICAgICAgICAgeTE6IHNyY091dHNpZGVbMV0sXG4gICAgICAgICAgeTI6IHRndE91dHNpZGVbMV1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZHkgPSAoIHRndE91dHNpZGVbMV0gLSBzcmNPdXRzaWRlWzFdICk7XG4gICAgICAgIHZhciBkeCA9ICggdGd0T3V0c2lkZVswXSAtIHNyY091dHNpZGVbMF0gKTtcbiAgICAgICAgdmFyIGwgPSBNYXRoLnNxcnQoIGR4KmR4ICsgZHkqZHkgKTtcblxuICAgICAgICB2YXIgdmVjdG9yID0ge1xuICAgICAgICAgIHg6IGR4LFxuICAgICAgICAgIHk6IGR5XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgdmVjdG9yTm9ybSA9IHtcbiAgICAgICAgICB4OiB2ZWN0b3IueC9sLFxuICAgICAgICAgIHk6IHZlY3Rvci55L2xcbiAgICAgICAgfTtcbiAgICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSB7XG4gICAgICAgICAgeDogLXZlY3Rvck5vcm0ueSxcbiAgICAgICAgICB5OiB2ZWN0b3JOb3JtLnhcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBpZiBzcmMgaW50ZXJzZWN0aW9uIGlzIGluc2lkZSB0Z3Qgb3IgdGd0IGludGVyc2VjdGlvbiBpcyBpbnNpZGUgc3JjLCB0aGVuIG5vIGN0cmwgcHRzIHRvIGRyYXdcbiAgICAgICAgaWYoIFxuICAgICAgICAgIHRndFNoYXBlLmNoZWNrUG9pbnQoIHNyY091dHNpZGVbMF0sIHNyY091dHNpZGVbMV0sIHRndEJvcmRlci8yLCB0Z3RXLCB0Z3RILCB0Z3RQb3MueCwgdGd0UG9zLnkgKSAgfHxcbiAgICAgICAgICBzcmNTaGFwZS5jaGVja1BvaW50KCB0Z3RPdXRzaWRlWzBdLCB0Z3RPdXRzaWRlWzFdLCBzcmNCb3JkZXIvMiwgc3JjVywgc3JjSCwgc3JjUG9zLngsIHNyY1Bvcy55ICkgXG4gICAgICAgICl7XG4gICAgICAgICAgdmVjdG9yTm9ybUludmVyc2UgPSB7fTtcbiAgICAgICAgICBiYWRCZXppZXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZWRnZTtcbiAgICAgIHZhciBycztcbiAgICAgIFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWlyRWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZWRnZSA9IHBhaXJFZGdlc1tpXTtcbiAgICAgICAgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgICAgICBcbiAgICAgICAgdmFyIGVkZ2VJbmRleDEgPSBycy5sYXN0RWRnZUluZGV4O1xuICAgICAgICB2YXIgZWRnZUluZGV4MiA9IGk7XG5cbiAgICAgICAgdmFyIG51bUVkZ2VzMSA9IHJzLmxhc3ROdW1FZGdlcztcbiAgICAgICAgdmFyIG51bUVkZ2VzMiA9IHBhaXJFZGdlcy5sZW5ndGg7XG5cbiAgICAgICAgdmFyIGVTdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gICAgICAgIHZhciBzdGVwU2l6ZSA9IGVTdHlsZVsnY29udHJvbC1wb2ludC1zdGVwLXNpemUnXS5weFZhbHVlO1xuICAgICAgICB2YXIgc3RlcERpc3QgPSBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtZGlzdGFuY2UnXSAhPT0gdW5kZWZpbmVkID8gZVN0eWxlWydjb250cm9sLXBvaW50LWRpc3RhbmNlJ10ucHhWYWx1ZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIHN0ZXBXZWlnaHQgPSBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtd2VpZ2h0J10udmFsdWU7XG4gICAgICAgIHZhciBlZGdlSXNVbmJ1bmRsZWQgPSBlU3R5bGVbJ2N1cnZlLXN0eWxlJ10udmFsdWUgPT09ICd1bmJ1bmRsZWQtYmV6aWVyJztcbiAgICAgICAgXG4gICAgICAgIHZhciBzd2FwcGVkRGlyZWN0aW9uID0gZWRnZS5fcHJpdmF0ZS5zb3VyY2UgIT09IHNyYztcblxuICAgICAgICBpZiggc3dhcHBlZERpcmVjdGlvbiAmJiBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgICBzdGVwRGlzdCAqPSAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzcmNYMSA9IHJzLmxhc3RTcmNDdGxQdFg7XG4gICAgICAgIHZhciBzcmNYMiA9IHNyY1Bvcy54O1xuICAgICAgICB2YXIgc3JjWTEgPSBycy5sYXN0U3JjQ3RsUHRZO1xuICAgICAgICB2YXIgc3JjWTIgPSBzcmNQb3MueTtcbiAgICAgICAgdmFyIHNyY1cxID0gcnMubGFzdFNyY0N0bFB0VztcbiAgICAgICAgdmFyIHNyY1cyID0gc3JjLm91dGVyV2lkdGgoKTtcbiAgICAgICAgdmFyIHNyY0gxID0gcnMubGFzdFNyY0N0bFB0SDtcbiAgICAgICAgdmFyIHNyY0gyID0gc3JjLm91dGVySGVpZ2h0KCk7XG5cbiAgICAgICAgdmFyIHRndFgxID0gcnMubGFzdFRndEN0bFB0WDtcbiAgICAgICAgdmFyIHRndFgyID0gdGd0UG9zLng7XG4gICAgICAgIHZhciB0Z3RZMSA9IHJzLmxhc3RUZ3RDdGxQdFk7XG4gICAgICAgIHZhciB0Z3RZMiA9IHRndFBvcy55O1xuICAgICAgICB2YXIgdGd0VzEgPSBycy5sYXN0VGd0Q3RsUHRXO1xuICAgICAgICB2YXIgdGd0VzIgPSB0Z3Qub3V0ZXJXaWR0aCgpO1xuICAgICAgICB2YXIgdGd0SDEgPSBycy5sYXN0VGd0Q3RsUHRIO1xuICAgICAgICB2YXIgdGd0SDIgPSB0Z3Qub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgICB2YXIgd2lkdGgxID0gcnMubGFzdFc7XG4gICAgICAgIHZhciB3aWR0aDIgPSBlU3R5bGVbJ2NvbnRyb2wtcG9pbnQtc3RlcC1zaXplJ10ucHhWYWx1ZTtcblxuICAgICAgICBpZiggYmFkQmV6aWVyICl7XG4gICAgICAgICAgcnMuYmFkQmV6aWVyID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBycy5iYWRCZXppZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBzcmNYMSA9PT0gc3JjWDIgJiYgc3JjWTEgPT09IHNyY1kyICYmIHNyY1cxID09PSBzcmNXMiAmJiBzcmNIMSA9PT0gc3JjSDJcbiAgICAgICAgJiYgIHRndFgxID09PSB0Z3RYMiAmJiB0Z3RZMSA9PT0gdGd0WTIgJiYgdGd0VzEgPT09IHRndFcyICYmIHRndEgxID09PSB0Z3RIMlxuICAgICAgICAmJiAgd2lkdGgxID09PSB3aWR0aDJcbiAgICAgICAgJiYgICgoZWRnZUluZGV4MSA9PT0gZWRnZUluZGV4MiAmJiBudW1FZGdlczEgPT09IG51bUVkZ2VzMikgfHwgZWRnZUlzVW5idW5kbGVkKSApe1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdlZGdlIGN0cmwgcHQgY2FjaGUgSElUJylcbiAgICAgICAgICBjb250aW51ZTsgLy8gdGhlbiB0aGUgY29udHJvbCBwb2ludHMgaGF2ZW4ndCBjaGFuZ2VkIGFuZCB3ZSBjYW4gc2tpcCBjYWxjdWxhdGluZyB0aGVtXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnMubGFzdFNyY0N0bFB0WCA9IHNyY1gyO1xuICAgICAgICAgIHJzLmxhc3RTcmNDdGxQdFkgPSBzcmNZMjtcbiAgICAgICAgICBycy5sYXN0U3JjQ3RsUHRXID0gc3JjVzI7XG4gICAgICAgICAgcnMubGFzdFNyY0N0bFB0SCA9IHNyY0gyO1xuICAgICAgICAgIHJzLmxhc3RUZ3RDdGxQdFggPSB0Z3RYMjtcbiAgICAgICAgICBycy5sYXN0VGd0Q3RsUHRZID0gdGd0WTI7XG4gICAgICAgICAgcnMubGFzdFRndEN0bFB0VyA9IHRndFcyO1xuICAgICAgICAgIHJzLmxhc3RUZ3RDdGxQdEggPSB0Z3RIMjtcbiAgICAgICAgICBycy5sYXN0RWRnZUluZGV4ID0gZWRnZUluZGV4MjtcbiAgICAgICAgICBycy5sYXN0TnVtRWRnZXMgPSBudW1FZGdlczI7XG4gICAgICAgICAgcnMubGFzdFdpZHRoID0gd2lkdGgyO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdlZGdlIGN0cmwgcHQgY2FjaGUgTUlTUycpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWxmLWVkZ2VcbiAgICAgICAgaWYgKCBzcmMgPT09IHRndCApIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgIHJzLmVkZ2VUeXBlID0gJ3NlbGYnO1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBqID0gaTtcbiAgICAgICAgICB2YXIgbG9vcERpc3QgPSBzdGVwU2l6ZTtcblxuICAgICAgICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgICAgIGogPSAwO1xuICAgICAgICAgICAgbG9vcERpc3QgPSBzdGVwRGlzdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOZXcgLS0gZml4IGZvciBsYXJnZSBub2Rlc1xuICAgICAgICAgIHJzLmNwMmF4ID0gc3JjUG9zLng7XG4gICAgICAgICAgcnMuY3AyYXkgPSBzcmNQb3MueSAtICgxICsgTWF0aC5wb3coc3JjSCwgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKTtcbiAgICAgICAgICBcbiAgICAgICAgICBycy5jcDJjeCA9IHNyY1Bvcy54IC0gKDEgKyBNYXRoLnBvdyhzcmNXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpO1xuICAgICAgICAgIHJzLmNwMmN5ID0gc3JjUG9zLnk7XG4gICAgICAgICAgXG4gICAgICAgICAgcnMuc2VsZkVkZ2VNaWRYID0gKHJzLmNwMmF4ICsgcnMuY3AyY3gpIC8gMi4wO1xuICAgICAgICAgIHJzLnNlbGZFZGdlTWlkWSA9IChycy5jcDJheSArIHJzLmNwMmN5KSAvIDIuMDtcbiAgICAgICAgXG4gICAgICAgIC8vIENvbXBvdW5kIGVkZ2VcbiAgICAgICAgfSBlbHNlIGlmKFxuICAgICAgICAgIGhhc0NvbXBvdW5kcyAmJlxuICAgICAgICAgICggc3JjLmlzUGFyZW50KCkgfHwgc3JjLmlzQ2hpbGQoKSB8fCB0Z3QuaXNQYXJlbnQoKSB8fCB0Z3QuaXNDaGlsZCgpICkgJiZcbiAgICAgICAgICAoIHNyYy5wYXJlbnRzKCkuYW55U2FtZSh0Z3QpIHx8IHRndC5wYXJlbnRzKCkuYW55U2FtZShzcmMpIClcbiAgICAgICAgKXtcblxuICAgICAgICAgIHJzLmVkZ2VUeXBlID0gJ2NvbXBvdW5kJztcblxuICAgICAgICAgIC8vIGJlY2F1c2UgdGhlIGxpbmUgYXBwcm94aW1hdGlvbiBkb2Vzbid0IGFwcGx5IGZvciBjb21wb3VuZCBiZXppZXJzXG4gICAgICAgICAgLy8gKGxvb3Avc2VsZiBlZGdlcyBhcmUgYWxyZWFkeSBlbGlkZWQgYi9jIG9mIGNoZWFwIHNyYz09dGd0IGNoZWNrKVxuICAgICAgICAgIHJzLmJhZEJlemllciA9IGZhbHNlO1xuXG4gICAgICAgICAgdmFyIGogPSBpO1xuICAgICAgICAgIHZhciBsb29wRGlzdCA9IHN0ZXBTaXplO1xuXG4gICAgICAgICAgaWYoIGVkZ2VJc1VuYnVuZGxlZCApe1xuICAgICAgICAgICAgaiA9IDA7XG4gICAgICAgICAgICBsb29wRGlzdCA9IHN0ZXBEaXN0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIFxuICAgICAgICAgIHZhciBsb29wVyA9IDUwO1xuXG4gICAgICAgICAgdmFyIGxvb3BhUG9zID0ge1xuICAgICAgICAgICAgeDogc3JjUG9zLnggLSBzcmNXLzIsXG4gICAgICAgICAgICB5OiBzcmNQb3MueSAtIHNyY0gvMlxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgbG9vcGJQb3MgPSB7XG4gICAgICAgICAgICB4OiB0Z3RQb3MueCAtIHRndFcvMixcbiAgICAgICAgICAgIHk6IHRndFBvcy55IC0gdGd0SC8yXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBtaW5Db21wb3VuZFN0cmV0Y2ggPSAxO1xuXG4gICAgICAgICAgcnMuY3AyYXggPSBsb29wYVBvcy54O1xuICAgICAgICAgIHJzLmNvbXBvdW5kU3RyZXRjaEEgPSBNYXRoLm1heCggbWluQ29tcG91bmRTdHJldGNoLCBNYXRoLmxvZyhzcmNXICogMC4wMSkgKTsgLy8gYXZvaWRzIGNhc2VzIHdpdGggaW1wb3NzaWJsZSBiZXppZXJzXG4gICAgICAgICAgcnMuY3AyYXkgPSBsb29wYVBvcy55IC0gKDEgKyBNYXRoLnBvdyhsb29wVywgMS4xMikgLyAxMDApICogbG9vcERpc3QgKiAoaiAvIDMgKyAxKSAqIHJzLmNvbXBvdW5kU3RyZXRjaEE7XG4gICAgICAgICAgXG4gICAgICAgICAgcnMuY29tcG91bmRTdHJldGNoQiA9IE1hdGgubWF4KCBtaW5Db21wb3VuZFN0cmV0Y2gsIE1hdGgubG9nKHRndFcgKiAwLjAxKSApOyAvLyBhdm9pZHMgY2FzZXMgd2l0aCBpbXBvc3NpYmxlIGJlemllcnNcbiAgICAgICAgICBycy5jcDJjeCA9IGxvb3BiUG9zLnggLSAoMSArIE1hdGgucG93KGxvb3BXLCAxLjEyKSAvIDEwMCkgKiBsb29wRGlzdCAqIChqIC8gMyArIDEpICogcnMuY29tcG91bmRTdHJldGNoQjtcbiAgICAgICAgICBycy5jcDJjeSA9IGxvb3BiUG9zLnk7XG4gICAgICAgICAgXG4gICAgICAgICAgcnMuc2VsZkVkZ2VNaWRYID0gKHJzLmNwMmF4ICsgcnMuY3AyY3gpIC8gMi4wO1xuICAgICAgICAgIHJzLnNlbGZFZGdlTWlkWSA9IChycy5jcDJheSArIHJzLmNwMmN5KSAvIDIuMDtcblxuICAgICAgICAvLyBTdHJhaWdodCBlZGdlXG4gICAgICAgIH0gZWxzZSBpZiAocGFpckVkZ2VzLmxlbmd0aCAlIDIgPT09IDFcbiAgICAgICAgICAmJiBpID09PSBNYXRoLmZsb29yKHBhaXJFZGdlcy5sZW5ndGggLyAyKVxuICAgICAgICAgICYmICFlZGdlSXNVbmJ1bmRsZWQgKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgcnMuZWRnZVR5cGUgPSAnc3RyYWlnaHQnO1xuICAgICAgICAgIFxuICAgICAgICAvLyBCZXppZXIgZWRnZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBub3JtU3RlcERpc3QgPSAoMC41IC0gcGFpckVkZ2VzLmxlbmd0aCAvIDIgKyBpKSAqIHN0ZXBTaXplO1xuICAgICAgICAgIHZhciBtYW5TdGVwRGlzdDtcbiAgICAgICAgICB2YXIgc2lnbiA9ICQkLm1hdGguc2lnbnVtKCBub3JtU3RlcERpc3QgKTtcblxuICAgICAgICAgIGlmKCBlZGdlSXNVbmJ1bmRsZWQgKXtcbiAgICAgICAgICAgIG1hblN0ZXBEaXN0ID0gc3RlcERpc3Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hblN0ZXBEaXN0ID0gc3RlcERpc3QgIT09IHVuZGVmaW5lZCA/IHNpZ24gKiBzdGVwRGlzdCA6IHVuZGVmaW5lZDsgXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGRpc3RhbmNlRnJvbU1pZHBvaW50ID0gbWFuU3RlcERpc3QgIT09IHVuZGVmaW5lZCA/IG1hblN0ZXBEaXN0IDogbm9ybVN0ZXBEaXN0O1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciB3MSA9ICgxIC0gc3RlcFdlaWdodCk7XG4gICAgICAgICAgdmFyIHcyID0gc3RlcFdlaWdodDtcblxuICAgICAgICAgIGlmKCBzd2FwcGVkRGlyZWN0aW9uICl7XG4gICAgICAgICAgICB3MSA9IHN0ZXBXZWlnaHQ7XG4gICAgICAgICAgICB3MiA9ICgxIC0gc3RlcFdlaWdodCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGFkanVzdGVkTWlkcHQgPSB7XG4gICAgICAgICAgICB4OiBtaWRwdFNyY1B0cy54MSAqIHcxICsgbWlkcHRTcmNQdHMueDIgKiB3MixcbiAgICAgICAgICAgIHk6IG1pZHB0U3JjUHRzLnkxICogdzEgKyBtaWRwdFNyY1B0cy55MiAqIHcyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHJzLmVkZ2VUeXBlID0gJ2Jlemllcic7XG4gICAgICAgICAgXG4gICAgICAgICAgcnMuY3AyeCA9IGFkanVzdGVkTWlkcHQueCArIHZlY3Rvck5vcm1JbnZlcnNlLnggKiBkaXN0YW5jZUZyb21NaWRwb2ludDtcbiAgICAgICAgICBycy5jcDJ5ID0gYWRqdXN0ZWRNaWRwdC55ICsgdmVjdG9yTm9ybUludmVyc2UueSAqIGRpc3RhbmNlRnJvbU1pZHBvaW50O1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGVkZ2UsIG1pZFBvaW50WCwgZGlzcGxhY2VtZW50WCwgZGlzdGFuY2VGcm9tTWlkcG9pbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZmluZCBlbmRwdHMgZm9yIGVkZ2VcbiAgICAgICAgdGhpcy5maW5kRW5kcG9pbnRzKCBlZGdlICk7XG5cbiAgICAgICAgdmFyIGJhZFN0YXJ0ID0gISQkLmlzLm51bWJlciggcnMuc3RhcnRYICkgfHwgISQkLmlzLm51bWJlciggcnMuc3RhcnRZICk7XG4gICAgICAgIHZhciBiYWRBU3RhcnQgPSAhJCQuaXMubnVtYmVyKCBycy5hcnJvd1N0YXJ0WCApIHx8ICEkJC5pcy5udW1iZXIoIHJzLmFycm93U3RhcnRZICk7XG4gICAgICAgIHZhciBiYWRFbmQgPSAhJCQuaXMubnVtYmVyKCBycy5lbmRYICkgfHwgISQkLmlzLm51bWJlciggcnMuZW5kWSApO1xuICAgICAgICB2YXIgYmFkQUVuZCA9ICEkJC5pcy5udW1iZXIoIHJzLmFycm93RW5kWCApIHx8ICEkJC5pcy5udW1iZXIoIHJzLmFycm93RW5kWSApO1xuXG4gICAgICAgIHZhciBtaW5DcEFEaXN0RmFjdG9yID0gMztcbiAgICAgICAgdmFyIGFycm93VyA9IHRoaXMuZ2V0QXJyb3dXaWR0aCggZWRnZS5fcHJpdmF0ZS5zdHlsZVsnd2lkdGgnXS5weFZhbHVlICkgKiBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlSGVpZ2h0O1xuICAgICAgICB2YXIgbWluQ3BBRGlzdCA9IG1pbkNwQURpc3RGYWN0b3IgKiBhcnJvd1c7XG4gICAgICAgIHZhciBzdGFydEFDcERpc3QgPSAkJC5tYXRoLmRpc3RhbmNlKCB7IHg6IHJzLmNwMngsIHk6IHJzLmNwMnkgfSwgeyB4OiBycy5zdGFydFgsIHk6IHJzLnN0YXJ0WSB9ICk7XG4gICAgICAgIHZhciBjbG9zZVN0YXJ0QUNwID0gc3RhcnRBQ3BEaXN0IDwgbWluQ3BBRGlzdDtcbiAgICAgICAgdmFyIGVuZEFDcERpc3QgPSAkJC5tYXRoLmRpc3RhbmNlKCB7IHg6IHJzLmNwMngsIHk6IHJzLmNwMnkgfSwgeyB4OiBycy5lbmRYLCB5OiBycy5lbmRZIH0gKTtcbiAgICAgICAgdmFyIGNsb3NlRW5kQUNwID0gZW5kQUNwRGlzdCA8IG1pbkNwQURpc3Q7XG5cbiAgICAgICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyApe1xuICAgICAgICAgIHZhciBvdmVybGFwcGluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYoIGJhZFN0YXJ0IHx8IGJhZEFTdGFydCB8fCBjbG9zZVN0YXJ0QUNwICl7XG4gICAgICAgICAgICBvdmVybGFwcGluZyA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIHByb2plY3QgY29udHJvbCBwb2ludCBhbG9uZyBsaW5lIGZyb20gc3JjIGNlbnRyZSB0byBvdXRzaWRlIHRoZSBzcmMgc2hhcGVcbiAgICAgICAgICAgIC8vIChvdGhlcndpc2UgaW50ZXJzZWN0aW9uIHdpbGwgeWllbGQgbm90aGluZylcbiAgICAgICAgICAgIHZhciBjcEQgPSB7IC8vIGRlbHRhXG4gICAgICAgICAgICAgIHg6IHJzLmNwMnggLSBzcmNQb3MueCxcbiAgICAgICAgICAgICAgeTogcnMuY3AyeSAtIHNyY1Bvcy55XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGNwTCA9IE1hdGguc3FydCggY3BELngqY3BELnggKyBjcEQueSpjcEQueSApOyAvLyBsZW5ndGggb2YgbGluZVxuICAgICAgICAgICAgdmFyIGNwTSA9IHsgLy8gbm9ybWFsaXNlZCBkZWx0YVxuICAgICAgICAgICAgICB4OiBjcEQueCAvIGNwTCxcbiAgICAgICAgICAgICAgeTogY3BELnkgLyBjcExcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gTWF0aC5tYXgoc3JjVywgc3JjSCk7XG4gICAgICAgICAgICB2YXIgY3BQcm9qID0geyAvLyAqMiByYWRpdXMgZ3VhcmFudGVlcyBvdXRzaWRlIHNoYXBlXG4gICAgICAgICAgICAgIHg6IHJzLmNwMnggKyBjcE0ueCAqIDIgKiByYWRpdXMsXG4gICAgICAgICAgICAgIHk6IHJzLmNwMnkgKyBjcE0ueSAqIDIgKiByYWRpdXNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBzcmNDdHJsUHRJbnRuID0gc3JjU2hhcGUuaW50ZXJzZWN0TGluZShcbiAgICAgICAgICAgICAgc3JjUG9zLngsXG4gICAgICAgICAgICAgIHNyY1Bvcy55LFxuICAgICAgICAgICAgICBzcmNXLFxuICAgICAgICAgICAgICBzcmNILFxuICAgICAgICAgICAgICBjcFByb2oueCxcbiAgICAgICAgICAgICAgY3BQcm9qLnksXG4gICAgICAgICAgICAgIHNyY0JvcmRlciAvIDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGlmKCBjbG9zZVN0YXJ0QUNwICl7XG4gICAgICAgICAgICAgIHJzLmNwMnggPSBycy5jcDJ4ICsgY3BNLnggKiAobWluQ3BBRGlzdCAtIHN0YXJ0QUNwRGlzdCk7IFxuICAgICAgICAgICAgICBycy5jcDJ5ID0gcnMuY3AyeSArIGNwTS55ICogKG1pbkNwQURpc3QgLSBzdGFydEFDcERpc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcnMuY3AyeCA9IHNyY0N0cmxQdEludG5bMF0gKyBjcE0ueCAqIG1pbkNwQURpc3Q7IFxuICAgICAgICAgICAgICBycy5jcDJ5ID0gc3JjQ3RybFB0SW50blsxXSArIGNwTS55ICogbWluQ3BBRGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggYmFkRW5kIHx8IGJhZEFFbmQgfHwgY2xvc2VFbmRBQ3AgKXtcbiAgICAgICAgICAgIG92ZXJsYXBwaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gcHJvamVjdCBjb250cm9sIHBvaW50IGFsb25nIGxpbmUgZnJvbSB0Z3QgY2VudHJlIHRvIG91dHNpZGUgdGhlIHRndCBzaGFwZVxuICAgICAgICAgICAgLy8gKG90aGVyd2lzZSBpbnRlcnNlY3Rpb24gd2lsbCB5aWVsZCBub3RoaW5nKVxuICAgICAgICAgICAgdmFyIGNwRCA9IHsgLy8gZGVsdGFcbiAgICAgICAgICAgICAgeDogcnMuY3AyeCAtIHRndFBvcy54LFxuICAgICAgICAgICAgICB5OiBycy5jcDJ5IC0gdGd0UG9zLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY3BMID0gTWF0aC5zcXJ0KCBjcEQueCpjcEQueCArIGNwRC55KmNwRC55ICk7IC8vIGxlbmd0aCBvZiBsaW5lXG4gICAgICAgICAgICB2YXIgY3BNID0geyAvLyBub3JtYWxpc2VkIGRlbHRhXG4gICAgICAgICAgICAgIHg6IGNwRC54IC8gY3BMLFxuICAgICAgICAgICAgICB5OiBjcEQueSAvIGNwTFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSBNYXRoLm1heChzcmNXLCBzcmNIKTtcbiAgICAgICAgICAgIHZhciBjcFByb2ogPSB7IC8vICoyIHJhZGl1cyBndWFyYW50ZWVzIG91dHNpZGUgc2hhcGVcbiAgICAgICAgICAgICAgeDogcnMuY3AyeCArIGNwTS54ICogMiAqIHJhZGl1cyxcbiAgICAgICAgICAgICAgeTogcnMuY3AyeSArIGNwTS55ICogMiAqIHJhZGl1c1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIHRndEN0cmxQdEludG4gPSB0Z3RTaGFwZS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICAgICAgICB0Z3RQb3MueCxcbiAgICAgICAgICAgICAgdGd0UG9zLnksXG4gICAgICAgICAgICAgIHRndFcsXG4gICAgICAgICAgICAgIHRndEgsXG4gICAgICAgICAgICAgIGNwUHJvai54LFxuICAgICAgICAgICAgICBjcFByb2oueSxcbiAgICAgICAgICAgICAgdGd0Qm9yZGVyIC8gMlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYoIGNsb3NlRW5kQUNwICl7XG4gICAgICAgICAgICAgIHJzLmNwMnggPSBycy5jcDJ4ICsgY3BNLnggKiAobWluQ3BBRGlzdCAtIGVuZEFDcERpc3QpOyBcbiAgICAgICAgICAgICAgcnMuY3AyeSA9IHJzLmNwMnkgKyBjcE0ueSAqIChtaW5DcEFEaXN0IC0gZW5kQUNwRGlzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBycy5jcDJ4ID0gdGd0Q3RybFB0SW50blswXSArIGNwTS54ICogbWluQ3BBRGlzdDsgXG4gICAgICAgICAgICAgIHJzLmNwMnkgPSB0Z3RDdHJsUHRJbnRuWzFdICsgY3BNLnkgKiBtaW5DcEFEaXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIG92ZXJsYXBwaW5nICl7XG4gICAgICAgICAgICAvLyByZWNhbGMgZW5kcHRzXG4gICAgICAgICAgICB0aGlzLmZpbmRFbmRwb2ludHMoIGVkZ2UgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiggcnMuZWRnZVR5cGUgPT09ICdzdHJhaWdodCcgKXtcbiAgICAgICAgICBycy5taWRYID0gKCBzcmNYMiArIHRndFgyICkvMjtcbiAgICAgICAgICBycy5taWRZID0gKCBzcmNZMiArIHRndFkyICkvMjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByb2plY3QgdGhlIGVkZ2UgaW50byByc3R5bGVcbiAgICAgICAgdGhpcy5wcm9qZWN0QmV6aWVyKCBlZGdlICk7XG4gICAgICAgIHRoaXMucmVjYWxjdWxhdGVFZGdlTGFiZWxQcm9qZWN0aW9uKCBlZGdlICk7XG5cbiAgICAgIH1cbiAgICB9XG4gICAgICBcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IGhheXN0YWNrRWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlZGdlID0gaGF5c3RhY2tFZGdlc1tpXTtcbiAgICAgIHZhciBfcCA9IGVkZ2UuX3ByaXZhdGU7XG4gICAgICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgICAgIHZhciBycyA9IHJzY3JhdGNoO1xuXG4gICAgICBpZiggIXJzY3JhdGNoLmhheXN0YWNrICl7XG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcblxuICAgICAgICByc2NyYXRjaC5zb3VyY2UgPSB7XG4gICAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhbmdsZSA9IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSTtcblxuICAgICAgICByc2NyYXRjaC50YXJnZXQgPSB7XG4gICAgICAgICAgeDogTWF0aC5jb3MoYW5nbGUpLFxuICAgICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKVxuICAgICAgICB9O1xuXG4gICAgICB9XG5cbiAgICAgIHZhciBzcmMgPSBfcC5zb3VyY2U7XG4gICAgICB2YXIgdGd0ID0gX3AudGFyZ2V0O1xuICAgICAgdmFyIHNyY1BvcyA9IHNyYy5fcHJpdmF0ZS5wb3NpdGlvbjtcbiAgICAgIHZhciB0Z3RQb3MgPSB0Z3QuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICB2YXIgc3JjVyA9IHNyYy53aWR0aCgpO1xuICAgICAgdmFyIHRndFcgPSB0Z3Qud2lkdGgoKTtcbiAgICAgIHZhciBzcmNIID0gc3JjLmhlaWdodCgpO1xuICAgICAgdmFyIHRndEggPSB0Z3QuaGVpZ2h0KCk7XG4gICAgICB2YXIgcmFkaXVzID0gc3R5bGVbJ2hheXN0YWNrLXJhZGl1cyddLnZhbHVlO1xuICAgICAgdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMvMjsgLy8gYi9jIGhhdmUgdG8gaGFsZiB3aWR0aC9oZWlnaHRcblxuICAgICAgcnMuaGF5c3RhY2tQdHMgPSBbXG4gICAgICAgIHJzLnNvdXJjZS54ICogc3JjVyAqIGhhbGZSYWRpdXMgKyBzcmNQb3MueCxcbiAgICAgICAgcnMuc291cmNlLnkgKiBzcmNIICogaGFsZlJhZGl1cyArIHNyY1Bvcy55LFxuICAgICAgICBycy50YXJnZXQueCAqIHRndFcgKiBoYWxmUmFkaXVzICsgdGd0UG9zLngsXG4gICAgICAgIHJzLnRhcmdldC55ICogdGd0SCAqIGhhbGZSYWRpdXMgKyB0Z3RQb3MueVxuICAgICAgXTtcblxuICAgICAgLy8gYWx3YXlzIG92ZXJyaWRlIGFzIGhheXN0YWNrIGluIGNhc2Ugc2V0IHRvIGRpZmZlcmVudCB0eXBlIHByZXZpb3VzbHlcbiAgICAgIHJzY3JhdGNoLmVkZ2VUeXBlID0gJ2hheXN0YWNrJztcbiAgICAgIHJzY3JhdGNoLmhheXN0YWNrID0gdHJ1ZTtcblxuICAgICAgdGhpcy5yZWNhbGN1bGF0ZUVkZ2VMYWJlbFByb2plY3Rpb24oIGVkZ2UgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaFRhYmxlO1xuICB9O1xuXG4gIENScC5maW5kRW5kcG9pbnRzID0gZnVuY3Rpb24oZWRnZSkge1xuICAgIHZhciBpbnRlcnNlY3Q7XG5cbiAgICB2YXIgc291cmNlID0gZWRnZS5zb3VyY2UoKVswXTtcbiAgICB2YXIgdGFyZ2V0ID0gZWRnZS50YXJnZXQoKVswXTtcbiAgICBcbiAgICB2YXIgdGd0QXJTaGFwZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ3RhcmdldC1hcnJvdy1zaGFwZSddLnZhbHVlO1xuICAgIHZhciBzcmNBclNoYXBlID0gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnc291cmNlLWFycm93LXNoYXBlJ10udmFsdWU7XG5cbiAgICB2YXIgdGd0Qm9yZGVyVyA9IHRhcmdldC5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcbiAgICB2YXIgc3JjQm9yZGVyVyA9IHNvdXJjZS5fcHJpdmF0ZS5zdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcblxuICAgIHZhciBycyA9IGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2g7XG4gICAgXG4gICAgaWYgKHJzLmVkZ2VUeXBlID09ICdzZWxmJyB8fCBycy5lZGdlVHlwZSA9PSAnY29tcG91bmQnKSB7XG4gICAgICBcbiAgICAgIHZhciBjcCA9IFtycy5jcDJjeCwgcnMuY3AyY3ldO1xuICAgICAgXG4gICAgICBpbnRlcnNlY3QgPSBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKHRhcmdldCldLmludGVyc2VjdExpbmUoXG4gICAgICAgIHRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgdGhpcy5nZXROb2RlV2lkdGgodGFyZ2V0KSxcbiAgICAgICAgdGhpcy5nZXROb2RlSGVpZ2h0KHRhcmdldCksXG4gICAgICAgIGNwWzBdLFxuICAgICAgICBjcFsxXSwgXG4gICAgICAgIHRndEJvcmRlclcgLyAyXG4gICAgICApO1xuICAgICAgXG4gICAgICB2YXIgYXJyb3dFbmQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uc3BhY2luZyhlZGdlKSk7XG4gICAgICB2YXIgZWRnZUVuZCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5nYXAoZWRnZSkpO1xuICAgICAgXG4gICAgICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgICAgIHJzLmVuZFkgPSBlZGdlRW5kWzFdO1xuICAgICAgXG4gICAgICBycy5hcnJvd0VuZFggPSBhcnJvd0VuZFswXTtcbiAgICAgIHJzLmFycm93RW5kWSA9IGFycm93RW5kWzFdO1xuICAgICAgXG4gICAgICB2YXIgY3AgPSBbcnMuY3AyYXgsIHJzLmNwMmF5XTtcblxuICAgICAgaW50ZXJzZWN0ID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShzb3VyY2UpXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICBzb3VyY2UuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgc291cmNlLl9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVdpZHRoKHNvdXJjZSksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUhlaWdodChzb3VyY2UpLFxuICAgICAgICBjcFswXSwgLy9oYWxmUG9pbnRYLFxuICAgICAgICBjcFsxXSwgLy9oYWxmUG9pbnRZXG4gICAgICAgIHNyY0JvcmRlclcgLyAyXG4gICAgICApO1xuICAgICAgXG4gICAgICB2YXIgYXJyb3dTdGFydCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5zcGFjaW5nKGVkZ2UpKTtcbiAgICAgIHZhciBlZGdlU3RhcnQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uZ2FwKGVkZ2UpKTtcbiAgICAgIFxuICAgICAgcnMuc3RhcnRYID0gZWRnZVN0YXJ0WzBdO1xuICAgICAgcnMuc3RhcnRZID0gZWRnZVN0YXJ0WzFdO1xuXG5cbiAgICAgIHJzLmFycm93U3RhcnRYID0gYXJyb3dTdGFydFswXTtcbiAgICAgIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcbiAgICAgIFxuICAgIH0gZWxzZSBpZiAocnMuZWRnZVR5cGUgPT0gJ3N0cmFpZ2h0Jykge1xuICAgIFxuICAgICAgaW50ZXJzZWN0ID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZSh0YXJnZXQpXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgdGFyZ2V0Ll9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVdpZHRoKHRhcmdldCksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUhlaWdodCh0YXJnZXQpLFxuICAgICAgICBzb3VyY2UucG9zaXRpb24oKS54LFxuICAgICAgICBzb3VyY2UucG9zaXRpb24oKS55LFxuICAgICAgICB0Z3RCb3JkZXJXIC8gMik7XG4gICAgICAgIFxuICAgICAgaWYgKGludGVyc2VjdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcnMubm9BcnJvd1BsYWNlbWVudCA9IHRydWU7XG4gICAgICAgIC8vIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLm5vQXJyb3dQbGFjZW1lbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIGFycm93RW5kID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCxcbiAgICAgICAgW3NvdXJjZS5wb3NpdGlvbigpLngsIHNvdXJjZS5wb3NpdGlvbigpLnldLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5zcGFjaW5nKGVkZ2UpKTtcbiAgICAgIHZhciBlZGdlRW5kID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCxcbiAgICAgICAgW3NvdXJjZS5wb3NpdGlvbigpLngsIHNvdXJjZS5wb3NpdGlvbigpLnldLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1t0Z3RBclNoYXBlXS5nYXAoZWRnZSkpO1xuXG4gICAgICBycy5lbmRYID0gZWRnZUVuZFswXTtcbiAgICAgIHJzLmVuZFkgPSBlZGdlRW5kWzFdO1xuICAgICAgXG4gICAgICBycy5hcnJvd0VuZFggPSBhcnJvd0VuZFswXTtcbiAgICAgIHJzLmFycm93RW5kWSA9IGFycm93RW5kWzFdO1xuICAgIFxuICAgICAgaW50ZXJzZWN0ID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShzb3VyY2UpXS5pbnRlcnNlY3RMaW5lKFxuICAgICAgICBzb3VyY2UuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgc291cmNlLl9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVdpZHRoKHNvdXJjZSksXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUhlaWdodChzb3VyY2UpLFxuICAgICAgICB0YXJnZXQucG9zaXRpb24oKS54LFxuICAgICAgICB0YXJnZXQucG9zaXRpb24oKS55LFxuICAgICAgICBzcmNCb3JkZXJXIC8gMik7XG4gICAgICBcbiAgICAgIGlmIChpbnRlcnNlY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJzLm5vQXJyb3dQbGFjZW1lbnQgPSB0cnVlO1xuICAgICAgIC8vIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzLm5vQXJyb3dQbGFjZW1lbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLypcbiAgICAgIGNvbnNvbGUubG9nKFwiMTogXCJcbiAgICAgICAgKyBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXSxcbiAgICAgICAgICBzcmNBclNoYXBlKTtcbiAgICAgICovXG4gICAgICB2YXIgYXJyb3dTdGFydCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihpbnRlcnNlY3QsXG4gICAgICAgIFt0YXJnZXQucG9zaXRpb24oKS54LCB0YXJnZXQucG9zaXRpb24oKS55XSxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0uc3BhY2luZyhlZGdlKSk7XG4gICAgICB2YXIgZWRnZVN0YXJ0ID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCxcbiAgICAgICAgW3RhcmdldC5wb3NpdGlvbigpLngsIHRhcmdldC5wb3NpdGlvbigpLnldLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5nYXAoZWRnZSkpO1xuXG4gICAgICBycy5zdGFydFggPSBlZGdlU3RhcnRbMF07XG4gICAgICBycy5zdGFydFkgPSBlZGdlU3RhcnRbMV07XG4gICAgICBcbiAgICAgIHJzLmFycm93U3RhcnRYID0gYXJyb3dTdGFydFswXTtcbiAgICAgIHJzLmFycm93U3RhcnRZID0gYXJyb3dTdGFydFsxXTtcbiAgICAgIFxuICAgICAgaWYoICEkJC5pcy5udW1iZXIocnMuc3RhcnRYKSB8fCAhJCQuaXMubnVtYmVyKHJzLnN0YXJ0WSkgfHwgISQkLmlzLm51bWJlcihycy5lbmRYKSB8fCAhJCQuaXMubnVtYmVyKHJzLmVuZFkpICl7XG4gICAgICAgIHJzLmJhZExpbmUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcnMuYmFkTGluZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgICAgICAgXG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PSAnYmV6aWVyJykge1xuICAgICAgLy8gaWYoIHdpbmRvdy5iYWRBcnJvdykgZGVidWdnZXI7XG4gICAgICB2YXIgY3AgPSBbcnMuY3AyeCwgcnMuY3AyeV07XG4gICAgICBcbiAgICAgIGludGVyc2VjdCA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXNbXG4gICAgICAgIHRoaXMuZ2V0Tm9kZVNoYXBlKHRhcmdldCldLmludGVyc2VjdExpbmUoXG4gICAgICAgIHRhcmdldC5fcHJpdmF0ZS5wb3NpdGlvbi54LFxuICAgICAgICB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb24ueSxcbiAgICAgICAgdGhpcy5nZXROb2RlV2lkdGgodGFyZ2V0KSxcbiAgICAgICAgdGhpcy5nZXROb2RlSGVpZ2h0KHRhcmdldCksXG4gICAgICAgIGNwWzBdLCAvL2hhbGZQb2ludFgsXG4gICAgICAgIGNwWzFdLCAvL2hhbGZQb2ludFlcbiAgICAgICAgdGd0Qm9yZGVyVyAvIDJcbiAgICAgICk7XG4gICAgICBcbiAgICAgIC8qXG4gICAgICBjb25zb2xlLmxvZyhcIjI6IFwiXG4gICAgICAgICsgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc3JjQXJTaGFwZV0sXG4gICAgICAgICAgc3JjQXJTaGFwZSk7XG4gICAgICAqL1xuICAgICAgdmFyIGFycm93RW5kID0gJCQubWF0aC5zaG9ydGVuSW50ZXJzZWN0aW9uKGludGVyc2VjdCwgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3RndEFyU2hhcGVdLnNwYWNpbmcoZWRnZSkpO1xuICAgICAgdmFyIGVkZ2VFbmQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oaW50ZXJzZWN0LCBjcCxcbiAgICAgICAgQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbdGd0QXJTaGFwZV0uZ2FwKGVkZ2UpKTtcbiAgICAgIFxuICAgICAgcnMuZW5kWCA9IGVkZ2VFbmRbMF07XG4gICAgICBycy5lbmRZID0gZWRnZUVuZFsxXTtcbiAgICAgIFxuICAgICAgcnMuYXJyb3dFbmRYID0gYXJyb3dFbmRbMF07XG4gICAgICBycy5hcnJvd0VuZFkgPSBhcnJvd0VuZFsxXTtcbiAgICAgIFxuICAgICAgaW50ZXJzZWN0ID0gQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1tcbiAgICAgICAgdGhpcy5nZXROb2RlU2hhcGUoc291cmNlKV0uaW50ZXJzZWN0TGluZShcbiAgICAgICAgc291cmNlLl9wcml2YXRlLnBvc2l0aW9uLngsXG4gICAgICAgIHNvdXJjZS5fcHJpdmF0ZS5wb3NpdGlvbi55LFxuICAgICAgICB0aGlzLmdldE5vZGVXaWR0aChzb3VyY2UpLFxuICAgICAgICB0aGlzLmdldE5vZGVIZWlnaHQoc291cmNlKSxcbiAgICAgICAgY3BbMF0sIC8vaGFsZlBvaW50WCxcbiAgICAgICAgY3BbMV0sIC8vaGFsZlBvaW50WVxuICAgICAgICBzcmNCb3JkZXJXIC8gMlxuICAgICAgKTtcbiAgICAgIFxuICAgICAgdmFyIGFycm93U3RhcnQgPSAkJC5tYXRoLnNob3J0ZW5JbnRlcnNlY3Rpb24oXG4gICAgICAgIGludGVyc2VjdCwgXG4gICAgICAgIGNwLFxuICAgICAgICBDYW52YXNSZW5kZXJlci5hcnJvd1NoYXBlc1tzcmNBclNoYXBlXS5zcGFjaW5nKGVkZ2UpXG4gICAgICApO1xuICAgICAgdmFyIGVkZ2VTdGFydCA9ICQkLm1hdGguc2hvcnRlbkludGVyc2VjdGlvbihcbiAgICAgICAgaW50ZXJzZWN0LCBcbiAgICAgICAgY3AsXG4gICAgICAgIENhbnZhc1JlbmRlcmVyLmFycm93U2hhcGVzW3NyY0FyU2hhcGVdLmdhcChlZGdlKVxuICAgICAgKTtcbiAgICBcbiAgICAgIHJzLnN0YXJ0WCA9IGVkZ2VTdGFydFswXTtcbiAgICAgIHJzLnN0YXJ0WSA9IGVkZ2VTdGFydFsxXTtcbiAgICAgIFxuICAgICAgcnMuYXJyb3dTdGFydFggPSBhcnJvd1N0YXJ0WzBdO1xuICAgICAgcnMuYXJyb3dTdGFydFkgPSBhcnJvd1N0YXJ0WzFdO1xuICAgICAgXG4gICAgICAvLyBpZiggaXNOYU4ocnMuc3RhcnRYKSB8fCBpc05hTihycy5zdGFydFkpICl7XG4gICAgICAvLyAgIGRlYnVnZ2VyO1xuICAgICAgLy8gfVxuXG4gICAgfSBlbHNlIGlmIChycy5pc0FyY0VkZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH07XG5cbiAgLy8gRmluZCBhZGphY2VudCBlZGdlc1xuICBDUnAuZmluZEVkZ2VzID0gZnVuY3Rpb24obm9kZVNldCkge1xuICAgIFxuICAgIHZhciBlZGdlcyA9IHRoaXMuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgICBcbiAgICB2YXIgaGFzaFRhYmxlID0ge307XG4gICAgdmFyIGFkamFjZW50RWRnZXMgPSBbXTtcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGhhc2hUYWJsZVtub2RlU2V0W2ldLl9wcml2YXRlLmRhdGEuaWRdID0gbm9kZVNldFtpXTtcbiAgICB9XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGhhc2hUYWJsZVtlZGdlc1tpXS5fcHJpdmF0ZS5kYXRhLnNvdXJjZV1cbiAgICAgICAgfHwgaGFzaFRhYmxlW2VkZ2VzW2ldLl9wcml2YXRlLmRhdGEudGFyZ2V0XSkge1xuICAgICAgICBcbiAgICAgICAgYWRqYWNlbnRFZGdlcy5wdXNoKGVkZ2VzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGFkamFjZW50RWRnZXM7XG4gIH07XG5cbiAgQ1JwLmdldEFycm93V2lkdGggPSBDUnAuZ2V0QXJyb3dIZWlnaHQgPSBmdW5jdGlvbihlZGdlV2lkdGgpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmFycm93V2lkdGhDYWNoZSA9IHRoaXMuYXJyb3dXaWR0aENhY2hlIHx8IHt9O1xuXG4gICAgdmFyIGNhY2hlZFZhbCA9IGNhY2hlW2VkZ2VXaWR0aF07XG4gICAgaWYoIGNhY2hlZFZhbCApe1xuICAgICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgICB9XG5cbiAgICBjYWNoZWRWYWwgPSAgTWF0aC5tYXgoTWF0aC5wb3coZWRnZVdpZHRoICogMTMuMzcsIDAuOSksIDI5KTtcbiAgICBjYWNoZVtlZGdlV2lkdGhdID0gY2FjaGVkVmFsO1xuXG4gICAgcmV0dXJuIGNhY2hlZFZhbDtcbiAgfTtcblxuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG4vLyBEcmF3IGVkZ2VcbiAgQ1JwLmRyYXdFZGdlID0gZnVuY3Rpb24oY29udGV4dCwgZWRnZSwgZHJhd092ZXJsYXlJbnN0ZWFkKSB7XG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgdXNlUGF0aHMgPSBDYW52YXNSZW5kZXJlci51c2VQYXRocygpO1xuXG4gICAgLy8gaWYgYmV6aWVyIGN0cmwgcHRzIGNhbiBub3QgYmUgY2FsY3VsYXRlZCwgdGhlbiBkaWVcbiAgICBpZiggcnMuYmFkQmV6aWVyIHx8ICggKHJzLmVkZ2VUeXBlID09PSAnYmV6aWVyJyB8fCBycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0JykgJiYgaXNOYU4ocnMuc3RhcnRYKSkgKXsgLy8gZXh0cmEgaXNOYU4oKSBmb3Igc2FmYXJpIDcuMSBiL2MgaXQgbWFuZ2xlcyBjdHJscHQgY2FsY3NcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3R5bGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlO1xuICAgIFxuICAgIC8vIEVkZ2UgbGluZSB3aWR0aFxuICAgIGlmIChzdHlsZVsnd2lkdGgnXS5weFZhbHVlIDw9IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3ZlcmxheVBhZGRpbmcgPSBzdHlsZVsnb3ZlcmxheS1wYWRkaW5nJ10ucHhWYWx1ZTtcbiAgICB2YXIgb3ZlcmxheU9wYWNpdHkgPSBzdHlsZVsnb3ZlcmxheS1vcGFjaXR5J10udmFsdWU7XG4gICAgdmFyIG92ZXJsYXlDb2xvciA9IHN0eWxlWydvdmVybGF5LWNvbG9yJ10udmFsdWU7XG5cbiAgICAvLyBFZGdlIGNvbG9yICYgb3BhY2l0eVxuICAgIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgKXtcblxuICAgICAgaWYoIG92ZXJsYXlPcGFjaXR5ID09PSAwICl7IC8vIGV4aXQgZWFybHkgaWYgbm8gb3ZlcmxheVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3Ryb2tlU3R5bGUoY29udGV4dCwgb3ZlcmxheUNvbG9yWzBdLCBvdmVybGF5Q29sb3JbMV0sIG92ZXJsYXlDb2xvclsyXSwgb3ZlcmxheU9wYWNpdHkpO1xuICAgICAgY29udGV4dC5saW5lQ2FwID0gJ3JvdW5kJztcblxuICAgICAgaWYoIGVkZ2UuX3ByaXZhdGUucnNjcmF0Y2guZWRnZVR5cGUgPT0gJ3NlbGYnICYmICF1c2VQYXRocyApe1xuICAgICAgICBjb250ZXh0LmxpbmVDYXAgPSAnYnV0dCc7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxpbmVDb2xvciA9IHN0eWxlWydsaW5lLWNvbG9yJ10udmFsdWU7XG5cbiAgICAgIHRoaXMuc3Ryb2tlU3R5bGUoY29udGV4dCwgbGluZUNvbG9yWzBdLCBsaW5lQ29sb3JbMV0sIGxpbmVDb2xvclsyXSwgc3R5bGUub3BhY2l0eS52YWx1ZSk7XG4gICAgICBcbiAgICAgIGNvbnRleHQubGluZUNhcCA9ICdidXR0JzsgXG4gICAgfVxuICAgIFxuICAgIHZhciBzdGFydE5vZGUsIGVuZE5vZGUsIHNvdXJjZSwgdGFyZ2V0O1xuICAgIHNvdXJjZSA9IHN0YXJ0Tm9kZSA9IGVkZ2UuX3ByaXZhdGUuc291cmNlO1xuICAgIHRhcmdldCA9IGVuZE5vZGUgPSBlZGdlLl9wcml2YXRlLnRhcmdldDtcblxuICAgIC8vIHZhciB0YXJnZXRQb3MgPSB0YXJnZXQuX3ByaXZhdGUucG9zaXRpb247XG4gICAgLy8gdmFyIHRhcmdldFcgPSB0YXJnZXQud2lkdGgoKTtcbiAgICAvLyB2YXIgdGFyZ2V0SCA9IHRhcmdldC5oZWlnaHQoKTtcbiAgICAvLyB2YXIgc291cmNlUG9zID0gc291cmNlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgIC8vIHZhciBzb3VyY2VXID0gc291cmNlLndpZHRoKCk7XG4gICAgLy8gdmFyIHNvdXJjZUggPSBzb3VyY2UuaGVpZ2h0KCk7XG5cblxuICAgIHZhciBlZGdlV2lkdGggPSBzdHlsZVsnd2lkdGgnXS5weFZhbHVlICsgKGRyYXdPdmVybGF5SW5zdGVhZCA/IDIgKiBvdmVybGF5UGFkZGluZyA6IDApO1xuICAgIHZhciBsaW5lU3R5bGUgPSBkcmF3T3ZlcmxheUluc3RlYWQgPyAnc29saWQnIDogc3R5bGVbJ2xpbmUtc3R5bGUnXS52YWx1ZTtcbiAgICBjb250ZXh0LmxpbmVXaWR0aCA9IGVkZ2VXaWR0aDtcbiAgICBcbiAgICB2YXIgc2hhZG93Qmx1ciA9IHN0eWxlWydzaGFkb3ctYmx1ciddLnB4VmFsdWU7XG4gICAgdmFyIHNoYWRvd09wYWNpdHkgPSBzdHlsZVsnc2hhZG93LW9wYWNpdHknXS52YWx1ZTtcbiAgICB2YXIgc2hhZG93Q29sb3IgPSBzdHlsZVsnc2hhZG93LWNvbG9yJ10udmFsdWU7XG4gICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZVsnc2hhZG93LW9mZnNldC14J10ucHhWYWx1ZTtcbiAgICB2YXIgc2hhZG93T2Zmc2V0WSA9IHN0eWxlWydzaGFkb3ctb2Zmc2V0LXknXS5weFZhbHVlO1xuXG4gICAgdGhpcy5zaGFkb3dTdHlsZShjb250ZXh0LCAgc2hhZG93Q29sb3IsIGRyYXdPdmVybGF5SW5zdGVhZCA/IDAgOiBzaGFkb3dPcGFjaXR5LCBzaGFkb3dCbHVyLCBzaGFkb3dPZmZzZXRYLCBzaGFkb3dPZmZzZXRZKTtcbiAgICBcbiAgICAvLyBpZiggcnMuZWRnZVR5cGUgIT09ICdoYXlzdGFjaycgKXtcbiAgICAvLyAgIHRoaXMuZmluZEVuZHBvaW50cyhlZGdlKTtcbiAgICAvLyB9XG4gICAgXG4gICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snICl7XG4gICAgICAvLyB2YXIgcmFkaXVzID0gc3R5bGVbJ2hheXN0YWNrLXJhZGl1cyddLnZhbHVlO1xuICAgICAgLy8gdmFyIGhhbGZSYWRpdXMgPSByYWRpdXMvMjsgLy8gYi9jIGhhdmUgdG8gaGFsZiB3aWR0aC9oZWlnaHRcblxuICAgICAgdGhpcy5kcmF3U3R5bGVkRWRnZShcbiAgICAgICAgZWRnZSwgXG4gICAgICAgIGNvbnRleHQsIFxuICAgICAgICBycy5oYXlzdGFja1B0cyxcbiAgICAgICAgbGluZVN0eWxlLFxuICAgICAgICBlZGdlV2lkdGhcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3NlbGYnIHx8IHJzLmVkZ2VUeXBlID09PSAnY29tcG91bmQnKSB7XG4gICAgICBcbiAgICAgIHZhciBkZXRhaWxzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICAgIHZhciBwb2ludHMgPSBbZGV0YWlscy5zdGFydFgsIGRldGFpbHMuc3RhcnRZLCBkZXRhaWxzLmNwMmF4LFxuICAgICAgICBkZXRhaWxzLmNwMmF5LCBkZXRhaWxzLnNlbGZFZGdlTWlkWCwgZGV0YWlscy5zZWxmRWRnZU1pZFksXG4gICAgICAgIGRldGFpbHMuc2VsZkVkZ2VNaWRYLCBkZXRhaWxzLnNlbGZFZGdlTWlkWSxcbiAgICAgICAgZGV0YWlscy5jcDJjeCwgZGV0YWlscy5jcDJjeSwgZGV0YWlscy5lbmRYLCBkZXRhaWxzLmVuZFldO1xuXG4gICAgICB0aGlzLmRyYXdTdHlsZWRFZGdlKGVkZ2UsIGNvbnRleHQsIHBvaW50cywgbGluZVN0eWxlLCBlZGdlV2lkdGgpO1xuICAgICAgXG4gICAgfSBlbHNlIGlmIChycy5lZGdlVHlwZSA9PT0gJ3N0cmFpZ2h0Jykge1xuICAgICAgXG4gICAgICB2YXIgbm9kZURpcmVjdGlvblggPSBlbmROb2RlLl9wcml2YXRlLnBvc2l0aW9uLnggLSBzdGFydE5vZGUuX3ByaXZhdGUucG9zaXRpb24ueDtcbiAgICAgIHZhciBub2RlRGlyZWN0aW9uWSA9IGVuZE5vZGUuX3ByaXZhdGUucG9zaXRpb24ueSAtIHN0YXJ0Tm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi55O1xuICAgICAgXG4gICAgICB2YXIgZWRnZURpcmVjdGlvblggPSBycy5lbmRYIC0gcnMuc3RhcnRYO1xuICAgICAgdmFyIGVkZ2VEaXJlY3Rpb25ZID0gcnMuZW5kWSAtIHJzLnN0YXJ0WTtcbiAgICAgIFxuICAgICAgaWYgKG5vZGVEaXJlY3Rpb25YICogZWRnZURpcmVjdGlvblhcbiAgICAgICAgKyBub2RlRGlyZWN0aW9uWSAqIGVkZ2VEaXJlY3Rpb25ZIDwgMCkge1xuICAgICAgICBcbiAgICAgICAgcnMuc3RyYWlnaHRFZGdlVG9vU2hvcnQgPSB0cnVlOyAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBcbiAgICAgICAgdmFyIGRldGFpbHMgPSBycztcbiAgICAgICAgdGhpcy5kcmF3U3R5bGVkRWRnZShlZGdlLCBjb250ZXh0LCBbZGV0YWlscy5zdGFydFgsIGRldGFpbHMuc3RhcnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWxzLmVuZFgsIGRldGFpbHMuZW5kWV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRnZVdpZHRoKTtcbiAgICAgICAgXG4gICAgICAgIHJzLnN0cmFpZ2h0RWRnZVRvb1Nob3J0ID0gZmFsc2U7ICBcbiAgICAgIH0gIFxuICAgIH0gZWxzZSB7XG4gICAgICBcbiAgICAgIHZhciBkZXRhaWxzID0gcnM7XG4gICAgICBcbiAgICAgIHRoaXMuZHJhd1N0eWxlZEVkZ2UoZWRnZSwgY29udGV4dCwgW2RldGFpbHMuc3RhcnRYLCBkZXRhaWxzLnN0YXJ0WSxcbiAgICAgICAgZGV0YWlscy5jcDJ4LCBkZXRhaWxzLmNwMnksIGRldGFpbHMuZW5kWCwgZGV0YWlscy5lbmRZXSxcbiAgICAgICAgbGluZVN0eWxlLFxuICAgICAgICBlZGdlV2lkdGgpO1xuICAgICAgXG4gICAgfVxuICAgIFxuICAgIGlmKCBycy5lZGdlVHlwZSA9PT0gJ2hheXN0YWNrJyApe1xuICAgICAgdGhpcy5kcmF3QXJyb3doZWFkcyhjb250ZXh0LCBlZGdlLCBkcmF3T3ZlcmxheUluc3RlYWQpO1xuICAgIH0gZWxzZSBpZiAoIHJzLm5vQXJyb3dQbGFjZW1lbnQgIT09IHRydWUgJiYgcnMuc3RhcnRYICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHRoaXMuZHJhd0Fycm93aGVhZHMoY29udGV4dCwgZWRnZSwgZHJhd092ZXJsYXlJbnN0ZWFkKTtcbiAgICB9XG5cbiAgICB0aGlzLnNoYWRvd1N0eWxlKGNvbnRleHQsICd0cmFuc3BhcmVudCcsIDApOyAvLyByZXNldCBmb3IgbmV4dCBndXlcblxuICB9O1xuICBcbiAgXG4gIENScC5kcmF3U3R5bGVkRWRnZSA9IGZ1bmN0aW9uKFxuICAgICAgZWRnZSwgY29udGV4dCwgcHRzLCB0eXBlLCB3aWR0aCkge1xuXG4gICAgLy8gMyBwb2ludHMgZ2l2ZW4gLT4gYXNzdW1lIEJlemllclxuICAgIC8vIDIgLT4gYXNzdW1lIHN0cmFpZ2h0XG4gICAgXG4gICAgdmFyIHJzID0gZWRnZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2FudmFzQ3h0ID0gY29udGV4dDtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgcGF0aENhY2hlSGl0ID0gZmFsc2U7XG4gICAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcblxuXG4gICAgaWYoIHVzZVBhdGhzICl7XG5cbiAgICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBwdHM7XG4gICAgICB2YXIga2V5TGVuZ3RoTWF0Y2hlcyA9IHJzLnBhdGhDYWNoZUtleSAmJiBwYXRoQ2FjaGVLZXkubGVuZ3RoID09PSBycy5wYXRoQ2FjaGVLZXkubGVuZ3RoO1xuICAgICAgdmFyIGtleU1hdGNoZXMgPSBrZXlMZW5ndGhNYXRjaGVzO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsga2V5TWF0Y2hlcyAmJiBpIDwgcGF0aENhY2hlS2V5Lmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGlmKCBycy5wYXRoQ2FjaGVLZXlbaV0gIT09IHBhdGhDYWNoZUtleVtpXSApe1xuICAgICAgICAgIGtleU1hdGNoZXMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZigga2V5TWF0Y2hlcyApe1xuICAgICAgICBwYXRoID0gY29udGV4dCA9IHJzLnBhdGhDYWNoZTtcbiAgICAgICAgcGF0aENhY2hlSGl0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGggPSBjb250ZXh0ID0gbmV3IFBhdGgyRCgpO1xuICAgICAgICBycy5wYXRoQ2FjaGVLZXkgPSBwYXRoQ2FjaGVLZXk7XG4gICAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICBpZiggY2FudmFzQ3h0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgc3dpdGNoKCB0eXBlICl7XG4gICAgICAgIGNhc2UgJ2RvdHRlZCc6XG4gICAgICAgICAgY2FudmFzQ3h0LnNldExpbmVEYXNoKFsgMSwgMSBdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbIDYsIDMgXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgIGNhbnZhc0N4dC5zZXRMaW5lRGFzaChbIF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCAhcGF0aENhY2hlSGl0ICl7XG4gICAgICBpZiggY29udGV4dC5iZWdpblBhdGggKXsgY29udGV4dC5iZWdpblBhdGgoKTsgfVxuICAgICAgY29udGV4dC5tb3ZlVG8ocHRzWzBdLCBwdHNbMV0pO1xuICAgICAgXG4gICAgICBpZiggcHRzLmxlbmd0aCA9PT0gNiAmJiAhcnMuYmFkQmV6aWVyICl7IC8vIGJlemllclxuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8ocHRzWzJdLCBwdHNbM10sIHB0c1s0XSwgcHRzWzVdKTtcbiAgICAgIH0gZWxzZSBpZiggcHRzLmxlbmd0aCA9PT0gMTIgJiYgIXJzLmJhZEJlemllciApeyAvLyBkb3VibGUgYmV6aWVyIGxvb3BcbiAgICAgICAgY29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHB0c1syXSwgcHRzWzNdLCBwdHNbNF0sIHB0c1s1XSk7XG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhwdHNbOF0sIHB0c1s5XSwgcHRzWzEwXSwgcHRzWzExXSk7XG4gICAgICB9IGVsc2UgaWYoIHB0cy5sZW5ndGggPT09IDQgJiYgIXJzLmJhZExpbmUgKXsgLy8gbGluZVxuICAgICAgICBjb250ZXh0LmxpbmVUbyhwdHNbMl0sIHB0c1szXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29udGV4dCA9IGNhbnZhc0N4dDtcbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICBcbiAgICAvLyByZXNldCBhbnkgbGluZSBkYXNoZXNcbiAgICBpZiggY29udGV4dC5zZXRMaW5lRGFzaCApeyAvLyBmb3IgdmVyeSBvdXRvZmRhdGUgYnJvd3NlcnNcbiAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyBdKTtcbiAgICB9XG5cbiAgfTtcblxuICBDUnAuZHJhd0Fycm93aGVhZHMgPSBmdW5jdGlvbihjb250ZXh0LCBlZGdlLCBkcmF3T3ZlcmxheUluc3RlYWQpIHtcbiAgICBpZiggZHJhd092ZXJsYXlJbnN0ZWFkICl7IHJldHVybjsgfSAvLyBkb24ndCBkbyBhbnl0aGluZyBmb3Igb3ZlcmxheXMgXG5cbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgaXNIYXlzdGFjayA9IHJzLmVkZ2VUeXBlID09PSAnaGF5c3RhY2snO1xuXG4gICAgLy8gRGlzcGxhY2VtZW50IGdpdmVzIGRpcmVjdGlvbiBmb3IgYXJyb3doZWFkIG9yaWVudGF0aW9uXG4gICAgdmFyIGRpc3BYLCBkaXNwWTtcbiAgICB2YXIgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFk7XG5cbiAgICB2YXIgc3JjUG9zID0gZWRnZS5zb3VyY2UoKS5wb3NpdGlvbigpO1xuICAgIHZhciB0Z3RQb3MgPSBlZGdlLnRhcmdldCgpLnBvc2l0aW9uKCk7XG5cbiAgICBpZiggaXNIYXlzdGFjayApe1xuICAgICAgc3RhcnRYID0gcnMuaGF5c3RhY2tQdHNbMF07XG4gICAgICBzdGFydFkgPSBycy5oYXlzdGFja1B0c1sxXTtcbiAgICAgIGVuZFggPSBycy5oYXlzdGFja1B0c1syXTtcbiAgICAgIGVuZFkgPSBycy5oYXlzdGFja1B0c1szXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRYID0gcnMuYXJyb3dTdGFydFg7XG4gICAgICBzdGFydFkgPSBycy5hcnJvd1N0YXJ0WTtcbiAgICAgIGVuZFggPSBycy5hcnJvd0VuZFg7XG4gICAgICBlbmRZID0gcnMuYXJyb3dFbmRZO1xuICAgIH1cblxuICAgIHZhciBzdHlsZSA9IGVkZ2UuX3ByaXZhdGUuc3R5bGU7XG4gICAgXG4gICAgZnVuY3Rpb24gZHJhd0Fycm93aGVhZCggcHJlZml4LCB4LCB5LCBkaXNwWCwgZGlzcFkgKXtcbiAgICAgIHZhciBhcnJvd1NoYXBlID0gc3R5bGVbcHJlZml4ICsgJy1hcnJvdy1zaGFwZSddLnZhbHVlO1xuXG4gICAgICBpZiggYXJyb3dTaGFwZSA9PT0gJ25vbmUnICl7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGdjbyA9IGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uO1xuXG4gICAgICB2YXIgYXJyb3dDbGVhckZpbGwgPSBzdHlsZVtwcmVmaXggKyAnLWFycm93LWZpbGwnXS52YWx1ZSA9PT0gJ2hvbGxvdycgPyAnYm90aCcgOiAnZmlsbGVkJztcbiAgICAgIHZhciBhcnJvd0ZpbGwgPSBzdHlsZVtwcmVmaXggKyAnLWFycm93LWZpbGwnXS52YWx1ZTtcblxuICAgICAgaWYoIGFycm93U2hhcGUgPT09ICdoYWxmLXRyaWFuZ2xlLW92ZXJzaG90JyApe1xuICAgICAgICBhcnJvd0ZpbGwgPSAnaG9sbG93JztcbiAgICAgICAgYXJyb3dDbGVhckZpbGwgPSAnaG9sbG93JztcbiAgICAgIH1cblxuICAgICAgaWYoIHN0eWxlLm9wYWNpdHkudmFsdWUgIT09IDEgfHwgYXJyb3dGaWxsID09PSAnaG9sbG93JyApeyAvLyB0aGVuIGV4dHJhIGNsZWFyIGlzIG5lZWRlZFxuICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdXQnO1xuICAgICAgICBcbiAgICAgICAgc2VsZi5maWxsU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgICAgIHNlbGYuc3Ryb2tlU3R5bGUoY29udGV4dCwgMjU1LCAyNTUsIDI1NSwgMSk7XG4gICAgICAgIFxuICAgICAgICBzZWxmLmRyYXdBcnJvd1NoYXBlKCBlZGdlLCBwcmVmaXgsIGNvbnRleHQsIFxuICAgICAgICAgIGFycm93Q2xlYXJGaWxsLCBzdHlsZVsnd2lkdGgnXS5weFZhbHVlLCBzdHlsZVtwcmVmaXggKyAnLWFycm93LXNoYXBlJ10udmFsdWUsIFxuICAgICAgICAgIHgsIHksIGRpc3BYLCBkaXNwWVxuICAgICAgICApO1xuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgICAgfSAvLyBvdGhlcndpc2UsIHRoZSBvcGFxdWUgYXJyb3cgY2xlYXJzIGl0IGZvciBmcmVlIDopXG5cbiAgICAgIHZhciBjb2xvciA9IHN0eWxlW3ByZWZpeCArICctYXJyb3ctY29sb3InXS52YWx1ZTtcbiAgICAgIHNlbGYuZmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIHN0eWxlLm9wYWNpdHkudmFsdWUpO1xuICAgICAgc2VsZi5zdHJva2VTdHlsZShjb250ZXh0LCBjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdLCBzdHlsZS5vcGFjaXR5LnZhbHVlKTtcblxuICAgICAgc2VsZi5kcmF3QXJyb3dTaGFwZSggZWRnZSwgcHJlZml4LCBjb250ZXh0LCBcbiAgICAgICAgYXJyb3dGaWxsLCBzdHlsZVsnd2lkdGgnXS5weFZhbHVlLCBzdHlsZVtwcmVmaXggKyAnLWFycm93LXNoYXBlJ10udmFsdWUsIFxuICAgICAgICB4LCB5LCBkaXNwWCwgZGlzcFlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgZGlzcFggPSBzdGFydFggLSBzcmNQb3MueDtcbiAgICBkaXNwWSA9IHN0YXJ0WSAtIHNyY1Bvcy55O1xuXG4gICAgaWYoICFpc0hheXN0YWNrICYmICFpc05hTihzdGFydFgpICYmICFpc05hTihzdGFydFkpICYmICFpc05hTihkaXNwWCkgJiYgIWlzTmFOKGRpc3BZKSApe1xuICAgICAgZHJhd0Fycm93aGVhZCggJ3NvdXJjZScsIHN0YXJ0WCwgc3RhcnRZLCBkaXNwWCwgZGlzcFkgKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB3aW5kb3cuYmFkQXJyb3cgPSB0cnVlO1xuICAgICAgLy8gZGVidWdnZXI7XG4gICAgfVxuICAgIFxuICAgIHZhciBtaWRYID0gcnMubWlkWDtcbiAgICB2YXIgbWlkWSA9IHJzLm1pZFk7XG5cbiAgICBpZiggaXNIYXlzdGFjayApe1xuICAgICAgbWlkWCA9ICggc3RhcnRYICsgZW5kWCApLzI7XG4gICAgICBtaWRZID0gKCBzdGFydFkgKyBlbmRZICkvMjtcbiAgICB9XG5cbiAgICBkaXNwWCA9IHN0YXJ0WCAtIGVuZFg7XG4gICAgZGlzcFkgPSBzdGFydFkgLSBlbmRZO1xuXG4gICAgaWYoIHJzLmVkZ2VUeXBlID09PSAnc2VsZicgKXtcbiAgICAgIGRpc3BYID0gMTtcbiAgICAgIGRpc3BZID0gLTE7XG4gICAgfVxuXG4gICAgaWYoICFpc05hTihtaWRYKSAmJiAhaXNOYU4obWlkWSkgKXtcbiAgICAgIGRyYXdBcnJvd2hlYWQoICdtaWQtdGFyZ2V0JywgbWlkWCwgbWlkWSwgZGlzcFgsIGRpc3BZICk7XG4gICAgfVxuXG4gICAgZGlzcFggKj0gLTE7XG4gICAgZGlzcFkgKj0gLTE7XG5cbiAgICBpZiggIWlzTmFOKG1pZFgpICYmICFpc05hTihtaWRZKSApe1xuICAgICAgZHJhd0Fycm93aGVhZCggJ21pZC1zb3VyY2UnLCBtaWRYLCBtaWRZLCBkaXNwWCwgZGlzcFkgKTtcbiAgICB9XG4gICAgXG4gICAgZGlzcFggPSBlbmRYIC0gdGd0UG9zLng7XG4gICAgZGlzcFkgPSBlbmRZIC0gdGd0UG9zLnk7XG4gICAgXG4gICAgaWYoICFpc0hheXN0YWNrICYmICFpc05hTihlbmRYKSAmJiAhaXNOYU4oZW5kWSkgJiYgIWlzTmFOKGRpc3BYKSAmJiAhaXNOYU4oZGlzcFkpICl7XG4gICAgICBkcmF3QXJyb3doZWFkKCAndGFyZ2V0JywgZW5kWCwgZW5kWSwgZGlzcFgsIGRpc3BZICk7XG4gICAgfVxuICB9O1xuICBcbiAgLy8gRHJhdyBhcnJvd3NoYXBlXG4gIENScC5kcmF3QXJyb3dTaGFwZSA9IGZ1bmN0aW9uKGVkZ2UsIGFycm93VHlwZSwgY29udGV4dCwgZmlsbCwgZWRnZVdpZHRoLCBzaGFwZSwgeCwgeSwgZGlzcFgsIGRpc3BZKSB7XG4gICAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgY2FudmFzQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgdmFyIHRyYW5zbGF0aW9uID0geyB4OiB4LCB5OiB5IH07XG5cbiAgICAvLyBOZWdhdGl2ZSBvZiB0aGUgYW5nbGVcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmFzaW4oZGlzcFkgLyAoTWF0aC5zcXJ0KGRpc3BYICogZGlzcFggKyBkaXNwWSAqIGRpc3BZKSkpO1xuICBcbiAgICBpZiAoZGlzcFggPCAwKSB7XG4gICAgICBhbmdsZSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFuZ2xlID0gLSAoTWF0aC5QSSAvIDIgKyBhbmdsZSk7XG4gICAgfVxuICAgIFxuICAgIHZhciBzaXplID0gdGhpcy5nZXRBcnJvd1dpZHRoKCBlZGdlV2lkdGggKTtcbiAgICB2YXIgc2hhcGVJbXBsID0gQ2FudmFzUmVuZGVyZXIuYXJyb3dTaGFwZXNbc2hhcGVdO1xuXG4gICAgLy8gY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG5cbiAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgIHZhciBwYXRoQ2FjaGVLZXkgPSBzaXplICsgJyQnICsgc2hhcGUgKyAnJCcgKyBhbmdsZSArICckJyArIHggKyAnJCcgKyB5O1xuICAgICAgcnMuYXJyb3dQYXRoQ2FjaGVLZXkgPSBycy5hcnJvd1BhdGhDYWNoZUtleSB8fCB7fTtcbiAgICAgIHJzLmFycm93UGF0aENhY2hlID0gcnMuYXJyb3dQYXRoQ2FjaGUgfHwge307XG5cbiAgICAgIHZhciBhbHJlYWR5Q2FjaGVkID0gcnMuYXJyb3dQYXRoQ2FjaGVLZXlbYXJyb3dUeXBlXSA9PT0gcGF0aENhY2hlS2V5O1xuICAgICAgaWYoIGFscmVhZHlDYWNoZWQgKXtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBycy5hcnJvd1BhdGhDYWNoZVthcnJvd1R5cGVdO1xuICAgICAgICBwYXRoQ2FjaGVIaXQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgIHJzLmFycm93UGF0aENhY2hlS2V5W2Fycm93VHlwZV0gPSBwYXRoQ2FjaGVLZXk7XG4gICAgICAgIHJzLmFycm93UGF0aENhY2hlW2Fycm93VHlwZV0gPSBwYXRoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgICBpZiggIXBhdGhDYWNoZUhpdCApe1xuICAgICAgc2hhcGVJbXBsLmRyYXcoY29udGV4dCwgc2l6ZSwgYW5nbGUsIHRyYW5zbGF0aW9uKTtcbiAgICB9XG4gICAgXG4gICAgaWYoICFzaGFwZUltcGwubGVhdmVQYXRoT3BlbiAmJiBjb250ZXh0LmNsb3NlUGF0aCApe1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICBjb250ZXh0ID0gY2FudmFzQ29udGV4dDtcblxuICAgIGlmKCBmaWxsID09PSAnZmlsbGVkJyB8fCBmaWxsID09PSAnYm90aCcgKXtcbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICBjb250ZXh0LmZpbGwoIHBhdGggKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmKCBmaWxsID09PSAnaG9sbG93JyB8fCBmaWxsID09PSAnYm90aCcgKXtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gKCBzaGFwZUltcGwubWF0Y2hFZGdlV2lkdGggPyBlZGdlV2lkdGggOiAxICk7XG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJztcblxuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgfVxuXG4gICAgLy8gY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIENScCA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcblxuICBDUnAuZ2V0Q2FjaGVkSW1hZ2UgPSBmdW5jdGlvbih1cmwsIG9uTG9hZCkge1xuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSA9IHIuaW1hZ2VDYWNoZSB8fCB7fTtcblxuICAgIGlmKCBpbWFnZUNhY2hlW3VybF0gJiYgaW1hZ2VDYWNoZVt1cmxdLmltYWdlICl7XG4gICAgICByZXR1cm4gaW1hZ2VDYWNoZVt1cmxdLmltYWdlO1xuICAgIH1cbiAgICBcbiAgICB2YXIgY2FjaGUgPSBpbWFnZUNhY2hlW3VybF0gPSBpbWFnZUNhY2hlW3VybF0gfHwge307XG5cbiAgICB2YXIgaW1hZ2UgPSBjYWNoZS5pbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBvbkxvYWQpO1xuICAgIGltYWdlLnNyYyA9IHVybDtcbiAgICBcbiAgICByZXR1cm4gaW1hZ2U7XG4gIH07XG4gIFxuICBDUnAuc2FmZURyYXdJbWFnZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBpbWcsIGl4LCBpeSwgaXcsIGloLCB4LCB5LCB3LCBoICl7XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZSggaW1nLCBpeCwgaXksIGl3LCBpaCwgeCwgeSwgdywgaCApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuTk9ERV0gPSB0cnVlO1xuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLkRSQUddID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgci5kcmF3aW5nSW1hZ2UgPSB0cnVlO1xuICAgICAgXG4gICAgICByLnJlZHJhdygpO1xuICAgIH1cbiAgfTtcbiAgXG4gIENScC5kcmF3SW5zY3JpYmVkSW1hZ2UgPSBmdW5jdGlvbihjb250ZXh0LCBpbWcsIG5vZGUpIHtcbiAgICB2YXIgciA9IHRoaXM7XG4gICAgdmFyIG5vZGVYID0gbm9kZS5fcHJpdmF0ZS5wb3NpdGlvbi54O1xuICAgIHZhciBub2RlWSA9IG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueTtcbiAgICB2YXIgc3R5bGUgPSBub2RlLl9wcml2YXRlLnN0eWxlO1xuICAgIHZhciBmaXQgPSBzdHlsZVsnYmFja2dyb3VuZC1maXQnXS52YWx1ZTtcbiAgICB2YXIgeFBvcyA9IHN0eWxlWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXgnXTtcbiAgICB2YXIgeVBvcyA9IHN0eWxlWydiYWNrZ3JvdW5kLXBvc2l0aW9uLXknXTtcbiAgICB2YXIgcmVwZWF0ID0gc3R5bGVbJ2JhY2tncm91bmQtcmVwZWF0J10udmFsdWU7XG4gICAgdmFyIG5vZGVXID0gbm9kZS53aWR0aCgpO1xuICAgIHZhciBub2RlSCA9IG5vZGUuaGVpZ2h0KCk7XG4gICAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgY2xpcCA9IHN0eWxlWydiYWNrZ3JvdW5kLWNsaXAnXS52YWx1ZTtcbiAgICB2YXIgc2hvdWxkQ2xpcCA9IGNsaXAgPT09ICdub2RlJztcbiAgICB2YXIgaW1nT3BhY2l0eSA9IHN0eWxlWydiYWNrZ3JvdW5kLWltYWdlLW9wYWNpdHknXS52YWx1ZTtcbiAgICBcbiAgICB2YXIgdyA9IGltZy53aWR0aDtcbiAgICB2YXIgaCA9IGltZy5oZWlnaHQ7XG4gICAgXG4gICAgaWYoIHcgPT09IDAgfHwgaCA9PT0gMCApe1xuICAgICAgcmV0dXJuOyAvLyBubyBwb2ludCBpbiBkcmF3aW5nIGVtcHR5IGltYWdlIChhbmQgY2hyb21lIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UpXG4gICAgfVxuXG4gICAgdmFyIGJnVyA9IHN0eWxlWydiYWNrZ3JvdW5kLXdpZHRoJ107XG4gICAgaWYoIGJnVy52YWx1ZSAhPT0gJ2F1dG8nICl7XG4gICAgICBpZiggYmdXLnVuaXRzID09PSAnJScgKXtcbiAgICAgICAgdyA9IGJnVy52YWx1ZS8xMDAgKiBub2RlVztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHcgPSBiZ1cucHhWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYmdIID0gc3R5bGVbJ2JhY2tncm91bmQtaGVpZ2h0J107XG4gICAgaWYoIGJnSC52YWx1ZSAhPT0gJ2F1dG8nICl7XG4gICAgICBpZiggYmdILnVuaXRzID09PSAnJScgKXtcbiAgICAgICAgaCA9IGJnSC52YWx1ZS8xMDAgKiBub2RlSDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSBiZ0gucHhWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiggdyA9PT0gMCB8fCBoID09PSAwICl7XG4gICAgICByZXR1cm47IC8vIG5vIHBvaW50IGluIGRyYXdpbmcgZW1wdHkgaW1hZ2UgKGFuZCBjaHJvbWUgaXMgYnJva2VuIGluIHRoaXMgY2FzZSlcbiAgICB9XG5cbiAgICBpZiggZml0ID09PSAnY29udGFpbicgKXtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWluKCBub2RlVy93LCBub2RlSC9oICk7XG5cbiAgICAgIHcgKj0gc2NhbGU7XG4gICAgICBoICo9IHNjYWxlO1xuXG4gICAgfSBlbHNlIGlmKCBmaXQgPT09ICdjb3ZlcicgKXtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWF4KCBub2RlVy93LCBub2RlSC9oICk7XG5cbiAgICAgIHcgKj0gc2NhbGU7XG4gICAgICBoICo9IHNjYWxlO1xuICAgIH1cblxuICAgIHZhciB4ID0gKG5vZGVYIC0gbm9kZVcvMik7IC8vIGxlZnRcbiAgICBpZiggeFBvcy51bml0cyA9PT0gJyUnICl7XG4gICAgICB4ICs9IChub2RlVyAtIHcpICogeFBvcy52YWx1ZS8xMDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggKz0geFBvcy5weFZhbHVlO1xuICAgIH1cblxuICAgIHZhciB5ID0gKG5vZGVZIC0gbm9kZUgvMik7IC8vIHRvcFxuICAgIGlmKCB5UG9zLnVuaXRzID09PSAnJScgKXtcbiAgICAgIHkgKz0gKG5vZGVIIC0gaCkgKiB5UG9zLnZhbHVlLzEwMDtcbiAgICB9IGVsc2Uge1xuICAgICAgeSArPSB5UG9zLnB4VmFsdWU7XG4gICAgfVxuXG4gICAgaWYoIHJzLnBhdGhDYWNoZSApe1xuICAgICAgeCAtPSBub2RlWDtcbiAgICAgIHkgLT0gbm9kZVk7XG5cbiAgICAgIG5vZGVYID0gMDtcbiAgICAgIG5vZGVZID0gMDtcbiAgICB9XG5cbiAgICB2YXIgZ0FscGhhID0gY29udGV4dC5nbG9iYWxBbHBoYTtcblxuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBpbWdPcGFjaXR5O1xuXG4gICAgaWYoIHJlcGVhdCA9PT0gJ25vLXJlcGVhdCcgKXtcblxuICAgICAgaWYoIHNob3VsZENsaXAgKXtcbiAgICAgICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgaWYoIHJzLnBhdGhDYWNoZSApe1xuICAgICAgICAgIGNvbnRleHQuY2xpcCggcnMucGF0aENhY2hlICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1tyLmdldE5vZGVTaGFwZShub2RlKV0uZHJhd1BhdGgoXG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgbm9kZVgsIG5vZGVZLCBcbiAgICAgICAgICAgIG5vZGVXLCBub2RlSCk7XG5cbiAgICAgICAgICBjb250ZXh0LmNsaXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBjb250ZXh0LmRyYXdJbWFnZSggaW1nLCAwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQsIHgsIHksIHcsIGggKTtcbiAgICAgIHIuc2FmZURyYXdJbWFnZSggY29udGV4dCwgaW1nLCAwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQsIHgsIHksIHcsIGggKTtcblxuICAgICAgaWYoIHNob3VsZENsaXAgKXtcbiAgICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKCBpbWcsIHJlcGVhdCApO1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuXG4gICAgICBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3IuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3UGF0aChcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG5vZGVYLCBub2RlWSwgXG4gICAgICAgICAgbm9kZVcsIG5vZGVIKTtcblxuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC14LCAteSk7XG4gICAgfVxuXG4gICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGdBbHBoYTtcbiAgICBcbiAgfTtcblxuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgLy8gRHJhdyBlZGdlIHRleHRcbiAgQ1JwLmRyYXdFZGdlVGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQsIGVkZ2UpIHtcbiAgICB2YXIgdGV4dCA9IGVkZ2UuX3ByaXZhdGUuc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcblxuICAgIGlmKCAhdGV4dCB8fCB0ZXh0Lm1hdGNoKC9eXFxzKyQvKSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKCB0aGlzLmhpZGVFZGdlc09uVmlld3BvcnQgJiYgKHRoaXMuZHJhZ0RhdGEuZGlkRHJhZyB8fCB0aGlzLnBpbmNoaW5nIHx8IHRoaXMuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHRoaXMuZGF0YS53aGVlbCB8fCB0aGlzLnN3aXBlUGFubmluZykgKXsgcmV0dXJuOyB9IC8vIHNhdmUgY3ljbGVzIG9uIHBpbmNoaW5nXG5cbiAgICB2YXIgY29tcHV0ZWRTaXplID0gZWRnZS5fcHJpdmF0ZS5zdHlsZVsnZm9udC1zaXplJ10ucHhWYWx1ZSAqIGVkZ2UuY3koKS56b29tKCk7XG4gICAgdmFyIG1pblNpemUgPSBlZGdlLl9wcml2YXRlLnN0eWxlWydtaW4tem9vbWVkLWZvbnQtc2l6ZSddLnB4VmFsdWU7XG5cbiAgICBpZiggY29tcHV0ZWRTaXplIDwgbWluU2l6ZSApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0ZXh0IGRyYXcgcG9zaXRpb25cblxuICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBcbiAgICB2YXIgcnMgPSBlZGdlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIGlmKCAhJCQuaXMubnVtYmVyKCBycy5sYWJlbFggKSB8fCAhJCQuaXMubnVtYmVyKCBycy5sYWJlbFkgKSApeyByZXR1cm47IH0gLy8gbm8gcG9zID0+IGxhYmVsIGNhbid0IGJlIHJlbmRlcmVkXG5cbiAgICB2YXIgc3R5bGUgPSBlZGdlLl9wcml2YXRlLnN0eWxlO1xuICAgIHZhciBhdXRvcm90YXRlID0gc3R5bGVbJ2VkZ2UtdGV4dC1yb3RhdGlvbiddLnN0clZhbHVlID09PSAnYXV0b3JvdGF0ZSc7XG4gICAgdmFyIHRoZXRhLCBkeCwgZHk7XG5cbiAgICBpZiggYXV0b3JvdGF0ZSApe1xuICAgICAgc3dpdGNoKCBycy5lZGdlVHlwZSApe1xuICAgICAgICBjYXNlICdoYXlzdGFjayc6XG4gICAgICAgICAgZHggPSBycy5oYXlzdGFja1B0c1syXSAtIHJzLmhheXN0YWNrUHRzWzBdO1xuICAgICAgICAgIGR5ID0gcnMuaGF5c3RhY2tQdHNbM10gLSBycy5oYXlzdGFja1B0c1sxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkeCA9IHJzLmVuZFggLSBycy5zdGFydFg7XG4gICAgICAgICAgZHkgPSBycy5lbmRZIC0gcnMuc3RhcnRZO1xuICAgICAgfVxuXG4gICAgICB0aGV0YSA9IE1hdGguYXRhbiggZHkgLyBkeCApO1xuXG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZShycy5sYWJlbFgsIHJzLmxhYmVsWSk7XG4gICAgICBjb250ZXh0LnJvdGF0ZSh0aGV0YSk7XG5cbiAgICAgIHRoaXMuZHJhd1RleHQoY29udGV4dCwgZWRnZSwgMCwgMCk7XG5cbiAgICAgIGNvbnRleHQucm90YXRlKC10aGV0YSk7XG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSgtcnMubGFiZWxYLCAtcnMubGFiZWxZKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kcmF3VGV4dChjb250ZXh0LCBlZGdlLCBycy5sYWJlbFgsIHJzLmxhYmVsWSk7XG4gICAgfVxuXG4gIH07XG5cbiAgLy8gRHJhdyBub2RlIHRleHRcbiAgQ1JwLmRyYXdOb2RlVGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQsIG5vZGUpIHtcbiAgICB2YXIgdGV4dCA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2NvbnRlbnQnXS5zdHJWYWx1ZTtcblxuICAgIGlmICggIXRleHQgfHwgdGV4dC5tYXRjaCgvXlxccyskLykgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvbXB1dGVkU2l6ZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGVbJ2ZvbnQtc2l6ZSddLnB4VmFsdWUgKiBub2RlLmN5KCkuem9vbSgpO1xuICAgIHZhciBtaW5TaXplID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsnbWluLXpvb21lZC1mb250LXNpemUnXS5weFZhbHVlO1xuXG4gICAgaWYoIGNvbXB1dGVkU2l6ZSA8IG1pblNpemUgKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0aGlzLnJlY2FsY3VsYXRlTm9kZUxhYmVsUHJvamVjdGlvbiggbm9kZSApO1xuXG4gICAgdmFyIHRleHRIYWxpZ24gPSBub2RlLl9wcml2YXRlLnN0eWxlWyd0ZXh0LWhhbGlnbiddLnN0clZhbHVlO1xuICAgIHZhciB0ZXh0VmFsaWduID0gbm9kZS5fcHJpdmF0ZS5zdHlsZVsndGV4dC12YWxpZ24nXS5zdHJWYWx1ZTtcbiAgICB2YXIgcnMgPSBub2RlLl9wcml2YXRlLnJzY3JhdGNoO1xuICAgIGlmKCAhJCQuaXMubnVtYmVyKCBycy5sYWJlbFggKSB8fCAhJCQuaXMubnVtYmVyKCBycy5sYWJlbFkgKSApeyByZXR1cm47IH0gLy8gbm8gcG9zID0+IGxhYmVsIGNhbid0IGJlIHJlbmRlcmVkXG5cbiAgICBzd2l0Y2goIHRleHRIYWxpZ24gKXtcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDogLy8gZS5nLiBjZW50ZXJcbiAgICAgICAgY29udGV4dC50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICBzd2l0Y2goIHRleHRWYWxpZ24gKXtcbiAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDogLy8gZS5nLiBjZW50ZXJcbiAgICAgICAgY29udGV4dC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICB9XG5cbiAgICB0aGlzLmRyYXdUZXh0KGNvbnRleHQsIG5vZGUsIHJzLmxhYmVsWCwgcnMubGFiZWxZKTtcbiAgfTtcblxuICBDUnAuZ2V0Rm9udENhY2hlID0gZnVuY3Rpb24oY29udGV4dCl7XG4gICAgdmFyIGNhY2hlO1xuXG4gICAgdGhpcy5mb250Q2FjaGVzID0gdGhpcy5mb250Q2FjaGVzIHx8IFtdO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmZvbnRDYWNoZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGNhY2hlID0gdGhpcy5mb250Q2FjaGVzW2ldO1xuXG4gICAgICBpZiggY2FjaGUuY29udGV4dCA9PT0gY29udGV4dCApe1xuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2FjaGUgPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgfTtcbiAgICB0aGlzLmZvbnRDYWNoZXMucHVzaChjYWNoZSk7XG5cbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgLy8gc2V0IHVwIGNhbnZhcyBjb250ZXh0IHdpdGggZm9udFxuICAvLyByZXR1cm5zIHRyYW5zZm9ybWVkIHRleHQgc3RyaW5nXG4gIENScC5zZXR1cFRleHRTdHlsZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtZW50ICl7XG4gICAgLy8gRm9udCBzdHlsZVxuICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gZWxlbWVudC5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gICAgdmFyIHN0eWxlID0gZWxlbWVudC5fcHJpdmF0ZS5zdHlsZTtcbiAgICB2YXIgbGFiZWxTdHlsZSA9IHN0eWxlWydmb250LXN0eWxlJ10uc3RyVmFsdWU7XG4gICAgdmFyIGxhYmVsU2l6ZSA9IHN0eWxlWydmb250LXNpemUnXS5weFZhbHVlICsgJ3B4JztcbiAgICB2YXIgbGFiZWxGYW1pbHkgPSBzdHlsZVsnZm9udC1mYW1pbHknXS5zdHJWYWx1ZTtcbiAgICB2YXIgbGFiZWxXZWlnaHQgPSBzdHlsZVsnZm9udC13ZWlnaHQnXS5zdHJWYWx1ZTtcbiAgICB2YXIgb3BhY2l0eSA9IHN0eWxlWyd0ZXh0LW9wYWNpdHknXS52YWx1ZSAqIHN0eWxlWydvcGFjaXR5J10udmFsdWUgKiBwYXJlbnRPcGFjaXR5O1xuICAgIHZhciBvdXRsaW5lT3BhY2l0eSA9IHN0eWxlWyd0ZXh0LW91dGxpbmUtb3BhY2l0eSddLnZhbHVlICogb3BhY2l0eTtcbiAgICB2YXIgY29sb3IgPSBzdHlsZVsnY29sb3InXS52YWx1ZTtcbiAgICB2YXIgb3V0bGluZUNvbG9yID0gc3R5bGVbJ3RleHQtb3V0bGluZS1jb2xvciddLnZhbHVlO1xuICAgIHZhciBzaGFkb3dCbHVyID0gc3R5bGVbJ3RleHQtc2hhZG93LWJsdXInXS5weFZhbHVlO1xuICAgIHZhciBzaGFkb3dPcGFjaXR5ID0gc3R5bGVbJ3RleHQtc2hhZG93LW9wYWNpdHknXS52YWx1ZTtcbiAgICB2YXIgc2hhZG93Q29sb3IgPSBzdHlsZVsndGV4dC1zaGFkb3ctY29sb3InXS52YWx1ZTtcbiAgICB2YXIgc2hhZG93T2Zmc2V0WCA9IHN0eWxlWyd0ZXh0LXNoYWRvdy1vZmZzZXQteCddLnB4VmFsdWU7XG4gICAgdmFyIHNoYWRvd09mZnNldFkgPSBzdHlsZVsndGV4dC1zaGFkb3ctb2Zmc2V0LXknXS5weFZhbHVlO1xuXG4gICAgdmFyIGZvbnRDYWNoZUtleSA9IGVsZW1lbnQuX3ByaXZhdGUuZm9udEtleTtcbiAgICB2YXIgY2FjaGUgPSB0aGlzLmdldEZvbnRDYWNoZShjb250ZXh0KTtcblxuICAgIGlmKCBjYWNoZS5rZXkgIT09IGZvbnRDYWNoZUtleSApe1xuICAgICAgY29udGV4dC5mb250ID0gbGFiZWxTdHlsZSArICcgJyArIGxhYmVsV2VpZ2h0ICsgJyAnICsgbGFiZWxTaXplICsgJyAnICsgbGFiZWxGYW1pbHk7XG5cbiAgICAgIGNhY2hlLmtleSA9IGZvbnRDYWNoZUtleTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KCBlbGVtZW50ICk7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGV4dCBkcmF3IHBvc2l0aW9uIGJhc2VkIG9uIHRleHQgYWxpZ25tZW50XG5cbiAgICAvLyBzbyB0ZXh0IG91dGxpbmVzIGFyZW4ndCBqYWdnZWRcbiAgICBjb250ZXh0LmxpbmVKb2luID0gJ3JvdW5kJztcblxuICAgIHRoaXMuZmlsbFN0eWxlKGNvbnRleHQsIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0sIG9wYWNpdHkpO1xuXG4gICAgdGhpcy5zdHJva2VTdHlsZShjb250ZXh0LCBvdXRsaW5lQ29sb3JbMF0sIG91dGxpbmVDb2xvclsxXSwgb3V0bGluZUNvbG9yWzJdLCBvdXRsaW5lT3BhY2l0eSk7XG5cbiAgICB0aGlzLnNoYWRvd1N0eWxlKGNvbnRleHQsIHNoYWRvd0NvbG9yLCBzaGFkb3dPcGFjaXR5LCBzaGFkb3dCbHVyLCBzaGFkb3dPZmZzZXRYLCBzaGFkb3dPZmZzZXRZKTtcblxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgIHZhciByYWRpdXMgPSByYWRpdXMgfHwgNTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCAtIHJhZGl1cywgeSk7XG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyByYWRpdXMpO1xuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICBjdHgubGluZVRvKHgsIHkgKyByYWRpdXMpO1xuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyByYWRpdXMsIHkpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbCgpO1xuICB9XG5cbiAgLy8gRHJhdyB0ZXh0XG4gIENScC5kcmF3VGV4dCA9IGZ1bmN0aW9uKGNvbnRleHQsIGVsZW1lbnQsIHRleHRYLCB0ZXh0WSkge1xuICAgIHZhciBfcCA9IGVsZW1lbnQuX3ByaXZhdGU7XG4gICAgdmFyIHN0eWxlID0gX3Auc3R5bGU7XG4gICAgdmFyIHJzdHlsZSA9IF9wLnJzdHlsZTtcbiAgICB2YXIgcnNjcmF0Y2ggPSBfcC5yc2NyYXRjaDtcbiAgICB2YXIgcGFyZW50T3BhY2l0eSA9IGVsZW1lbnQuZWZmZWN0aXZlT3BhY2l0eSgpO1xuICAgIGlmKCBwYXJlbnRPcGFjaXR5ID09PSAwIHx8IHN0eWxlWyd0ZXh0LW9wYWNpdHknXS52YWx1ZSA9PT0gMCl7IHJldHVybjsgfVxuXG4gICAgdmFyIHRleHQgPSB0aGlzLnNldHVwVGV4dFN0eWxlKCBjb250ZXh0LCBlbGVtZW50ICk7XG4gICAgdmFyIGhhbGlnbiA9IHN0eWxlWyd0ZXh0LWhhbGlnbiddLnZhbHVlO1xuICAgIHZhciB2YWxpZ24gPSBzdHlsZVsndGV4dC12YWxpZ24nXS52YWx1ZTtcblxuICAgIGlmKCBlbGVtZW50LmlzRWRnZSgpICl7XG4gICAgICBoYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIHZhbGlnbiA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIGlmICggdGV4dCAhPSBudWxsICYmICFpc05hTih0ZXh0WCkgJiYgIWlzTmFOKHRleHRZKSkge1xuICAgICAgdmFyIGJhY2tncm91bmRPcGFjaXR5ID0gc3R5bGVbJ3RleHQtYmFja2dyb3VuZC1vcGFjaXR5J10udmFsdWU7XG4gICAgICB2YXIgYm9yZGVyT3BhY2l0eSA9IHN0eWxlWyd0ZXh0LWJvcmRlci1vcGFjaXR5J10udmFsdWU7XG4gICAgICB2YXIgdGV4dEJvcmRlcldpZHRoID0gc3R5bGVbJ3RleHQtYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcbiAgICAgIFxuICAgICAgaWYoIGJhY2tncm91bmRPcGFjaXR5ID4gMCB8fCAodGV4dEJvcmRlcldpZHRoID4gMCAmJiBib3JkZXJPcGFjaXR5ID4gMCkgKXtcbiAgICAgICAgdmFyIG1hcmdpbiA9IDQgKyB0ZXh0Qm9yZGVyV2lkdGgvMjtcblxuICAgICAgICBpZiAoZWxlbWVudC5pc05vZGUoKSkge1xuICAgICAgICAgIC8vTW92ZSB0ZXh0WCwgdGV4dFkgdG8gaW5jbHVkZSB0aGUgYmFja2dyb3VuZCBtYXJnaW5zXG4gICAgICAgICAgaWYgKHZhbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHRleHRZIC09IG1hcmdpbjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHRleHRZICs9IG1hcmdpbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICB0ZXh0WCAtPSBtYXJnaW47XG4gICAgICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHRleHRYICs9IG1hcmdpbjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYmdXaWR0aCA9IHJzdHlsZS5sYWJlbFdpZHRoO1xuICAgICAgICB2YXIgYmdIZWlnaHQgPSByc3R5bGUubGFiZWxIZWlnaHQ7XG4gICAgICAgIHZhciBiZ1ggPSB0ZXh0WDtcblxuICAgICAgICBpZiAoaGFsaWduKSB7XG4gICAgICAgICAgaWYgKGhhbGlnbiA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgYmdYID0gYmdYIC0gYmdXaWR0aCAvIDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChoYWxpZ24gPT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBiZ1ggPSBiZ1gtIGJnV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJnWSA9IHRleHRZO1xuXG4gICAgICAgIGlmIChlbGVtZW50LmlzTm9kZSgpKSB7XG4gICAgICAgICAgaWYgKHZhbGlnbiA9PSAndG9wJykge1xuICAgICAgICAgICAgIGJnWSA9IGJnWSAtIGJnSGVpZ2h0O1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsaWduID09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICBiZ1kgPSBiZ1ktIGJnSGVpZ2h0IC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmdZID0gYmdZIC0gYmdIZWlnaHQgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0eWxlWydlZGdlLXRleHQtcm90YXRpb24nXS5zdHJWYWx1ZSA9PT0gJ2F1dG9yb3RhdGUnKSB7XG4gICAgICAgICAgdGV4dFkgPSAwO1xuICAgICAgICAgIGJnV2lkdGggKz0gNDtcbiAgICAgICAgICBiZ1ggPSB0ZXh0WCAtIGJnV2lkdGggLyAyO1xuICAgICAgICAgIGJnWSA9IHRleHRZIC0gYmdIZWlnaHQgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFkanVzdCB3aXRoIGJvcmRlciB3aWR0aCAmIG1hcmdpblxuICAgICAgICAgIGJnWCAtPSBtYXJnaW47XG4gICAgICAgICAgYmdZIC09IG1hcmdpbjtcbiAgICAgICAgICBiZ0hlaWdodCArPSBtYXJnaW4qMjtcbiAgICAgICAgICBiZ1dpZHRoICs9IG1hcmdpbioyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGJhY2tncm91bmRPcGFjaXR5ID4gMCApe1xuICAgICAgICAgIHZhciB0ZXh0RmlsbCA9IGNvbnRleHQuZmlsbFN0eWxlO1xuICAgICAgICAgIHZhciB0ZXh0QmFja2dyb3VuZENvbG9yID0gc3R5bGVbJ3RleHQtYmFja2dyb3VuZC1jb2xvciddLnZhbHVlO1xuXG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgdGV4dEJhY2tncm91bmRDb2xvclswXSArICcsJyArIHRleHRCYWNrZ3JvdW5kQ29sb3JbMV0gKyAnLCcgKyB0ZXh0QmFja2dyb3VuZENvbG9yWzJdICsgJywnICsgYmFja2dyb3VuZE9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICAgIHZhciBzdHlsZVNoYXBlID0gc3R5bGVbJ3RleHQtYmFja2dyb3VuZC1zaGFwZSddLnN0clZhbHVlO1xuICAgICAgICAgIGlmIChzdHlsZVNoYXBlID09ICdyb3VuZHJlY3RhbmdsZScpIHtcbiAgICAgICAgICAgIHJvdW5kUmVjdChjb250ZXh0LCBiZ1gsIGJnWSwgYmdXaWR0aCwgYmdIZWlnaHQsIDIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KGJnWCxiZ1ksYmdXaWR0aCxiZ0hlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gdGV4dEZpbGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggdGV4dEJvcmRlcldpZHRoID4gMCAmJiBib3JkZXJPcGFjaXR5ID4gMCApe1xuICAgICAgICAgIHZhciB0ZXh0U3Ryb2tlID0gY29udGV4dC5zdHJva2VTdHlsZTtcbiAgICAgICAgICB2YXIgdGV4dExpbmVXaWR0aCA9IGNvbnRleHQubGluZVdpZHRoO1xuICAgICAgICAgIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBzdHlsZVsndGV4dC1ib3JkZXItY29sb3InXS52YWx1ZTtcbiAgICAgICAgICB2YXIgdGV4dEJvcmRlclN0eWxlID0gc3R5bGVbJ3RleHQtYm9yZGVyLXN0eWxlJ10udmFsdWU7XG5cbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHRleHRCb3JkZXJDb2xvclswXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsxXSArICcsJyArIHRleHRCb3JkZXJDb2xvclsyXSArICcsJyArIGJvcmRlck9wYWNpdHkgKiBwYXJlbnRPcGFjaXR5ICsgJyknO1xuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoO1xuXG4gICAgICAgICAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgICBzd2l0Y2goIHRleHRCb3JkZXJTdHlsZSApe1xuICAgICAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyAxLCAxIF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdkYXNoZWQnOlxuICAgICAgICAgICAgICAgIGNvbnRleHQuc2V0TGluZURhc2goWyA0LCAyIF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdkb3VibGUnOlxuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dEJvcmRlcldpZHRoLzQ7IC8vIDUwJSByZXNlcnZlZCBmb3Igd2hpdGUgYmV0d2VlbiB0aGUgdHdvIGJvcmRlcnNcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ3NvbGlkJzpcbiAgICAgICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCxiZ1ksYmdXaWR0aCxiZ0hlaWdodCk7XG5cbiAgICAgICAgICBpZiggdGV4dEJvcmRlclN0eWxlID09PSAnZG91YmxlJyApe1xuICAgICAgICAgICAgdmFyIHdoaXRlV2lkdGggPSB0ZXh0Qm9yZGVyV2lkdGgvMjtcblxuICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KGJnWCt3aGl0ZVdpZHRoLGJnWSt3aGl0ZVdpZHRoLGJnV2lkdGgtd2hpdGVXaWR0aCoyLGJnSGVpZ2h0LXdoaXRlV2lkdGgqMik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGV4dExpbmVXaWR0aDtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGV4dFN0cm9rZTtcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lV2lkdGggPSAyICAqIHN0eWxlWyd0ZXh0LW91dGxpbmUtd2lkdGgnXS5weFZhbHVlOyAvLyAqMiBiL2MgdGhlIHN0cm9rZSBpcyBkcmF3biBjZW50cmVkIG9uIHRoZSBtaWRkbGVcblxuICAgICAgaWYoIGxpbmVXaWR0aCA+IDAgKXtcbiAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmKCBzdHlsZVsndGV4dC13cmFwJ10udmFsdWUgPT09ICd3cmFwJyApeyAvL2NvbnNvbGUubG9nKCdkcmF3IHdyYXAnKTtcbiAgICAgICAgdmFyIGxpbmVzID0gcnNjcmF0Y2gubGFiZWxXcmFwQ2FjaGVkTGluZXM7XG4gICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gcnN0eWxlLmxhYmVsSGVpZ2h0IC8gbGluZXMubGVuZ3RoO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2xpbmVzJywgbGluZXMpO1xuXG4gICAgICAgIHN3aXRjaCggdmFsaWduICl7XG4gICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAvLyBub3RoaW5nIHJlcXVpcmVkXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHRleHRZIC09IChsaW5lcy5sZW5ndGggLSAxKSAqIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKCB2YXIgbCA9IDA7IGwgPCBsaW5lcy5sZW5ndGg7IGwrKyApe1xuICAgICAgICAgIGlmKCBsaW5lV2lkdGggPiAwICl7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVRleHQoIGxpbmVzW2xdLCB0ZXh0WCwgdGV4dFkgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmZpbGxUZXh0KCBsaW5lc1tsXSwgdGV4dFgsIHRleHRZICk7XG5cbiAgICAgICAgICB0ZXh0WSArPSBsaW5lSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFyIGZvbnRTaXplID0gc3R5bGVbJ2ZvbnQtc2l6ZSddLnB4VmFsdWU7XG4gICAgICAgIC8vIHdyYXBUZXh0KGNvbnRleHQsIHRleHQsIHRleHRYLCB0ZXh0WSwgc3R5bGVbJ3RleHQtbWF4LXdpZHRoJ10ucHhWYWx1ZSwgZm9udFNpemUgKyAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKCBsaW5lV2lkdGggPiAwICl7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KCB0ZXh0LCB0ZXh0WCwgdGV4dFkgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQoIHRleHQsIHRleHRYLCB0ZXh0WSApO1xuICAgICAgfVxuXG5cbiAgICAgIHRoaXMuc2hhZG93U3R5bGUoY29udGV4dCwgJ3RyYW5zcGFyZW50JywgMCk7IC8vIHJlc2V0IGZvciBuZXh0IGd1eVxuICAgIH1cbiAgfTtcblxuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIC8vIERyYXcgbm9kZVxuICBDUnAuZHJhd05vZGUgPSBmdW5jdGlvbihjb250ZXh0LCBub2RlLCBkcmF3T3ZlcmxheUluc3RlYWQpIHtcblxuICAgIHZhciByID0gdGhpcztcbiAgICB2YXIgbm9kZVdpZHRoLCBub2RlSGVpZ2h0O1xuICAgIHZhciBzdHlsZSA9IG5vZGUuX3ByaXZhdGUuc3R5bGU7XG4gICAgdmFyIHJzID0gbm9kZS5fcHJpdmF0ZS5yc2NyYXRjaDtcbiAgICB2YXIgX3AgPSBub2RlLl9wcml2YXRlO1xuICAgIFxuICAgIHZhciB1c2VQYXRocyA9IENhbnZhc1JlbmRlcmVyLnVzZVBhdGhzKCk7XG4gICAgdmFyIGNhbnZhc0NvbnRleHQgPSBjb250ZXh0O1xuICAgIHZhciBwYXRoO1xuICAgIHZhciBwYXRoQ2FjaGVIaXQgPSBmYWxzZTtcblxuICAgIHZhciBvdmVybGF5UGFkZGluZyA9IHN0eWxlWydvdmVybGF5LXBhZGRpbmcnXS5weFZhbHVlO1xuICAgIHZhciBvdmVybGF5T3BhY2l0eSA9IHN0eWxlWydvdmVybGF5LW9wYWNpdHknXS52YWx1ZTtcbiAgICB2YXIgb3ZlcmxheUNvbG9yID0gc3R5bGVbJ292ZXJsYXktY29sb3InXS52YWx1ZTtcblxuICAgIGlmKCBkcmF3T3ZlcmxheUluc3RlYWQgJiYgb3ZlcmxheU9wYWNpdHkgPT09IDAgKXsgLy8gZXhpdCBlYXJseSBpZiBkcmF3aW5nIG92ZXJsYXkgYnV0IG5vbmUgdG8gZHJhd1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRPcGFjaXR5ID0gbm9kZS5lZmZlY3RpdmVPcGFjaXR5KCk7XG4gICAgaWYoIHBhcmVudE9wYWNpdHkgPT09IDAgKXsgcmV0dXJuOyB9XG5cbiAgICBub2RlV2lkdGggPSB0aGlzLmdldE5vZGVXaWR0aChub2RlKTtcbiAgICBub2RlSGVpZ2h0ID0gdGhpcy5nZXROb2RlSGVpZ2h0KG5vZGUpO1xuICAgIFxuICAgIGNvbnRleHQubGluZVdpZHRoID0gc3R5bGVbJ2JvcmRlci13aWR0aCddLnB4VmFsdWU7XG5cbiAgICBpZiggZHJhd092ZXJsYXlJbnN0ZWFkID09PSB1bmRlZmluZWQgfHwgIWRyYXdPdmVybGF5SW5zdGVhZCApe1xuXG4gICAgICB2YXIgdXJsID0gc3R5bGVbJ2JhY2tncm91bmQtaW1hZ2UnXS52YWx1ZVsyXSB8fFxuICAgICAgICBzdHlsZVsnYmFja2dyb3VuZC1pbWFnZSddLnZhbHVlWzFdO1xuICAgICAgdmFyIGltYWdlO1xuXG4gICAgICBpZiAodXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgXG4gICAgICAgIC8vIGdldCBpbWFnZSwgYW5kIGlmIG5vdCBsb2FkZWQgdGhlbiBhc2sgdG8gcmVkcmF3IHdoZW4gbGF0ZXIgbG9hZGVkXG4gICAgICAgIGltYWdlID0gdGhpcy5nZXRDYWNoZWRJbWFnZSh1cmwsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NhbnZhc1JlbmRlcmVyLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ2FudmFzUmVuZGVyZXIuRFJBR10gPSB0cnVlO1xuICAgICAgICAgIFxuICAgICAgICAgIHIuZHJhd2luZ0ltYWdlID0gdHJ1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHZhciBwcmV2QmdpbmcgPSBfcC5iYWNrZ3JvdW5kaW5nO1xuICAgICAgICBfcC5iYWNrZ3JvdW5kaW5nID0gIWltYWdlLmNvbXBsZXRlO1xuXG4gICAgICAgIGlmKCBwcmV2QmdpbmcgIT09IF9wLmJhY2tncm91bmRpbmcgKXsgLy8gdXBkYXRlIHN0eWxlIGIvYyA6YmFja2dyb3VuZGluZyBzdGF0ZSBjaGFuZ2VkXG4gICAgICAgICAgbm9kZS51cGRhdGVTdHlsZSggZmFsc2UgKTtcbiAgICAgICAgfVxuICAgICAgfSBcblxuICAgICAgLy8gTm9kZSBjb2xvciAmIG9wYWNpdHlcblxuICAgICAgdmFyIGJnQ29sb3IgPSBzdHlsZVsnYmFja2dyb3VuZC1jb2xvciddLnZhbHVlO1xuICAgICAgdmFyIGJvcmRlckNvbG9yID0gc3R5bGVbJ2JvcmRlci1jb2xvciddLnZhbHVlO1xuICAgICAgdmFyIGJvcmRlclN0eWxlID0gc3R5bGVbJ2JvcmRlci1zdHlsZSddLnZhbHVlO1xuXG4gICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCBiZ0NvbG9yWzBdLCBiZ0NvbG9yWzFdLCBiZ0NvbG9yWzJdLCBzdHlsZVsnYmFja2dyb3VuZC1vcGFjaXR5J10udmFsdWUgKiBwYXJlbnRPcGFjaXR5KTtcbiAgICAgIFxuICAgICAgdGhpcy5zdHJva2VTdHlsZShjb250ZXh0LCBib3JkZXJDb2xvclswXSwgYm9yZGVyQ29sb3JbMV0sIGJvcmRlckNvbG9yWzJdLCBzdHlsZVsnYm9yZGVyLW9wYWNpdHknXS52YWx1ZSAqIHBhcmVudE9wYWNpdHkpO1xuICAgICAgXG4gICAgICB2YXIgc2hhZG93Qmx1ciA9IHN0eWxlWydzaGFkb3ctYmx1ciddLnB4VmFsdWU7XG4gICAgICB2YXIgc2hhZG93T3BhY2l0eSA9IHN0eWxlWydzaGFkb3ctb3BhY2l0eSddLnZhbHVlO1xuICAgICAgdmFyIHNoYWRvd0NvbG9yID0gc3R5bGVbJ3NoYWRvdy1jb2xvciddLnZhbHVlO1xuICAgICAgdmFyIHNoYWRvd09mZnNldFggPSBzdHlsZVsnc2hhZG93LW9mZnNldC14J10ucHhWYWx1ZTtcbiAgICAgIHZhciBzaGFkb3dPZmZzZXRZID0gc3R5bGVbJ3NoYWRvdy1vZmZzZXQteSddLnB4VmFsdWU7XG5cbiAgICAgIHRoaXMuc2hhZG93U3R5bGUoY29udGV4dCwgc2hhZG93Q29sb3IsIHNoYWRvd09wYWNpdHksIHNoYWRvd0JsdXIsIHNoYWRvd09mZnNldFgsIHNoYWRvd09mZnNldFkpO1xuXG4gICAgICBjb250ZXh0LmxpbmVKb2luID0gJ21pdGVyJzsgLy8gc28gYm9yZGVycyBhcmUgc3F1YXJlIHdpdGggdGhlIG5vZGUgc2hhcGVcblxuICAgICAgaWYoIGNvbnRleHQuc2V0TGluZURhc2ggKXsgLy8gZm9yIHZlcnkgb3V0b2ZkYXRlIGJyb3dzZXJzXG4gICAgICAgIHN3aXRjaCggYm9yZGVyU3R5bGUgKXtcbiAgICAgICAgICBjYXNlICdkb3R0ZWQnOlxuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChbIDEsIDEgXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2Rhc2hlZCc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgNCwgMiBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc29saWQnOlxuICAgICAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBcbiAgICAgIHZhciBzdHlsZVNoYXBlID0gc3R5bGVbJ3NoYXBlJ10uc3RyVmFsdWU7XG5cbiAgICAgIHZhciBwb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgdmFyIHBhdGhDYWNoZUtleSA9IHN0eWxlU2hhcGUgKyAnJCcgKyBub2RlV2lkdGggKyckJyArIG5vZGVIZWlnaHQ7XG5cbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoIHBvcy54LCBwb3MueSApO1xuXG4gICAgICAgIGlmKCBycy5wYXRoQ2FjaGVLZXkgPT09IHBhdGhDYWNoZUtleSApe1xuICAgICAgICAgIHBhdGggPSBjb250ZXh0ID0gcnMucGF0aENhY2hlO1xuICAgICAgICAgIHBhdGhDYWNoZUhpdCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCA9IGNvbnRleHQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICAgICAgcnMucGF0aENhY2hlS2V5ID0gcGF0aENhY2hlS2V5O1xuICAgICAgICAgIHJzLnBhdGhDYWNoZSA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICFwYXRoQ2FjaGVIaXQgKXtcblxuICAgICAgICB2YXIgbnBvcyA9IHBvcztcblxuICAgICAgICBpZiggdXNlUGF0aHMgKXtcbiAgICAgICAgICBucG9zID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1t0aGlzLmdldE5vZGVTaGFwZShub2RlKV0uZHJhd1BhdGgoXG4gICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgIG5wb3MueCxcbiAgICAgICAgICAgICAgbnBvcy55LFxuICAgICAgICAgICAgICBub2RlV2lkdGgsXG4gICAgICAgICAgICAgIG5vZGVIZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0ID0gY2FudmFzQ29udGV4dDtcblxuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIGNvbnRleHQuZmlsbCggcGF0aCApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2hhZG93U3R5bGUoY29udGV4dCwgJ3RyYW5zcGFyZW50JywgMCk7IC8vIHJlc2V0IGZvciBuZXh0IGd1eVxuXG4gICAgICBpZiAodXJsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYoIGltYWdlLmNvbXBsZXRlICl7XG4gICAgICAgICAgdGhpcy5kcmF3SW5zY3JpYmVkSW1hZ2UoY29udGV4dCwgaW1hZ2UsIG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9IFxuICAgICAgXG4gICAgICB2YXIgZGFya25lc3MgPSBzdHlsZVsnYmFja2dyb3VuZC1ibGFja2VuJ10udmFsdWU7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSBzdHlsZVsnYm9yZGVyLXdpZHRoJ10ucHhWYWx1ZTtcblxuICAgICAgaWYoIHRoaXMuaGFzUGllKG5vZGUpICl7XG4gICAgICAgIHRoaXMuZHJhd1BpZSggY29udGV4dCwgbm9kZSwgcGFyZW50T3BhY2l0eSApO1xuXG4gICAgICAgIC8vIHJlZHJhdyBwYXRoIGZvciBibGFja2VuIGFuZCBib3JkZXJcbiAgICAgICAgaWYoIGRhcmtuZXNzICE9PSAwIHx8IGJvcmRlcldpZHRoICE9PSAwICl7XG5cbiAgICAgICAgICBpZiggIXVzZVBhdGhzICl7XG4gICAgICAgICAgICBDYW52YXNSZW5kZXJlci5ub2RlU2hhcGVzW3RoaXMuZ2V0Tm9kZVNoYXBlKG5vZGUpXS5kcmF3UGF0aChcbiAgICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHBvcy54LFxuICAgICAgICAgICAgICAgIHBvcy55LFxuICAgICAgICAgICAgICAgIG5vZGVXaWR0aCxcbiAgICAgICAgICAgICAgICBub2RlSGVpZ2h0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIGRhcmtuZXNzID4gMCApe1xuICAgICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCAwLCAwLCAwLCBkYXJrbmVzcyk7XG5cbiAgICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9IGVsc2UgaWYoIGRhcmtuZXNzIDwgMCApe1xuICAgICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCAyNTUsIDI1NSwgMjU1LCAtZGFya25lc3MpO1xuICAgICAgICBcbiAgICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgICAgY29udGV4dC5maWxsKCBwYXRoICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQm9yZGVyIHdpZHRoLCBkcmF3IGJvcmRlclxuICAgICAgaWYgKGJvcmRlcldpZHRoID4gMCkge1xuXG4gICAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICAgIGNvbnRleHQuc3Ryb2tlKCBwYXRoICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBib3JkZXJTdHlsZSA9PT0gJ2RvdWJsZScgKXtcbiAgICAgICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHN0eWxlWydib3JkZXItd2lkdGgnXS5weFZhbHVlLzM7XG5cbiAgICAgICAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG4gICAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcblxuICAgICAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoIHBhdGggKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGdjbztcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmKCB1c2VQYXRocyApe1xuICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSggLXBvcy54LCAtcG9zLnkgKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVzZXQgaW4gY2FzZSB3ZSBjaGFuZ2VkIHRoZSBib3JkZXIgc3R5bGVcbiAgICAgIGlmKCBjb250ZXh0LnNldExpbmVEYXNoICl7IC8vIGZvciB2ZXJ5IG91dG9mZGF0ZSBicm93c2Vyc1xuICAgICAgICBjb250ZXh0LnNldExpbmVEYXNoKFsgXSk7XG4gICAgICB9XG5cbiAgICAvLyBkcmF3IHRoZSBvdmVybGF5XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYoIG92ZXJsYXlPcGFjaXR5ID4gMCApe1xuICAgICAgICB0aGlzLmZpbGxTdHlsZShjb250ZXh0LCBvdmVybGF5Q29sb3JbMF0sIG92ZXJsYXlDb2xvclsxXSwgb3ZlcmxheUNvbG9yWzJdLCBvdmVybGF5T3BhY2l0eSk7XG5cbiAgICAgICAgQ2FudmFzUmVuZGVyZXIubm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXS5kcmF3UGF0aChcbiAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgIG5vZGUuX3ByaXZhdGUucG9zaXRpb24ueCxcbiAgICAgICAgICBub2RlLl9wcml2YXRlLnBvc2l0aW9uLnksXG4gICAgICAgICAgbm9kZVdpZHRoICsgb3ZlcmxheVBhZGRpbmcgKiAyLFxuICAgICAgICAgIG5vZGVIZWlnaHQgKyBvdmVybGF5UGFkZGluZyAqIDJcbiAgICAgICAgKTtcblxuICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfTtcblxuICAvLyBkb2VzIHRoZSBub2RlIGhhdmUgYXQgbGVhc3Qgb25lIHBpZSBwaWVjZT9cbiAgQ1JwLmhhc1BpZSA9IGZ1bmN0aW9uKG5vZGUpe1xuICAgIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuICAgIFxuICAgIHJldHVybiBub2RlLl9wcml2YXRlLmhhc1BpZTtcbiAgfTtcblxuICBDUnAuZHJhd1BpZSA9IGZ1bmN0aW9uKCBjb250ZXh0LCBub2RlLCBub2RlT3BhY2l0eSApe1xuICAgIG5vZGUgPSBub2RlWzBdOyAvLyBlbnN1cmUgZWxlIHJlZlxuXG4gICAgdmFyIF9wID0gbm9kZS5fcHJpdmF0ZTtcbiAgICB2YXIgc3R5bGUgPSBfcC5zdHlsZTtcbiAgICB2YXIgcGllU2l6ZSA9IHN0eWxlWydwaWUtc2l6ZSddO1xuICAgIHZhciBub2RlVyA9IHRoaXMuZ2V0Tm9kZVdpZHRoKCBub2RlICk7XG4gICAgdmFyIG5vZGVIID0gdGhpcy5nZXROb2RlSGVpZ2h0KCBub2RlICk7XG4gICAgdmFyIHggPSBfcC5wb3NpdGlvbi54O1xuICAgIHZhciB5ID0gX3AucG9zaXRpb24ueTtcbiAgICB2YXIgcmFkaXVzID0gTWF0aC5taW4oIG5vZGVXLCBub2RlSCApIC8gMjsgLy8gbXVzdCBmaXQgaW4gbm9kZVxuICAgIHZhciBsYXN0UGVyY2VudCA9IDA7IC8vIHdoYXQgJSB0byBjb250aW51ZSBkcmF3aW5nIHBpZSBzbGljZXMgZnJvbSBvbiBbMCwgMV1cbiAgICB2YXIgdXNlUGF0aHMgPSBDYW52YXNSZW5kZXJlci51c2VQYXRocygpO1xuXG4gICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICB4ID0gMDtcbiAgICAgIHkgPSAwO1xuICAgIH1cblxuICAgIGlmKCBwaWVTaXplLnVuaXRzID09PSAnJScgKXtcbiAgICAgIHJhZGl1cyA9IHJhZGl1cyAqIHBpZVNpemUudmFsdWUgLyAxMDA7XG4gICAgfSBlbHNlIGlmKCBwaWVTaXplLnB4VmFsdWUgIT09IHVuZGVmaW5lZCApe1xuICAgICAgcmFkaXVzID0gcGllU2l6ZS5weFZhbHVlIC8gMjtcbiAgICB9XG5cbiAgICBmb3IoIHZhciBpID0gMTsgaSA8PSAkJC5zdHlsZS5waWVCYWNrZ3JvdW5kTjsgaSsrICl7IC8vIDEuLk5cbiAgICAgIHZhciBzaXplID0gc3R5bGVbJ3BpZS0nICsgaSArICctYmFja2dyb3VuZC1zaXplJ10udmFsdWU7XG4gICAgICB2YXIgY29sb3IgPSBzdHlsZVsncGllLScgKyBpICsgJy1iYWNrZ3JvdW5kLWNvbG9yJ10udmFsdWU7XG4gICAgICB2YXIgb3BhY2l0eSA9IHN0eWxlWydwaWUtJyArIGkgKyAnLWJhY2tncm91bmQtb3BhY2l0eSddLnZhbHVlICogbm9kZU9wYWNpdHk7XG4gICAgICB2YXIgcGVyY2VudCA9IHNpemUgLyAxMDA7IC8vIG1hcCBpbnRlZ2VyIHJhbmdlIFswLCAxMDBdIHRvIFswLCAxXVxuICAgICAgdmFyIGFuZ2xlU3RhcnQgPSAxLjUgKiBNYXRoLlBJICsgMiAqIE1hdGguUEkgKiBsYXN0UGVyY2VudDsgLy8gc3RhcnQgYXQgMTIgbydjbG9jayBhbmQgZ28gY2xvY2t3aXNlXG4gICAgICB2YXIgYW5nbGVEZWx0YSA9IDIgKiBNYXRoLlBJICogcGVyY2VudDtcbiAgICAgIHZhciBhbmdsZUVuZCA9IGFuZ2xlU3RhcnQgKyBhbmdsZURlbHRhO1xuXG4gICAgICAvLyBpZ25vcmUgaWZcbiAgICAgIC8vIC0gemVybyBzaXplXG4gICAgICAvLyAtIHdlJ3JlIGFscmVhZHkgYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgICAgLy8gLSBhZGRpbmcgdGhlIGN1cnJlbnQgc2xpY2Ugd291bGQgZ28gYmV5b25kIHRoZSBmdWxsIGNpcmNsZVxuICAgICAgaWYoIHNpemUgPT09IDAgfHwgbGFzdFBlcmNlbnQgPj0gMSB8fCBsYXN0UGVyY2VudCArIHBlcmNlbnQgPiAxICl7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICBjb250ZXh0LmFyYyggeCwgeSwgcmFkaXVzLCBhbmdsZVN0YXJ0LCBhbmdsZUVuZCApO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcblxuICAgICAgdGhpcy5maWxsU3R5bGUoY29udGV4dCwgY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSwgb3BhY2l0eSk7XG5cbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgICBsYXN0UGVyY2VudCArPSBwZXJjZW50O1xuICAgIH1cblxuICB9O1xuXG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIENSID0gQ2FudmFzUmVuZGVyZXI7XG4gIHZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgLy8gdmFyIGlzRmlyZWZveCA9IHR5cGVvZiBJbnN0YWxsVHJpZ2dlciAhPT0gJ3VuZGVmaW5lZCc7XG5cbiAgQ1JwLmdldFBpeGVsUmF0aW8gPSBmdW5jdGlvbigpeyBcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuZGF0YS5jb250ZXh0c1swXTtcblxuICAgIGlmKCB0aGlzLmZvcmNlZFBpeGVsUmF0aW8gIT0gbnVsbCApe1xuICAgICAgcmV0dXJuIHRoaXMuZm9yY2VkUGl4ZWxSYXRpbztcbiAgICB9XG5cbiAgICB2YXIgYmFja2luZ1N0b3JlID0gY29udGV4dC5iYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICBjb250ZXh0LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGNvbnRleHQubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgY29udGV4dC5tc0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGNvbnRleHQub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgIGNvbnRleHQuYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgLy9jb25zb2xlLmxvZyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgYmFja2luZ1N0b3JlKTtcblxuICAgIC8vIGlmKCBpc0ZpcmVmb3ggKXsgLy8gYmVjYXVzZSBmZiBjYW4ndCBzY2FsZSBjYW52YXMgcHJvcGVybHlcbiAgICAvLyAgIHJldHVybiAxO1xuICAgIC8vIH1cblxuICAgIHJldHVybiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkgLyBiYWNraW5nU3RvcmU7XG4gIH07XG5cbiAgQ1JwLnBhaW50Q2FjaGUgPSBmdW5jdGlvbihjb250ZXh0KXtcbiAgICB2YXIgY2FjaGVzID0gdGhpcy5wYWludENhY2hlcyA9IHRoaXMucGFpbnRDYWNoZXMgfHwgW107XG4gICAgdmFyIG5lZWRUb0NyZWF0ZUNhY2hlID0gdHJ1ZTtcbiAgICB2YXIgY2FjaGU7XG5cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgY2FjaGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICBjYWNoZSA9IGNhY2hlc1tpXTtcblxuICAgICAgaWYoIGNhY2hlLmNvbnRleHQgPT09IGNvbnRleHQgKXtcbiAgICAgICAgbmVlZFRvQ3JlYXRlQ2FjaGUgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIG5lZWRUb0NyZWF0ZUNhY2hlICl7XG4gICAgICBjYWNoZSA9IHtcbiAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgfTtcbiAgICAgIGNhY2hlcy5wdXNoKCBjYWNoZSApO1xuICAgIH1cblxuICAgIHJldHVybiBjYWNoZTtcbiAgfTtcblxuICBDUnAuZmlsbFN0eWxlID0gZnVuY3Rpb24oY29udGV4dCwgciwgZywgYiwgYSl7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnICsgciArICcsJyArIGcgKyAnLCcgKyBiICsgJywnICsgYSArICcpJztcbiAgICBcbiAgICAvLyB0dXJuIG9mZiBmb3Igbm93LCBzZWVtcyBjb250ZXh0IGRvZXMgaXRzIG93biBjYWNoaW5nXG5cbiAgICAvLyB2YXIgY2FjaGUgPSB0aGlzLnBhaW50Q2FjaGUoY29udGV4dCk7XG5cbiAgICAvLyB2YXIgZmlsbFN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cbiAgICAvLyBpZiggY2FjaGUuZmlsbFN0eWxlICE9PSBmaWxsU3R5bGUgKXtcbiAgICAvLyAgIGNvbnRleHQuZmlsbFN0eWxlID0gY2FjaGUuZmlsbFN0eWxlID0gZmlsbFN0eWxlO1xuICAgIC8vIH1cbiAgfTtcblxuICBDUnAuc3Ryb2tlU3R5bGUgPSBmdW5jdGlvbihjb250ZXh0LCByLCBnLCBiLCBhKXtcbiAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG4gICAgXG4gICAgLy8gdHVybiBvZmYgZm9yIG5vdywgc2VlbXMgY29udGV4dCBkb2VzIGl0cyBvd24gY2FjaGluZ1xuXG4gICAgLy8gdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuXG4gICAgLy8gdmFyIHN0cm9rZVN0eWxlID0gJ3JnYmEoJyArIHIgKyAnLCcgKyBnICsgJywnICsgYiArICcsJyArIGEgKyAnKSc7XG5cbiAgICAvLyBpZiggY2FjaGUuc3Ryb2tlU3R5bGUgIT09IHN0cm9rZVN0eWxlICl7XG4gICAgLy8gICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY2FjaGUuc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAvLyB9XG4gIH07XG4gIFxuICBDUnAuc2hhZG93U3R5bGUgPSBmdW5jdGlvbihjb250ZXh0LCBjb2xvciwgb3BhY2l0eSwgYmx1ciwgb2Zmc2V0WCwgb2Zmc2V0WSl7XG4gICAgdmFyIHpvb20gPSB0aGlzLmRhdGEuY3kuem9vbSgpO1xuXG4gICAgdmFyIGNhY2hlID0gdGhpcy5wYWludENhY2hlKGNvbnRleHQpO1xuICAgIFxuICAgIC8vIGRvbid0IG1ha2UgZXhwZW5zaXZlIGNoYW5nZXMgdG8gdGhlIHNoYWRvdyBzdHlsZSBpZiBpdCdzIG5vdCB1c2VkXG4gICAgaWYoIGNhY2hlLnNoYWRvd09wYWNpdHkgPT09IDAgJiYgb3BhY2l0eSA9PT0gMCApe1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhY2hlLnNoYWRvd09wYWNpdHkgPSBvcGFjaXR5O1xuXG4gICAgaWYgKG9wYWNpdHkgPiAwKSB7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSBibHVyICogem9vbTtcbiAgICAgIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcInJnYmEoXCIgKyBjb2xvclswXSArIFwiLFwiICsgY29sb3JbMV0gKyBcIixcIiArIGNvbG9yWzJdICsgXCIsXCIgKyBvcGFjaXR5ICsgXCIpXCI7XG4gICAgICBjb250ZXh0LnNoYWRvd09mZnNldFggPSBvZmZzZXRYICogem9vbTtcbiAgICAgIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IG9mZnNldFkgKiB6b29tO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuICAgICAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwidHJhbnNwYXJlbnRcIjtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVzaXplIGNhbnZhc1xuICBDUnAubWF0Y2hDYW52YXNTaXplID0gZnVuY3Rpb24oY29udGFpbmVyKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIHdpZHRoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5nZXRQaXhlbFJhdGlvKCk7XG4gICAgdmFyIG1iUHhSYXRpbyA9IHRoaXMubW90aW9uQmx1clB4UmF0aW87XG5cbiAgICBpZihcbiAgICAgIGNvbnRhaW5lciA9PT0gdGhpcy5kYXRhLmJ1ZmZlckNhbnZhc2VzW0NSLk1PVElPTkJMVVJfQlVGRkVSX05PREVdIHx8XG4gICAgICBjb250YWluZXIgPT09IHRoaXMuZGF0YS5idWZmZXJDYW52YXNlc1tDUi5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXVxuICAgICl7XG4gICAgICBwaXhlbFJhdGlvID0gbWJQeFJhdGlvO1xuICAgIH1cblxuICAgIHZhciBjYW52YXNXaWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICB2YXIgY2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcbiAgICB2YXIgY2FudmFzO1xuXG4gICAgaWYoIGNhbnZhc1dpZHRoID09PSB0aGlzLmNhbnZhc1dpZHRoICYmIGNhbnZhc0hlaWdodCA9PT0gdGhpcy5jYW52YXNIZWlnaHQgKXtcbiAgICAgIHJldHVybjsgLy8gc2F2ZSBjeWNsZXMgaWYgc2FtZVxuICAgIH1cblxuICAgIHRoaXMuZm9udENhY2hlcyA9IG51bGw7IC8vIHJlc2l6aW5nIHJlc2V0cyB0aGUgc3R5bGVcblxuICAgIHZhciBjYW52YXNDb250YWluZXIgPSBkYXRhLmNhbnZhc0NvbnRhaW5lcjtcbiAgICBjYW52YXNDb250YWluZXIuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IENhbnZhc1JlbmRlcmVyLkNBTlZBU19MQVlFUlM7IGkrKykge1xuXG4gICAgICBjYW52YXMgPSBkYXRhLmNhbnZhc2VzW2ldO1xuICAgICAgXG4gICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBjYW52YXNXaWR0aCB8fCBjYW52YXMuaGVpZ2h0ICE9PSBjYW52YXNIZWlnaHQpIHtcbiAgICAgICAgXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ2FudmFzUmVuZGVyZXIuQlVGRkVSX0NPVU5UOyBpKyspIHtcbiAgICAgIFxuICAgICAgY2FudmFzID0gZGF0YS5idWZmZXJDYW52YXNlc1tpXTtcbiAgICAgIFxuICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gY2FudmFzV2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gY2FudmFzSGVpZ2h0KSB7XG4gICAgICAgIFxuICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXNXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodDtcblxuICAgICAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudGV4dHVyZU11bHQgPSAxO1xuICAgIGlmKCBwaXhlbFJhdGlvIDw9IDEgKXtcbiAgICAgIGNhbnZhcyA9IGRhdGEuYnVmZmVyQ2FudmFzZXNbIENhbnZhc1JlbmRlcmVyLlRFWFRVUkVfQlVGRkVSIF07XG5cbiAgICAgIHRoaXMudGV4dHVyZU11bHQgPSAyO1xuICAgICAgY2FudmFzLndpZHRoID0gY2FudmFzV2lkdGggKiB0aGlzLnRleHR1cmVNdWx0O1xuICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhc0hlaWdodCAqIHRoaXMudGV4dHVyZU11bHQ7XG4gICAgfVxuXG4gICAgdGhpcy5jYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoO1xuICAgIHRoaXMuY2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0O1xuXG4gIH07XG5cbiAgQ1JwLnJlbmRlclRvID0gZnVuY3Rpb24oIGN4dCwgem9vbSwgcGFuLCBweFJhdGlvICl7XG4gICAgdGhpcy5yZWRyYXcoe1xuICAgICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgICAgZm9yY2VkWm9vbTogem9vbSxcbiAgICAgIGZvcmNlZFBhbjogcGFuLFxuICAgICAgZHJhd0FsbExheWVyczogdHJ1ZSxcbiAgICAgIGZvcmNlZFB4UmF0aW86IHB4UmF0aW9cbiAgICB9KTtcbiAgfTtcblxuICBDUnAudGltZVRvUmVuZGVyID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5yZWRyYXdUb3RhbFRpbWUgLyB0aGlzLnJlZHJhd0NvdW50O1xuICB9O1xuXG4gIENhbnZhc1JlbmRlcmVyLm1pblJlZHJhd0xpbWl0ID0gMTAwMC82MDsgLy8gcGVvcGxlIGNhbid0IHNlZSBtdWNoIGJldHRlciB0aGFuIDYwZnBzXG4gIENhbnZhc1JlbmRlcmVyLm1heFJlZHJhd0xpbWl0ID0gMTAwMDsgIC8vIGRvbid0IGNhcCBtYXggYi9jIGl0J3MgbW9yZSBpbXBvcnRhbnQgdG8gYmUgcmVzcG9uc2l2ZSB0aGFuIHNtb290aFxuICBDYW52YXNSZW5kZXJlci5tb3Rpb25CbHVyRGVsYXkgPSAxMDA7XG5cbiAgLy8gUmVkcmF3IGZyYW1lXG4gIENScC5yZWRyYXcgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdyZWRyYXcoKScpO1xuXG4gICAgdmFyIGZvcmNlZENvbnRleHQgPSBvcHRpb25zLmZvcmNlZENvbnRleHQ7XG4gICAgdmFyIGRyYXdBbGxMYXllcnMgPSBvcHRpb25zLmRyYXdBbGxMYXllcnM7XG4gICAgdmFyIGRyYXdPbmx5Tm9kZUxheWVyID0gb3B0aW9ucy5kcmF3T25seU5vZGVMYXllcjtcbiAgICB2YXIgZm9yY2VkWm9vbSA9IG9wdGlvbnMuZm9yY2VkWm9vbTtcbiAgICB2YXIgZm9yY2VkUGFuID0gb3B0aW9ucy5mb3JjZWRQYW47XG4gICAgdmFyIHIgPSB0aGlzO1xuICAgIHZhciBwaXhlbFJhdGlvID0gb3B0aW9ucy5mb3JjZWRQeFJhdGlvID09PSB1bmRlZmluZWQgPyB0aGlzLmdldFBpeGVsUmF0aW8oKSA6IG9wdGlvbnMuZm9yY2VkUHhSYXRpbztcbiAgICB2YXIgY3kgPSByLmRhdGEuY3k7IHZhciBkYXRhID0gci5kYXRhOyBcbiAgICB2YXIgbmVlZERyYXcgPSBkYXRhLmNhbnZhc05lZWRzUmVkcmF3O1xuICAgIHZhciB0ZXh0dXJlRHJhdyA9IHIudGV4dHVyZU9uVmlld3BvcnQgJiYgIWZvcmNlZENvbnRleHQgJiYgKHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyk7XG4gICAgdmFyIG1vdGlvbkJsdXIgPSBvcHRpb25zLm1vdGlvbkJsdXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubW90aW9uQmx1ciA6IHIubW90aW9uQmx1cjtcbiAgICB2YXIgbWJQeFJhdGlvID0gci5tb3Rpb25CbHVyUHhSYXRpbztcbiAgICB2YXIgaGFzQ29tcG91bmROb2RlcyA9IGN5Lmhhc0NvbXBvdW5kTm9kZXMoKTtcbiAgICB2YXIgaW5Ob2RlRHJhZ0dlc3R1cmUgPSByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXM7XG4gICAgdmFyIGluQm94U2VsZWN0aW9uID0gci5ob3ZlckRhdGEuc2VsZWN0aW5nIHx8IHIudG91Y2hEYXRhLnNlbGVjdGluZyA/IHRydWUgOiBmYWxzZTtcbiAgICBtb3Rpb25CbHVyID0gbW90aW9uQmx1ciAmJiAhZm9yY2VkQ29udGV4dCAmJiByLm1vdGlvbkJsdXJFbmFibGVkICYmICFpbkJveFNlbGVjdGlvbjtcbiAgICB2YXIgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBtb3Rpb25CbHVyO1xuXG4gICAgLy8gY29uc29sZS5sb2coJ3RleHR1cmVEcmF3PycsIHRleHR1cmVEcmF3KTtcblxuXG4gICAgaWYoICFmb3JjZWRDb250ZXh0ICYmIHIubW90aW9uQmx1clRpbWVvdXQgKXtcbiAgICAgIGNsZWFyVGltZW91dCggci5tb3Rpb25CbHVyVGltZW91dCApO1xuICAgIH1cblxuICAgIGlmKCAhZm9yY2VkQ29udGV4dCAmJiB0aGlzLnJlZHJhd1RpbWVvdXQgKXtcbiAgICAgIGNsZWFyVGltZW91dCggdGhpcy5yZWRyYXdUaW1lb3V0ICk7XG4gICAgfVxuICAgIHRoaXMucmVkcmF3VGltZW91dCA9IG51bGw7XG5cbiAgICBpZiggdGhpcy5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkICl7IHRoaXMuYXZlcmFnZVJlZHJhd1RpbWUgPSAwOyB9XG5cbiAgICB2YXIgbWluUmVkcmF3TGltaXQgPSBDYW52YXNSZW5kZXJlci5taW5SZWRyYXdMaW1pdDsgXG4gICAgdmFyIG1heFJlZHJhd0xpbWl0ID0gQ2FudmFzUmVuZGVyZXIubWF4UmVkcmF3TGltaXQ7XG5cbiAgICB2YXIgcmVkcmF3TGltaXQgPSB0aGlzLmF2ZXJhZ2VSZWRyYXdUaW1lOyAvLyBlc3RpbWF0ZSB0aGUgaWRlYWwgcmVkcmF3IGxpbWl0IGJhc2VkIG9uIGhvdyBmYXN0IHdlIGNhbiBkcmF3XG4gICAgcmVkcmF3TGltaXQgPSBtaW5SZWRyYXdMaW1pdCA+IHJlZHJhd0xpbWl0ID8gbWluUmVkcmF3TGltaXQgOiByZWRyYXdMaW1pdDtcbiAgICByZWRyYXdMaW1pdCA9IHJlZHJhd0xpbWl0IDwgbWF4UmVkcmF3TGltaXQgPyByZWRyYXdMaW1pdCA6IG1heFJlZHJhd0xpbWl0O1xuXG4gICAgLy9jb25zb2xlLmxvZygnLS1cXG5pZGVhbDogJWk7IGVmZmVjdGl2ZTogJWknLCB0aGlzLmF2ZXJhZ2VSZWRyYXdUaW1lLCByZWRyYXdMaW1pdCk7XG5cbiAgICBpZiggdGhpcy5sYXN0RHJhd1RpbWUgPT09IHVuZGVmaW5lZCApeyB0aGlzLmxhc3REcmF3VGltZSA9IDA7IH1cblxuICAgIHZhciBub3dUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB2YXIgdGltZUVsYXBzZWQgPSBub3dUaW1lIC0gdGhpcy5sYXN0RHJhd1RpbWU7XG4gICAgdmFyIGNhbGxBZnRlckxpbWl0ID0gdGltZUVsYXBzZWQgPj0gcmVkcmF3TGltaXQ7XG5cbiAgICBpZiggIWZvcmNlZENvbnRleHQgJiYgIXIuY2xlYXJpbmdNb3Rpb25CbHVyICl7XG4gICAgICBpZiggIWNhbGxBZnRlckxpbWl0IHx8IHRoaXMuY3VycmVudGx5RHJhd2luZyApe1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0gc2tpcCcsIHJlZHJhd0xpbWl0KTtcblxuICAgICAgICAvLyB3ZSBoYXZlIG5ldyB0aGluZ3MgdG8gZHJhdyBidXQgd2UncmUgYnVzeSwgc28gdHJ5IGFnYWluIHdoZW4gcG9zc2libHkgZnJlZVxuICAgICAgICB0aGlzLnJlZHJhd1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfSwgcmVkcmF3TGltaXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGFzdERyYXdUaW1lID0gbm93VGltZTtcbiAgICAgIHRoaXMuY3VycmVudGx5RHJhd2luZyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYoIG1vdGlvbkJsdXIgKXtcbiAgICAgIGlmKCByLm1iRnJhbWVzID09IG51bGwgKXtcbiAgICAgICAgci5tYkZyYW1lcyA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmKCAhci5kcmF3aW5nSW1hZ2UgKXsgLy8gaW1hZ2UgbG9hZGluZyBmcmFtZXMgZG9uJ3QgY291bnQgdG93YXJkcyBtb3Rpb24gYmx1ciBibHVycnkgZnJhbWVzXG4gICAgICAgIHIubWJGcmFtZXMrKztcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIHIubWJGcmFtZXMgPCAzICl7IC8vIG5lZWQgc2V2ZXJhbCBmcmFtZXMgYmVmb3JlIGV2ZW4gaGlnaCBxdWFsaXR5IG1vdGlvbmJsdXJcbiAgICAgICAgbW90aW9uQmx1ckZhZGVFZmZlY3QgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gZ28gdG8gbG93ZXIgcXVhbGl0eSBibHVycnkgZnJhbWVzIHdoZW4gc2V2ZXJhbCBtL2IgZnJhbWVzIGhhdmUgYmVlbiByZW5kZXJlZCAoYXZvaWRzIGZsYXNoaW5nKVxuICAgICAgaWYoIHIubWJGcmFtZXMgPiByLm1pbk1iTG93UXVhbEZyYW1lcyApe1xuICAgICAgICAvL3IuZnVsbFF1YWxpdHlNYiA9IGZhbHNlO1xuICAgICAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gci5tYlB4UkJsdXJyeTtcbiAgICAgIH1cbiAgICB9IFxuXG4gICAgLy8gY29uc29sZS5sb2coJ21iOiAlcywgTjogJXMsIHE6ICVzJywgbW90aW9uQmx1ciwgci5tYkZyYW1lcywgci5tb3Rpb25CbHVyUHhSYXRpbyk7XG5cbiAgICBpZiggci5jbGVhcmluZ01vdGlvbkJsdXIgKXtcbiAgICAgIC8vci5mdWxsUXVhbGl0eU1iID0gdHJ1ZTsgLy8gVE9ETyBlbmFibGUgd2hlbiBkb2Vzbid0IGNhdXNlIHNjYWxlZCBmbGFzaGluZyBpc3N1ZVxuXG4gICAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgICB9XG5cblxuICAgIHZhciBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gY29uc29sZS5sb2coJy0tIHJlZHJhdyAtLScpXG4gICAgXG4gICAgZnVuY3Rpb24gZHJhd1RvQ29udGV4dCgpeyBcbiAgICAgIC8vIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAvLyBjb25zb2xlLnByb2ZpbGUoJ2RyYXcnICsgc3RhcnRUaW1lKVxuICAgICAgXG4gICAgICAvLyBiL2MgZHJhd1RvQ29udGV4dCgpIG1heSBiZSBhc3luYyB3LnIudC4gcmVkcmF3KCksIGtlZXAgdHJhY2sgb2YgbGFzdCB0ZXh0dXJlIGZyYW1lXG4gICAgICAvLyBiZWNhdXNlIGEgcm9ndWUgYXN5bmMgdGV4dHVyZSBmcmFtZSB3b3VsZCBjbGVhciBuZWVkRHJhd1xuICAgICAgaWYoIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgJiYgIXRleHR1cmVEcmF3ICl7XG4gICAgICAgIG5lZWREcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgbmVlZERyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBjb25zb2xlLmxvZygnZHJhd1RvQ29udGV4dCgpJyk7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ25lZWREcmF3JywgbmVlZERyYXdbQ1IuTk9ERV0sIG5lZWREcmF3W0NSLkRSQUddLCBuZWVkRHJhd1tDUi5TRUxFQ1RfQk9YXSApO1xuXG4gICAgICB2YXIgZWRnZXMgPSByLmdldENhY2hlZEVkZ2VzKCk7XG4gICAgICB2YXIgY29yZVN0eWxlID0gY3kuc3R5bGUoKS5fcHJpdmF0ZS5jb3JlU3R5bGU7XG4gICAgICBcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIGVmZmVjdGl2ZVpvb20gPSBmb3JjZWRab29tICE9PSB1bmRlZmluZWQgPyBmb3JjZWRab29tIDogem9vbTtcbiAgICAgIHZhciBwYW4gPSBjeS5wYW4oKTtcbiAgICAgIHZhciBlZmZlY3RpdmVQYW4gPSB7XG4gICAgICAgIHg6IHBhbi54LFxuICAgICAgICB5OiBwYW4ueVxuICAgICAgfTtcblxuICAgICAgdmFyIHZwID0ge1xuICAgICAgICB6b29tOiB6b29tLFxuICAgICAgICBwYW46IHtcbiAgICAgICAgICB4OiBwYW4ueCxcbiAgICAgICAgICB5OiBwYW4ueVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIHByZXZWcCA9IHIucHJldlZpZXdwb3J0O1xuICAgICAgdmFyIHZpZXdwb3J0SXNEaWZmID0gcHJldlZwID09PSB1bmRlZmluZWQgfHwgdnAuem9vbSAhPT0gcHJldlZwLnpvb20gfHwgdnAucGFuLnggIT09IHByZXZWcC5wYW4ueCB8fCB2cC5wYW4ueSAhPT0gcHJldlZwLnBhbi55O1xuXG4gICAgICAvLyB3ZSB3YW50IHRoZSBsb3cgcXVhbGl0eSBtb3Rpb25ibHVyIG9ubHkgd2hlbiB0aGUgdmlld3BvcnQgaXMgYmVpbmcgbWFuaXB1bGF0ZWQgZXRjICh3aGVyZSBpdCdzIG5vdCBub3RpY2VkKVxuICAgICAgaWYoICF2aWV3cG9ydElzRGlmZiAmJiAhKGluTm9kZURyYWdHZXN0dXJlICYmICFoYXNDb21wb3VuZE5vZGVzKSApe1xuICAgICAgICByLm1vdGlvbkJsdXJQeFJhdGlvID0gMTtcbiAgICAgIH1cblxuICAgICAgaWYoIGZvcmNlZFBhbiApe1xuICAgICAgICBlZmZlY3RpdmVQYW4gPSBmb3JjZWRQYW47XG4gICAgICB9XG5cbiAgICAgIC8vIGFwcGx5IHBpeGVsIHJhdGlvXG5cbiAgICAgIGVmZmVjdGl2ZVpvb20gKj0gcGl4ZWxSYXRpbztcbiAgICAgIGVmZmVjdGl2ZVBhbi54ICo9IHBpeGVsUmF0aW87XG4gICAgICBlZmZlY3RpdmVQYW4ueSAqPSBwaXhlbFJhdGlvO1xuICAgICAgXG4gICAgICB2YXIgZWxlcyA9IHtcbiAgICAgICAgZHJhZzoge1xuICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICBlZGdlczogW10sXG4gICAgICAgICAgZWxlczogW11cbiAgICAgICAgfSxcbiAgICAgICAgbm9uZHJhZzoge1xuICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICBlZGdlczogW10sXG4gICAgICAgICAgZWxlczogW11cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gbWJjbGVhciggY29udGV4dCwgeCwgeSwgdywgaCApe1xuICAgICAgICB2YXIgZ2NvID0gY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb247XG5cbiAgICAgICAgY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3V0JztcbiAgICAgICAgci5maWxsU3R5bGUoIGNvbnRleHQsIDI1NSwgMjU1LCAyNTUsIHIubW90aW9uQmx1clRyYW5zcGFyZW5jeSApO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuXG4gICAgICAgIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gZ2NvO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzZXRDb250ZXh0VHJhbnNmb3JtKGNvbnRleHQsIGNsZWFyKXtcbiAgICAgICAgdmFyIGVQYW4sIGVab29tLCB3LCBoO1xuXG4gICAgICAgIGlmKCAvKiFyLmZ1bGxRdWFsaXR5TWIgJiYqLyAhci5jbGVhcmluZ01vdGlvbkJsdXIgJiYgKGNvbnRleHQgPT09IGRhdGEuYnVmZmVyQ29udGV4dHNbQ1IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERV0gfHwgY29udGV4dCA9PT0gZGF0YS5idWZmZXJDb250ZXh0c1tDUi5NT1RJT05CTFVSX0JVRkZFUl9EUkFHXSkgKXtcbiAgICAgICAgICBlUGFuID0ge1xuICAgICAgICAgICAgeDogcGFuLnggKiBtYlB4UmF0aW8sXG4gICAgICAgICAgICB5OiBwYW4ueSAqIG1iUHhSYXRpb1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBlWm9vbSA9IHpvb20gKiBtYlB4UmF0aW87XG5cbiAgICAgICAgICB3ID0gci5jYW52YXNXaWR0aCAqIG1iUHhSYXRpbztcbiAgICAgICAgICBoID0gci5jYW52YXNIZWlnaHQgKiBtYlB4UmF0aW87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZVBhbiA9IGVmZmVjdGl2ZVBhbjtcbiAgICAgICAgICBlWm9vbSA9IGVmZmVjdGl2ZVpvb207XG5cbiAgICAgICAgICB3ID0gci5jYW52YXNXaWR0aDtcbiAgICAgICAgICBoID0gci5jYW52YXNIZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgICAgICBpZiggY2xlYXIgPT09ICdtb3Rpb25CbHVyJyApeyBcbiAgICAgICAgICBtYmNsZWFyKGNvbnRleHQsIDAsIDAsIHcsIGgpO1xuICAgICAgICB9IGVsc2UgaWYoICFmb3JjZWRDb250ZXh0ICYmIChjbGVhciA9PT0gdW5kZWZpbmVkIHx8IGNsZWFyKSApe1xuICAgICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiggIWRyYXdBbGxMYXllcnMgKXtcbiAgICAgICAgICBjb250ZXh0LnRyYW5zbGF0ZSggZVBhbi54LCBlUGFuLnkgKTtcbiAgICAgICAgICBjb250ZXh0LnNjYWxlKCBlWm9vbSwgZVpvb20gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiggZm9yY2VkUGFuICl7XG4gICAgICAgICAgY29udGV4dC50cmFuc2xhdGUoIGZvcmNlZFBhbi54LCBmb3JjZWRQYW4ueSApO1xuICAgICAgICB9IFxuICAgICAgICBpZiggZm9yY2VkWm9vbSApe1xuICAgICAgICAgIGNvbnRleHQuc2NhbGUoIGZvcmNlZFpvb20sIGZvcmNlZFpvb20gKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggIXRleHR1cmVEcmF3ICl7XG4gICAgICAgIHIudGV4dHVyZURyYXdMYXN0RnJhbWUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYoIHRleHR1cmVEcmF3ICl7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0ZXh0dXJlRHJhdycpXG4gICAgICAgIFxuICAgICAgICByLnRleHR1cmVEcmF3TGFzdEZyYW1lID0gdHJ1ZTtcblxuICAgICAgICB2YXIgYmI7XG5cbiAgICAgICAgaWYoICFyLnRleHR1cmVDYWNoZSApe1xuICAgICAgICAgIHIudGV4dHVyZUNhY2hlID0ge307XG5cbiAgICAgICAgICBiYiA9IHIudGV4dHVyZUNhY2hlLmJiID0gY3kuZWxlbWVudHMoKS5ib3VuZGluZ0JveCgpO1xuXG4gICAgICAgICAgci50ZXh0dXJlQ2FjaGUudGV4dHVyZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1sgQ2FudmFzUmVuZGVyZXIuVEVYVFVSRV9CVUZGRVIgXTtcblxuICAgICAgICAgIHZhciBjeHQgPSByLmRhdGEuYnVmZmVyQ29udGV4dHNbIENhbnZhc1JlbmRlcmVyLlRFWFRVUkVfQlVGRkVSIF07XG5cbiAgICAgICAgICBjeHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgIGN4dC5jbGVhclJlY3QoMCwgMCwgci5jYW52YXNXaWR0aCAqIHIudGV4dHVyZU11bHQsIHIuY2FudmFzSGVpZ2h0ICogci50ZXh0dXJlTXVsdCk7XG4gICAgICAgICAgXG4gICAgICAgICAgci5yZWRyYXcoe1xuICAgICAgICAgICAgZm9yY2VkQ29udGV4dDogY3h0LFxuICAgICAgICAgICAgZHJhd09ubHlOb2RlTGF5ZXI6IHRydWUsXG4gICAgICAgICAgICBmb3JjZWRQeFJhdGlvOiBwaXhlbFJhdGlvICogci50ZXh0dXJlTXVsdFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIHZwID0gci50ZXh0dXJlQ2FjaGUudmlld3BvcnQgPSB7XG4gICAgICAgICAgICB6b29tOiBjeS56b29tKCksXG4gICAgICAgICAgICBwYW46IGN5LnBhbigpLFxuICAgICAgICAgICAgd2lkdGg6IHIuY2FudmFzV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHIuY2FudmFzSGVpZ2h0XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZwLm1wYW4gPSB7XG4gICAgICAgICAgICB4OiAoMCAtIHZwLnBhbi54KS92cC56b29tLFxuICAgICAgICAgICAgeTogKDAgLSB2cC5wYW4ueSkvdnAuem9vbVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBuZWVkRHJhd1tDUi5EUkFHXSA9IGZhbHNlO1xuICAgICAgICBuZWVkRHJhd1tDUi5OT0RFXSA9IGZhbHNlO1xuXG4gICAgICAgIHZhciBjb250ZXh0ID0gZGF0YS5jb250ZXh0c1tDUi5OT0RFXTtcblxuICAgICAgICB2YXIgdGV4dHVyZSA9IHIudGV4dHVyZUNhY2hlLnRleHR1cmU7XG4gICAgICAgIHZhciB2cCA9IHIudGV4dHVyZUNhY2hlLnZpZXdwb3J0O1xuICAgICAgICBiYiA9IHIudGV4dHVyZUNhY2hlLmJiO1xuXG4gICAgICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICAgIGlmKCBtb3Rpb25CbHVyICl7XG4gICAgICAgICAgbWJjbGVhcihjb250ZXh0LCAwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvdXRzaWRlQmdDb2xvciA9IGNvcmVTdHlsZVsnb3V0c2lkZS10ZXh0dXJlLWJnLWNvbG9yJ10udmFsdWU7XG4gICAgICAgIHZhciBvdXRzaWRlQmdPcGFjaXR5ID0gY29yZVN0eWxlWydvdXRzaWRlLXRleHR1cmUtYmctb3BhY2l0eSddLnZhbHVlO1xuICAgICAgICByLmZpbGxTdHlsZSggY29udGV4dCwgb3V0c2lkZUJnQ29sb3JbMF0sIG91dHNpZGVCZ0NvbG9yWzFdLCBvdXRzaWRlQmdDb2xvclsyXSwgb3V0c2lkZUJnT3BhY2l0eSApO1xuICAgICAgICBjb250ZXh0LmZpbGxSZWN0KCAwLCAwLCB2cC53aWR0aCwgdnAuaGVpZ2h0ICk7XG5cbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICAgIFxuICAgICAgICBzZXRDb250ZXh0VHJhbnNmb3JtKCBjb250ZXh0LCBmYWxzZSApO1xuXG4gICAgICAgIGNvbnRleHQuY2xlYXJSZWN0KCB2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGgvdnAuem9vbS9waXhlbFJhdGlvLCB2cC5oZWlnaHQvdnAuem9vbS9waXhlbFJhdGlvICk7XG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKCB0ZXh0dXJlLCB2cC5tcGFuLngsIHZwLm1wYW4ueSwgdnAud2lkdGgvdnAuem9vbS9waXhlbFJhdGlvLCB2cC5oZWlnaHQvdnAuem9vbS9waXhlbFJhdGlvICk7XG5cbiAgICAgIH0gZWxzZSBpZiggci50ZXh0dXJlT25WaWV3cG9ydCAmJiAhZm9yY2VkQ29udGV4dCApeyAvLyBjbGVhciB0aGUgY2FjaGUgc2luY2Ugd2UgZG9uJ3QgbmVlZCBpdFxuICAgICAgICByLnRleHR1cmVDYWNoZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB2cE1hbmlwID0gKHIucGluY2hpbmcgfHwgci5ob3ZlckRhdGEuZHJhZ2dpbmcgfHwgci5zd2lwZVBhbm5pbmcgfHwgci5kYXRhLndoZWVsWm9vbWluZyB8fCByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMpO1xuICAgICAgdmFyIGhpZGVFZGdlcyA9IHIuaGlkZUVkZ2VzT25WaWV3cG9ydCAmJiB2cE1hbmlwO1xuICAgICAgdmFyIGhpZGVMYWJlbHMgPSByLmhpZGVMYWJlbHNPblZpZXdwb3J0ICYmIHZwTWFuaXA7XG5cbiAgICAgIGlmIChuZWVkRHJhd1tDUi5EUkFHXSB8fCBuZWVkRHJhd1tDUi5OT0RFXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IGRyYXdPbmx5Tm9kZUxheWVyKSB7XG4gICAgICAgIC8vTkIgOiBWRVJZIEVYUEVOU0lWRVxuXG4gICAgICAgIGlmKCBoaWRlRWRnZXMgKXsgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgci5maW5kRWRnZUNvbnRyb2xQb2ludHMoZWRnZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHpFbGVzID0gci5nZXRDYWNoZWRaU29ydGVkRWxlcygpO1xuICAgICAgICB2YXIgZXh0ZW50ID0gY3kuZXh0ZW50KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB6RWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbGUgPSB6RWxlc1tpXTtcbiAgICAgICAgICB2YXIgbGlzdDtcbiAgICAgICAgICB2YXIgYmIgPSBmb3JjZWRDb250ZXh0ID8gbnVsbCA6IGVsZS5ib3VuZGluZ0JveCgpO1xuICAgICAgICAgIHZhciBpbnNpZGVFeHRlbnQgPSBmb3JjZWRDb250ZXh0ID8gdHJ1ZSA6ICQkLm1hdGguYm91bmRpbmdCb3hlc0ludGVyc2VjdCggZXh0ZW50LCBiYiApO1xuXG4gICAgICAgICAgaWYoICFpbnNpZGVFeHRlbnQgKXsgY29udGludWU7IH0gLy8gbm8gbmVlZCB0byByZW5kZXJcblxuICAgICAgICAgIGlmICggZWxlLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyICkge1xuICAgICAgICAgICAgbGlzdCA9IGVsZXMuZHJhZztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdCA9IGVsZXMubm9uZHJhZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0LmVsZXMucHVzaCggZWxlICk7XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgXG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGRyYXdFbGVtZW50cyggbGlzdCwgY29udGV4dCApe1xuICAgICAgICB2YXIgZWxlcyA9IGxpc3QuZWxlcztcblxuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tpXTtcblxuICAgICAgICAgIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgICAgIHIuZHJhd05vZGUoY29udGV4dCwgZWxlKTtcblxuICAgICAgICAgICAgaWYoICFoaWRlTGFiZWxzICl7XG4gICAgICAgICAgICAgIHIuZHJhd05vZGVUZXh0KGNvbnRleHQsIGVsZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHIuZHJhd05vZGUoY29udGV4dCwgZWxlLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYoICFoaWRlRWRnZXMgKSB7XG4gICAgICAgICAgICByLmRyYXdFZGdlKGNvbnRleHQsIGVsZSk7XG5cbiAgICAgICAgICAgIGlmKCAhaGlkZUxhYmVscyApe1xuICAgICAgICAgICAgICByLmRyYXdFZGdlVGV4dChjb250ZXh0LCBlbGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmRyYXdFZGdlKGNvbnRleHQsIGVsZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdmFyIG5lZWRNYkNsZWFyID0gW107XG5cbiAgICAgIG5lZWRNYkNsZWFyW0NSLk5PREVdID0gIW5lZWREcmF3W0NSLk5PREVdICYmIG1vdGlvbkJsdXIgJiYgIXIuY2xlYXJlZEZvck1vdGlvbkJsdXJbQ1IuTk9ERV0gfHwgci5jbGVhcmluZ01vdGlvbkJsdXI7XG4gICAgICBpZiggbmVlZE1iQ2xlYXJbQ1IuTk9ERV0gKXsgci5jbGVhcmVkRm9yTW90aW9uQmx1cltDUi5OT0RFXSA9IHRydWU7IH1cblxuICAgICAgbmVlZE1iQ2xlYXJbQ1IuRFJBR10gPSAhbmVlZERyYXdbQ1IuRFJBR10gJiYgbW90aW9uQmx1ciAmJiAhci5jbGVhcmVkRm9yTW90aW9uQmx1cltDUi5EUkFHXSB8fCByLmNsZWFyaW5nTW90aW9uQmx1cjtcbiAgICAgIGlmKCBuZWVkTWJDbGVhcltDUi5EUkFHXSApeyByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW0NSLkRSQUddID0gdHJ1ZTsgfVxuXG4gICAgICAvLyBjb25zb2xlLmxvZygnLS0nKTtcblxuICAgICAgLy8gaWYoIG5lZWREcmF3W0NSLkRSQUddICYmIG1vdGlvbkJsdXIgJiYgbmVlZERyYXdbQ1IuTk9ERV0gJiYgaW5Ob2RlRHJhZ0dlc3R1cmUgKXtcbiAgICAgIC8vICAgY29uc29sZS5sb2coJ05PREUgYmx1cmNsZWFuJyk7XG4gICAgICAvLyBcbiAgICAgIC8vICAgdmFyIGNvbnRleHQgPSBkYXRhLmNvbnRleHRzW0NSLk5PREVdO1xuICAgICAgLy8gXG4gICAgICAvLyAgIHNldENvbnRleHRUcmFuc2Zvcm0oIGNvbnRleHQsIHRydWUgKTtcbiAgICAgIC8vICAgZHJhd0VsZW1lbnRzKGVsZXMubm9uZHJhZywgY29udGV4dCk7XG4gICAgICAvLyBcbiAgICAgIC8vICAgbmVlZERyYXdbQ1IuTk9ERV0gPSBmYWxzZTsgXG4gICAgICAvLyAgIG5lZWRNYkNsZWFyW0NSLk5PREVdID0gZmFsc2U7XG4gICAgICAvLyBcbiAgICAgIC8vIH0gZWxzZSBcbiAgICAgIGlmKCBuZWVkRHJhd1tDUi5OT0RFXSB8fCBkcmF3QWxsTGF5ZXJzIHx8IGRyYXdPbmx5Tm9kZUxheWVyIHx8IG5lZWRNYkNsZWFyW0NSLk5PREVdICl7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdOT0RFJywgbmVlZERyYXdbQ1IuTk9ERV0sIG5lZWRNYkNsZWFyW0NSLk5PREVdKTtcblxuICAgICAgICB2YXIgdXNlQnVmZmVyID0gbW90aW9uQmx1ciAmJiAhbmVlZE1iQ2xlYXJbQ1IuTk9ERV0gJiYgbWJQeFJhdGlvICE9PSAxO1xuICAgICAgICB2YXIgY29udGV4dCA9IGZvcmNlZENvbnRleHQgfHwgKCB1c2VCdWZmZXIgPyByLmRhdGEuYnVmZmVyQ29udGV4dHNbIENSLk1PVElPTkJMVVJfQlVGRkVSX05PREUgXSA6IGRhdGEuY29udGV4dHNbQ1IuTk9ERV0gKTtcbiAgICAgICAgdmFyIGNsZWFyID0gbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIGlmKCBuZWVkRHJhd1tDUi5EUkFHXSAmJiBuZWVkRHJhd1tDUi5OT0RFXSApe1xuICAgICAgICAvLyAgIGNsZWFyID0gdHJ1ZTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHNldENvbnRleHRUcmFuc2Zvcm0oIGNvbnRleHQsIGNsZWFyICk7XG4gICAgICAgIGRyYXdFbGVtZW50cyhlbGVzLm5vbmRyYWcsIGNvbnRleHQpO1xuICAgICAgICBcbiAgICAgICAgaWYoICFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyICl7XG4gICAgICAgICAgbmVlZERyYXdbQ1IuTk9ERV0gPSBmYWxzZTsgXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCAhZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3W0NSLkRSQUddIHx8IGRyYXdBbGxMYXllcnMgfHwgbmVlZE1iQ2xlYXJbQ1IuRFJBR10pICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnRFJBRycpO1xuXG4gICAgICAgIHZhciB1c2VCdWZmZXIgPSBtb3Rpb25CbHVyICYmICFuZWVkTWJDbGVhcltDUi5EUkFHXSAmJiBtYlB4UmF0aW8gIT09IDE7XG4gICAgICAgIHZhciBjb250ZXh0ID0gZm9yY2VkQ29udGV4dCB8fCAoIHVzZUJ1ZmZlciA/IHIuZGF0YS5idWZmZXJDb250ZXh0c1sgQ1IuTU9USU9OQkxVUl9CVUZGRVJfRFJBRyBdIDogZGF0YS5jb250ZXh0c1tDUi5EUkFHXSApO1xuICAgICAgICBcbiAgICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCwgbW90aW9uQmx1ciAmJiAhdXNlQnVmZmVyID8gJ21vdGlvbkJsdXInIDogdW5kZWZpbmVkICk7XG4gICAgICAgIGRyYXdFbGVtZW50cyhlbGVzLmRyYWcsIGNvbnRleHQpO1xuICAgICAgICBcbiAgICAgICAgaWYoICFkcmF3QWxsTGF5ZXJzICYmICFtb3Rpb25CbHVyICl7XG4gICAgICAgICAgbmVlZERyYXdbQ1IuRFJBR10gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggci5zaG93RnBzIHx8ICghZHJhd09ubHlOb2RlTGF5ZXIgJiYgKG5lZWREcmF3W0NSLlNFTEVDVF9CT1hdICYmICFkcmF3QWxsTGF5ZXJzKSkgKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZWRyYXdpbmcgc2VsZWN0aW9uIGJveCcpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGNvbnRleHQgPSBmb3JjZWRDb250ZXh0IHx8IGRhdGEuY29udGV4dHNbQ1IuU0VMRUNUX0JPWF07XG5cbiAgICAgICAgc2V0Q29udGV4dFRyYW5zZm9ybSggY29udGV4dCApO1xuXG4gICAgICAgIGlmKCBkYXRhLnNlbGVjdFs0XSA9PSAxICYmICggci5ob3ZlckRhdGEuc2VsZWN0aW5nIHx8IHIudG91Y2hEYXRhLnNlbGVjdGluZyApICl7XG4gICAgICAgICAgdmFyIHpvb20gPSBkYXRhLmN5Lnpvb20oKTtcbiAgICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLXdpZHRoJ10udmFsdWUgLyB6b29tO1xuICAgICAgICAgIFxuICAgICAgICAgIGNvbnRleHQubGluZVdpZHRoID0gYm9yZGVyV2lkdGg7XG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoXCIgXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1jb2xvciddLnZhbHVlWzBdICsgXCIsXCJcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWNvbG9yJ10udmFsdWVbMV0gKyBcIixcIlxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtY29sb3InXS52YWx1ZVsyXSArIFwiLFwiXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1vcGFjaXR5J10udmFsdWUgKyBcIilcIjtcbiAgICAgICAgICBcbiAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KFxuICAgICAgICAgICAgZGF0YS5zZWxlY3RbMF0sXG4gICAgICAgICAgICBkYXRhLnNlbGVjdFsxXSxcbiAgICAgICAgICAgIGRhdGEuc2VsZWN0WzJdIC0gZGF0YS5zZWxlY3RbMF0sXG4gICAgICAgICAgICBkYXRhLnNlbGVjdFszXSAtIGRhdGEuc2VsZWN0WzFdKTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiAoYm9yZGVyV2lkdGggPiAwKSB7XG4gICAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gXCJyZ2JhKFwiIFxuICAgICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1ib3JkZXItY29sb3InXS52YWx1ZVswXSArIFwiLFwiXG4gICAgICAgICAgICAgICsgY29yZVN0eWxlWydzZWxlY3Rpb24tYm94LWJvcmRlci1jb2xvciddLnZhbHVlWzFdICsgXCIsXCJcbiAgICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ3NlbGVjdGlvbi1ib3gtYm9yZGVyLWNvbG9yJ10udmFsdWVbMl0gKyBcIixcIlxuICAgICAgICAgICAgICArIGNvcmVTdHlsZVsnc2VsZWN0aW9uLWJveC1vcGFjaXR5J10udmFsdWUgKyBcIilcIjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KFxuICAgICAgICAgICAgICBkYXRhLnNlbGVjdFswXSxcbiAgICAgICAgICAgICAgZGF0YS5zZWxlY3RbMV0sXG4gICAgICAgICAgICAgIGRhdGEuc2VsZWN0WzJdIC0gZGF0YS5zZWxlY3RbMF0sXG4gICAgICAgICAgICAgIGRhdGEuc2VsZWN0WzNdIC0gZGF0YS5zZWxlY3RbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBkYXRhLmJnQWN0aXZlUG9zaXN0aW9uICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmcgKXtcbiAgICAgICAgICB2YXIgem9vbSA9IGRhdGEuY3kuem9vbSgpO1xuICAgICAgICAgIHZhciBwb3MgPSBkYXRhLmJnQWN0aXZlUG9zaXN0aW9uO1xuXG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBcInJnYmEoXCIgXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnYWN0aXZlLWJnLWNvbG9yJ10udmFsdWVbMF0gKyBcIixcIlxuICAgICAgICAgICAgKyBjb3JlU3R5bGVbJ2FjdGl2ZS1iZy1jb2xvciddLnZhbHVlWzFdICsgXCIsXCJcbiAgICAgICAgICAgICsgY29yZVN0eWxlWydhY3RpdmUtYmctY29sb3InXS52YWx1ZVsyXSArIFwiLFwiXG4gICAgICAgICAgICArIGNvcmVTdHlsZVsnYWN0aXZlLWJnLW9wYWNpdHknXS52YWx1ZSArIFwiKVwiO1xuXG4gICAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjb250ZXh0LmFyYyhwb3MueCwgcG9zLnksIGNvcmVTdHlsZVsnYWN0aXZlLWJnLXNpemUnXS5weFZhbHVlIC8gem9vbSwgMCwgMiAqIE1hdGguUEkpOyBcbiAgICAgICAgICBjb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHRpbWVUb1JlbmRlciA9IHIuYXZlcmFnZVJlZHJhd1RpbWU7XG4gICAgICAgIGlmKCByLnNob3dGcHMgJiYgdGltZVRvUmVuZGVyICl7XG4gICAgICAgICAgdGltZVRvUmVuZGVyID0gTWF0aC5yb3VuZCggdGltZVRvUmVuZGVyICk7XG4gICAgICAgICAgdmFyIGZwcyA9IE1hdGgucm91bmQoMTAwMC90aW1lVG9SZW5kZXIpO1xuXG4gICAgICAgICAgY29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgICAgICAvL2NvbnRleHQuZm9udCA9ICcyMHB4IGhlbHZldGljYSc7XG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgyNTUsIDAsIDAsIDAuNzUpJztcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gJ3JnYmEoMjU1LCAwLCAwLCAwLjc1KSc7XG4gICAgICAgICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoICcxIGZyYW1lID0gJyArIHRpbWVUb1JlbmRlciArICcgbXMgPSAnICsgZnBzICsgJyBmcHMnLCAwLCAyMCk7XG5cbiAgICAgICAgICB2YXIgbWF4RnBzID0gNjA7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VSZWN0KDAsIDMwLCAyNTAsIDIwKTtcbiAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KDAsIDMwLCAyNTAgKiBNYXRoLm1pbihmcHMvbWF4RnBzLCAxKSwgMjApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoICFkcmF3QWxsTGF5ZXJzICl7XG4gICAgICAgICAgbmVlZERyYXdbQ1IuU0VMRUNUX0JPWF0gPSBmYWxzZTsgXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbW90aW9uYmx1cjogYmxpdCByZW5kZXJlZCBibHVycnkgZnJhbWVzXG4gICAgICBpZiggbW90aW9uQmx1ciAmJiBtYlB4UmF0aW8gIT09IDEgKXtcbiAgICAgICAgdmFyIGN4dE5vZGUgPSBkYXRhLmNvbnRleHRzW0NSLk5PREVdO1xuICAgICAgICB2YXIgdHh0Tm9kZSA9IHIuZGF0YS5idWZmZXJDYW52YXNlc1sgQ1IuTU9USU9OQkxVUl9CVUZGRVJfTk9ERSBdO1xuXG4gICAgICAgIHZhciBjeHREcmFnID0gZGF0YS5jb250ZXh0c1tDUi5EUkFHXTtcbiAgICAgICAgdmFyIHR4dERyYWcgPSByLmRhdGEuYnVmZmVyQ2FudmFzZXNbIENSLk1PVElPTkJMVVJfQlVGRkVSX0RSQUcgXTtcblxuICAgICAgICB2YXIgZHJhd01vdGlvbkJsdXIgPSBmdW5jdGlvbiggY3h0LCB0eHQsIG5lZWRDbGVhciApe1xuICAgICAgICAgIGN4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cbiAgICAgICAgICBpZiggbmVlZENsZWFyIHx8ICFtb3Rpb25CbHVyRmFkZUVmZmVjdCApe1xuICAgICAgICAgICAgY3h0LmNsZWFyUmVjdCggMCwgMCwgci5jYW52YXNXaWR0aCwgci5jYW52YXNIZWlnaHQgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWJjbGVhciggY3h0LCAwLCAwLCByLmNhbnZhc1dpZHRoLCByLmNhbnZhc0hlaWdodCApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgcHhyID0gLypyLmZ1bGxRdWFsaXR5TWIgPyAxIDoqLyBtYlB4UmF0aW87XG5cbiAgICAgICAgICBjeHQuZHJhd0ltYWdlKCBcbiAgICAgICAgICAgIHR4dCwgLy8gaW1nXG4gICAgICAgICAgICAwLCAwLCAvLyBzeCwgc3lcbiAgICAgICAgICAgIHIuY2FudmFzV2lkdGggKiBweHIsIHIuY2FudmFzSGVpZ2h0ICogcHhyLCAvLyBzdywgc2hcbiAgICAgICAgICAgIDAsIDAsIC8vIHgsIHlcbiAgICAgICAgICAgIHIuY2FudmFzV2lkdGgsIHIuY2FudmFzSGVpZ2h0IC8vIHcsIGhcbiAgICAgICAgICApO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmKCBuZWVkRHJhd1tDUi5OT0RFXSB8fCBuZWVkTWJDbGVhcltDUi5OT0RFXSApe1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtYiBOT0RFJywgbmVlZE1iQ2xlYXJbQ1IuTk9ERV0pO1xuXG4gICAgICAgICAgZHJhd01vdGlvbkJsdXIoIGN4dE5vZGUsIHR4dE5vZGUsIG5lZWRNYkNsZWFyW0NSLk5PREVdICk7XG4gICAgICAgICAgbmVlZERyYXdbQ1IuTk9ERV0gPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBuZWVkRHJhd1tDUi5EUkFHXSB8fCBuZWVkTWJDbGVhcltDUi5EUkFHXSApe1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtYiBEUkFHJyk7XG5cbiAgICAgICAgICBkcmF3TW90aW9uQmx1ciggY3h0RHJhZywgdHh0RHJhZywgbmVlZE1iQ2xlYXJbQ1IuRFJBR10gKTtcbiAgICAgICAgICBuZWVkRHJhd1tDUi5EUkFHXSA9IGZhbHNlO1xuICAgICAgICAgIC8vbmVlZE1iQ2xlYXJbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgdmFyIGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICBpZiggci5hdmVyYWdlUmVkcmF3VGltZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIuYXZlcmFnZVJlZHJhd1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuICAgICAgfVxuXG4gICAgICBpZiggci5yZWRyYXdDb3VudCA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIucmVkcmF3Q291bnQgPSAwO1xuICAgICAgfVxuXG4gICAgICByLnJlZHJhd0NvdW50Kys7XG5cbiAgICAgIGlmKCByLnJlZHJhd1RvdGFsVGltZSA9PT0gdW5kZWZpbmVkICl7XG4gICAgICAgIHIucmVkcmF3VG90YWxUaW1lID0gMDtcbiAgICAgIH1cblxuICAgICAgci5yZWRyYXdUb3RhbFRpbWUgKz0gZW5kVGltZSAtIHN0YXJ0VGltZTtcbiAgICAgIHIubGFzdFJlZHJhd1RpbWUgPSBlbmRUaW1lIC0gc3RhcnRUaW1lO1xuXG4gICAgICAvLyB1c2UgYSB3ZWlnaHRlZCBhdmVyYWdlIHdpdGggYSBiaWFzIGZyb20gdGhlIHByZXZpb3VzIGF2ZXJhZ2Ugc28gd2UgZG9uJ3Qgc3Bpa2Ugc28gZWFzaWx5XG4gICAgICByLmF2ZXJhZ2VSZWRyYXdUaW1lID0gci5hdmVyYWdlUmVkcmF3VGltZS8yICsgKGVuZFRpbWUgLSBzdGFydFRpbWUpLzI7XG4gICAgICAvL2NvbnNvbGUubG9nKCdhY3R1YWw6ICVpLCBhdmVyYWdlOiAlaScsIGVuZFRpbWUgLSBzdGFydFRpbWUsIHRoaXMuYXZlcmFnZVJlZHJhd1RpbWUpO1xuXG4gICAgICByLmN1cnJlbnRseURyYXdpbmcgPSBmYWxzZTtcblxuICAgICAgci5wcmV2Vmlld3BvcnQgPSB2cDtcblxuICAgICAgLy8gY29uc29sZS5wcm9maWxlRW5kKCdkcmF3JyArIHN0YXJ0VGltZSlcblxuICAgICAgaWYoIHIuY2xlYXJpbmdNb3Rpb25CbHVyICl7XG4gICAgICAgIHIuY2xlYXJpbmdNb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgIHIubW90aW9uQmx1ckNsZWFyZWQgPSB0cnVlO1xuICAgICAgICByLm1vdGlvbkJsdXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiggbW90aW9uQmx1ciApeyBcbiAgICAgICAgci5tb3Rpb25CbHVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICByLm1vdGlvbkJsdXJUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbWIgQ0xFQVInKTtcblxuICAgICAgICAgIHIuY2xlYXJlZEZvck1vdGlvbkJsdXJbQ1IuTk9ERV0gPSBmYWxzZTtcbiAgICAgICAgICByLmNsZWFyZWRGb3JNb3Rpb25CbHVyW0NSLkRSQUddID0gZmFsc2U7XG4gICAgICAgICAgci5tb3Rpb25CbHVyID0gZmFsc2U7XG4gICAgICAgICAgci5jbGVhcmluZ01vdGlvbkJsdXIgPSAhdGV4dHVyZURyYXc7XG4gICAgICAgICAgci5tYkZyYW1lcyA9IDA7XG5cbiAgICAgICAgICBuZWVkRHJhd1tDUi5OT0RFXSA9IHRydWU7IFxuICAgICAgICAgIG5lZWREcmF3W0NSLkRSQUddID0gdHJ1ZTsgXG5cbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9LCBDYW52YXNSZW5kZXJlci5tb3Rpb25CbHVyRGVsYXkpO1xuICAgICAgfVxuXG4gICAgICByLmRyYXdpbmdJbWFnZSA9IGZhbHNlO1xuXG4gICAgfSAvLyBkcmF3IHRvIGNvbnRleHRcblxuICAgIGlmKCAhZm9yY2VkQ29udGV4dCApe1xuICAgICAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhd1RvQ29udGV4dCk7IC8vIG1ha2VzIGRpcmVjdCByZW5kZXJzIHRvIHNjcmVlbiBhIGJpdCBtb3JlIHJlc3BvbnNpdmVcbiAgICB9IGVsc2Uge1xuICAgICAgZHJhd1RvQ29udGV4dCgpO1xuICAgIH1cblxuICAgIGlmKCAhZm9yY2VkQ29udGV4dCAmJiAhci5pbml0cmVuZGVyICl7XG4gICAgICByLmluaXRyZW5kZXIgPSB0cnVlO1xuICAgICAgY3kudHJpZ2dlcignaW5pdHJlbmRlcicpO1xuICAgIH1cblxuICAgIGlmKCAhZm9yY2VkQ29udGV4dCApe1xuICAgICAgY3kudHJpZ2dlck9uUmVuZGVyKCk7XG4gICAgfVxuICAgIFxuICB9O1xuXG59KSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIENhbnZhc1JlbmRlcmVyID0gJCQoJ3JlbmRlcmVyJywgJ2NhbnZhcycpO1xuICB2YXIgQ1JwID0gQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlO1xuXG4gIC8vIEBPIFBvbHlnb24gZHJhd2luZ1xuICBDUnAuZHJhd1BvbHlnb25QYXRoID0gZnVuY3Rpb24oXG4gICAgY29udGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcG9pbnRzKSB7XG5cbiAgICB2YXIgaGFsZlcgPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIID0gaGVpZ2h0IC8gMjtcblxuICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgICBjb250ZXh0Lm1vdmVUbyggeCArIGhhbGZXICogcG9pbnRzWzBdLCB5ICsgaGFsZkggKiBwb2ludHNbMV0gKTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aCAvIDI7IGkrKykge1xuICAgICAgY29udGV4dC5saW5lVG8oIHggKyBoYWxmVyAqIHBvaW50c1tpICogMl0sIHkgKyBoYWxmSCAqIHBvaW50c1tpICogMiArIDFdICk7XG4gICAgfVxuICAgIFxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG4gIFxuICBDUnAuZHJhd1BvbHlnb24gPSBmdW5jdGlvbihcbiAgICBjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBwb2ludHMpIHtcblxuICAgIC8vIERyYXcgcGF0aFxuICAgIHRoaXMuZHJhd1BvbHlnb25QYXRoKGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHBvaW50cyk7XG4gICAgXG4gICAgLy8gRmlsbCBwYXRoXG4gICAgY29udGV4dC5maWxsKCk7XG4gIH07XG4gIFxuICAvLyBSb3VuZCByZWN0YW5nbGUgZHJhd2luZ1xuICBDUnAuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aCA9IGZ1bmN0aW9uKFxuICAgIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgIFxuICAgIHZhciBoYWxmV2lkdGggPSB3aWR0aCAvIDI7XG4gICAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICAgIHZhciBjb3JuZXJSYWRpdXMgPSAkJC5tYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG4gICAgXG4gICAgLy8gU3RhcnQgYXQgdG9wIG1pZGRsZVxuICAgIGNvbnRleHQubW92ZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgICAvLyBBcmMgZnJvbSBtaWRkbGUgdG9wIHRvIHJpZ2h0IHNpZGVcbiAgICBjb250ZXh0LmFyY1RvKHggKyBoYWxmV2lkdGgsIHkgLSBoYWxmSGVpZ2h0LCB4ICsgaGFsZldpZHRoLCB5LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEFyYyBmcm9tIHJpZ2h0IHNpZGUgdG8gYm90dG9tXG4gICAgY29udGV4dC5hcmNUbyh4ICsgaGFsZldpZHRoLCB5ICsgaGFsZkhlaWdodCwgeCwgeSArIGhhbGZIZWlnaHQsIGNvcm5lclJhZGl1cyk7XG4gICAgLy8gQXJjIGZyb20gYm90dG9tIHRvIGxlZnQgc2lkZVxuICAgIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSArIGhhbGZIZWlnaHQsIHggLSBoYWxmV2lkdGgsIHksIGNvcm5lclJhZGl1cyk7XG4gICAgLy8gQXJjIGZyb20gbGVmdCBzaWRlIHRvIHRvcEJvcmRlclxuICAgIGNvbnRleHQuYXJjVG8oeCAtIGhhbGZXaWR0aCwgeSAtIGhhbGZIZWlnaHQsIHgsIHkgLSBoYWxmSGVpZ2h0LCBjb3JuZXJSYWRpdXMpO1xuICAgIC8vIEpvaW4gbGluZVxuICAgIGNvbnRleHQubGluZVRvKHgsIHkgLSBoYWxmSGVpZ2h0KTtcbiAgICBcbiAgICBcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuICBcbiAgQ1JwLmRyYXdSb3VuZFJlY3RhbmdsZSA9IGZ1bmN0aW9uKFxuICAgIGNvbnRleHQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cykge1xuICAgIFxuICAgIHRoaXMuZHJhd1JvdW5kUmVjdGFuZ2xlUGF0aChjb250ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMpO1xuICAgIFxuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9O1xuXG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciBDUnAgPSBDYW52YXNSZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgQ1JwLmNyZWF0ZUJ1ZmZlciA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgICB2YXIgYnVmZmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgYnVmZmVyLndpZHRoID0gdztcbiAgICBidWZmZXIuaGVpZ2h0ID0gaDtcbiAgICBcbiAgICByZXR1cm4gW2J1ZmZlciwgYnVmZmVyLmdldENvbnRleHQoJzJkJyldO1xuICB9O1xuXG4gIENScC5idWZmZXJDYW52YXNJbWFnZSA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIGN5ID0gZGF0YS5jeTtcbiAgICB2YXIgYmIgPSBjeS5lbGVtZW50cygpLmJvdW5kaW5nQm94KCk7XG4gICAgdmFyIHdpZHRoID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKGJiLncpIDogdGhpcy5kYXRhLmNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gb3B0aW9ucy5mdWxsID8gTWF0aC5jZWlsKGJiLmgpIDogdGhpcy5kYXRhLmNvbnRhaW5lci5jbGllbnRIZWlnaHQ7XG4gICAgdmFyIHNjYWxlID0gMTtcblxuICAgIGlmKCBvcHRpb25zLnNjYWxlICE9PSB1bmRlZmluZWQgKXtcbiAgICAgIHdpZHRoICo9IG9wdGlvbnMuc2NhbGU7XG4gICAgICBoZWlnaHQgKj0gb3B0aW9ucy5zY2FsZTtcblxuICAgICAgc2NhbGUgPSBvcHRpb25zLnNjYWxlO1xuICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKG9wdGlvbnMubWF4V2lkdGgpIHx8ICQkLmlzLm51bWJlcihvcHRpb25zLm1heEhlaWdodCkgKXtcbiAgICAgIHZhciBtYXhTY2FsZVcgPSBJbmZpbml0eTtcbiAgICAgIHZhciBtYXhTY2FsZUggPSBJbmZpbml0eTtcblxuICAgICAgaWYoICQkLmlzLm51bWJlcihvcHRpb25zLm1heFdpZHRoKSApe1xuICAgICAgICBtYXhTY2FsZVcgPSBzY2FsZSAqIG9wdGlvbnMubWF4V2lkdGggLyB3aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYoICQkLmlzLm51bWJlcihvcHRpb25zLm1heEhlaWdodCkgKXtcbiAgICAgICAgbWF4U2NhbGVIID0gc2NhbGUgKiBvcHRpb25zLm1heEhlaWdodCAvIGhlaWdodDtcbiAgICAgIH1cblxuICAgICAgc2NhbGUgPSBNYXRoLm1pbiggbWF4U2NhbGVXLCBtYXhTY2FsZUggKTtcblxuICAgICAgd2lkdGggKj0gc2NhbGU7XG4gICAgICBoZWlnaHQgKj0gc2NhbGU7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblxuICAgIGJ1ZmZDYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBidWZmQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcblxuICAgIGJ1ZmZDYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgYnVmZkNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgdmFyIGJ1ZmZDeHQgPSBidWZmQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAvLyBSYXN0ZXJpemUgdGhlIGxheWVycywgYnV0IG9ubHkgaWYgY29udGFpbmVyIGhhcyBub256ZXJvIHNpemVcbiAgICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcblxuICAgICAgYnVmZkN4dC5jbGVhclJlY3QoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcblxuICAgICAgaWYoIG9wdGlvbnMuYmcgKXtcbiAgICAgICAgYnVmZkN4dC5maWxsU3R5bGUgPSBvcHRpb25zLmJnO1xuICAgICAgICBidWZmQ3h0LnJlY3QoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcbiAgICAgICAgYnVmZkN4dC5maWxsKCk7XG4gICAgICB9XG5cbiAgICAgIGJ1ZmZDeHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcblxuICAgICAgaWYoIG9wdGlvbnMuZnVsbCApeyAvLyBkcmF3IHRoZSBmdWxsIGJvdW5kcyBvZiB0aGUgZ3JhcGhcbiAgICAgICAgdGhpcy5yZWRyYXcoe1xuICAgICAgICAgIGZvcmNlZENvbnRleHQ6IGJ1ZmZDeHQsXG4gICAgICAgICAgZHJhd0FsbExheWVyczogdHJ1ZSxcbiAgICAgICAgICBmb3JjZWRab29tOiBzY2FsZSxcbiAgICAgICAgICBmb3JjZWRQYW46IHsgeDogLWJiLngxKnNjYWxlLCB5OiAtYmIueTEqc2NhbGUgfSxcbiAgICAgICAgICBmb3JjZWRQeFJhdGlvOiAxXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHsgLy8gZHJhdyB0aGUgY3VycmVudCB2aWV3XG4gICAgICAgIHZhciBjeVBhbiA9IGN5LnBhbigpO1xuICAgICAgICB2YXIgcGFuID0ge1xuICAgICAgICAgIHg6IGN5UGFuLnggKiBzY2FsZSxcbiAgICAgICAgICB5OiBjeVBhbi55ICogc2NhbGVcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHpvb20gPSBjeS56b29tKCkgKiBzY2FsZTtcblxuICAgICAgICB0aGlzLnJlZHJhdyh7XG4gICAgICAgICAgZm9yY2VkQ29udGV4dDogYnVmZkN4dCxcbiAgICAgICAgICBkcmF3QWxsTGF5ZXJzOiB0cnVlLFxuICAgICAgICAgIGZvcmNlZFpvb206IHpvb20sXG4gICAgICAgICAgZm9yY2VkUGFuOiBwYW4sXG4gICAgICAgICAgZm9yY2VkUHhSYXRpbzogMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZkNhbnZhcztcbiAgfTsgXG5cbiAgQ1JwLnBuZyA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyQ2FudmFzSW1hZ2UoIG9wdGlvbnMgKS50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICB9O1xuICBcbiAgQ1JwLmpwZyA9IGZ1bmN0aW9uKCBvcHRpb25zICl7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyQ2FudmFzSW1hZ2UoIG9wdGlvbnMgKS50b0RhdGFVUkwoJ2ltYWdlL2pwZWcnKTtcbiAgfTtcblxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBDYW52YXNSZW5kZXJlciA9ICQkKCdyZW5kZXJlcicsICdjYW52YXMnKTtcbiAgdmFyIENSID0gQ2FudmFzUmVuZGVyZXI7XG4gIHZhciBDUnAgPSBDUi5wcm90b3R5cGU7XG5cbiAgQ1JwLnJlZ2lzdGVyQmluZGluZyA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIGhhbmRsZXIsIHVzZUNhcHR1cmUpe1xuICAgIHRoaXMuYmluZGluZ3MucHVzaCh7XG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGhhbmRsZXI6IGhhbmRsZXIsXG4gICAgICB1c2VDYXB0dXJlOiB1c2VDYXB0dXJlXG4gICAgfSk7XG5cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG4gIH07XG5cbiAgQ1JwLm5vZGVJc0RyYWdnYWJsZSA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAobm9kZS5fcHJpdmF0ZS5zdHlsZVsnb3BhY2l0eSddLnZhbHVlICE9PSAwXG4gICAgICAmJiBub2RlLl9wcml2YXRlLnN0eWxlWyd2aXNpYmlsaXR5J10udmFsdWUgPT0gJ3Zpc2libGUnXG4gICAgICAmJiBub2RlLl9wcml2YXRlLnN0eWxlWydkaXNwbGF5J10udmFsdWUgPT0gJ2VsZW1lbnQnXG4gICAgICAmJiAhbm9kZS5sb2NrZWQoKVxuICAgICAgJiYgbm9kZS5ncmFiYmFibGUoKSApIHtcblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIENScC5sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHIgPSB0aGlzO1xuXG4gICAgdmFyIGdldERyYWdMaXN0SWRzID0gZnVuY3Rpb24ob3B0cyl7XG4gICAgICB2YXIgbGlzdEhhc0lkO1xuXG4gICAgICBpZiggb3B0cy5hZGRUb0xpc3QgJiYgci5kYXRhLmN5Lmhhc0NvbXBvdW5kTm9kZXMoKSApeyAvLyBvbmx5IG5lZWRlZCBmb3IgY29tcG91bmQgZ3JhcGhzXG4gICAgICAgIGlmKCAhb3B0cy5hZGRUb0xpc3QuaGFzSWQgKXsgLy8gYnVpbGQgaWRzIGxvb2t1cCBpZiBkb2Vzbid0IGFscmVhZHkgZXhpc3RcbiAgICAgICAgICBvcHRzLmFkZFRvTGlzdC5oYXNJZCA9IHt9O1xuXG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHRzLmFkZFRvTGlzdC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgdmFyIGVsZSA9IG9wdHMuYWRkVG9MaXN0W2ldO1xuXG4gICAgICAgICAgICBvcHRzLmFkZFRvTGlzdC5oYXNJZFsgZWxlLmlkKCkgXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGlzdEhhc0lkID0gb3B0cy5hZGRUb0xpc3QuaGFzSWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaXN0SGFzSWQgfHwge307XG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggY2hpbGQgbm9kZXMgYW5kIGlubmVyIGVkZ2VzXG4gICAgLy8gb2YgYSBjb21wb3VuZCBub2RlIHRvIGJlIGRyYWdnZWQgYXMgd2VsbCBhcyB0aGUgZ3JhYmJlZCBhbmQgc2VsZWN0ZWQgbm9kZXNcbiAgICB2YXIgYWRkRGVzY2VuZGFudHNUb0RyYWcgPSBmdW5jdGlvbihub2RlLCBvcHRzKXtcbiAgICAgIGlmKCAhbm9kZS5fcHJpdmF0ZS5jeS5oYXNDb21wb3VuZE5vZGVzKCkgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0cy5pbkRyYWdMYXllciA9PSBudWxsICYmIG9wdHMuYWRkVG9MaXN0ID09IG51bGwgKXsgcmV0dXJuOyB9IC8vIG5vdGhpbmcgdG8gZG9cblxuICAgICAgdmFyIGxpc3RIYXNJZCA9IGdldERyYWdMaXN0SWRzKCBvcHRzICk7XG5cbiAgICAgIHZhciBpbm5lck5vZGVzID0gbm9kZS5kZXNjZW5kYW50cygpO1xuXG4gICAgICAvLyBUT0RPIGRvIG5vdCBkcmFnIGhpZGRlbiBjaGlsZHJlbiAmIGNoaWxkcmVuIG9mIGhpZGRlbiBjaGlsZHJlbj9cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgaW5uZXJOb2Rlcy5zaXplKCk7IGkrKyApe1xuICAgICAgICB2YXIgaU5vZGUgPSBpbm5lck5vZGVzW2ldO1xuICAgICAgICB2YXIgX3AgPSBpTm9kZS5fcHJpdmF0ZTtcblxuICAgICAgICBpZiggb3B0cy5pbkRyYWdMYXllciApe1xuICAgICAgICAgIF9wLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCBvcHRzLmFkZFRvTGlzdCAmJiAhbGlzdEhhc0lkWyBpTm9kZS5pZCgpIF0gKXtcbiAgICAgICAgICBvcHRzLmFkZFRvTGlzdC5wdXNoKCBpTm9kZSApO1xuICAgICAgICAgIGxpc3RIYXNJZFsgaU5vZGUuaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICAgIF9wLmdyYWJiZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVkZ2VzID0gX3AuZWRnZXM7XG4gICAgICAgIGZvciggdmFyIGogPSAwOyBvcHRzLmluRHJhZ0xheWVyICYmIGogPCBlZGdlcy5sZW5ndGg7IGorKyApe1xuICAgICAgICAgIGVkZ2VzW2pdLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhZGRzIHRoZSBnaXZlbiBub2RlcywgYW5kIGl0cyBlZGdlcyB0byB0aGUgZHJhZyBsYXllclxuICAgIHZhciBhZGROb2RlVG9EcmFnID0gZnVuY3Rpb24obm9kZSwgb3B0cyl7XG5cbiAgICAgIHZhciBfcCA9IG5vZGUuX3ByaXZhdGU7XG4gICAgICB2YXIgbGlzdEhhc0lkID0gZ2V0RHJhZ0xpc3RJZHMoIG9wdHMgKTtcblxuICAgICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgKXtcbiAgICAgICAgX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiggb3B0cy5hZGRUb0xpc3QgJiYgIWxpc3RIYXNJZFsgbm9kZS5pZCgpIF0gKXtcbiAgICAgICAgb3B0cy5hZGRUb0xpc3QucHVzaCggbm9kZSApO1xuICAgICAgICBsaXN0SGFzSWRbIG5vZGUuaWQoKSBdID0gdHJ1ZTtcblxuICAgICAgICBfcC5ncmFiYmVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVkZ2VzID0gX3AuZWRnZXM7XG4gICAgICBmb3IoIHZhciBpID0gMDsgb3B0cy5pbkRyYWdMYXllciAmJiBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgZWRnZXNbaV0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBhZGREZXNjZW5kYW50c1RvRHJhZyggbm9kZSwgb3B0cyApOyAvLyBhbHdheXMgYWRkIHRvIGRyYWdcblxuICAgICAgLy8gYWxzbyBhZGQgbm9kZXMgYW5kIGVkZ2VzIHJlbGF0ZWQgdG8gdGhlIHRvcG1vc3QgYW5jZXN0b3JcbiAgICAgIHVwZGF0ZUFuY2VzdG9yc0luRHJhZ0xheWVyKCBub2RlLCB7XG4gICAgICAgIGluRHJhZ0xheWVyOiBvcHRzLmluRHJhZ0xheWVyXG4gICAgICB9ICk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgZnJlZURyYWdnZWRFbGVtZW50cyA9IGZ1bmN0aW9uKCBkcmFnZ2VkRWxlbWVudHMgKXtcbiAgICAgIGlmKCAhZHJhZ2dlZEVsZW1lbnRzICl7IHJldHVybjsgfVxuICAgICAgXG4gICAgICBmb3IgKHZhciBpPTA7IGkgPCBkcmFnZ2VkRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICB2YXIgZEVpX3AgPSBkcmFnZ2VkRWxlbWVudHNbaV0uX3ByaXZhdGU7XG5cbiAgICAgICAgaWYoZEVpX3AuZ3JvdXAgPT09ICdub2RlcycpIHtcbiAgICAgICAgICBkRWlfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICAgIGRFaV9wLmdyYWJiZWQgPSBmYWxzZTtcblxuICAgICAgICAgIHZhciBzRWRnZXMgPSBkRWlfcC5lZGdlcztcbiAgICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IHNFZGdlcy5sZW5ndGg7IGorKyApeyBzRWRnZXNbal0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTsgfVxuXG4gICAgICAgICAgLy8gZm9yIGNvbXBvdW5kIG5vZGVzLCBhbHNvIHJlbW92ZSByZWxhdGVkIG5vZGVzIGFuZCBlZGdlcyBmcm9tIHRoZSBkcmFnIGxheWVyXG4gICAgICAgICAgdXBkYXRlQW5jZXN0b3JzSW5EcmFnTGF5ZXIoZHJhZ2dlZEVsZW1lbnRzW2ldLCB7IGluRHJhZ0xheWVyOiBmYWxzZSB9KTtcblxuICAgICAgICB9IGVsc2UgaWYoIGRFaV9wLmdyb3VwID09PSAnZWRnZXMnICl7XG4gICAgICAgICAgZEVpX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiB0byBkZXRlcm1pbmUgd2hpY2ggYW5jZXN0b3Igbm9kZXMgYW5kIGVkZ2VzIHNob3VsZCBnb1xuICAgIC8vIHRvIHRoZSBkcmFnIGxheWVyIChvciBzaG91bGQgYmUgcmVtb3ZlZCBmcm9tIGRyYWcgbGF5ZXIpLlxuICAgIHZhciB1cGRhdGVBbmNlc3RvcnNJbkRyYWdMYXllciA9IGZ1bmN0aW9uKG5vZGUsIG9wdHMpIHtcblxuICAgICAgaWYoIG9wdHMuaW5EcmFnTGF5ZXIgPT0gbnVsbCAmJiBvcHRzLmFkZFRvTGlzdCA9PSBudWxsICl7IHJldHVybjsgfSAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICAgIC8vIGZpbmQgdG9wLWxldmVsIHBhcmVudFxuICAgICAgdmFyIHBhcmVudCA9IG5vZGU7XG5cbiAgICAgIGlmKCAhbm9kZS5fcHJpdmF0ZS5jeS5oYXNDb21wb3VuZE5vZGVzKCkgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSggcGFyZW50LnBhcmVudCgpLm5vbmVtcHR5KCkgKXtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudCgpWzBdO1xuICAgICAgfVxuXG4gICAgICAvLyBubyBwYXJlbnQgbm9kZTogbm8gbm9kZXMgdG8gYWRkIHRvIHRoZSBkcmFnIGxheWVyXG4gICAgICBpZiggcGFyZW50ID09IG5vZGUgKXtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZXMgPSBwYXJlbnQuZGVzY2VuZGFudHMoKVxuICAgICAgICAubWVyZ2UoIHBhcmVudCApXG4gICAgICAgIC51bm1lcmdlKCBub2RlIClcbiAgICAgICAgLnVubWVyZ2UoIG5vZGUuZGVzY2VuZGFudHMoKSApXG4gICAgICA7XG5cbiAgICAgIHZhciBlZGdlcyA9IG5vZGVzLmNvbm5lY3RlZEVkZ2VzKCk7XG5cbiAgICAgIHZhciBsaXN0SGFzSWQgPSBnZXREcmFnTGlzdElkcyggb3B0cyApO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLnNpemUoKTsgaSsrICl7XG4gICAgICAgIGlmKCBvcHRzLmluRHJhZ0xheWVyICE9PSB1bmRlZmluZWQgKXtcbiAgICAgICAgICBub2Rlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IG9wdHMuaW5EcmFnTGF5ZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggb3B0cy5hZGRUb0xpc3QgJiYgIWxpc3RIYXNJZFsgbm9kZXNbaV0uaWQoKSBdICl7XG4gICAgICAgICAgb3B0cy5hZGRUb0xpc3QucHVzaCggbm9kZXNbaV0gKTtcbiAgICAgICAgICBsaXN0SGFzSWRbIG5vZGVzW2ldLmlkKCkgXSA9IHRydWU7XG5cbiAgICAgICAgICBub2Rlc1tpXS5fcHJpdmF0ZS5ncmFiYmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgb3B0cy5pbkRyYWdMYXllciAhPT0gdW5kZWZpbmVkICYmIGogPCBlZGdlcy5sZW5ndGg7IGorKyApIHtcbiAgICAgICAgZWRnZXNbal0uX3ByaXZhdGUucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBvcHRzLmluRHJhZ0xheWVyO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiggdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICl7XG4gICAgICByLnJlbW92ZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oIG11dG5zICl7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbXV0bnMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgbXV0biA9IG11dG5zW2ldO1xuICAgICAgICAgIHZhciByTm9kZXMgPSBtdXRuLnJlbW92ZWROb2RlcztcblxuICAgICAgICAgIGlmKCByTm9kZXMgKXsgZm9yKCB2YXIgaiA9IDA7IGogPCByTm9kZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICAgIHZhciByTm9kZSA9IHJOb2Rlc1tqXTtcblxuICAgICAgICAgICAgaWYoIHJOb2RlID09PSByLmRhdGEuY29udGFpbmVyICl7XG4gICAgICAgICAgICAgIHIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IH1cbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHIucmVtb3ZlT2JzZXJ2ZXIub2JzZXJ2ZSggci5kYXRhLmNvbnRhaW5lci5wYXJlbnROb2RlLCB7IGNoaWxkTGlzdDogdHJ1ZSB9ICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdET01Ob2RlUmVtb3ZlZCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICByLmRlc3Ryb3koKTtcbiAgICAgIH0pO1xuICAgIH1cblxuXG5cbiAgICAvLyBhdXRvIHJlc2l6ZVxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ3Jlc2l6ZScsICQkLnV0aWwuZGVib3VuY2UoIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHIuaW52YWxpZGF0ZUNvbnRhaW5lckNsaWVudENvb3Jkc0NhY2hlKCk7XG5cbiAgICAgIHIubWF0Y2hDYW52YXNTaXplKHIuZGF0YS5jb250YWluZXIpO1xuICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgIHIucmVkcmF3KCk7XG4gICAgfSwgMTAwICkgKTtcblxuICAgIHZhciBpbnZhbEN0bnJCQk9uU2Nyb2xsID0gZnVuY3Rpb24oZG9tRWxlKXtcbiAgICAgIHIucmVnaXN0ZXJCaW5kaW5nKGRvbUVsZSwgJ3Njcm9sbCcsIGZ1bmN0aW9uKGUpe1xuICAgICAgICByLmludmFsaWRhdGVDb250YWluZXJDbGllbnRDb29yZHNDYWNoZSgpO1xuICAgICAgfSApO1xuICAgIH07XG5cbiAgICB2YXIgYmJDdG5yID0gci5kYXRhLmN5LmNvbnRhaW5lcigpO1xuXG4gICAgZm9yKCA7OyApe1xuXG4gICAgICBpbnZhbEN0bnJCQk9uU2Nyb2xsKCBiYkN0bnIgKTtcblxuICAgICAgaWYoIGJiQ3Ruci5wYXJlbnROb2RlICl7XG4gICAgICAgIGJiQ3RuciA9IGJiQ3Ruci5wYXJlbnROb2RlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAvLyBzdG9wIHJpZ2h0IGNsaWNrIG1lbnUgZnJvbSBhcHBlYXJpbmcgb24gY3lcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnY29udGV4dG1lbnUnLCBmdW5jdGlvbihlKXtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcblxuICAgIHZhciBpbkJveFNlbGVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gci5kYXRhLnNlbGVjdFs0XSAhPT0gMDtcbiAgICB9O1xuXG4gICAgLy8gUHJpbWFyeSBrZXlcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnbW91c2Vkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgci5ob3ZlckRhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgICByLmhvdmVyRGF0YS53aGljaCA9IGUud2hpY2g7XG5cbiAgICAgIHZhciBjeSA9IHIuZGF0YS5jeTtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgdmFyIHNlbGVjdCA9IHIuZGF0YS5zZWxlY3Q7XG4gICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cztcblxuICAgICAgci5ob3ZlckRhdGEubWRvd25Qb3MgPSBwb3M7XG4gICAgICBcbiAgICAgIHZhciBuZWVkc1JlZHJhdyA9IHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcblxuICAgICAgdmFyIGNoZWNrRm9yVGFwaG9sZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHIuaG92ZXJEYXRhLnRhcGhvbGRDYW5jZWxsZWQgPSBmYWxzZTtcblxuICAgICAgICBjbGVhclRpbWVvdXQoIHIuaG92ZXJEYXRhLnRhcGhvbGRUaW1lb3V0ICk7XG5cbiAgICAgICAgci5ob3ZlckRhdGEudGFwaG9sZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICBpZiggci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCApe1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZWxlID0gci5ob3ZlckRhdGEuZG93bjtcblxuICAgICAgICAgICAgaWYoIGVsZSApe1xuICAgICAgICAgICAgICBlbGUudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwaG9sZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjeS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBob2xkJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSwgci50YXBob2xkRHVyYXRpb24pO1xuICAgICAgfTtcblxuICAgICAgLy8gUmlnaHQgY2xpY2sgYnV0dG9uXG4gICAgICBpZiggZS53aGljaCA9PSAzICl7XG5cbiAgICAgICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIGN4dEV2dCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoIG5lYXIgKXtcbiAgICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG4gICAgICAgICAgbmVhci50cmlnZ2VyKCBjeHRFdnQgKTtcblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN5LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICB9XG5cbiAgICAgICAgci5ob3ZlckRhdGEuZG93blRpbWUgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG5cbiAgICAgIC8vIFByaW1hcnkgYnV0dG9uXG4gICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT0gMSkge1xuXG4gICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgbmVhci5hY3RpdmF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRWxlbWVudCBkcmFnZ2luZ1xuICAgICAgICB7XG4gICAgICAgICAgLy8gSWYgc29tZXRoaW5nIGlzIHVuZGVyIHRoZSBjdXJzb3IgYW5kIGl0IGlzIGRyYWdnYWJsZSwgcHJlcGFyZSB0byBncmFiIGl0XG4gICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuXG4gICAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUobmVhcikgKXtcblxuICAgICAgICAgICAgICB2YXIgZ3JhYkV2ZW50ID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnZ3JhYicsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGlmICggbmVhci5pc05vZGUoKSAmJiAhbmVhci5zZWxlY3RlZCgpICl7XG5cbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudHMgPSByLmRyYWdEYXRhLnBvc3NpYmxlRHJhZ0VsZW1lbnRzID0gW107XG4gICAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggbmVhciwgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50cyB9ICk7XG5cbiAgICAgICAgICAgICAgICBuZWFyLnRyaWdnZXIoZ3JhYkV2ZW50KTtcblxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBuZWFyLmlzTm9kZSgpICYmIG5lYXIuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHMgPSBbICBdO1xuXG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZXMgPSBjeS4kKGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmlzTm9kZSgpICYmIHRoaXMuc2VsZWN0ZWQoKTsgfSk7XG5cbiAgICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHNlbGVjdGVkTm9kZXMubGVuZ3RoOyBpKysgKXtcblxuICAgICAgICAgICAgICAgICAgLy8gT25seSBhZGQgdGhpcyBzZWxlY3RlZCBub2RlIHRvIGRyYWcgaWYgaXQgaXMgZHJhZ2dhYmxlLCBlZy4gaGFzIG5vbnplcm8gb3BhY2l0eVxuICAgICAgICAgICAgICAgICAgaWYoIHIubm9kZUlzRHJhZ2dhYmxlKCBzZWxlY3RlZE5vZGVzW2ldICkgKXtcbiAgICAgICAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggc2VsZWN0ZWROb2Rlc1tpXSwgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVtZW50cyB9ICk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBncmFiRXZlbnQgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuRFJBR10gPSB0cnVlO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5lYXJcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZWRvd24nLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcblxuICAgICAgICAgIH0gZWxzZSBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjeVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdtb3VzZWRvd24nLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwc3RhcnQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlZG93bicsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmRvd24gPSBuZWFyO1xuICAgICAgICAgIHIuaG92ZXJEYXRhLmRvd25UaW1lID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZWN0aW9uIGJveFxuICAgICAgICBpZiAoIG5lYXIgPT0gbnVsbCB8fCBuZWFyLmlzRWRnZSgpICkge1xuICAgICAgICAgIHNlbGVjdFs0XSA9IDE7XG4gICAgICAgICAgdmFyIHRpbWVVbnRpbEFjdGl2ZSA9IE1hdGgubWF4KCAwLCBDUi5wYW5PckJveFNlbGVjdERlbGF5IC0gKCtuZXcgRGF0ZSgpIC0gci5ob3ZlckRhdGEuZG93blRpbWUpICk7XG5cbiAgICAgICAgICBjbGVhclRpbWVvdXQoIHIuYmdBY3RpdmVUaW1lb3V0ICk7XG5cbiAgICAgICAgICBpZiggY3kuYm94U2VsZWN0aW9uRW5hYmxlZCgpIHx8ICggbmVhciAmJiBuZWFyLmlzRWRnZSgpICkgKXtcbiAgICAgICAgICAgIHIuYmdBY3RpdmVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBpZiggbmVhciApe1xuICAgICAgICAgICAgICAgIG5lYXIudW5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IHBvc1swXSxcbiAgICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgICAgICAgLy9jaGVja0ZvclRhcGhvbGQoKTtcblxuICAgICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgICAgIH0sIHRpbWVVbnRpbEFjdGl2ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICAgICAgeDogcG9zWzBdLFxuICAgICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vci5ob3ZlckRhdGEuZHJhZ2dpbmcgPSB0cnVlO1xuXG4gICAgICAgICAgICAvL2NoZWNrRm9yVGFwaG9sZCgpO1xuXG4gICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICBjaGVja0ZvclRhcGhvbGQoKTtcblxuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXplIHNlbGVjdGlvbiBib3ggY29vcmRpbmF0ZXNcbiAgICAgIHNlbGVjdFswXSA9IHNlbGVjdFsyXSA9IHBvc1swXTtcbiAgICAgIHNlbGVjdFsxXSA9IHNlbGVjdFszXSA9IHBvc1sxXTtcblxuICAgIH0sIGZhbHNlKTtcblxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHdpbmRvdywgJ21vdXNlbW92ZScsICQkLnV0aWwudGhyb3R0bGUoIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBwcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICAgICAgdmFyIGNhcHR1cmUgPSByLmhvdmVyRGF0YS5jYXB0dXJlO1xuXG4gICAgICAvLyBzYXZlIGN5Y2xlcyBpZiBtb3VzZSBldmVudHMgYXJlbid0IHRvIGJlIGNhcHR1cmVkXG4gICAgICBpZiAoICFjYXB0dXJlICl7XG4gICAgICAgIHZhciBjb250YWluZXJQYWdlQ29vcmRzID0gci5maW5kQ29udGFpbmVyQ2xpZW50Q29vcmRzKCk7XG5cbiAgICAgICAgaWYgKGUuY2xpZW50WCA+IGNvbnRhaW5lclBhZ2VDb29yZHNbMF0gJiYgZS5jbGllbnRYIDwgY29udGFpbmVyUGFnZUNvb3Jkc1swXSArIHIuY2FudmFzV2lkdGhcbiAgICAgICAgICAmJiBlLmNsaWVudFkgPiBjb250YWluZXJQYWdlQ29vcmRzWzFdICYmIGUuY2xpZW50WSA8IGNvbnRhaW5lclBhZ2VDb29yZHNbMV0gKyByLmNhbnZhc0hlaWdodFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBpbnNpZGUgY29udGFpbmVyIGJvdW5kcyBzbyBPS1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjeUNvbnRhaW5lciA9IHIuZGF0YS5jb250YWluZXI7XG4gICAgICAgIHZhciB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIHRQYXJlbnQgPSB0YXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lcklzVGFyZ2V0ID0gZmFsc2U7XG5cbiAgICAgICAgd2hpbGUoIHRQYXJlbnQgKXtcbiAgICAgICAgICBpZiggdFBhcmVudCA9PT0gY3lDb250YWluZXIgKXtcbiAgICAgICAgICAgIGNvbnRhaW5lcklzVGFyZ2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRQYXJlbnQgPSB0UGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggIWNvbnRhaW5lcklzVGFyZ2V0ICl7IHJldHVybjsgfSAvLyBpZiB0YXJnZXQgaXMgb3V0aXNkZSBjeSBjb250YWluZXIsIHRoZW4gdGhpcyBldmVudCBpcyBub3QgZm9yIHVzXG4gICAgICB9XG5cbiAgICAgIHZhciBjeSA9IHIuZGF0YS5jeTtcbiAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuICAgICAgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLmNsaWVudFgsIGUuY2xpZW50WSk7XG4gICAgICB2YXIgc2VsZWN0ID0gci5kYXRhLnNlbGVjdDtcbiAgICAgIHZhciBuZWVkc1JlZHJhdyA9IHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcblxuICAgICAgdmFyIG5lYXIgPSBudWxsO1xuICAgICAgaWYoICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgKXtcbiAgICAgICAgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdCA9IHIuaG92ZXJEYXRhLmxhc3Q7XG4gICAgICB2YXIgZG93biA9IHIuaG92ZXJEYXRhLmRvd247XG5cbiAgICAgIHZhciBkaXNwID0gW3Bvc1swXSAtIHNlbGVjdFsyXSwgcG9zWzFdIC0gc2VsZWN0WzNdXTtcblxuICAgICAgdmFyIGRyYWdnZWRFbGVtZW50cyA9IHIuZHJhZ0RhdGEucG9zc2libGVEcmFnRWxlbWVudHM7XG5cbiAgICAgIHZhciBkeCA9IHNlbGVjdFsyXSAtIHNlbGVjdFswXTtcbiAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgdmFyIGR5ID0gc2VsZWN0WzNdIC0gc2VsZWN0WzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTtcblxuICAgICAgci5ob3ZlckRhdGEudGFwaG9sZENhbmNlbGxlZCA9IHRydWU7XG5cbiAgICAgIHZhciB1cGRhdGVEcmFnRGVsdGEgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gci5ob3ZlckRhdGEuZHJhZ0RlbHRhIHx8IFtdO1xuXG4gICAgICAgIGlmKCBkcmFnRGVsdGEubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgZHJhZ0RlbHRhLnB1c2goIGRpc3BbMF0gKTtcbiAgICAgICAgICBkcmFnRGVsdGEucHVzaCggZGlzcFsxXSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRyYWdEZWx0YVswXSArPSBkaXNwWzBdO1xuICAgICAgICAgIGRyYWdEZWx0YVsxXSArPSBkaXNwWzFdO1xuICAgICAgICB9XG4gICAgICB9O1xuXG5cbiAgICAgIHByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcblxuICAgICAgLy8gTW91c2Vtb3ZlIGV2ZW50XG4gICAgICB7XG4gICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA7XG5cbiAgICAgICAgfSBlbHNlIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICBjeVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ21vdXNlbW92ZScsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlbW92ZScsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZycsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgO1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgLy8gdHJpZ2dlciBjb250ZXh0IGRyYWcgaWYgcm1vdXNlIGRvd25cbiAgICAgIGlmKCByLmhvdmVyRGF0YS53aGljaCA9PT0gMyApe1xuICAgICAgICB2YXIgY3h0RXZ0ID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0ZHJhZycsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCBkb3duICl7XG4gICAgICAgICAgZG93bi50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIuaG92ZXJEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmKCAhci5ob3ZlckRhdGEuY3h0T3ZlciB8fCBuZWFyICE9PSByLmhvdmVyRGF0YS5jeHRPdmVyICl7XG5cbiAgICAgICAgICBpZiggci5ob3ZlckRhdGEuY3h0T3ZlciApe1xuICAgICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3Zlci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2N4dGRyYWdvdXQgJyArIHIuaG92ZXJEYXRhLmN4dE92ZXIuaWQoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5ob3ZlckRhdGEuY3h0T3ZlciA9IG5lYXI7XG5cbiAgICAgICAgICBpZiggbmVhciApe1xuICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ292ZXInLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjeHRkcmFnb3ZlciAnICsgbmVhci5pZCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgZHJhZyBwYW5uaW5nIHRoZSBlbnRpcmUgZ3JhcGhcbiAgICAgIH0gZWxzZSBpZiAoci5ob3ZlckRhdGEuZHJhZ2dpbmcpIHtcbiAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuXG4gICAgICAgIGlmKCBjeS5wYW5uaW5nRW5hYmxlZCgpICYmIGN5LnVzZXJQYW5uaW5nRW5hYmxlZCgpICl7XG4gICAgICAgICAgdmFyIGRlbHRhUDtcblxuICAgICAgICAgIGlmKCByLmhvdmVyRGF0YS5qdXN0U3RhcnRlZFBhbiApe1xuICAgICAgICAgICAgdmFyIG1kUG9zID0gci5ob3ZlckRhdGEubWRvd25Qb3M7XG5cbiAgICAgICAgICAgIGRlbHRhUCA9IHtcbiAgICAgICAgICAgICAgeDogKCBwb3NbMF0gLSBtZFBvc1swXSApICogem9vbSxcbiAgICAgICAgICAgICAgeTogKCBwb3NbMV0gLSBtZFBvc1sxXSApICogem9vbVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgci5ob3ZlckRhdGEuanVzdFN0YXJ0ZWRQYW4gPSBmYWxzZTtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YVAgPSB7XG4gICAgICAgICAgICAgIHg6IGRpc3BbMF0gKiB6b29tLFxuICAgICAgICAgICAgICB5OiBkaXNwWzFdICogem9vbVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgIH1cblxuICAgICAgICAgIGN5LnBhbkJ5KCBkZWx0YVAgKTtcblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTmVlZHMgcmVwcm9qZWN0IGR1ZSB0byBwYW4gY2hhbmdpbmcgdmlld3BvcnRcbiAgICAgICAgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgICAgLy8gQ2hlY2tzIHByaW1hcnkgYnV0dG9uIGRvd24gJiBvdXQgb2YgdGltZSAmIG1vdXNlIG5vdCBtb3ZlZCBtdWNoXG4gICAgICB9IGVsc2UgaWYoXG4gICAgICAgICAgc2VsZWN0WzRdID09IDEgJiYgKGRvd24gPT0gbnVsbCB8fCBkb3duLmlzRWRnZSgpKVxuICAgICAgICAgICYmICggIWN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSB8fCAoK25ldyBEYXRlKCkgLSByLmhvdmVyRGF0YS5kb3duVGltZSA+PSBDUi5wYW5PckJveFNlbGVjdERlbGF5KSApXG4gICAgICAgICAgLy8mJiAoTWF0aC5hYnMoc2VsZWN0WzNdIC0gc2VsZWN0WzFdKSArIE1hdGguYWJzKHNlbGVjdFsyXSAtIHNlbGVjdFswXSkgPCA0KVxuICAgICAgICAgICYmICFyLmhvdmVyRGF0YS5zZWxlY3RpbmdcbiAgICAgICAgICAmJiByZGlzdDIgPj0gci5kZXNrdG9wVGFwVGhyZXNob2xkMlxuICAgICAgICAgICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKClcbiAgICAgICl7XG4gICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHIuaG92ZXJEYXRhLmp1c3RTdGFydGVkUGFuID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0WzRdID0gMDtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVhY3RpdmF0ZSBiZyBvbiBib3ggc2VsZWN0aW9uXG4gICAgICAgIGlmIChjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgIXIuaG92ZXJEYXRhLmRyYWdnaW5nICYmIE1hdGgucG93KHNlbGVjdFsyXSAtIHNlbGVjdFswXSwgMikgKyBNYXRoLnBvdyhzZWxlY3RbM10gLSBzZWxlY3RbMV0sIDIpID4gNyAmJiBzZWxlY3RbNF0pe1xuICAgICAgICAgIGNsZWFyVGltZW91dCggci5iZ0FjdGl2ZVRpbWVvdXQgKTtcbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgci5ob3ZlckRhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcblxuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGRvd24gJiYgZG93bi5pc0VkZ2UoKSAmJiBkb3duLmFjdGl2ZSgpICl7IGRvd24udW5hY3RpdmF0ZSgpOyB9XG5cbiAgICAgICAgaWYgKG5lYXIgIT0gbGFzdCkge1xuXG4gICAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGxhc3QudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ21vdXNlb3V0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICBsYXN0LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnb3V0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZWFyKSB7XG4gICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdtb3VzZW92ZXInLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgIG5lYXIudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcGRyYWdvdmVyJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHIuaG92ZXJEYXRhLmxhc3QgPSBuZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGRvd24gJiYgZG93bi5pc05vZGUoKSAmJiByLm5vZGVJc0RyYWdnYWJsZShkb3duKSApe1xuXG4gICAgICAgICAgaWYoIHJkaXN0MiA+PSByLmRlc2t0b3BUYXBUaHJlc2hvbGQyICl7IC8vIHRoZW4gZHJhZ1xuXG4gICAgICAgICAgICB2YXIganVzdFN0YXJ0ZWREcmFnID0gIXIuZHJhZ0RhdGEuZGlkRHJhZztcblxuICAgICAgICAgICAgaWYoIGp1c3RTdGFydGVkRHJhZyApIHtcbiAgICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLmRyYWdEYXRhLmRpZERyYWcgPSB0cnVlOyAvLyBpbmRpY2F0ZSB0aGF0IHdlIGFjdHVhbGx5IGRpZCBkcmFnIHRoZSBub2RlXG5cbiAgICAgICAgICAgIHZhciB0b1RyaWdnZXIgPSBbXTtcblxuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlbWVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgICAgdmFyIGRFbGUgPSBkcmFnZ2VkRWxlbWVudHNbaV07XG5cbiAgICAgICAgICAgICAgLy8gbm93LCBhZGQgdGhlIGVsZW1lbnRzIHRvIHRoZSBkcmFnIGxheWVyIGlmIG5vdCBkb25lIGFscmVhZHlcbiAgICAgICAgICAgICAgaWYoICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgKXtcbiAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBkRWxlLCB7IGluRHJhZ0xheWVyOiB0cnVlIH0gKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIExvY2tlZCBub2RlcyBub3QgZHJhZ2dhYmxlLCBhcyB3ZWxsIGFzIG5vbi12aXNpYmxlIG5vZGVzXG4gICAgICAgICAgICAgIGlmKCBkRWxlLmlzTm9kZSgpICYmIHIubm9kZUlzRHJhZ2dhYmxlKGRFbGUpICYmIGRFbGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICAgICAgdmFyIGRQb3MgPSBkRWxlLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgdG9UcmlnZ2VyLnB1c2goIGRFbGUgKTtcblxuICAgICAgICAgICAgICAgIGlmKCAkJC5pcy5udW1iZXIoZGlzcFswXSkgJiYgJCQuaXMubnVtYmVyKGRpc3BbMV0pICl7XG4gICAgICAgICAgICAgICAgICBkUG9zLnggKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgICAgIGRQb3MueSArPSBkaXNwWzFdO1xuXG4gICAgICAgICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLmhvdmVyRGF0YS5kcmFnRGVsdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoICQkLmlzLm51bWJlcihkcmFnRGVsdGFbMF0pICYmICQkLmlzLm51bWJlcihkcmFnRGVsdGFbMV0pICl7XG4gICAgICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZHJhZ0RlbHRhWzFdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gdHJ1ZTtcblxuICAgICAgICAgICAgdmFyIHRjb2wgPSAobmV3ICQkLkNvbGxlY3Rpb24oY3ksIHRvVHJpZ2dlcikpO1xuXG4gICAgICAgICAgICB0Y29sLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7XG4gICAgICAgICAgICB0Y29sLnRyaWdnZXIoJ3Bvc2l0aW9uIGRyYWcnKTtcblxuICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuRFJBR10gPSB0cnVlO1xuICAgICAgICAgICAgci5yZWRyYXcoKTtcblxuICAgICAgICAgIH0gZWxzZSB7IC8vIG90aGVyd2lzZSBzYXZlIGRyYWcgZGVsdGEgZm9yIHdoZW4gd2UgYWN0dWFsbHkgc3RhcnQgZHJhZ2dpbmcgc28gdGhlIHJlbGF0aXZlIGdyYWIgcG9zIGlzIGNvbnN0YW50XG4gICAgICAgICAgICB1cGRhdGVEcmFnRGVsdGEoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmV2ZW50IHRoZSBkcmFnZ2luZyBmcm9tIHRyaWdnZXJpbmcgdGV4dCBzZWxlY3Rpb24gb24gdGhlIHBhZ2VcbiAgICAgICAgcHJldmVudERlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBzZWxlY3RbMl0gPSBwb3NbMF07IHNlbGVjdFszXSA9IHBvc1sxXTtcblxuICAgICAgaWYoIHByZXZlbnREZWZhdWx0ICl7XG4gICAgICAgIGlmKGUuc3RvcFByb3BhZ2F0aW9uKSBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgIGlmKGUucHJldmVudERlZmF1bHQpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LCAxMDAwLzMwLCB7IHRyYWlsaW5nOiB0cnVlIH0pLCBmYWxzZSk7XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICdtb3VzZXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJy0tXFxubW91c2V1cCcsIGUpXG5cbiAgICAgIHZhciBjYXB0dXJlID0gci5ob3ZlckRhdGEuY2FwdHVyZTtcbiAgICAgIGlmICghY2FwdHVyZSkgeyByZXR1cm47IH1cbiAgICAgIHIuaG92ZXJEYXRhLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5OyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTsgdmFyIHNlbGVjdCA9IHIuZGF0YS5zZWxlY3Q7XG4gICAgICB2YXIgbmVhciA9IHIuZmluZE5lYXJlc3RFbGVtZW50KHBvc1swXSwgcG9zWzFdLCB0cnVlLCBmYWxzZSk7XG4gICAgICB2YXIgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50czsgdmFyIGRvd24gPSByLmhvdmVyRGF0YS5kb3duO1xuICAgICAgdmFyIHNoaWZ0RG93biA9IGUuc2hpZnRLZXk7XG4gICAgICB2YXIgbmVlZHNSZWRyYXcgPSByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG5cbiAgICAgIGlmKCByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gKXtcbiAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7IC8vIG5vdCBhY3RpdmUgYmcgbm93XG4gICAgICBjbGVhclRpbWVvdXQoIHIuYmdBY3RpdmVUaW1lb3V0ICk7XG5cbiAgICAgIGlmKCBkb3duICl7XG4gICAgICAgIGRvd24udW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiggci5ob3ZlckRhdGEud2hpY2ggPT09IDMgKXtcbiAgICAgICAgdmFyIGN4dEV2dCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmKCBkb3duICl7XG4gICAgICAgICAgZG93bi50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCAhci5ob3ZlckRhdGEuY3h0RHJhZ2dlZCApe1xuICAgICAgICAgIHZhciBjeHRUYXAgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmKCBkb3duICl7XG4gICAgICAgICAgICBkb3duLnRyaWdnZXIoIGN4dFRhcCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRUYXAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByLmhvdmVyRGF0YS5jeHREcmFnZ2VkID0gZmFsc2U7XG4gICAgICAgIHIuaG92ZXJEYXRhLndoaWNoID0gbnVsbDtcblxuICAgICAgLy8gaWYgbm90IHJpZ2h0IG1vdXNlXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIERlc2VsZWN0IGFsbCBlbGVtZW50cyBpZiBub3RoaW5nIGlzIGN1cnJlbnRseSB1bmRlciB0aGUgbW91c2UgY3Vyc29yIGFuZCB3ZSBhcmVuJ3QgZHJhZ2dpbmcgc29tZXRoaW5nXG4gICAgICAgIGlmICggKGRvd24gPT0gbnVsbCkgLy8gbm90IG1vdXNlZG93biBvbiBub2RlXG4gICAgICAgICAgJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZyAvLyBkaWRuJ3QgbW92ZSB0aGUgbm9kZSBhcm91bmRcbiAgICAgICAgICAvLyYmICEoTWF0aC5wb3coc2VsZWN0WzJdIC0gc2VsZWN0WzBdLCAyKSArIE1hdGgucG93KHNlbGVjdFszXSAtIHNlbGVjdFsxXSwgMikgPiA3ICYmIHNlbGVjdFs0XSkgLy8gbm90IGJveCBzZWxlY3Rpb25cbiAgICAgICAgICAmJiAhci5ob3ZlckRhdGEuZHJhZ2dlZCAvLyBkaWRuJ3QgcGFuXG4gICAgICAgICkge1xuXG4gICAgICAgICAgY3kuJChmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWQoKTtcbiAgICAgICAgICB9KS51bnNlbGVjdCgpO1xuXG4gICAgICAgICAgaWYgKGRyYWdnZWRFbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IGRyYWdnZWRFbGVtZW50cyA9IFtdO1xuICAgICAgICB9XG5cblxuICAgICAgICAvLyBNb3VzZXVwIGV2ZW50XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygndHJpZ2dlciBtb3VzZXVwIGV0IGFsJyk7XG5cbiAgICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ21vdXNldXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZW5kJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZXVwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfSBlbHNlIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICAgIGN5XG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ21vdXNldXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZW5kJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZXVwJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xpY2sgZXZlbnRcbiAgICAgICAge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0cmlnZ2VyIGNsaWNrIGV0IGFsJyk7XG5cbiAgICAgICAgICBpZihcbiAgICAgICAgICAgIC8vTWF0aC5wb3coc2VsZWN0WzJdIC0gc2VsZWN0WzBdLCAyKSArIE1hdGgucG93KHNlbGVjdFszXSAtIHNlbGVjdFsxXSwgMikgPT09IDBcbiAgICAgICAgICAgICFyLmRyYWdEYXRhLmRpZERyYWcgLy8gZGlkbid0IG1vdmUgYSBub2RlIGFyb3VuZFxuICAgICAgICAgICAgJiYgIXIuaG92ZXJEYXRhLmRyYWdnZWQgLy8gZGlkbid0IHBhblxuICAgICAgICAgICl7XG4gICAgICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIG5lYXJcbiAgICAgICAgICAgICAgICAudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdjbGljaycsXG4gICAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgICB9KSApXG4gICAgICAgICAgICAgICAgLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndGFwJyxcbiAgICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICAgIH0pIClcbiAgICAgICAgICAgICAgICAudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICd2Y2xpY2snLFxuICAgICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgICAgfSkgKVxuICAgICAgICAgICAgICA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5lYXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjeVxuICAgICAgICAgICAgICAgIC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2NsaWNrJyxcbiAgICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogcG9zWzBdLCB5OiBwb3NbMV0gfVxuICAgICAgICAgICAgICAgIH0pIClcbiAgICAgICAgICAgICAgICAudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICd0YXAnLFxuICAgICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICAgICAgICAgICAgfSkgKVxuICAgICAgICAgICAgICAgIC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ3ZjbGljaycsXG4gICAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IHBvc1swXSwgeTogcG9zWzFdIH1cbiAgICAgICAgICAgICAgICB9KSApXG4gICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaW5nbGUgc2VsZWN0aW9uXG4gICAgICAgIGlmIChuZWFyID09IGRvd24gJiYgIXIuZHJhZ0RhdGEuZGlkRHJhZykge1xuICAgICAgICAgIGlmIChuZWFyICE9IG51bGwgJiYgbmVhci5fcHJpdmF0ZS5zZWxlY3RhYmxlKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzaW5nbGUgc2VsZWN0aW9uJylcblxuICAgICAgICAgICAgaWYoIHIuaG92ZXJEYXRhLmRyYWdnaW5nICl7XG4gICAgICAgICAgICAgIC8vIGlmIHBhbm5pbmcsIGRvbid0IGNoYW5nZSBzZWxlY3Rpb24gc3RhdGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiggY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnIHx8IHNoaWZ0RG93biApe1xuICAgICAgICAgICAgICBpZiggbmVhci5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAgICAgbmVhci51bnNlbGVjdCgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5lYXIuc2VsZWN0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmKCAhc2hpZnREb3duICl7XG4gICAgICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5tZXJnZSggbmVhciApLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgbmVhci5zZWxlY3QoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG5cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICggci5ob3ZlckRhdGEuc2VsZWN0aW5nICYmIGN5LmJveFNlbGVjdGlvbkVuYWJsZWQoKSAmJiAgTWF0aC5wb3coc2VsZWN0WzJdIC0gc2VsZWN0WzBdLCAyKSArIE1hdGgucG93KHNlbGVjdFszXSAtIHNlbGVjdFsxXSwgMikgPiA3ICYmIHNlbGVjdFs0XSApIHtcbiAgICAgICAgICB2YXIgbmV3bHlTZWxlY3RlZCA9IFtdO1xuICAgICAgICAgIHZhciBib3ggPSByLmdldEFsbEluQm94KCBzZWxlY3RbMF0sIHNlbGVjdFsxXSwgc2VsZWN0WzJdLCBzZWxlY3RbM10gKTtcblxuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICAgIGlmKCBib3gubGVuZ3RoID4gMCApIHtcbiAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGJveC5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgaWYoIGJveFtpXS5fcHJpdmF0ZS5zZWxlY3RhYmxlICl7XG4gICAgICAgICAgICAgIG5ld2x5U2VsZWN0ZWQucHVzaCggYm94W2ldICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIG5ld2x5U2VsQ29sID0gbmV3ICQkLkNvbGxlY3Rpb24oIGN5LCBuZXdseVNlbGVjdGVkICk7XG5cbiAgICAgICAgICBpZiggY3kuc2VsZWN0aW9uVHlwZSgpID09PSAnYWRkaXRpdmUnICl7XG4gICAgICAgICAgICBuZXdseVNlbENvbC5zZWxlY3QoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoICFzaGlmdERvd24gKXtcbiAgICAgICAgICAgICAgY3kuJCgnOnNlbGVjdGVkJykudW5tZXJnZSggbmV3bHlTZWxDb2wgKS51bnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBuZXdseVNlbENvbC5zZWxlY3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhbHdheXMgbmVlZCByZWRyYXcgaW4gY2FzZSBlbGVzIHVuc2VsZWN0YWJsZVxuICAgICAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbmNlbCBkcmFnIHBhblxuICAgICAgICBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmcgKXtcbiAgICAgICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIFxuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcbiAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5OT0RFXSA9IHRydWU7XG4gICAgICAgICAgXG4gICAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc2VsZWN0WzRdKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZyZWUgYXQgZW5kJywgZHJhZ2dlZEVsZW1lbnRzKVxuXG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuRFJBR10gPSB0cnVlO1xuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcblxuICAgICAgICAgIGZyZWVEcmFnZ2VkRWxlbWVudHMoIGRyYWdnZWRFbGVtZW50cyApO1xuXG4gICAgICAgICAgaWYoIGRvd24gKXsgZG93bi50cmlnZ2VyKCdmcmVlJyk7IH1cblxuICAvLyAgICAgICAgZHJhZ2dlZEVsZW1lbnRzID0gci5kcmFnRGF0YS5wb3NzaWJsZURyYWdFbGVtZW50cyA9IFtdO1xuXG4gICAgICAgIH1cblxuICAgICAgfSAvLyBlbHNlIG5vdCByaWdodCBtb3VzZVxuXG4gICAgICBzZWxlY3RbNF0gPSAwOyByLmhvdmVyRGF0YS5kb3duID0gbnVsbDtcblxuICAgICAgLy9yLmRhdGEuY2FudmFzTmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuXG4vLyAgICAgIGNvbnNvbGUubG9nKCdtdScsIHBvc1swXSwgcG9zWzFdKTtcbi8vICAgICAgY29uc29sZS5sb2coJ3NzJywgc2VsZWN0KTtcblxuICAgICAgci5ob3ZlckRhdGEuY3h0U3RhcnRlZCA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5zZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuZHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgci5ob3ZlckRhdGEuZHJhZ0RlbHRhID0gW107XG5cbiAgICB9LCBmYWxzZSk7XG5cbiAgICB2YXIgd2hlZWxIYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYoIHIuc2Nyb2xsaW5nUGFnZSApeyByZXR1cm47IH0gLy8gd2hpbGUgc2Nyb2xsaW5nLCBpZ25vcmUgd2hlZWwtdG8tem9vbVxuXG4gICAgICB2YXIgY3kgPSByLmRhdGEuY3k7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgIHZhciBycG9zID0gW3Bvc1swXSAqIGN5Lnpvb20oKSArIGN5LnBhbigpLngsXG4gICAgICAgICAgICAgICAgICAgIHBvc1sxXSAqIGN5Lnpvb20oKSArIGN5LnBhbigpLnldO1xuXG4gICAgICBpZiggci5ob3ZlckRhdGEuZHJhZ2dpbmdFbGVzIHx8IHIuaG92ZXJEYXRhLmRyYWdnaW5nIHx8IHIuaG92ZXJEYXRhLmN4dFN0YXJ0ZWQgfHwgaW5Cb3hTZWxlY3Rpb24oKSApeyAvLyBpZiBwYW4gZHJhZ2dpbmcgb3IgY3h0IGRyYWdnaW5nLCB3aGVlbCBtb3ZlbWVudHMgbWFrZSBubyB6b29tXG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiggY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSAmJiBjeS56b29taW5nRW5hYmxlZCgpICYmIGN5LnVzZXJab29taW5nRW5hYmxlZCgpICl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICByLmRhdGEud2hlZWxab29taW5nID0gdHJ1ZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KCByLmRhdGEud2hlZWxUaW1lb3V0ICk7XG4gICAgICAgIHIuZGF0YS53aGVlbFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgci5kYXRhLndoZWVsWm9vbWluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgci5kYXRhLmNhbnZhc05lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICB9LCAxNTApO1xuXG4gICAgICAgIHZhciBkaWZmID0gZS5kZWx0YVkgLyAtMjUwIHx8IGUud2hlZWxEZWx0YVkgLyAxMDAwIHx8IGUud2hlZWxEZWx0YSAvIDEwMDA7XG4gICAgICAgIGRpZmYgPSBkaWZmICogci53aGVlbFNlbnNpdGl2aXR5O1xuXG4gICAgICAgIHZhciBuZWVkc1doZWVsRml4ID0gZS5kZWx0YU1vZGUgPT09IDE7XG4gICAgICAgIGlmKCBuZWVkc1doZWVsRml4ICl7IC8vIGZpeGVzIHNsb3cgd2hlZWwgZXZlbnRzIG9uIGZmL2xpbnV4IGFuZCBmZi93aW5kb3dzXG4gICAgICAgICAgZGlmZiAqPSAzMztcbiAgICAgICAgfVxuXG4gICAgICAgIGN5Lnpvb20oe1xuICAgICAgICAgIGxldmVsOiBjeS56b29tKCkgKiBNYXRoLnBvdygxMCwgZGlmZiksXG4gICAgICAgICAgcmVuZGVyZWRQb3NpdGlvbjogeyB4OiBycG9zWzBdLCB5OiBycG9zWzFdIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICB9O1xuXG4gICAgLy8gRnVuY3Rpb25zIHRvIGhlbHAgd2l0aCB3aGV0aGVyIG1vdXNlIHdoZWVsIHNob3VsZCB0cmlnZ2VyIHpvb21pbmdcbiAgICAvLyAtLVxuICAgIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICd3aGVlbCcsIHdoZWVsSGFuZGxlciwgdHJ1ZSk7XG5cbiAgICAvLyBkaXNhYmxlIG5vbnN0YW5kYXJkIHdoZWVsIGV2ZW50c1xuICAgIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdtb3VzZXdoZWVsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTtcbiAgICAvLyByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnRE9NTW91c2VTY3JvbGwnLCB3aGVlbEhhbmRsZXIsIHRydWUpO1xuICAgIC8vIHIucmVnaXN0ZXJCaW5kaW5nKHIuZGF0YS5jb250YWluZXIsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgd2hlZWxIYW5kbGVyLCB0cnVlKTsgLy8gb2xkZXIgZmlyZWZveFxuXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAnc2Nyb2xsJywgZnVuY3Rpb24oZSl7XG4gICAgICByLnNjcm9sbGluZ1BhZ2UgPSB0cnVlO1xuXG4gICAgICBjbGVhclRpbWVvdXQoIHIuc2Nyb2xsaW5nUGFnZVRpbWVvdXQgKTtcbiAgICAgIHIuc2Nyb2xsaW5nUGFnZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIHIuc2Nyb2xsaW5nUGFnZSA9IGZhbHNlO1xuICAgICAgfSwgMjUwKTtcbiAgICB9LCB0cnVlKTtcblxuICAgIC8vIEZ1bmN0aW9ucyB0byBoZWxwIHdpdGggaGFuZGxpbmcgbW91c2VvdXQvbW91c2VvdmVyIG9uIHRoZSBDeXRvc2NhcGUgY29udGFpbmVyXG4gICAgICAgICAgLy8gSGFuZGxlIG1vdXNlb3V0IG9uIEN5dG9zY2FwZSBjb250YWluZXJcbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAnbW91c2VvdXQnLCBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUuY2xpZW50WCwgZS5jbGllbnRZKTtcblxuICAgICAgci5kYXRhLmN5LnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgdHlwZTogJ21vdXNlb3V0JyxcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9KSk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcoci5kYXRhLmNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuXG4gICAgICByLmRhdGEuY3kudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICB0eXBlOiAnbW91c2VvdmVyJyxcbiAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBwb3NbMF0sIHk6IHBvc1sxXSB9XG4gICAgICB9KSk7XG4gICAgfSwgZmFsc2UpO1xuXG4gICAgdmFyIGYxeDEsIGYxeTEsIGYyeDEsIGYyeTE7IC8vIHN0YXJ0aW5nIHBvaW50cyBmb3IgcGluY2gtdG8tem9vbVxuICAgIHZhciBkaXN0YW5jZTEsIGRpc3RhbmNlMVNxOyAvLyBpbml0aWFsIGRpc3RhbmNlIGJldHdlZW4gZmluZ2VyIDEgYW5kIGZpbmdlciAyIGZvciBwaW5jaC10by16b29tXG4gICAgdmFyIGNlbnRlcjEsIG1vZGVsQ2VudGVyMTsgLy8gY2VudGVyIHBvaW50IG9uIHN0YXJ0IHBpbmNoIHRvIHpvb21cbiAgICB2YXIgb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wO1xuICAgIHZhciBjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0O1xuICAgIHZhciB0d29GaW5nZXJzU3RhcnRJbnNpZGU7XG5cbiAgICB2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mil7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KCAoeDIteDEpKih4Mi14MSkgKyAoeTIteTEpKih5Mi15MSkgKTtcbiAgICB9O1xuXG4gICAgdmFyIGRpc3RhbmNlU3EgPSBmdW5jdGlvbih4MSwgeTEsIHgyLCB5Mil7XG4gICAgICByZXR1cm4gKHgyLXgxKSooeDIteDEpICsgKHkyLXkxKSooeTIteTEpO1xuICAgIH07XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyhyLmRhdGEuY29udGFpbmVyLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgY2xlYXJUaW1lb3V0KCB0aGlzLnRocmVlRmluZ2VyU2VsZWN0VGltZW91dCApO1xuXG4gICAgICBpZiggZS50YXJnZXQgIT09IHIuZGF0YS5saW5rICl7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cblxuICAgICAgci50b3VjaERhdGEuY2FwdHVyZSA9IHRydWU7XG4gICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBjeSA9IHIuZGF0YS5jeTtcbiAgICAgIHZhciBub2RlcyA9IHIuZ2V0Q2FjaGVkTm9kZXMoKTtcbiAgICAgIHZhciBlZGdlcyA9IHIuZ2V0Q2FjaGVkRWRnZXMoKTtcbiAgICAgIHZhciBub3cgPSByLnRvdWNoRGF0YS5ub3c7XG4gICAgICB2YXIgZWFybGllciA9IHIudG91Y2hEYXRhLmVhcmxpZXI7XG4gICAgICB2YXIgbmVlZHNSZWRyYXcgPSByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cblxuXG4gICAgICAvLyByZWNvcmQgc3RhcnRpbmcgcG9pbnRzIGZvciBwaW5jaC10by16b29tXG4gICAgICBpZiggZS50b3VjaGVzWzFdICl7XG5cbiAgICAgICAgLy8gYW55dGhpbmcgaW4gdGhlIHNldCBvZiBkcmFnZ2VkIGVsZXMgc2hvdWxkIGJlIHJlbGVhc2VkXG4gICAgICAgIHZhciByZWxlYXNlID0gZnVuY3Rpb24oIGVsZXMgKXtcbiAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIGVsZXNbaV0uX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZWxlc1tpXS5fcHJpdmF0ZS5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuICAgICAgICAgICAgaWYoIGVsZXNbaV0uYWN0aXZlKCkgKXsgZWxlc1tpXS51bmFjdGl2YXRlKCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJlbGVhc2Uobm9kZXMpO1xuICAgICAgICByZWxlYXNlKGVkZ2VzKTtcblxuICAgICAgICB2YXIgb2Zmc2V0cyA9IHIuZmluZENvbnRhaW5lckNsaWVudENvb3JkcygpO1xuICAgICAgICBvZmZzZXRMZWZ0ID0gb2Zmc2V0c1swXTtcbiAgICAgICAgb2Zmc2V0VG9wID0gb2Zmc2V0c1sxXTtcbiAgICAgICAgY29udGFpbmVyV2lkdGggPSBvZmZzZXRzWzJdO1xuICAgICAgICBjb250YWluZXJIZWlnaHQgPSBvZmZzZXRzWzNdO1xuXG4gICAgICAgIGYxeDEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WCAtIG9mZnNldExlZnQ7XG4gICAgICAgIGYxeTEgPSBlLnRvdWNoZXNbMF0uY2xpZW50WSAtIG9mZnNldFRvcDtcblxuICAgICAgICBmMngxID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0O1xuICAgICAgICBmMnkxID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG5cbiAgICAgICAgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlID1cbiAgICAgICAgICAgICAwIDw9IGYxeDEgJiYgZjF4MSA8PSBjb250YWluZXJXaWR0aFxuICAgICAgICAgICYmIDAgPD0gZjJ4MSAmJiBmMngxIDw9IGNvbnRhaW5lcldpZHRoXG4gICAgICAgICAgJiYgMCA8PSBmMXkxICYmIGYxeTEgPD0gY29udGFpbmVySGVpZ2h0XG4gICAgICAgICAgJiYgMCA8PSBmMnkxICYmIGYyeTEgPD0gY29udGFpbmVySGVpZ2h0XG4gICAgICAgIDtcblxuICAgICAgICB2YXIgcGFuID0gY3kucGFuKCk7XG4gICAgICAgIHZhciB6b29tID0gY3kuem9vbSgpO1xuXG4gICAgICAgIGRpc3RhbmNlMSA9IGRpc3RhbmNlKCBmMXgxLCBmMXkxLCBmMngxLCBmMnkxICk7XG4gICAgICAgIGRpc3RhbmNlMVNxID0gZGlzdGFuY2VTcSggZjF4MSwgZjF5MSwgZjJ4MSwgZjJ5MSApO1xuICAgICAgICBjZW50ZXIxID0gWyAoZjF4MSArIGYyeDEpLzIsIChmMXkxICsgZjJ5MSkvMiBdO1xuICAgICAgICBtb2RlbENlbnRlcjEgPSBbXG4gICAgICAgICAgKGNlbnRlcjFbMF0gLSBwYW4ueCkgLyB6b29tLFxuICAgICAgICAgIChjZW50ZXIxWzFdIC0gcGFuLnkpIC8gem9vbVxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIGNvbnNpZGVyIGNvbnRleHQgdGFwXG4gICAgICAgIHZhciBjeHREaXN0VGhyZXNob2xkID0gMjAwO1xuICAgICAgICB2YXIgY3h0RGlzdFRocmVzaG9sZFNxID0gY3h0RGlzdFRocmVzaG9sZCAqIGN4dERpc3RUaHJlc2hvbGQ7XG4gICAgICAgIGlmKCBkaXN0YW5jZTFTcSA8IGN4dERpc3RUaHJlc2hvbGRTcSAmJiAhZS50b3VjaGVzWzJdICl7XG5cbiAgICAgICAgICB2YXIgbmVhcjEgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgdmFyIG5lYXIyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzJdLCBub3dbM10sIHRydWUsIHRydWUpO1xuXG4gICAgICAgICAgLy9jb25zb2xlLmxvZyhkaXN0YW5jZTEpXG5cbiAgICAgICAgICBpZiggbmVhcjEgJiYgbmVhcjEuaXNOb2RlKCkgKXtcbiAgICAgICAgICAgIG5lYXIxLmFjdGl2YXRlKCkudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMTtcblxuICAgICAgICAgIH0gZWxzZSBpZiggbmVhcjIgJiYgbmVhcjIuaXNOb2RlKCkgKXtcbiAgICAgICAgICAgIG5lYXIyLmFjdGl2YXRlKCkudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2N4dHRhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBuZWFyMjtcblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0dGFwc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7IHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTsgfVxuICAgICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IHRydWU7XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0RHJhZ2dlZCA9IGZhbHNlO1xuICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2N4dHRhcHN0YXJ0JylcblxuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhjZW50ZXIxKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3RvdWNoc3RhcnQgcHR6Jyk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG9mZnNldExlZnQsIG9mZnNldFRvcCk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGYxeDEsIGYxeTEpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhmMngxLCBmMnkxKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coZGlzdGFuY2UxKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coY2VudGVyMSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdhbm90aGVyIHRhcHN0YXJ0JylcblxuXG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG5cbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzFdKSB7XG5cbiAgICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzWzBdKSB7XG4gICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuXG4gICAgICAgIGlmIChuZWFyICE9IG51bGwpIHtcbiAgICAgICAgICBuZWFyLmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG5lYXI7XG5cbiAgICAgICAgICBpZiggbmVhci5pc05vZGUoKSAmJiByLm5vZGVJc0RyYWdnYWJsZShuZWFyKSApe1xuXG4gICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXMgPSBbXTtcblxuICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuRFJBR10gPSB0cnVlO1xuXG4gICAgICAgICAgICBpZiggbmVhci5zZWxlY3RlZCgpICl7XG4gICAgICAgICAgICAgIC8vIHJlc2V0IGRyYWcgZWxlbWVudHMsIHNpbmNlIG5lYXIgd2lsbCBiZSBhZGRlZCBhZ2FpblxuXG4gICAgICAgICAgICAgIHZhciBzZWxlY3RlZE5vZGVzID0gY3kuJChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzTm9kZSgpICYmIHRoaXMuc2VsZWN0ZWQoKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBzZWxlY3RlZE5vZGVzLmxlbmd0aDsgaysrICl7XG4gICAgICAgICAgICAgICAgdmFyIHNlbGVjdGVkTm9kZSA9IHNlbGVjdGVkTm9kZXNba107XG5cbiAgICAgICAgICAgICAgICBpZiggci5ub2RlSXNEcmFnZ2FibGUoc2VsZWN0ZWROb2RlKSApe1xuICAgICAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggc2VsZWN0ZWROb2RlLCB7IGFkZFRvTGlzdDogZHJhZ2dlZEVsZXMgfSApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkTm9kZVRvRHJhZyggbmVhciwgeyBhZGRUb0xpc3Q6IGRyYWdnZWRFbGVzIH0gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnZ3JhYicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndG91Y2hzdGFydCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZG93bicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgO1xuICAgICAgICB9IGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICBjeVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RhcHN0YXJ0JyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2bW91c2Vkb3duJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICA7XG5cbiAgICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB7XG4gICAgICAgICAgICB4OiBwb3NbMF0sXG4gICAgICAgICAgICB5OiBwb3NbMV1cbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgICAgICAgIHIucmVkcmF3KCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFRhcCwgdGFwaG9sZFxuICAgICAgICAvLyAtLS0tLVxuXG4gICAgICAgIGZvciAodmFyIGk9MDsgaTxub3cubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBlYXJsaWVyW2ldID0gbm93W2ldO1xuICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25baV0gPSBub3dbaV07XG4gICAgICAgIH1cblxuICAgICAgICByLnRvdWNoRGF0YS5zaW5nbGVUb3VjaE1vdmVkID0gZmFsc2U7XG4gICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoU3RhcnRUaW1lID0gK25ldyBEYXRlKCk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KCByLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCApO1xuICAgICAgICByLnRvdWNoRGF0YS50YXBob2xkVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYoXG4gICAgICAgICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPT09IGZhbHNlXG4gICAgICAgICAgICAgICYmICFyLnBpbmNoaW5nIC8vIGlmIHBpbmNoaW5nLCB0aGVuIHRhcGhvbGQgdW5zZWxlY3Qgc2hvdWxkbid0IHRha2UgZWZmZWN0XG5cbiAgICAgICAgICAgICAgLy8gVGhpcyB0aW1lIGRvdWJsZSBjb25zdHJhaW50IHByZXZlbnRzIG11bHRpcGxlIHF1aWNrIHRhcHNcbiAgICAgICAgICAgICAgLy8gZm9sbG93ZWQgYnkgYSB0YXBob2xkIHRyaWdnZXJpbmcgbXVsdGlwbGUgdGFwaG9sZCBldmVudHNcbiAgICAgICAgICAgICAgLy8mJiBEYXRlLm5vdygpIC0gci50b3VjaERhdGEuc2luZ2xlVG91Y2hTdGFydFRpbWUgPiAyNTBcbiAgICAgICAgICApe1xuICAgICAgICAgICAgaWYgKHIudG91Y2hEYXRhLnN0YXJ0KSB7XG4gICAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgci5kYXRhLmN5LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGhvbGQnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG5cbi8vICAgICAgICAgICAgY29uc29sZS5sb2coJ3RhcGhvbGQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHIudGFwaG9sZER1cmF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLy9yLnJlZHJhdygpO1xuXG4gICAgfSwgZmFsc2UpO1xuXG4vLyBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uKG0peyAkKCcjY29uc29sZScpLmFwcGVuZCgnPGRpdj4nK20rJzwvZGl2PicpOyB9O1xuXG4gICAgci5yZWdpc3RlckJpbmRpbmcod2luZG93LCAndG91Y2htb3ZlJywgJCQudXRpbC50aHJvdHRsZShmdW5jdGlvbihlKSB7XG5cbiAgICAgIHZhciBzZWxlY3QgPSByLmRhdGEuc2VsZWN0O1xuICAgICAgdmFyIGNhcHR1cmUgPSByLnRvdWNoRGF0YS5jYXB0dXJlOyAvL2lmICghY2FwdHVyZSkgeyByZXR1cm47IH07XG4gICAgICBpZiggY2FwdHVyZSApeyBlLnByZXZlbnREZWZhdWx0KCk7IH1cblxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5O1xuICAgICAgdmFyIG5vdyA9IHIudG91Y2hEYXRhLm5vdzsgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICBcbiAgICAgIHZhciBuZWVkc1JlZHJhdyA9IHIuZGF0YS5jYW52YXNOZWVkc1JlZHJhdztcblxuICAgICAgaWYgKGUudG91Y2hlc1swXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzFdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzFdLmNsaWVudFgsIGUudG91Y2hlc1sxXS5jbGllbnRZKTsgbm93WzJdID0gcG9zWzBdOyBub3dbM10gPSBwb3NbMV07IH1cbiAgICAgIGlmIChlLnRvdWNoZXNbMl0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMl0uY2xpZW50WCwgZS50b3VjaGVzWzJdLmNsaWVudFkpOyBub3dbNF0gPSBwb3NbMF07IG5vd1s1XSA9IHBvc1sxXTsgfVxuICAgICAgdmFyIGRpc3AgPSBbXTsgZm9yICh2YXIgaj0wO2o8bm93Lmxlbmd0aDtqKyspIHsgZGlzcFtqXSA9IG5vd1tqXSAtIGVhcmxpZXJbal07IH1cblxuICAgICAgdmFyIHN0YXJ0UG9zID0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbjtcblxuICAgICAgdmFyIGR4ID0gbm93WzBdIC0gc3RhcnRQb3NbMF07XG4gICAgICB2YXIgZHgyID0gZHggKiBkeDtcbiAgICAgIHZhciBkeSA9IG5vd1sxXSAtIHN0YXJ0UG9zWzFdO1xuICAgICAgdmFyIGR5MiA9IGR5ICogZHk7XG4gICAgICB2YXIgZGlzdDIgPSBkeDIgKyBkeTI7XG4gICAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTtcblxuICAgICAgaWYoIGNhcHR1cmUgJiYgci50b3VjaERhdGEuY3h0ICl7XG4gICAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIC8vIHZhciBkaXN0YW5jZTIgPSBkaXN0YW5jZSggZjF4MiwgZjF5MiwgZjJ4MiwgZjJ5MiApO1xuICAgICAgICB2YXIgZGlzdGFuY2UyU3EgPSBkaXN0YW5jZVNxKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAgIHZhciBmYWN0b3JTcSA9IGRpc3RhbmNlMlNxIC8gZGlzdGFuY2UxU3E7XG5cbiAgICAgICAgdmFyIGRpc3RUaHJlc2hvbGQgPSAxNTA7XG4gICAgICAgIHZhciBkaXN0VGhyZXNob2xkU3EgPSBkaXN0VGhyZXNob2xkICogZGlzdFRocmVzaG9sZDtcbiAgICAgICAgdmFyIGZhY3RvclRocmVzaG9sZCA9IDEuNTtcbiAgICAgICAgdmFyIGZhY3RvclRocmVzaG9sZFNxID0gZmFjdG9yVGhyZXNob2xkICogZmFjdG9yVGhyZXNob2xkO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coZmFjdG9yLCBkaXN0YW5jZTIpXG5cbiAgICAgICAgLy8gY2FuY2VsIGN0eCBnZXN0dXJlcyBpZiB0aGUgZGlzdGFuY2UgYi90IHRoZSBmaW5nZXJzIGluY3JlYXNlc1xuICAgICAgICBpZiggZmFjdG9yU3EgPj0gZmFjdG9yVGhyZXNob2xkU3EgfHwgZGlzdGFuY2UyU3EgPj0gZGlzdFRocmVzaG9sZFNxICl7XG4gICAgICAgICAgci50b3VjaERhdGEuY3h0ID0gZmFsc2U7XG4gICAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7IHIudG91Y2hEYXRhLnN0YXJ0LnVuYWN0aXZhdGUoKTsgci50b3VjaERhdGEuc3RhcnQgPSBudWxsOyB9XG4gICAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBjeHRFdnQgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcGVuZCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXtcbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0LnRyaWdnZXIoIGN4dEV2dCApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjeS50cmlnZ2VyKCBjeHRFdnQgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiggY2FwdHVyZSAmJiByLnRvdWNoRGF0YS5jeHQgKXtcbiAgICAgICAgdmFyIGN4dEV2dCA9IG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgdHlwZTogJ2N4dGRyYWcnLFxuICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICB9KTtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgaWYoIHIudG91Y2hEYXRhLnN0YXJ0ICl7XG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3h0RXZ0ICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlOyB9XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dERyYWdnZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vY29uc29sZS5sb2coJ2N4dGRyYWcnKVxuXG4gICAgICAgIHZhciBuZWFyID0gci5maW5kTmVhcmVzdEVsZW1lbnQobm93WzBdLCBub3dbMV0sIHRydWUsIHRydWUpO1xuXG4gICAgICAgIGlmKCAhci50b3VjaERhdGEuY3h0T3ZlciB8fCBuZWFyICE9PSByLnRvdWNoRGF0YS5jeHRPdmVyICl7XG5cbiAgICAgICAgICBpZiggci50b3VjaERhdGEuY3h0T3ZlciApe1xuICAgICAgICAgICAgci50b3VjaERhdGEuY3h0T3Zlci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAnY3h0ZHJhZ291dCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2N4dGRyYWdvdXQnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5jeHRPdmVyID0gbmVhcjtcblxuICAgICAgICAgIGlmKCBuZWFyICl7XG4gICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICdjeHRkcmFnb3ZlcicsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2N4dGRyYWdvdmVyJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmKCBjYXB0dXJlICYmIGUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgKXtcbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBjbGVhclRpbWVvdXQoIHRoaXMudGhyZWVGaW5nZXJTZWxlY3RUaW1lb3V0ICk7XG4gICAgICAgIHRoaXMubGFzdFRocmVlVG91Y2ggPSArbmV3IERhdGUoKTtcbiAgICAgICAgci50b3VjaERhdGEuc2VsZWN0aW5nID0gdHJ1ZTtcblxuICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG5cbiAgICAgICAgaWYoICFzZWxlY3QgfHwgc2VsZWN0Lmxlbmd0aCA9PT0gMCB8fCBzZWxlY3RbMF0gPT09IHVuZGVmaW5lZCApe1xuICAgICAgICAgIHNlbGVjdFswXSA9IChub3dbMF0gKyBub3dbMl0gKyBub3dbNF0pLzM7XG4gICAgICAgICAgc2VsZWN0WzFdID0gKG5vd1sxXSArIG5vd1szXSArIG5vd1s1XSkvMztcbiAgICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKS8zICsgMTtcbiAgICAgICAgICBzZWxlY3RbM10gPSAobm93WzFdICsgbm93WzNdICsgbm93WzVdKS8zICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxlY3RbMl0gPSAobm93WzBdICsgbm93WzJdICsgbm93WzRdKS8zO1xuICAgICAgICAgIHNlbGVjdFszXSA9IChub3dbMV0gKyBub3dbM10gKyBub3dbNV0pLzM7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxlY3RbNF0gPSAxO1xuICAgICAgICByLnRvdWNoRGF0YS5zZWxlY3RpbmcgPSB0cnVlO1xuXG4gICAgICAgIHIucmVkcmF3KCk7XG5cbiAgICAgIH0gZWxzZSBpZiAoIGNhcHR1cmUgJiYgZS50b3VjaGVzWzFdICYmIGN5Lnpvb21pbmdFbmFibGVkKCkgJiYgY3kucGFubmluZ0VuYWJsZWQoKSAmJiBjeS51c2VyWm9vbWluZ0VuYWJsZWQoKSAmJiBjeS51c2VyUGFubmluZ0VuYWJsZWQoKSApIHsgLy8gdHdvIGZpbmdlcnMgPT4gcGluY2ggdG8gem9vbVxuICAgICAgICByLmRhdGEuYmdBY3RpdmVQb3Npc3Rpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG4gICAgICAgIGlmKCBkcmFnZ2VkRWxlcyApe1xuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLkRSQUddID0gdHJ1ZTtcblxuICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZHJhZ2dlZEVsZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVzW2ldLl9wcml2YXRlLnJzY3JhdGNoLmluRHJhZ0xheWVyID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3RvdWNobW92ZSBwdHonKTtcblxuICAgICAgICAvLyAoeDIsIHkyKSBmb3IgZmluZ2VycyAxIGFuZCAyXG4gICAgICAgIHZhciBmMXgyID0gZS50b3VjaGVzWzBdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMXkyID0gZS50b3VjaGVzWzBdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG4gICAgICAgIHZhciBmMngyID0gZS50b3VjaGVzWzFdLmNsaWVudFggLSBvZmZzZXRMZWZ0LCBmMnkyID0gZS50b3VjaGVzWzFdLmNsaWVudFkgLSBvZmZzZXRUb3A7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coIGYxeDIsIGYxeTIgKVxuICAgICAgICAvLyBjb25zb2xlLmxvZyggZjJ4MiwgZjJ5MiApXG5cbiAgICAgICAgdmFyIGRpc3RhbmNlMiA9IGRpc3RhbmNlKCBmMXgyLCBmMXkyLCBmMngyLCBmMnkyICk7XG4gICAgICAgIC8vIHZhciBkaXN0YW5jZTJTcSA9IGRpc3RhbmNlU3EoIGYxeDIsIGYxeTIsIGYyeDIsIGYyeTIgKTtcbiAgICAgICAgLy8gdmFyIGZhY3RvciA9IE1hdGguc3FydCggZGlzdGFuY2UyU3EgKSAvIE1hdGguc3FydCggZGlzdGFuY2UxU3EgKTtcbiAgICAgICAgdmFyIGZhY3RvciA9IGRpc3RhbmNlMiAvIGRpc3RhbmNlMTtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhkaXN0YW5jZTIpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGZhY3RvcilcblxuICAgICAgICBpZiggZmFjdG9yICE9IDEgJiYgdHdvRmluZ2Vyc1N0YXJ0SW5zaWRlKXtcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGZhY3RvcilcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhkaXN0YW5jZTIgKyAnIC8gJyArIGRpc3RhbmNlMSk7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tJyk7XG5cbiAgICAgICAgICAvLyBkZWx0YSBmaW5nZXIxXG4gICAgICAgICAgdmFyIGRmMXggPSBmMXgyIC0gZjF4MTtcbiAgICAgICAgICB2YXIgZGYxeSA9IGYxeTIgLSBmMXkxO1xuXG4gICAgICAgICAgLy8gZGVsdGEgZmluZ2VyIDJcbiAgICAgICAgICB2YXIgZGYyeCA9IGYyeDIgLSBmMngxO1xuICAgICAgICAgIHZhciBkZjJ5ID0gZjJ5MiAtIGYyeTE7XG5cbiAgICAgICAgICAvLyB0cmFuc2xhdGlvbiBpcyB0aGUgbm9ybWFsaXNlZCB2ZWN0b3Igb2YgdGhlIHR3byBmaW5nZXJzIG1vdmVtZW50XG4gICAgICAgICAgLy8gaS5lLiBzbyBwaW5jaGluZyBjYW5jZWxzIG91dCBhbmQgbW92aW5nIHRvZ2V0aGVyIHBhbnNcbiAgICAgICAgICB2YXIgdHggPSAoZGYxeCArIGRmMngpLzI7XG4gICAgICAgICAgdmFyIHR5ID0gKGRmMXkgKyBkZjJ5KS8yO1xuXG4gICAgICAgICAgLy8gYWRqdXN0IGZhY3RvciBieSB0aGUgc3BlZWQgbXVsdGlwbGllclxuICAgICAgICAgIC8vIHZhciBzcGVlZCA9IDEuNTtcbiAgICAgICAgICAvLyBpZiggZmFjdG9yID4gMSApe1xuICAgICAgICAgIC8vICAgZmFjdG9yID0gKGZhY3RvciAtIDEpICogc3BlZWQgKyAxO1xuICAgICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgICAgLy8gICBmYWN0b3IgPSAxIC0gKDEgLSBmYWN0b3IpICogc3BlZWQ7XG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgLy8gbm93IGNhbGN1bGF0ZSB0aGUgem9vbVxuICAgICAgICAgIHZhciB6b29tMSA9IGN5Lnpvb20oKTtcbiAgICAgICAgICB2YXIgem9vbTIgPSB6b29tMSAqIGZhY3RvcjtcbiAgICAgICAgICB2YXIgcGFuMSA9IGN5LnBhbigpO1xuXG4gICAgICAgICAgLy8gdGhlIG1vZGVsIGNlbnRlciBwb2ludCBjb252ZXJ0ZWQgdG8gdGhlIGN1cnJlbnQgcmVuZGVyZWQgcG9zXG4gICAgICAgICAgdmFyIGN0cnggPSBtb2RlbENlbnRlcjFbMF0gKiB6b29tMSArIHBhbjEueDtcbiAgICAgICAgICB2YXIgY3RyeSA9IG1vZGVsQ2VudGVyMVsxXSAqIHpvb20xICsgcGFuMS55O1xuXG4gICAgICAgICAgdmFyIHBhbjIgPSB7XG4gICAgICAgICAgICB4OiAtem9vbTIvem9vbTEgKiAoY3RyeCAtIHBhbjEueCAtIHR4KSArIGN0cngsXG4gICAgICAgICAgICB5OiAtem9vbTIvem9vbTEgKiAoY3RyeSAtIHBhbjEueSAtIHR5KSArIGN0cnlcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2cocGFuMik7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coem9vbTIpO1xuXG4gICAgICAgICAgLy8gcmVtb3ZlIGRyYWdnZWQgZWxlc1xuICAgICAgICAgIGlmKCByLnRvdWNoRGF0YS5zdGFydCApe1xuICAgICAgICAgICAgdmFyIGRyYWdnZWRFbGVzID0gci5kcmFnRGF0YS50b3VjaERyYWdFbGVzO1xuXG4gICAgICAgICAgICBpZiggZHJhZ2dlZEVsZXMgKXsgZm9yKCB2YXIgaSA9IDA7IGkgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICB2YXIgZEVpX3AgPSBkcmFnZ2VkRWxlc1tpXS5fcHJpdmF0ZTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGRFaV9wLmdyYWJiZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgZEVpX3AucnNjcmF0Y2guaW5EcmFnTGF5ZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gfVxuXG4gICAgICAgICAgICB2YXIgc3RhcnRfcCA9IHIudG91Y2hEYXRhLnN0YXJ0Ll9wcml2YXRlO1xuICAgICAgICAgICAgc3RhcnRfcC5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHN0YXJ0X3AuZ3JhYmJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc3RhcnRfcC5yc2NyYXRjaC5pbkRyYWdMYXllciA9IGZhbHNlO1xuXG4gICAgICAgICAgICBuZWVkc1JlZHJhd1tDUi5EUkFHXSA9IHRydWU7XG5cbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0XG4gICAgICAgICAgICAgIC50cmlnZ2VyKCdmcmVlJylcbiAgICAgICAgICAgICAgLnRyaWdnZXIoJ3VuYWN0aXZhdGUnKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGN5LnZpZXdwb3J0KHtcbiAgICAgICAgICAgIHpvb206IHpvb20yLFxuICAgICAgICAgICAgcGFuOiBwYW4yLFxuICAgICAgICAgICAgY2FuY2VsT25GYWlsZWRab29tOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkaXN0YW5jZTEgPSBkaXN0YW5jZTI7XG4gICAgICAgICAgZjF4MSA9IGYxeDI7XG4gICAgICAgICAgZjF5MSA9IGYxeTI7XG4gICAgICAgICAgZjJ4MSA9IGYyeDI7XG4gICAgICAgICAgZjJ5MSA9IGYyeTI7XG5cbiAgICAgICAgICByLnBpbmNoaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlLXByb2plY3RcbiAgICAgICAgaWYgKGUudG91Y2hlc1swXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7IG5vd1swXSA9IHBvc1swXTsgbm93WzFdID0gcG9zWzFdOyB9XG4gICAgICAgIGlmIChlLnRvdWNoZXNbMV0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMV0uY2xpZW50WCwgZS50b3VjaGVzWzFdLmNsaWVudFkpOyBub3dbMl0gPSBwb3NbMF07IG5vd1szXSA9IHBvc1sxXTsgfVxuICAgICAgICBpZiAoZS50b3VjaGVzWzJdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cblxuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gci50b3VjaERhdGEuc3RhcnQ7XG4gICAgICAgIHZhciBsYXN0ID0gci50b3VjaERhdGEubGFzdDtcbiAgICAgICAgdmFyIG5lYXIgPSBuZWFyIHx8IHIuZmluZE5lYXJlc3RFbGVtZW50KG5vd1swXSwgbm93WzFdLCB0cnVlLCB0cnVlKTtcblxuICAgICAgICBpZiggc3RhcnQgIT0gbnVsbCAmJiBzdGFydC5fcHJpdmF0ZS5ncm91cCA9PSAnbm9kZXMnICYmIHIubm9kZUlzRHJhZ2dhYmxlKHN0YXJ0KSApe1xuXG4gICAgICAgICAgaWYoIHJkaXN0MiA+PSByLnRvdWNoVGFwVGhyZXNob2xkMiApeyAvLyB0aGVuIGRyYWdnaW5nIGNhbiBoYXBwZW5cbiAgICAgICAgICAgIHZhciBkcmFnZ2VkRWxlcyA9IHIuZHJhZ0RhdGEudG91Y2hEcmFnRWxlcztcblxuICAgICAgICAgICAgZm9yKCB2YXIgayA9IDA7IGsgPCBkcmFnZ2VkRWxlcy5sZW5ndGg7IGsrKyApe1xuICAgICAgICAgICAgICB2YXIgZHJhZ2dlZEVsZSA9IGRyYWdnZWRFbGVzW2tdO1xuXG4gICAgICAgICAgICAgIGlmKCByLm5vZGVJc0RyYWdnYWJsZShkcmFnZ2VkRWxlKSAmJiBkcmFnZ2VkRWxlLmlzTm9kZSgpICYmIGRyYWdnZWRFbGUuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICAgICAgci5kcmFnRGF0YS5kaWREcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZFBvcyA9IGRyYWdnZWRFbGUuX3ByaXZhdGUucG9zaXRpb247XG4gICAgICAgICAgICAgICAgdmFyIGp1c3RTdGFydGVkRHJhZyA9ICFyLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXM7XG5cbiAgICAgICAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKGRpc3BbMF0pICYmICQkLmlzLm51bWJlcihkaXNwWzFdKSApe1xuICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRpc3BbMF07XG4gICAgICAgICAgICAgICAgICBkUG9zLnkgKz0gZGlzcFsxXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZigganVzdFN0YXJ0ZWREcmFnICl7XG4gICAgICAgICAgICAgICAgICBhZGROb2RlVG9EcmFnKCBkcmFnZ2VkRWxlLCB7IGluRHJhZ0xheWVyOiB0cnVlIH0gKTtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgZHJhZ0RlbHRhID0gci50b3VjaERhdGEuZHJhZ0RlbHRhO1xuXG4gICAgICAgICAgICAgICAgICBpZiggJCQuaXMubnVtYmVyKGRyYWdEZWx0YVswXSkgJiYgJCQuaXMubnVtYmVyKGRyYWdEZWx0YVsxXSkgKXtcbiAgICAgICAgICAgICAgICAgICAgZFBvcy54ICs9IGRyYWdEZWx0YVswXTtcbiAgICAgICAgICAgICAgICAgICAgZFBvcy55ICs9IGRyYWdEZWx0YVsxXTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGNvbCA9IG5ldyAkJC5Db2xsZWN0aW9uKGN5LCBkcmFnZ2VkRWxlKTtcblxuICAgICAgICAgICAgdGNvbC51cGRhdGVDb21wb3VuZEJvdW5kcygpO1xuICAgICAgICAgICAgdGNvbC50cmlnZ2VyKCdwb3NpdGlvbiBkcmFnJyk7XG5cbiAgICAgICAgICAgIHIuaG92ZXJEYXRhLmRyYWdnaW5nRWxlcyA9IHRydWU7XG5cbiAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLkRSQUddID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYoXG4gICAgICAgICAgICAgICAgIHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gPT0gZWFybGllclswXVxuICAgICAgICAgICAgICAmJiByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdID09IGVhcmxpZXJbMV1cbiAgICAgICAgICAgICl7XG5cbiAgICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH0gZWxzZSB7IC8vIG90aGVyaXNlIGtlZXAgdHJhY2sgb2YgZHJhZyBkZWx0YSBmb3IgbGF0ZXJcbiAgICAgICAgICAgIHZhciBkcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgPSByLnRvdWNoRGF0YS5kcmFnRGVsdGEgfHwgW107XG5cbiAgICAgICAgICAgIGlmKCBkcmFnRGVsdGEubGVuZ3RoID09PSAwICl7XG4gICAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKCBkaXNwWzBdICk7XG4gICAgICAgICAgICAgIGRyYWdEZWx0YS5wdXNoKCBkaXNwWzFdICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkcmFnRGVsdGFbMF0gKz0gZGlzcFswXTtcbiAgICAgICAgICAgICAgZHJhZ0RlbHRhWzFdICs9IGRpc3BbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG91Y2htb3ZlIGV2ZW50XG4gICAgICAgIHtcblxuICAgICAgICAgIGlmIChzdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSApO1xuXG4gICAgICAgICAgICBzdGFydC50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZycsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgc3RhcnQudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZW1vdmUnLFxuICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXJ0ID09IG51bGwpIHtcblxuICAgICAgICAgICAgaWYgKG5lYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgICAgbmVhci50cmlnZ2VyKCBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXBkcmFnJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkgKTtcblxuICAgICAgICAgICAgICBuZWFyLnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Ztb3VzZW1vdmUnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmVhciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGN5LnRyaWdnZXIoIG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgICAgY3kudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGFwZHJhZycsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG5cbiAgICAgICAgICAgICAgY3kudHJpZ2dlciggbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndm1vdXNlbW92ZScsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG5lYXIgIT0gbGFzdCkge1xuICAgICAgICAgICAgaWYgKGxhc3QpIHsgbGFzdC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7IHR5cGU6ICd0YXBkcmFnb3V0JywgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9IH0pKTsgfVxuICAgICAgICAgICAgaWYgKG5lYXIpIHsgbmVhci50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7IHR5cGU6ICd0YXBkcmFnb3ZlcicsIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfSB9KSk7IH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByLnRvdWNoRGF0YS5sYXN0ID0gbmVhcjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIHRvIGNhbmNlbCB0YXBob2xkXG4gICAgICAgIGZvciAodmFyIGk9MDtpPG5vdy5sZW5ndGg7aSsrKSB7XG4gICAgICAgICAgaWYgKG5vd1tpXVxuICAgICAgICAgICAgJiYgci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXVxuICAgICAgICAgICAgJiYgTWF0aC5hYnMobm93W2ldIC0gci50b3VjaERhdGEuc3RhcnRQb3NpdGlvbltpXSkgPiA0KSB7XG5cbiAgICAgICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKFxuICAgICAgICAgICAgY2FwdHVyZVxuICAgICAgICAgICAgJiYgKCBzdGFydCA9PSBudWxsIHx8IHN0YXJ0LmlzRWRnZSgpIClcbiAgICAgICAgICAgICYmIGN5LnBhbm5pbmdFbmFibGVkKCkgJiYgY3kudXNlclBhbm5pbmdFbmFibGVkKClcbiAgICAgICAgKXtcblxuICAgICAgICAgIGlmKCByLnN3aXBlUGFubmluZyApe1xuICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICB4OiBkaXNwWzBdICogem9vbSxcbiAgICAgICAgICAgICAgeTogZGlzcFsxXSAqIHpvb21cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgfSBlbHNlIGlmKCByZGlzdDIgPj0gci50b3VjaFRhcFRocmVzaG9sZDIgKXtcbiAgICAgICAgICAgIHIuc3dpcGVQYW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICAgICAgY3kucGFuQnkoe1xuICAgICAgICAgICAgICB4OiBkeCAqIHpvb20sXG4gICAgICAgICAgICAgIHk6IGR5ICogem9vbVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG5cbiAgICAgICAgICAgIGlmKCAhci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uICl7XG4gICAgICAgICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBub3dbMF0sXG4gICAgICAgICAgICAgICAgeTogbm93WzFdXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFJlLXByb2plY3RcbiAgICAgICAgICB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1swXS5jbGllbnRYLCBlLnRvdWNoZXNbMF0uY2xpZW50WSk7XG4gICAgICAgICAgbm93WzBdID0gcG9zWzBdOyBub3dbMV0gPSBwb3NbMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaj0wOyBqPG5vdy5sZW5ndGg7IGorKykgeyBlYXJsaWVyW2pdID0gbm93W2pdOyB9XG4gICAgICAvL3IucmVkcmF3KCk7XG5cbiAgICB9LCAxMDAwLzMwLCB7IHRyYWlsaW5nOiB0cnVlIH0pLCBmYWxzZSk7XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaGNhbmNlbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuXG4gICAgICByLnRvdWNoRGF0YS5jYXB0dXJlID0gZmFsc2U7XG5cbiAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICBzdGFydC51bmFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByLnJlZ2lzdGVyQmluZGluZyh3aW5kb3csICd0b3VjaGVuZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBzdGFydCA9IHIudG91Y2hEYXRhLnN0YXJ0O1xuXG4gICAgICB2YXIgY2FwdHVyZSA9IHIudG91Y2hEYXRhLmNhcHR1cmU7XG5cbiAgICAgIGlmKCBjYXB0dXJlICl7XG4gICAgICAgIHIudG91Y2hEYXRhLmNhcHR1cmUgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHNlbGVjdCA9IHIuZGF0YS5zZWxlY3Q7XG5cbiAgICAgIHIuc3dpcGVQYW5uaW5nID0gZmFsc2U7XG4gICAgICByLmhvdmVyRGF0YS5kcmFnZ2luZ0VsZXMgPSBmYWxzZTtcblxuICAgICAgdmFyIGN5ID0gci5kYXRhLmN5O1xuICAgICAgdmFyIHpvb20gPSBjeS56b29tKCk7XG4gICAgICB2YXIgbm93ID0gci50b3VjaERhdGEubm93O1xuICAgICAgdmFyIGVhcmxpZXIgPSByLnRvdWNoRGF0YS5lYXJsaWVyO1xuICAgICAgXG4gICAgICB2YXIgbmVlZHNSZWRyYXcgPSByLmRhdGEuY2FudmFzTmVlZHNSZWRyYXc7XG5cbiAgICAgIGlmIChlLnRvdWNoZXNbMF0pIHsgdmFyIHBvcyA9IHIucHJvamVjdEludG9WaWV3cG9ydChlLnRvdWNoZXNbMF0uY2xpZW50WCwgZS50b3VjaGVzWzBdLmNsaWVudFkpOyBub3dbMF0gPSBwb3NbMF07IG5vd1sxXSA9IHBvc1sxXTsgfVxuICAgICAgaWYgKGUudG91Y2hlc1sxXSkgeyB2YXIgcG9zID0gci5wcm9qZWN0SW50b1ZpZXdwb3J0KGUudG91Y2hlc1sxXS5jbGllbnRYLCBlLnRvdWNoZXNbMV0uY2xpZW50WSk7IG5vd1syXSA9IHBvc1swXTsgbm93WzNdID0gcG9zWzFdOyB9XG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7IHZhciBwb3MgPSByLnByb2plY3RJbnRvVmlld3BvcnQoZS50b3VjaGVzWzJdLmNsaWVudFgsIGUudG91Y2hlc1syXS5jbGllbnRZKTsgbm93WzRdID0gcG9zWzBdOyBub3dbNV0gPSBwb3NbMV07IH1cblxuICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgIHN0YXJ0LnVuYWN0aXZhdGUoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eFRhcGVuZDtcbiAgICAgIGlmKCByLnRvdWNoRGF0YS5jeHQgKXtcbiAgICAgICAgY3R4VGFwZW5kID0gbmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICB0eXBlOiAnY3h0dGFwZW5kJyxcbiAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoIHN0YXJ0ICl7XG4gICAgICAgICAgc3RhcnQudHJpZ2dlciggY3R4VGFwZW5kICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3kudHJpZ2dlciggY3R4VGFwZW5kICk7XG4gICAgICAgIH1cblxuICAgICAgICAvL2NvbnNvbGUubG9nKCdjeHR0YXBlbmQnKVxuXG4gICAgICAgIGlmKCAhci50b3VjaERhdGEuY3h0RHJhZ2dlZCApe1xuICAgICAgICAgIHZhciBjdHhUYXAgPSBuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgdHlwZTogJ2N4dHRhcCcsXG4gICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmKCBzdGFydCApe1xuICAgICAgICAgICAgc3RhcnQudHJpZ2dlciggY3R4VGFwICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5LnRyaWdnZXIoIGN0eFRhcCApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vY29uc29sZS5sb2coJ2N4dHRhcCcpXG4gICAgICAgIH1cblxuICAgICAgICBpZiggci50b3VjaERhdGEuc3RhcnQgKXsgci50b3VjaERhdGEuc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZCA9IGZhbHNlOyB9XG4gICAgICAgIHIudG91Y2hEYXRhLmN4dCA9IGZhbHNlO1xuICAgICAgICByLnRvdWNoRGF0YS5zdGFydCA9IG51bGw7XG5cbiAgICAgICAgci5yZWRyYXcoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBubyBtb3JlIGJveCBzZWxlY3Rpb24gaWYgd2UgZG9uJ3QgaGF2ZSB0aHJlZSBmaW5nZXJzXG4gICAgICBpZiggIWUudG91Y2hlc1syXSAmJiBjeS5ib3hTZWxlY3Rpb25FbmFibGVkKCkgJiYgci50b3VjaERhdGEuc2VsZWN0aW5nICl7XG4gICAgICAgIHIudG91Y2hEYXRhLnNlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgICBjbGVhclRpbWVvdXQoIHRoaXMudGhyZWVGaW5nZXJTZWxlY3RUaW1lb3V0ICk7XG4gICAgICAgIC8vdGhpcy50aHJlZUZpbmdlclNlbGVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIG5ld2x5U2VsZWN0ZWQgPSBbXTtcbiAgICAgICAgICB2YXIgYm94ID0gci5nZXRBbGxJbkJveCggc2VsZWN0WzBdLCBzZWxlY3RbMV0sIHNlbGVjdFsyXSwgc2VsZWN0WzNdICk7XG5cbiAgICAgICAgICBzZWxlY3RbMF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgc2VsZWN0WzFdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHNlbGVjdFsyXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzZWxlY3RbM10gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgc2VsZWN0WzRdID0gMDtcblxuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLlNFTEVDVF9CT1hdID0gdHJ1ZTtcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGJveCk7XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGk8IGJveC5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGlmKCBib3hbaV0uX3ByaXZhdGUuc2VsZWN0YWJsZSApe1xuICAgICAgICAgICAgICBuZXdseVNlbGVjdGVkLnB1c2goIGJveFtpXSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXdseVNlbENvbCA9IG5ldyAkJC5Db2xsZWN0aW9uKCBjeSwgbmV3bHlTZWxlY3RlZCApO1xuXG4gICAgICAgICAgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ3NpbmdsZScgKXtcbiAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVubWVyZ2UoIG5ld2x5U2VsQ29sICkudW5zZWxlY3QoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXdseVNlbENvbC5zZWxlY3QoKTtcblxuICAgICAgICAgIGlmKCBuZXdseVNlbENvbC5sZW5ndGggPiAwICkge1xuICAgICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByLnJlZHJhdygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAvL30sIDEwMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB1cGRhdGVTdGFydFN0eWxlID0gZmFsc2U7XG5cbiAgICAgIGlmKCBzdGFydCAhPSBudWxsICl7XG4gICAgICAgIHN0YXJ0Ll9wcml2YXRlLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB1cGRhdGVTdGFydFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZS50b3VjaGVzWzJdKSB7XG4gICAgICAgIHIuZGF0YS5iZ0FjdGl2ZVBvc2lzdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgbmVlZHNSZWRyYXdbQ1IuU0VMRUNUX0JPWF0gPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMV0pIHtcblxuICAgICAgfSBlbHNlIGlmIChlLnRvdWNoZXNbMF0pIHtcblxuICAgICAgLy8gTGFzdCB0b3VjaCByZWxlYXNlZFxuICAgICAgfSBlbHNlIGlmICghZS50b3VjaGVzWzBdKSB7XG5cbiAgICAgICAgci5kYXRhLmJnQWN0aXZlUG9zaXN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBuZWVkc1JlZHJhd1tDUi5TRUxFQ1RfQk9YXSA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICB2YXIgZHJhZ2dlZEVsZXMgPSByLmRyYWdEYXRhLnRvdWNoRHJhZ0VsZXM7XG5cbiAgICAgICAgaWYgKHN0YXJ0ICE9IG51bGwgKSB7XG5cbiAgICAgICAgICB2YXIgc3RhcnRXYXNHcmFiYmVkID0gc3RhcnQuX3ByaXZhdGUuZ3JhYmJlZDtcbiAgICAgICAgICBcbiAgICAgICAgICBmcmVlRHJhZ2dlZEVsZW1lbnRzKCBkcmFnZ2VkRWxlcyApO1xuXG4gICAgICAgICAgbmVlZHNSZWRyYXdbQ1IuRFJBR10gPSB0cnVlO1xuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggc3RhcnRXYXNHcmFiYmVkICl7XG4gICAgICAgICAgICBzdGFydC50cmlnZ2VyKCdmcmVlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3RhcnRcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0b3VjaGVuZCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICB0eXBlOiAndGFwZW5kJyxcbiAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgIHR5cGU6ICd2bW91c2V1cCcsXG4gICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgfSkpXG4gICAgICAgICAgO1xuXG4gICAgICAgICAgc3RhcnQudW5hY3RpdmF0ZSgpO1xuXG4gICAgICAgICAgci50b3VjaERhdGEuc3RhcnQgPSBudWxsO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG5lYXIgPSByLmZpbmROZWFyZXN0RWxlbWVudChub3dbMF0sIG5vd1sxXSwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgICBpZiAobmVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICBuZWFyXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGVuZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2V1cCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChuZWFyID09IG51bGwpIHtcbiAgICAgICAgICAgIGN5XG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RvdWNoZW5kJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcGVuZCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2bW91c2V1cCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkeCA9IHIudG91Y2hEYXRhLnN0YXJ0UG9zaXRpb25bMF0gLSBub3dbMF07XG4gICAgICAgIHZhciBkeDIgPSBkeCAqIGR4O1xuICAgICAgICB2YXIgZHkgPSByLnRvdWNoRGF0YS5zdGFydFBvc2l0aW9uWzFdIC0gbm93WzFdO1xuICAgICAgICB2YXIgZHkyID0gZHkgKiBkeTtcbiAgICAgICAgdmFyIGRpc3QyID0gZHgyICsgZHkyO1xuICAgICAgICB2YXIgcmRpc3QyID0gZGlzdDIgKiB6b29tICogem9vbTtcblxuICAgICAgICAvLyBQcmVwYXJlIHRvIHNlbGVjdCB0aGUgY3VycmVudGx5IHRvdWNoZWQgbm9kZSwgb25seSBpZiBpdCBoYXNuJ3QgYmVlbiBkcmFnZ2VkIHBhc3QgYSBjZXJ0YWluIGRpc3RhbmNlXG4gICAgICAgIGlmIChzdGFydCAhPSBudWxsXG4gICAgICAgICAgICAmJiAhci5kcmFnRGF0YS5kaWREcmFnIC8vIGRpZG4ndCBkcmFnIG5vZGVzIGFyb3VuZFxuICAgICAgICAgICAgJiYgc3RhcnQuX3ByaXZhdGUuc2VsZWN0YWJsZVxuICAgICAgICAgICAgJiYgcmRpc3QyIDwgci50b3VjaFRhcFRocmVzaG9sZDJcbiAgICAgICAgICAgICYmICFyLnBpbmNoaW5nIC8vIHBpbmNoIHRvIHpvb20gc2hvdWxkIG5vdCBhZmZlY3Qgc2VsZWN0aW9uXG4gICAgICAgICkge1xuXG4gICAgICAgICAgaWYoIGN5LnNlbGVjdGlvblR5cGUoKSA9PT0gJ3NpbmdsZScgKXtcbiAgICAgICAgICAgIGN5LiQoJzpzZWxlY3RlZCcpLnVubWVyZ2UoIHN0YXJ0ICkudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIHN0YXJ0LnNlbGVjdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiggc3RhcnQuc2VsZWN0ZWQoKSApe1xuICAgICAgICAgICAgICBzdGFydC51bnNlbGVjdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RhcnQuc2VsZWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdXBkYXRlU3RhcnRTdHlsZSA9IHRydWU7XG5cblxuICAgICAgICAgIG5lZWRzUmVkcmF3W0NSLk5PREVdID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRhcCBldmVudCwgcm91Z2hseSBzYW1lIGFzIG1vdXNlIGNsaWNrIGV2ZW50IGZvciB0b3VjaFxuICAgICAgICBpZiAoIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPT09IGZhbHNlICkge1xuXG4gICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGFydFxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0YXAnLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgLnRyaWdnZXIobmV3ICQkLkV2ZW50KGUsIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndmNsaWNrJyxcbiAgICAgICAgICAgICAgICBjeVBvc2l0aW9uOiB7IHg6IG5vd1swXSwgeTogbm93WzFdIH1cbiAgICAgICAgICAgICAgfSkpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN5XG4gICAgICAgICAgICAgIC50cmlnZ2VyKG5ldyAkJC5FdmVudChlLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RhcCcsXG4gICAgICAgICAgICAgICAgY3lQb3NpdGlvbjogeyB4OiBub3dbMF0sIHk6IG5vd1sxXSB9XG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAudHJpZ2dlcihuZXcgJCQuRXZlbnQoZSwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd2Y2xpY2snLFxuICAgICAgICAgICAgICAgIGN5UG9zaXRpb246IHsgeDogbm93WzBdLCB5OiBub3dbMV0gfVxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgIDtcbiAgICAgICAgICB9XG5cbi8vICAgICAgICAgIGNvbnNvbGUubG9nKCd0YXAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIudG91Y2hEYXRhLnNpbmdsZVRvdWNoTW92ZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IG5vdy5sZW5ndGg7IGorKyApeyBlYXJsaWVyW2pdID0gbm93W2pdOyB9XG5cbiAgICAgIHIuZHJhZ0RhdGEuZGlkRHJhZyA9IGZhbHNlOyAvLyByZXNldCBmb3IgbmV4dCBtb3VzZWRvd25cblxuICAgICAgaWYoIGUudG91Y2hlcy5sZW5ndGggPT09IDAgKXtcbiAgICAgICAgci50b3VjaERhdGEuZHJhZ0RlbHRhID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmKCB1cGRhdGVTdGFydFN0eWxlICYmIHN0YXJ0ICl7XG4gICAgICAgIHN0YXJ0LnVwZGF0ZVN0eWxlKGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgaWYoIGUudG91Y2hlcy5sZW5ndGggPCAyICl7XG4gICAgICAgIHIucGluY2hpbmcgPSBmYWxzZTtcbiAgICAgICAgbmVlZHNSZWRyYXdbQ1IuTk9ERV0gPSB0cnVlO1xuICAgICAgICByLnJlZHJhdygpO1xuICAgICAgfVxuXG4gICAgICAvL3IucmVkcmF3KCk7XG5cbiAgICB9LCBmYWxzZSk7XG4gIH07XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgQ2FudmFzUmVuZGVyZXIgPSAkJCgncmVuZGVyZXInLCAnY2FudmFzJyk7XG4gIHZhciByZW5kZXJlciA9IENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZTtcbiAgdmFyIHVzZVBhdGhzID0gQ2FudmFzUmVuZGVyZXIudXNlUGF0aHMoKTtcblxuICAvLyBOb2RlIHNoYXBlIGNvbnRyYWN0OlxuICAvL1xuICAvLyBkcmF3OiBkcmF3XG4gIC8vIGludGVyc2VjdExpbmU6IHJlcG9ydCBpbnRlcnNlY3Rpb24gZnJvbSB4LCB5LCB0byBub2RlIGNlbnRlclxuICAvLyBjaGVja1BvaW50OiBjaGVjayB4LCB5IGluIG5vZGVcblxuICB2YXIgbm9kZVNoYXBlcyA9IENhbnZhc1JlbmRlcmVyLm5vZGVTaGFwZXMgPSB7fTtcblxuICB2YXIgc2luMCA9IE1hdGguc2luKDApO1xuICB2YXIgY29zMCA9IE1hdGguY29zKDApO1xuXG4gIHZhciBzaW4gPSB7fTtcbiAgdmFyIGNvcyA9IHt9O1xuXG4gIHZhciBlbGxpcHNlU3RlcFNpemUgPSAwLjE7XG5cbiAgZm9yICh2YXIgaSA9IDAgKiBNYXRoLlBJOyBpIDwgMiAqIE1hdGguUEk7IGkgKz0gZWxsaXBzZVN0ZXBTaXplICkge1xuICAgIHNpbltpXSA9IE1hdGguc2luKGkpO1xuICAgIGNvc1tpXSA9IE1hdGguY29zKGkpO1xuICB9XG5cbiAgbm9kZVNoYXBlc1snZWxsaXBzZSddID0ge1xuICAgIGRyYXc6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIG5vZGVTaGFwZXNbJ2VsbGlwc2UnXS5kcmF3UGF0aChjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgIH0sXG4gICAgXG4gICAgZHJhd1BhdGg6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIFxuICAgICAgaWYoIHVzZVBhdGhzICl7XG4gICAgICAgIGlmKCBjb250ZXh0LmJlZ2luUGF0aCApeyBjb250ZXh0LmJlZ2luUGF0aCgpOyB9XG5cbiAgICAgICAgdmFyIHhQb3MsIHlQb3M7XG4gICAgICAgIHZhciBydyA9IHdpZHRoLzI7XG4gICAgICAgIHZhciByaCA9IGhlaWdodC8yO1xuICAgICAgICBmb3IgKHZhciBpID0gMCAqIE1hdGguUEk7IGkgPCAyICogTWF0aC5QSTsgaSArPSBlbGxpcHNlU3RlcFNpemUgKSB7XG4gICAgICAgICAgICB4UG9zID0gY2VudGVyWCAtIChydyAqIHNpbltpXSkgKiBzaW4wICsgKHJ3ICogY29zW2ldKSAqIGNvczA7XG4gICAgICAgICAgICB5UG9zID0gY2VudGVyWSArIChyaCAqIGNvc1tpXSkgKiBzaW4wICsgKHJoICogc2luW2ldKSAqIGNvczA7XG5cbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5tb3ZlVG8oeFBvcywgeVBvcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHQubGluZVRvKHhQb3MsIHlQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYoIGNvbnRleHQuYmVnaW5QYXRoICl7IGNvbnRleHQuYmVnaW5QYXRoKCk7IH1cbiAgICAgICAgY29udGV4dC50cmFuc2xhdGUoY2VudGVyWCwgY2VudGVyWSk7XG4gICAgICAgIGNvbnRleHQuc2NhbGUod2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICAgICAgLy8gQXQgb3JpZ2luLCByYWRpdXMgMSwgMCB0byAycGlcbiAgICAgICAgY29udGV4dC5hcmMoMCwgMCwgMSwgMCwgTWF0aC5QSSAqIDIgKiAwLjk5OSwgZmFsc2UpOyAvLyAqMC45OTkgYi9jIGNocm9tZSByZW5kZXJpbmcgYnVnIG9uIGZ1bGwgY2lyY2xlXG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgICAgICAgY29udGV4dC5zY2FsZSgyL3dpZHRoLCAyL2hlaWdodCk7XG4gICAgICAgIGNvbnRleHQudHJhbnNsYXRlKC1jZW50ZXJYLCAtY2VudGVyWSk7XG5cbiAgICAgIH1cbiAgICAgIFxuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24obm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICB2YXIgaW50ZXJzZWN0ID0gJCQubWF0aC5pbnRlcnNlY3RMaW5lRWxsaXBzZShcbiAgICAgICAgeCwgeSxcbiAgICAgICAgbm9kZVgsXG4gICAgICAgIG5vZGVZLFxuICAgICAgICB3aWR0aCAvIDIgKyBwYWRkaW5nLFxuICAgICAgICBoZWlnaHQgLyAyICsgcGFkZGluZyk7XG4gICAgICBcbiAgICAgIHJldHVybiBpbnRlcnNlY3Q7XG4gICAgfSxcbiAgICBcbiAgICBpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uKFxuICAgICAgeDEsIHkxLCB4MiwgeTIsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICAgIFxuICAgICAgcmV0dXJuICQkLm1hdGguYm94SW50ZXJzZWN0RWxsaXBzZShcbiAgICAgICAgeDEsIHkxLCB4MiwgeTIsIHBhZGRpbmcsIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgIH0sXG4gICAgXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oXG4gICAgICB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICBcbi8vICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzKTtcbiAgICAgIFxuICAgICAgeCAtPSBjZW50ZXJYO1xuICAgICAgeSAtPSBjZW50ZXJZO1xuICAgICAgXG4gICAgICB4IC89ICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIHkgLz0gKGhlaWdodCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIChNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpIDw9IDEpO1xuICAgIH1cbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIGdlbmVyYXRlUG9seWdvbiggbmFtZSwgcG9pbnRzICl7XG4gICAgbm9kZVNoYXBlc1tuYW1lXSA9IHtcbiAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgXG4gICAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uKGNvbnRleHQsXG4gICAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgIG5vZGVTaGFwZXNbbmFtZV0ucG9pbnRzKTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGRyYXdQYXRoOiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJlbmRlcmVyLmRyYXdQb2x5Z29uUGF0aChjb250ZXh0LFxuICAgICAgICAgIGNlbnRlclgsIGNlbnRlclksXG4gICAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICBub2RlU2hhcGVzW25hbWVdLnBvaW50cyk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICBpbnRlcnNlY3RMaW5lOiBmdW5jdGlvbihub2RlWCwgbm9kZVksIHdpZHRoLCBoZWlnaHQsIHgsIHksIHBhZGRpbmcpIHtcbiAgICAgICAgcmV0dXJuICQkLm1hdGgucG9seWdvbkludGVyc2VjdExpbmUoXG4gICAgICAgICAgICB4LCB5LFxuICAgICAgICAgICAgbm9kZVNoYXBlc1tuYW1lXS5wb2ludHMsXG4gICAgICAgICAgICBub2RlWCxcbiAgICAgICAgICAgIG5vZGVZLFxuICAgICAgICAgICAgd2lkdGggLyAyLCBoZWlnaHQgLyAyLFxuICAgICAgICAgICAgcGFkZGluZyk7XG4gICAgICB9LFxuICAgICAgXG4gICAgICBpbnRlcnNlY3RCb3g6IGZ1bmN0aW9uKFxuICAgICAgICB4MSwgeTEsIHgyLCB5MixcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgXG4gICAgICAgIGNlbnRlclksIHBhZGRpbmcpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBwb2ludHMgPSBub2RlU2hhcGVzW25hbWVdLnBvaW50cztcbiAgICAgICAgXG4gICAgICAgIHJldHVybiAkJC5tYXRoLmJveEludGVyc2VjdFBvbHlnb24oXG4gICAgICAgICAgeDEsIHkxLCB4MiwgeTIsXG4gICAgICAgICAgcG9pbnRzLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBcbiAgICAgICAgICBjZW50ZXJZLCBbMCwgLTFdLCBwYWRkaW5nKTtcbiAgICAgIH0sXG4gICAgICBcbiAgICAgIGNoZWNrUG9pbnQ6IGZ1bmN0aW9uKFxuICAgICAgICB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgbm9kZVNoYXBlc1tuYW1lXS5wb2ludHMsXG4gICAgICAgICAgY2VudGVyWCwgY2VudGVyWSwgd2lkdGgsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBcbiAgZ2VuZXJhdGVQb2x5Z29uKCAndHJpYW5nbGUnLCAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSgzLCAwKSApO1xuICBcbiAgZ2VuZXJhdGVQb2x5Z29uKCAnc3F1YXJlJywgJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNCwgMCkgKTtcbiAgbm9kZVNoYXBlc1sncmVjdGFuZ2xlJ10gPSBub2RlU2hhcGVzWydzcXVhcmUnXTtcbiAgXG4gIG5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10gPSB7XG4gICAgcG9pbnRzOiAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg0LCAwKSxcbiAgICBcbiAgICBkcmF3OiBmdW5jdGlvbihjb250ZXh0LCBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICByZW5kZXJlci5kcmF3Um91bmRSZWN0YW5nbGUoY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgMTApO1xuICAgIH0sXG4gICAgXG4gICAgZHJhd1BhdGg6IGZ1bmN0aW9uKGNvbnRleHQsIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJlbmRlcmVyLmRyYXdSb3VuZFJlY3RhbmdsZVBhdGgoY29udGV4dCxcbiAgICAgICAgY2VudGVyWCwgY2VudGVyWSxcbiAgICAgICAgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgMTApO1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0TGluZTogZnVuY3Rpb24obm9kZVgsIG5vZGVZLCB3aWR0aCwgaGVpZ2h0LCB4LCB5LCBwYWRkaW5nKSB7XG4gICAgICByZXR1cm4gJCQubWF0aC5yb3VuZFJlY3RhbmdsZUludGVyc2VjdExpbmUoXG4gICAgICAgICAgeCwgeSxcbiAgICAgICAgICBub2RlWCxcbiAgICAgICAgICBub2RlWSxcbiAgICAgICAgICB3aWR0aCwgaGVpZ2h0LFxuICAgICAgICAgIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgaW50ZXJzZWN0Qm94OiBmdW5jdGlvbihcbiAgICAgIHgxLCB5MSwgeDIsIHkyLFxuICAgICAgd2lkdGgsIGhlaWdodCwgY2VudGVyWCwgXG4gICAgICBjZW50ZXJZLCBwYWRkaW5nKSB7XG5cbiAgICAgIHJldHVybiAkJC5tYXRoLnJvdW5kUmVjdGFuZ2xlSW50ZXJzZWN0Qm94KFxuICAgICAgICB4MSwgeTEsIHgyLCB5MiwgXG4gICAgICAgIHdpZHRoLCBoZWlnaHQsIGNlbnRlclgsIGNlbnRlclksIHBhZGRpbmcpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gTG9va3MgbGlrZSB0aGUgd2lkdGggcGFzc2VkIGludG8gdGhpcyBmdW5jdGlvbiBpcyBhY3R1YWxseSB0aGUgdG90YWwgd2lkdGggLyAyXG4gICAgY2hlY2tQb2ludDogZnVuY3Rpb24oXG4gICAgICB4LCB5LCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXJYLCBjZW50ZXJZKSB7XG4gICAgICBcbiAgICAgIHZhciBjb3JuZXJSYWRpdXMgPSAkJC5tYXRoLmdldFJvdW5kUmVjdGFuZ2xlUmFkaXVzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBDaGVjayBoQm94XG4gICAgICBpZiAoJCQubWF0aC5wb2ludEluc2lkZVBvbHlnb24oeCwgeSwgbm9kZVNoYXBlc1sncm91bmRyZWN0YW5nbGUnXS5wb2ludHMsXG4gICAgICAgIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgLSAyICogY29ybmVyUmFkaXVzLCBbMCwgLTFdLCBwYWRkaW5nKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQ2hlY2sgdkJveFxuICAgICAgaWYgKCQkLm1hdGgucG9pbnRJbnNpZGVQb2x5Z29uKHgsIHksIG5vZGVTaGFwZXNbJ3JvdW5kcmVjdGFuZ2xlJ10ucG9pbnRzLFxuICAgICAgICBjZW50ZXJYLCBjZW50ZXJZLCB3aWR0aCAtIDIgKiBjb3JuZXJSYWRpdXMsIGhlaWdodCwgWzAsIC0xXSwgcGFkZGluZykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBjaGVja0luRWxsaXBzZSA9IGZ1bmN0aW9uKHgsIHksIGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQsIHBhZGRpbmcpIHtcbiAgICAgICAgeCAtPSBjZW50ZXJYO1xuICAgICAgICB5IC09IGNlbnRlclk7XG4gICAgICAgIFxuICAgICAgICB4IC89ICh3aWR0aCAvIDIgKyBwYWRkaW5nKTtcbiAgICAgICAgeSAvPSAoaGVpZ2h0IC8gMiArIHBhZGRpbmcpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIChNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpIDw9IDEpO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgXG4gICAgICAvLyBDaGVjayB0b3AgbGVmdCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksXG4gICAgICAgIGNlbnRlclggLSB3aWR0aCAvIDIgKyBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nKSkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8qXG4gICAgICBpZiAocmVuZGVyZXIuYm94SW50ZXJzZWN0RWxsaXBzZSh4LCB5LCB4LCB5LCBwYWRkaW5nLCBcbiAgICAgICAgY29ybmVyUmFkaXVzICogMiwgY29ybmVyUmFkaXVzICogMixcbiAgICAgICAgY2VudGVyWCAtIHdpZHRoICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjZW50ZXJZIC0gaGVpZ2h0ICsgY29ybmVyUmFkaXVzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgICovXG4gICAgICBcbiAgICAgIC8vIENoZWNrIHRvcCByaWdodCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksXG4gICAgICAgIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgLSBoZWlnaHQgLyAyICsgY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nKSkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGJvdHRvbSByaWdodCBxdWFydGVyIGNpcmNsZVxuICAgICAgaWYgKGNoZWNrSW5FbGxpcHNlKHgsIHksXG4gICAgICAgIGNlbnRlclggKyB3aWR0aCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNlbnRlclkgKyBoZWlnaHQgLyAyIC0gY29ybmVyUmFkaXVzLFxuICAgICAgICBjb3JuZXJSYWRpdXMgKiAyLCBjb3JuZXJSYWRpdXMgKiAyLCBwYWRkaW5nKSkge1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIENoZWNrIGJvdHRvbSBsZWZ0IHF1YXJ0ZXIgY2lyY2xlXG4gICAgICBpZiAoY2hlY2tJbkVsbGlwc2UoeCwgeSxcbiAgICAgICAgY2VudGVyWCAtIHdpZHRoIC8gMiArIGNvcm5lclJhZGl1cyxcbiAgICAgICAgY2VudGVyWSArIGhlaWdodCAvIDIgLSBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGNvcm5lclJhZGl1cyAqIDIsIGNvcm5lclJhZGl1cyAqIDIsIHBhZGRpbmcpKSB7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgXG4gIGdlbmVyYXRlUG9seWdvbiggJ2RpYW1vbmQnLCBbXG4gICAgMCwgMSxcbiAgICAxLCAwLFxuICAgIDAsIC0xLFxuICAgIC0xLCAwXG4gIF0gKTtcbiAgXG4gIGdlbmVyYXRlUG9seWdvbiggJ3BlbnRhZ29uJywgJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzRml0VG9TcXVhcmUoNSwgMCkgKTtcbiAgXG4gIGdlbmVyYXRlUG9seWdvbiggJ2hleGFnb24nLCAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg2LCAwKSApO1xuICBcbiAgZ2VuZXJhdGVQb2x5Z29uKCAnaGVwdGFnb24nLCAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHNGaXRUb1NxdWFyZSg3LCAwKSApO1xuICBcbiAgZ2VuZXJhdGVQb2x5Z29uKCAnb2N0YWdvbicsICQkLm1hdGguZ2VuZXJhdGVVbml0TmdvblBvaW50c0ZpdFRvU3F1YXJlKDgsIDApICk7XG4gICAgXG4gIHZhciBzdGFyNVBvaW50cyA9IG5ldyBBcnJheSgyMCk7XG4gIHtcbiAgICB2YXIgb3V0ZXJQb2ludHMgPSAkJC5tYXRoLmdlbmVyYXRlVW5pdE5nb25Qb2ludHMoNSwgMCk7XG4gICAgdmFyIGlubmVyUG9pbnRzID0gJCQubWF0aC5nZW5lcmF0ZVVuaXROZ29uUG9pbnRzKDUsIE1hdGguUEkgLyA1KTtcbiAgICBcbiAgLy8gIGNvbnNvbGUubG9nKG91dGVyUG9pbnRzKTtcbiAgLy8gIGNvbnNvbGUubG9nKGlubmVyUG9pbnRzKTtcbiAgICBcbiAgICAvLyBPdXRlciByYWRpdXMgaXMgMTsgaW5uZXIgcmFkaXVzIG9mIHN0YXIgaXMgc21hbGxlclxuICAgIHZhciBpbm5lclJhZGl1cyA9IDAuNSAqICgzIC0gTWF0aC5zcXJ0KDUpKTtcbiAgICBpbm5lclJhZGl1cyAqPSAxLjU3O1xuICAgIFxuICAgIGZvciAodmFyIGk9MDtpPGlubmVyUG9pbnRzLmxlbmd0aC8yO2krKykge1xuICAgICAgaW5uZXJQb2ludHNbaSoyXSAqPSBpbm5lclJhZGl1cztcbiAgICAgIGlubmVyUG9pbnRzW2kqMisxXSAqPSBpbm5lclJhZGl1cztcbiAgICB9XG4gICAgXG4gICAgZm9yICh2YXIgaT0wO2k8MjAvNDtpKyspIHtcbiAgICAgIHN0YXI1UG9pbnRzW2kqNF0gPSBvdXRlclBvaW50c1tpKjJdO1xuICAgICAgc3RhcjVQb2ludHNbaSo0KzFdID0gb3V0ZXJQb2ludHNbaSoyKzFdO1xuICAgICAgXG4gICAgICBzdGFyNVBvaW50c1tpKjQrMl0gPSBpbm5lclBvaW50c1tpKjJdO1xuICAgICAgc3RhcjVQb2ludHNbaSo0KzNdID0gaW5uZXJQb2ludHNbaSoyKzFdO1xuICAgIH1cbiAgICBcbiAgLy8gIGNvbnNvbGUubG9nKHN0YXI1UG9pbnRzKTtcbiAgfVxuXG4gIHN0YXI1UG9pbnRzID0gJCQubWF0aC5maXRQb2x5Z29uVG9TcXVhcmUoIHN0YXI1UG9pbnRzICk7XG4gIFxuICBnZW5lcmF0ZVBvbHlnb24oICdzdGFyJywgc3RhcjVQb2ludHMgKTtcbiAgXG4gIGdlbmVyYXRlUG9seWdvbiggJ3ZlZScsIFtcbiAgICAtMSwgLTEsXG4gICAgMCwgLTAuMzMzLFxuICAgIDEsIC0xLFxuICAgIDAsIDFcbiAgXSApO1xuICBcbiAgZ2VuZXJhdGVQb2x5Z29uKCAncmhvbWJvaWQnLCBbXG4gICAgLTEsIC0xLFxuICAgIDAuMzMzLCAtMSxcbiAgICAxLCAxLFxuICAgIC0wLjMzMywgMVxuICBdICk7XG5cbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBhbmltYXRlOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHNob3cgdGhlIGxheW91dCBhcyBpdCdzIHJ1bm5pbmdcbiAgICBtYXhTaW11bGF0aW9uVGltZTogNDAwMCwgLy8gbWF4IGxlbmd0aCBpbiBtcyB0byBydW4gdGhlIGxheW91dFxuICAgIGZpdDogdHJ1ZSwgLy8gb24gZXZlcnkgbGF5b3V0IHJlcG9zaXRpb24gb2Ygbm9kZXMsIGZpdCB0aGUgdmlld3BvcnRcbiAgICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyBhcm91bmQgdGhlIHNpbXVsYXRpb25cbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICB1bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmc6IGZhbHNlLCAvLyBzbyB5b3UgY2FuJ3QgZHJhZyBub2RlcyBkdXJpbmcgbGF5b3V0XG5cbiAgICAvLyBjYWxsYmFja3Mgb24gbGF5b3V0IGV2ZW50c1xuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5IFxuICAgIHN0b3A6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuXG4gICAgLy8gZm9yY2VzIHVzZWQgYnkgYXJib3IgKHVzZSBhcmJvciBkZWZhdWx0IG9uIHVuZGVmaW5lZClcbiAgICByZXB1bHNpb246IHVuZGVmaW5lZCxcbiAgICBzdGlmZm5lc3M6IHVuZGVmaW5lZCxcbiAgICBmcmljdGlvbjogdW5kZWZpbmVkLFxuICAgIGdyYXZpdHk6IHRydWUsXG4gICAgZnBzOiB1bmRlZmluZWQsXG4gICAgcHJlY2lzaW9uOiB1bmRlZmluZWQsXG5cbiAgICAvLyBzdGF0aWMgbnVtYmVycyBvciBmdW5jdGlvbnMgdGhhdCBkeW5hbWljYWxseSByZXR1cm4gd2hhdCB0aGVzZVxuICAgIC8vIHZhbHVlcyBzaG91bGQgYmUgZm9yIGVhY2ggZWxlbWVudFxuICAgIC8vIGUuZy4gbm9kZU1hc3M6IGZ1bmN0aW9uKG4peyByZXR1cm4gbi5kYXRhKCd3ZWlnaHQnKSB9XG4gICAgbm9kZU1hc3M6IHVuZGVmaW5lZCwgXG4gICAgZWRnZUxlbmd0aDogdW5kZWZpbmVkLFxuXG4gICAgc3RlcFNpemU6IDAuMSwgLy8gc21vb3RoaW5nIG9mIGFyYm9yIGJvdW5kaW5nIGJveFxuXG4gICAgLy8gZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIHN5c3RlbSBpcyBzdGFibGUgdG8gaW5kaWNhdGVcbiAgICAvLyB0aGF0IHRoZSBsYXlvdXQgY2FuIGJlIHN0b3BwZWRcbiAgICBzdGFibGVFbmVyZ3k6IGZ1bmN0aW9uKCBlbmVyZ3kgKXtcbiAgICAgIHZhciBlID0gZW5lcmd5OyBcbiAgICAgIHJldHVybiAoZS5tYXggPD0gMC41KSB8fCAoZS5tZWFuIDw9IDAuMyk7XG4gICAgfSxcblxuICAgIC8vIGluZmluaXRlIGxheW91dCBvcHRpb25zXG4gICAgaW5maW5pdGU6IGZhbHNlIC8vIG92ZXJyaWRlcyBhbGwgb3RoZXIgb3B0aW9ucyBmb3IgYSBmb3JjZXMtYWxsLXRoZS10aW1lIG1vZGVcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIEFyYm9yTGF5b3V0KG9wdGlvbnMpe1xuICAgIHRoaXMuX3ByaXZhdGUgPSB7fTtcblxuICAgIHRoaXMuX3ByaXZhdGUub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgICBcbiAgQXJib3JMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGxheW91dCA9IHRoaXM7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLl9wcml2YXRlLm9wdGlvbnM7XG5cbiAgICAkJC51dGlsLnJlcXVpcmUoJ2FyYm9yJywgZnVuY3Rpb24oYXJib3Ipe1xuXG4gICAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgICB2YXIgZWRnZXMgPSBlbGVzLmVkZ2VzKCk7XG4gICAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICAgIH0gKTtcbiAgICAgIHZhciBzaW1VcGRhdGluZ1BvcyA9IGZhbHNlO1xuXG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGZvciBvbGQgYW5pbWF0aW9uIG9wdGlvblxuICAgICAgaWYoIG9wdGlvbnMubGl2ZVVwZGF0ZSAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgIG9wdGlvbnMuYW5pbWF0ZSA9IG9wdGlvbnMubGl2ZVVwZGF0ZTtcbiAgICAgIH1cblxuICAgICAgLy8gYXJib3IgZG9lc24ndCB3b3JrIHdpdGgganVzdCAxIG5vZGUgXG4gICAgICBpZiggZWxlcy5ub2RlcygpLnNpemUoKSA8PSAxICl7XG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgIGN5LnJlc2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBlbGVzLm5vZGVzKCkucG9zaXRpb24oe1xuICAgICAgICAgIHg6IE1hdGgucm91bmQoIChiYi54MSArIGJiLngyKS8yICksXG4gICAgICAgICAgeTogTWF0aC5yb3VuZCggKGJiLnkxICsgYmIueTIpLzIgKVxuICAgICAgICB9KTtcblxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3lzID0gbGF5b3V0Ll9wcml2YXRlLnN5c3RlbSA9IGFyYm9yLlBhcnRpY2xlU3lzdGVtKCk7XG5cbiAgICAgIHN5cy5wYXJhbWV0ZXJzKHtcbiAgICAgICAgcmVwdWxzaW9uOiBvcHRpb25zLnJlcHVsc2lvbixcbiAgICAgICAgc3RpZmZuZXNzOiBvcHRpb25zLnN0aWZmbmVzcywgXG4gICAgICAgIGZyaWN0aW9uOiBvcHRpb25zLmZyaWN0aW9uLCBcbiAgICAgICAgZ3Jhdml0eTogb3B0aW9ucy5ncmF2aXR5LCBcbiAgICAgICAgZnBzOiBvcHRpb25zLmZwcywgXG4gICAgICAgIGR0OiBvcHRpb25zLmR0LCBcbiAgICAgICAgcHJlY2lzaW9uOiBvcHRpb25zLnByZWNpc2lvblxuICAgICAgfSk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgJiYgb3B0aW9ucy5maXQgKXtcbiAgICAgICAgY3kuZml0KCBiYiwgb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHZhciBkb25lVGltZSA9IDI1MDtcbiAgICAgIHZhciBkb25lVGltZW91dDtcbiAgICAgIFxuICAgICAgdmFyIHJlYWR5ID0gZmFsc2U7XG4gICAgICBcbiAgICAgIHZhciBsYXN0RHJhdyA9ICtuZXcgRGF0ZSgpO1xuICAgICAgdmFyIHN5c1JlbmRlcmVyID0ge1xuICAgICAgICBpbml0OiBmdW5jdGlvbihzeXN0ZW0pe1xuICAgICAgICB9LFxuICAgICAgICByZWRyYXc6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdmFyIGVuZXJneSA9IHN5cy5lbmVyZ3koKTtcblxuICAgICAgICAgIC8vIGlmIHdlJ3JlIHN0YWJsZSAoYWNjb3JkaW5nIHRvIHRoZSBjbGllbnQpLCB3ZSdyZSBkb25lXG4gICAgICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlICYmIG9wdGlvbnMuc3RhYmxlRW5lcmd5ICE9IG51bGwgJiYgZW5lcmd5ICE9IG51bGwgJiYgZW5lcmd5Lm4gPiAwICYmIG9wdGlvbnMuc3RhYmxlRW5lcmd5KGVuZXJneSkgKXtcbiAgICAgICAgICAgIGxheW91dC5zdG9wKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlICYmIGRvbmVUaW1lICE9IEluZmluaXR5ICl7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZG9uZVRpbWVvdXQpO1xuICAgICAgICAgICAgZG9uZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvbmVIYW5kbGVyLCBkb25lVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHZhciBtb3ZlZE5vZGVzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICAgIFxuICAgICAgICAgIHN5cy5lYWNoTm9kZShmdW5jdGlvbihuLCBwb2ludCl7IFxuICAgICAgICAgICAgdmFyIGRhdGEgPSBuLmRhdGE7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRhdGEuZWxlbWVudDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIG5vZGUgPT0gbnVsbCApe1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCAhbm9kZS5sb2NrZWQoKSAmJiAhbm9kZS5ncmFiYmVkKCkgKXtcbiAgICAgICAgICAgICAgbm9kZS5zaWxlbnRQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgeDogYmIueDEgKyBwb2ludC54LFxuICAgICAgICAgICAgICAgIHk6IGJiLnkxICsgcG9pbnQueVxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBtb3ZlZE5vZGVzLm1lcmdlKCBub2RlICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgXG5cbiAgICAgICAgICBpZiggb3B0aW9ucy5hbmltYXRlICYmIG1vdmVkTm9kZXMubGVuZ3RoID4gMCApe1xuICAgICAgICAgICAgc2ltVXBkYXRpbmdQb3MgPSB0cnVlO1xuXG4gICAgICAgICAgICBtb3ZlZE5vZGVzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuXG4gICAgICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdERyYXcgPSArbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHNpbVVwZGF0aW5nUG9zID0gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXG4gICAgICAgICAgaWYoICFyZWFkeSApe1xuICAgICAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0cmVhZHknLCBvcHRpb25zLnJlYWR5KTtcbiAgICAgICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHJlYWR5JywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfTtcbiAgICAgIHN5cy5yZW5kZXJlciA9IHN5c1JlbmRlcmVyO1xuICAgICAgc3lzLnNjcmVlblNpemUoIGJiLncsIGJiLmggKTtcbiAgICAgIHN5cy5zY3JlZW5QYWRkaW5nKCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgIHN5cy5zY3JlZW5TdGVwKCBvcHRpb25zLnN0ZXBTaXplICk7XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZVZhbHVlRm9yRWxlbWVudChlbGVtZW50LCB2YWx1ZSl7XG4gICAgICAgIGlmKCB2YWx1ZSA9PSBudWxsICl7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmKCB0eXBlb2YgdmFsdWUgPT0gdHlwZW9mIGZ1bmN0aW9uKCl7fSApe1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5hcHBseShlbGVtZW50LCBbZWxlbWVudC5fcHJpdmF0ZS5kYXRhLCB7XG4gICAgICAgICAgICBub2Rlczogbm9kZXMubGVuZ3RoLFxuICAgICAgICAgICAgZWRnZXM6IGVkZ2VzLmxlbmd0aCxcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgICAgICAgICB9XSk7IFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZ3JhYkhhbmRsZXI7XG4gICAgICBub2Rlcy5vbignZ3JhYiBmcmVlIHBvc2l0aW9uJywgZ3JhYkhhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgaWYoIHNpbVVwZGF0aW5nUG9zICl7IHJldHVybjsgfVxuXG4gICAgICAgIHZhciBwb3MgPSB0aGlzLnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBhcG9zID0gc3lzLmZyb21TY3JlZW4oIHBvcyApO1xuICAgICAgICBpZiggIWFwb3MgKXsgcmV0dXJuOyB9XG5cbiAgICAgICAgdmFyIHAgPSBhcmJvci5Qb2ludChhcG9zLngsIGFwb3MueSk7XG4gICAgICAgIHZhciBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nO1xuXG4gICAgICAgIGlmKFxuICAgICAgICAgIGJiLngxICsgcGFkZGluZyA8PSBwb3MueCAmJiBwb3MueCA8PSBiYi54MiAtIHBhZGRpbmcgJiZcbiAgICAgICAgICBiYi55MSArIHBhZGRpbmcgPD0gcG9zLnkgJiYgcG9zLnkgPD0gYmIueTIgLSBwYWRkaW5nXG4gICAgICAgICl7XG4gICAgICAgICAgdGhpcy5zY3JhdGNoKCkuYXJib3IucCA9IHA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN3aXRjaCggZS50eXBlICl7XG4gICAgICAgIGNhc2UgJ2dyYWInOlxuICAgICAgICAgIHRoaXMuc2NyYXRjaCgpLmFyYm9yLmZpeGVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZnJlZSc6XG4gICAgICAgICAgdGhpcy5zY3JhdGNoKCkuYXJib3IuZml4ZWQgPSBmYWxzZTtcbiAgICAgICAgICAvL3RoaXMuc2NyYXRjaCgpLmFyYm9yLnRlbXBNYXNzID0gMTAwMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBsb2NrSGFuZGxlcjtcbiAgICAgIG5vZGVzLm9uKCdsb2NrIHVubG9jaycsIGxvY2tIYW5kbGVyID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIG5vZGUuc2NyYXRjaCgpLmFyYm9yLmZpeGVkID0gbm9kZS5sb2NrZWQoKTtcbiAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICB2YXIgcmVtb3ZlSGFuZGxlcjtcbiAgICAgIGVsZXMub24oJ3JlbW92ZScsIHJlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbihlKXsgcmV0dXJuOyAvLyBUT0RPIGVuYWJsZSB3aGVuIGxheW91dCBhZGQvcmVtb3ZlIGFwaSBhZGRlZFxuICAgICAgICAvLyB2YXIgZWxlID0gdGhpcztcbiAgICAgICAgLy8gdmFyIGFyYm9yRWxlID0gZWxlLnNjcmF0Y2goKS5hcmJvcjtcblxuICAgICAgICAvLyBpZiggIWFyYm9yRWxlICl7IHJldHVybjsgfVxuXG4gICAgICAgIC8vIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgLy8gICBzeXMucHJ1bmVOb2RlKCBhcmJvckVsZSApO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgIHN5cy5wcnVuZUVkZ2UoIGFyYm9yRWxlICk7XG4gICAgICAgIC8vIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgYWRkSGFuZGxlcjtcbiAgICAgIGN5Lm9uKCdhZGQnLCAnKicsIGFkZEhhbmRsZXIgPSBmdW5jdGlvbigpeyByZXR1cm47IC8vIFRPRE8gZW5hYmxlIHdoZW4gbGF5b3V0IGFkZC9yZW1vdmUgYXBpIGFkZGVkXG4gICAgICAgIC8vIHZhciBlbGUgPSB0aGlzO1xuXG4gICAgICAgIC8vIGlmKCBlbGUuaXNOb2RlKCkgKXtcbiAgICAgICAgLy8gICBhZGROb2RlKCBlbGUgKTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICBhZGRFZGdlKCBlbGUgKTtcbiAgICAgICAgLy8gfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciByZXNpemVIYW5kbGVyO1xuICAgICAgY3kub24oJ3Jlc2l6ZScsIHJlc2l6ZUhhbmRsZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCA9PSBudWxsICYmIGxheW91dC5fcHJpdmF0ZS5zeXN0ZW0gIT0gbnVsbCApe1xuICAgICAgICAgIHZhciB3ID0gY3kud2lkdGgoKTtcbiAgICAgICAgICB2YXIgaCA9IGN5LmhlaWdodCgpO1xuXG4gICAgICAgICAgc3lzLnNjcmVlblNpemUoIHcsIGggKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE5vZGUoIG5vZGUgKXtcbiAgICAgICAgaWYoIG5vZGUuaXNGdWxsQXV0b1BhcmVudCgpICl7IHJldHVybjsgfSAvLyB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSBzaW1cblxuICAgICAgICB2YXIgaWQgPSBub2RlLl9wcml2YXRlLmRhdGEuaWQ7XG4gICAgICAgIHZhciBtYXNzID0gY2FsY3VsYXRlVmFsdWVGb3JFbGVtZW50KG5vZGUsIG9wdGlvbnMubm9kZU1hc3MpO1xuICAgICAgICB2YXIgbG9ja2VkID0gbm9kZS5fcHJpdmF0ZS5sb2NrZWQ7XG4gICAgICAgIHZhciBuUG9zID0gbm9kZS5wb3NpdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgdmFyIHBvcyA9IHN5cy5mcm9tU2NyZWVuKHtcbiAgICAgICAgICB4OiBuUG9zLngsXG4gICAgICAgICAgeTogblBvcy55XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5vZGUuc2NyYXRjaCgpLmFyYm9yID0gc3lzLmFkZE5vZGUoaWQsIHtcbiAgICAgICAgICBlbGVtZW50OiBub2RlLFxuICAgICAgICAgIG1hc3M6IG1hc3MsXG4gICAgICAgICAgZml4ZWQ6IGxvY2tlZCxcbiAgICAgICAgICB4OiBsb2NrZWQgPyBwb3MueCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB5OiBsb2NrZWQgPyBwb3MueSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkRWRnZSggZWRnZSApe1xuICAgICAgICB2YXIgc3JjID0gZWRnZS5zb3VyY2UoKS5pZCgpO1xuICAgICAgICB2YXIgdGd0ID0gZWRnZS50YXJnZXQoKS5pZCgpO1xuICAgICAgICB2YXIgbGVuZ3RoID0gY2FsY3VsYXRlVmFsdWVGb3JFbGVtZW50KGVkZ2UsIG9wdGlvbnMuZWRnZUxlbmd0aCk7XG4gICAgICAgIFxuICAgICAgICBlZGdlLnNjcmF0Y2goKS5hcmJvciA9IHN5cy5hZGRFZGdlKHNyYywgdGd0LCB7XG4gICAgICAgICAgbGVuZ3RoOiBsZW5ndGhcbiAgICAgICAgfSk7IFxuICAgICAgfVxuXG4gICAgICBub2Rlcy5lYWNoKGZ1bmN0aW9uKGksIG5vZGUpe1xuICAgICAgICBhZGROb2RlKCBub2RlICk7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgZWRnZXMuZWFjaChmdW5jdGlvbihpLCBlZGdlKXtcbiAgICAgICAgYWRkRWRnZSggZWRnZSApO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIHZhciBncmFiYmFibGVOb2RlcyA9IG5vZGVzLmZpbHRlcihcIjpncmFiYmFibGVcIik7XG4gICAgICAvLyBkaXNhYmxlIGdyYWJiaW5nIGlmIHNvIHNldFxuICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgIGdyYWJiYWJsZU5vZGVzLnVuZ3JhYmlmeSgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZG9uZUhhbmRsZXIgPSBsYXlvdXQuX3ByaXZhdGUuZG9uZUhhbmRsZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICBsYXlvdXQuX3ByaXZhdGUuZG9uZUhhbmRsZXIgPSBudWxsO1xuXG4gICAgICAgIGlmKCAhb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgICBjeS5yZXNldCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG5vZGVzLnJ0cmlnZ2VyKCdwb3NpdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdW5iaW5kIGhhbmRsZXJzXG4gICAgICAgIG5vZGVzLm9mZignZ3JhYiBmcmVlIHBvc2l0aW9uJywgZ3JhYkhhbmRsZXIpO1xuICAgICAgICBub2Rlcy5vZmYoJ2xvY2sgdW5sb2NrJywgbG9ja0hhbmRsZXIpO1xuICAgICAgICBlbGVzLm9mZigncmVtb3ZlJywgcmVtb3ZlSGFuZGxlcik7XG4gICAgICAgIGN5Lm9mZignYWRkJywgJyonLCBhZGRIYW5kbGVyKTtcbiAgICAgICAgY3kub2ZmKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcbiAgICAgICAgXG4gICAgICAgIC8vIGVuYWJsZSBiYWNrIGdyYWJiaW5nIGlmIHNvIHNldFxuICAgICAgICBpZiggb3B0aW9ucy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXtcbiAgICAgICAgICBncmFiYmFibGVOb2Rlcy5ncmFiaWZ5KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RvcCcsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfTtcbiAgICAgIFxuICAgICAgc3lzLnN0YXJ0KCk7XG4gICAgICBpZiggIW9wdGlvbnMuaW5maW5pdGUgJiYgb3B0aW9ucy5tYXhTaW11bGF0aW9uVGltZSAhPSBudWxsICYmIG9wdGlvbnMubWF4U2ltdWxhdGlvblRpbWUgPiAwICYmIG9wdGlvbnMubWF4U2ltdWxhdGlvblRpbWUgIT09IEluZmluaXR5ICl7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBsYXlvdXQuc3RvcCgpO1xuICAgICAgICB9LCBvcHRpb25zLm1heFNpbXVsYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICBcbiAgICB9KTsgLy8gcmVxdWlyZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cblxuICBBcmJvckxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIHRoaXMuX3ByaXZhdGUuc3lzdGVtICE9IG51bGwgKXtcbiAgICAgIHRoaXMuX3ByaXZhdGUuc3lzdGVtLnN0b3AoKTtcbiAgICB9XG5cbiAgICBpZiggdGhpcy5fcHJpdmF0ZS5kb25lSGFuZGxlciApe1xuICAgICAgdGhpcy5fcHJpdmF0ZS5kb25lSGFuZGxlcigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdhcmJvcicsIEFyYm9yTGF5b3V0KTtcbiAgXG4gIFxufSkoY3l0b3NjYXBlKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBkaXJlY3RlZDogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIHRyZWUgaXMgZGlyZWN0ZWQgZG93bndhcmRzIChvciBlZGdlcyBjYW4gcG9pbnQgaW4gYW55IGRpcmVjdGlvbiBpZiBmYWxzZSlcbiAgICBwYWRkaW5nOiAzMCwgLy8gcGFkZGluZyBvbiBmaXRcbiAgICBjaXJjbGU6IGZhbHNlLCAvLyBwdXQgZGVwdGhzIGluIGNvbmNlbnRyaWMgY2lyY2xlcyBpZiB0cnVlLCBwdXQgZGVwdGhzIHRvcCBkb3duIGlmIGZhbHNlXG4gICAgc3BhY2luZ0ZhY3RvcjogMS43NSwgLy8gcG9zaXRpdmUgc3BhY2luZyBmYWN0b3IsIGxhcmdlciA9PiBtb3JlIHNwYWNlIGJldHdlZW4gbm9kZXMgKE4uQi4gbi9hIGlmIGNhdXNlcyBvdmVybGFwKVxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIHJvb3RzOiB1bmRlZmluZWQsIC8vIHRoZSByb290cyBvZiB0aGUgdHJlZXNcbiAgICBtYXhpbWFsQWRqdXN0bWVudHM6IDAsIC8vIGhvdyBtYW55IHRpbWVzIHRvIHRyeSB0byBwb3NpdGlvbiB0aGUgbm9kZXMgaW4gYSBtYXhpbWFsIHdheSAoaS5lLiBubyBiYWNrdHJhY2tpbmcpXG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIEJyZWFkdGhGaXJzdExheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIEJyZWFkdGhGaXJzdExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICAgIFxuICAgIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgdmFyIGdyYXBoID0gZWxlcztcbiAgICBcbiAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgfSApO1xuXG4gICAgdmFyIHJvb3RzO1xuICAgIGlmKCAkJC5pcy5lbGVtZW50T3JDb2xsZWN0aW9uKG9wdGlvbnMucm9vdHMpICl7XG4gICAgICByb290cyA9IG9wdGlvbnMucm9vdHM7XG4gICAgfSBlbHNlIGlmKCAkJC5pcy5hcnJheShvcHRpb25zLnJvb3RzKSApe1xuICAgICAgdmFyIHJvb3RzQXJyYXkgPSBbXTtcblxuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBvcHRpb25zLnJvb3RzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBpZCA9IG9wdGlvbnMucm9vdHNbaV07XG4gICAgICAgIHZhciBlbGUgPSBjeS5nZXRFbGVtZW50QnlJZCggaWQgKTtcbiAgICAgICAgcm9vdHNBcnJheS5wdXNoKCBlbGUgKTtcbiAgICAgIH1cblxuICAgICAgcm9vdHMgPSBuZXcgJCQuQ29sbGVjdGlvbiggY3ksIHJvb3RzQXJyYXkgKTtcbiAgICB9IGVsc2UgaWYoICQkLmlzLnN0cmluZyhvcHRpb25zLnJvb3RzKSApe1xuICAgICAgcm9vdHMgPSBjeS4kKCBvcHRpb25zLnJvb3RzICk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoIG9wdGlvbnMuZGlyZWN0ZWQgKXtcbiAgICAgICAgcm9vdHMgPSBub2Rlcy5yb290cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICAgICAgdmFyIHVuaGFuZGxlZE5vZGVzID0gbm9kZXM7XG5cbiAgICAgICAgd2hpbGUoIHVuaGFuZGxlZE5vZGVzLmxlbmd0aCA+IDAgKXtcbiAgICAgICAgICB2YXIgY3VyckNvbXAgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgICAgICAgICBlbGVzLmJmcyh7XG4gICAgICAgICAgICByb290czogdW5oYW5kbGVkTm9kZXNbMF0sXG4gICAgICAgICAgICB2aXNpdDogZnVuY3Rpb24oaSwgZGVwdGgsIG5vZGUsIGVkZ2UsIHBOb2RlKXtcbiAgICAgICAgICAgICAgY3VyckNvbXAgPSBjdXJyQ29tcC5hZGQoIG5vZGUgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXJlY3RlZDogZmFsc2VcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHVuaGFuZGxlZE5vZGVzID0gdW5oYW5kbGVkTm9kZXMubm90KCBjdXJyQ29tcCApO1xuICAgICAgICAgIGNvbXBvbmVudHMucHVzaCggY3VyckNvbXAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvb3RzID0gY3kuY29sbGVjdGlvbigpO1xuICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgY29tcCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgdmFyIG1heERlZ3JlZSA9IGNvbXAubWF4RGVncmVlKCBmYWxzZSApO1xuICAgICAgICAgIHZhciBjb21wUm9vdHMgPSBjb21wLmZpbHRlcihmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVncmVlKGZhbHNlKSA9PT0gbWF4RGVncmVlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcm9vdHMgPSByb290cy5hZGQoIGNvbXBSb290cyApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgfVxuICAgIH1cblxuXG4gICAgdmFyIGRlcHRocyA9IFtdO1xuICAgIHZhciBmb3VuZEJ5QmZzID0ge307XG4gICAgdmFyIGlkMmRlcHRoID0ge307XG4gICAgdmFyIHByZXZOb2RlID0ge307XG4gICAgdmFyIHByZXZFZGdlID0ge307XG4gICAgdmFyIHN1Y2Nlc3NvcnMgPSB7fTtcblxuICAgIC8vIGZpbmQgdGhlIGRlcHRocyBvZiB0aGUgbm9kZXNcbiAgICBncmFwaC5iZnMoe1xuICAgICAgcm9vdHM6IHJvb3RzLFxuICAgICAgZGlyZWN0ZWQ6IG9wdGlvbnMuZGlyZWN0ZWQsXG4gICAgICB2aXNpdDogZnVuY3Rpb24oaSwgZGVwdGgsIG5vZGUsIGVkZ2UsIHBOb2RlKXtcbiAgICAgICAgdmFyIGVsZSA9IHRoaXNbMF07XG4gICAgICAgIHZhciBpZCA9IGVsZS5pZCgpO1xuXG4gICAgICAgIGlmKCAhZGVwdGhzW2RlcHRoXSApe1xuICAgICAgICAgIGRlcHRoc1tkZXB0aF0gPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcHRoc1tkZXB0aF0ucHVzaCggZWxlICk7XG4gICAgICAgIGZvdW5kQnlCZnNbIGlkIF0gPSB0cnVlO1xuICAgICAgICBpZDJkZXB0aFsgaWQgXSA9IGRlcHRoO1xuICAgICAgICBwcmV2Tm9kZVsgaWQgXSA9IHBOb2RlO1xuICAgICAgICBwcmV2RWRnZVsgaWQgXSA9IGVkZ2U7XG5cbiAgICAgICAgaWYoIHBOb2RlICl7XG4gICAgICAgICAgdmFyIHByZXZJZCA9IHBOb2RlLmlkKCk7XG4gICAgICAgICAgdmFyIHN1Y2MgPSBzdWNjZXNzb3JzWyBwcmV2SWQgXSA9IHN1Y2Nlc3NvcnNbIHByZXZJZCBdIHx8IFtdO1xuICAgICAgICAgIFxuICAgICAgICAgIHN1Y2MucHVzaCggbm9kZSApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmb3Igbm9kZXMgbm90IGZvdW5kIGJ5IGJmc1xuICAgIHZhciBvcnBoYW5Ob2RlcyA9IFtdO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBlbGUgPSBub2Rlc1tpXTtcblxuICAgICAgaWYoIGZvdW5kQnlCZnNbIGVsZS5pZCgpIF0gKXtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcnBoYW5Ob2Rlcy5wdXNoKCBlbGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gb3JwaGFuIG5vZGVzIGEgZGVwdGggZnJvbSB0aGVpciBuZWlnaGJvcmhvb2RcbiAgICB2YXIgbWF4Q2hlY2tzID0gb3JwaGFuTm9kZXMubGVuZ3RoICogMztcbiAgICB2YXIgY2hlY2tzID0gMDtcbiAgICB3aGlsZSggb3JwaGFuTm9kZXMubGVuZ3RoICE9PSAwICYmIGNoZWNrcyA8IG1heENoZWNrcyApe1xuICAgICAgdmFyIG5vZGUgPSBvcnBoYW5Ob2Rlcy5zaGlmdCgpO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IG5vZGUubmVpZ2hib3Job29kKCkubm9kZXMoKTtcbiAgICAgIHZhciBhc3NpZ25lZERlcHRoID0gZmFsc2U7XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbmVpZ2hib3JzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBkZXB0aCA9IGlkMmRlcHRoWyBuZWlnaGJvcnNbaV0uaWQoKSBdO1xuXG4gICAgICAgIGlmKCBkZXB0aCAhPT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgZGVwdGhzW2RlcHRoXS5wdXNoKCBub2RlICk7XG4gICAgICAgICAgYXNzaWduZWREZXB0aCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoICFhc3NpZ25lZERlcHRoICl7XG4gICAgICAgIG9ycGhhbk5vZGVzLnB1c2goIG5vZGUgKTtcbiAgICAgIH1cblxuICAgICAgY2hlY2tzKys7XG4gICAgfVxuXG4gICAgLy8gYXNzaWduIG9ycGhhbiBub2RlcyB0aGF0IGFyZSBzdGlsbCBsZWZ0IHRvIHRoZSBkZXB0aCBvZiB0aGVpciBzdWJncmFwaFxuICAgIHdoaWxlKCBvcnBoYW5Ob2Rlcy5sZW5ndGggIT09IDAgKXtcbiAgICAgIHZhciBub2RlID0gb3JwaGFuTm9kZXMuc2hpZnQoKTtcbiAgICAgIC8vdmFyIHN1YmdyYXBoID0gZ3JhcGguYmZzKCBub2RlICkucGF0aDtcbiAgICAgIHZhciBhc3NpZ25lZERlcHRoID0gZmFsc2U7XG5cbiAgICAgIC8vIGZvciggdmFyIGkgPSAwOyBpIDwgc3ViZ3JhcGgubGVuZ3RoOyBpKysgKXtcbiAgICAgIC8vICAgdmFyIGRlcHRoID0gaWQyZGVwdGhbIHN1YmdyYXBoW2ldLmlkKCkgXTtcblxuICAgICAgLy8gICBpZiggZGVwdGggIT09IHVuZGVmaW5lZCApe1xuICAgICAgLy8gICAgIGRlcHRoc1tkZXB0aF0ucHVzaCggbm9kZSApO1xuICAgICAgLy8gICAgIGFzc2lnbmVkRGVwdGggPSB0cnVlO1xuICAgICAgLy8gICAgIGJyZWFrO1xuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG5cbiAgICAgIGlmKCAhYXNzaWduZWREZXB0aCApeyAvLyB3b3JzdCBjYXNlIGlmIHRoZSBncmFwaCByZWFsbHkgaXNuJ3QgdHJlZSBmcmllbmRseSwgdGhlbiBqdXN0IGR1bXAgaXQgaW4gMFxuICAgICAgICBpZiggZGVwdGhzLmxlbmd0aCA9PT0gMCApe1xuICAgICAgICAgIGRlcHRocy5wdXNoKFtdKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZGVwdGhzWzBdLnB1c2goIG5vZGUgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhc3NpZ24gdGhlIG5vZGVzIGEgZGVwdGggYW5kIGluZGV4XG4gICAgdmFyIGFzc2lnbkRlcHRoc1RvRWxlcyA9IGZ1bmN0aW9uKCl7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGRlcHRocy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWxlcyA9IGRlcHRoc1tpXTtcblxuICAgICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGVsZXMubGVuZ3RoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZWxlc1tqXTtcblxuICAgICAgICAgIGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdCA9IHtcbiAgICAgICAgICAgIGRlcHRoOiBpLFxuICAgICAgICAgICAgaW5kZXg6IGpcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBhc3NpZ25EZXB0aHNUb0VsZXMoKTtcblxuXG4gICAgdmFyIGludGVyc2VjdHNEZXB0aCA9IGZ1bmN0aW9uKCBub2RlICl7IC8vIHJldHVybnMgdHJ1ZSBpZiBoYXMgZWRnZXMgcG9pbnRpbmcgaW4gZnJvbSBhIGhpZ2hlciBkZXB0aFxuICAgICAgdmFyIGVkZ2VzID0gbm9kZS5jb25uZWN0ZWRFZGdlcyhmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhKCd0YXJnZXQnKSA9PT0gbm9kZS5pZCgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgdGhpc0luZm8gPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgdmFyIGhpZ2hlc3REZXB0aE9mT3RoZXIgPSAwO1xuICAgICAgdmFyIGhpZ2hlc3RPdGhlcjtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tpXTtcbiAgICAgICAgdmFyIG90aGVyTm9kZSA9IGVkZ2Uuc291cmNlKClbMF07XG4gICAgICAgIHZhciBvdGhlckluZm8gPSBvdGhlck5vZGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG5cbiAgICAgICAgaWYoIHRoaXNJbmZvLmRlcHRoIDw9IG90aGVySW5mby5kZXB0aCAmJiBoaWdoZXN0RGVwdGhPZk90aGVyIDwgb3RoZXJJbmZvLmRlcHRoICl7XG4gICAgICAgICAgaGlnaGVzdERlcHRoT2ZPdGhlciA9IG90aGVySW5mby5kZXB0aDtcbiAgICAgICAgICBoaWdoZXN0T3RoZXIgPSBvdGhlck5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGhpZ2hlc3RPdGhlcjtcbiAgICB9O1xuXG4gICAgIC8vIG1ha2UgbWF4aW1hbCBpZiBzbyBzZXQgYnkgYWRqdXN0aW5nIGRlcHRoc1xuICAgIGZvciggdmFyIGFkaiA9IDA7IGFkaiA8IG9wdGlvbnMubWF4aW1hbEFkanVzdG1lbnRzOyBhZGorKyApe1xuXG4gICAgICB2YXIgbkRlcHRocyA9IGRlcHRocy5sZW5ndGg7XG4gICAgICB2YXIgZWxlc1RvTW92ZSA9IFtdO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBuRGVwdGhzOyBpKysgKXtcbiAgICAgICAgdmFyIGRlcHRoID0gZGVwdGhzW2ldO1xuXG4gICAgICAgIHZhciBuRGVwdGggPSBkZXB0aC5sZW5ndGg7XG4gICAgICAgIGZvciggdmFyIGogPSAwOyBqIDwgbkRlcHRoOyBqKysgKXtcbiAgICAgICAgICB2YXIgZWxlID0gZGVwdGhbal07XG4gICAgICAgICAgdmFyIGluZm8gPSBlbGUuX3ByaXZhdGUuc2NyYXRjaC5icmVhZHRoZmlyc3Q7XG4gICAgICAgICAgdmFyIGludEVsZSA9IGludGVyc2VjdHNEZXB0aChlbGUpO1xuXG4gICAgICAgICAgaWYoIGludEVsZSApe1xuICAgICAgICAgICAgaW5mby5pbnRFbGUgPSBpbnRFbGU7XG4gICAgICAgICAgICBlbGVzVG9Nb3ZlLnB1c2goIGVsZSApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IGVsZXNUb01vdmUubGVuZ3RoOyBpKysgKXsgXG4gICAgICAgIHZhciBlbGUgPSBlbGVzVG9Nb3ZlW2ldO1xuICAgICAgICB2YXIgaW5mbyA9IGVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcbiAgICAgICAgdmFyIGludEVsZSA9IGluZm8uaW50RWxlO1xuICAgICAgICB2YXIgaW50SW5mbyA9IGludEVsZS5fcHJpdmF0ZS5zY3JhdGNoLmJyZWFkdGhmaXJzdDtcblxuICAgICAgICBkZXB0aHNbIGluZm8uZGVwdGggXS5zcGxpY2UoIGluZm8uaW5kZXgsIDEgKTsgLy8gcmVtb3ZlIGZyb20gb2xkIGRlcHRoICYgaW5kZXhcblxuICAgICAgICAvLyBhZGQgdG8gZW5kIG9mIG5ldyBkZXB0aFxuICAgICAgICB2YXIgbmV3RGVwdGggPSBpbnRJbmZvLmRlcHRoICsgMTtcbiAgICAgICAgd2hpbGUoIG5ld0RlcHRoID4gZGVwdGhzLmxlbmd0aCAtIDEgKXtcbiAgICAgICAgICBkZXB0aHMucHVzaChbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVwdGhzWyBuZXdEZXB0aCBdLnB1c2goIGVsZSApO1xuXG4gICAgICAgIGluZm8uZGVwdGggPSBuZXdEZXB0aDtcbiAgICAgICAgaW5mby5pbmRleCA9IGRlcHRoc1tuZXdEZXB0aF0ubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgYXNzaWduRGVwdGhzVG9FbGVzKCk7XG4gICAgfVxuXG4gICAgLy8gZmluZCBtaW4gZGlzdGFuY2Ugd2UgbmVlZCB0byBsZWF2ZSBiZXR3ZWVuIG5vZGVzXG4gICAgdmFyIG1pbkRpc3RhbmNlID0gMDtcbiAgICBpZiggb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIHcgPSBub2Rlc1tpXS5vdXRlcldpZHRoKCk7XG4gICAgICAgIHZhciBoID0gbm9kZXNbaV0ub3V0ZXJIZWlnaHQoKTtcbiAgICAgICAgXG4gICAgICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgobWluRGlzdGFuY2UsIHcsIGgpO1xuICAgICAgfVxuICAgICAgbWluRGlzdGFuY2UgKj0gb3B0aW9ucy5zcGFjaW5nRmFjdG9yOyAvLyBqdXN0IHRvIGhhdmUgc29tZSBuaWNlIHNwYWNpbmdcbiAgICB9XG5cbiAgICAvLyBnZXQgdGhlIHdlaWdodGVkIHBlcmNlbnQgZm9yIGFuIGVsZW1lbnQgYmFzZWQgb24gaXRzIGNvbm5lY3Rpdml0eSB0byBvdGhlciBsZXZlbHNcbiAgICB2YXIgY2FjaGVkV2VpZ2h0ZWRQZXJjZW50ID0ge307XG4gICAgdmFyIGdldFdlaWdodGVkUGVyY2VudCA9IGZ1bmN0aW9uKCBlbGUgKXtcbiAgICAgIGlmKCBjYWNoZWRXZWlnaHRlZFBlcmNlbnRbIGVsZS5pZCgpIF0gKXtcbiAgICAgICAgcmV0dXJuIGNhY2hlZFdlaWdodGVkUGVyY2VudFsgZWxlLmlkKCkgXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVsZURlcHRoID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0LmRlcHRoO1xuICAgICAgdmFyIG5laWdoYm9ycyA9IGVsZS5uZWlnaGJvcmhvb2QoKS5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuICAgICAgdmFyIHBlcmNlbnQgPSAwO1xuICAgICAgdmFyIHNhbXBsZXMgPSAwO1xuXG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5laWdoYm9ycy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbmVpZ2hib3IgPSBuZWlnaGJvcnNbaV07XG4gICAgICAgIHZhciBiZiA9IG5laWdoYm9yLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgICB2YXIgaW5kZXggPSBiZi5pbmRleDtcbiAgICAgICAgdmFyIGRlcHRoID0gYmYuZGVwdGg7XG4gICAgICAgIHZhciBuRGVwdGggPSBkZXB0aHNbZGVwdGhdLmxlbmd0aDtcblxuICAgICAgICBpZiggZWxlRGVwdGggPiBkZXB0aCB8fCBlbGVEZXB0aCA9PT0gMCApeyAvLyBvbmx5IGdldCBpbmZsdWVuY2VkIGJ5IGVsZW1lbnRzIGFib3ZlXG4gICAgICAgICAgcGVyY2VudCArPSBpbmRleCAvIG5EZXB0aDtcbiAgICAgICAgICBzYW1wbGVzKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2FtcGxlcyA9IE1hdGgubWF4KDEsIHNhbXBsZXMpO1xuICAgICAgcGVyY2VudCA9IHBlcmNlbnQgLyBzYW1wbGVzO1xuXG4gICAgICBpZiggc2FtcGxlcyA9PT0gMCApeyAvLyBzbyBsb25lIG5vZGVzIGhhdmUgYSBcImRvbid0IGNhcmVcIiBzdGF0ZSBpbiBzb3J0aW5nXG4gICAgICAgIHBlcmNlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlZFdlaWdodGVkUGVyY2VudFsgZWxlLmlkKCkgXSA9IHBlcmNlbnQ7XG4gICAgICByZXR1cm4gcGVyY2VudDtcbiAgICB9O1xuXG5cbiAgICAvLyByZWFycmFuZ2UgdGhlIGluZGljZXMgaW4gZWFjaCBkZXB0aCBsZXZlbCBiYXNlZCBvbiBjb25uZWN0aXZpdHlcblxuICAgIHZhciBzb3J0Rm4gPSBmdW5jdGlvbihhLCBiKXtcbiAgICAgIHZhciBhcGN0ID0gZ2V0V2VpZ2h0ZWRQZXJjZW50KCBhICk7XG4gICAgICB2YXIgYnBjdCA9IGdldFdlaWdodGVkUGVyY2VudCggYiApO1xuXG4gICAgICByZXR1cm4gYXBjdCAtIGJwY3Q7XG4gICAgfTtcblxuICAgIGZvciggdmFyIHRpbWVzID0gMDsgdGltZXMgPCAzOyB0aW1lcysrICl7IC8vIGRvIGl0IGEgZmV3IHRpbWVzIGIvYyB0aGUgZGVwdGhzIGFyZSBkeW5hbWljIGFuZCB3ZSB3YW50IGEgbW9yZSBzdGFibGUgcmVzdWx0XG5cbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGVwdGhzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIGRlcHRoc1tpXSA9IGRlcHRoc1tpXS5zb3J0KCBzb3J0Rm4gKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbkRlcHRoc1RvRWxlcygpOyAvLyBhbmQgdXBkYXRlXG5cbiAgICB9XG5cbiAgICB2YXIgYmlnZ2VzdERlcHRoU2l6ZSA9IDA7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBkZXB0aHMubGVuZ3RoOyBpKysgKXtcbiAgICAgIGJpZ2dlc3REZXB0aFNpemUgPSBNYXRoLm1heCggZGVwdGhzW2ldLmxlbmd0aCwgYmlnZ2VzdERlcHRoU2l6ZSApO1xuICAgIH1cblxuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICB4OiBiYi54MSArIGJiLncvMixcbiAgICAgIHk6IGJiLngxICsgYmIuaC8yXG4gICAgfTtcbiAgIFxuICAgIHZhciBnZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCBlbGUsIGlzQm90dG9tRGVwdGggKXtcbiAgICAgIHZhciBpbmZvID0gZWxlLl9wcml2YXRlLnNjcmF0Y2guYnJlYWR0aGZpcnN0O1xuICAgICAgdmFyIGRlcHRoID0gaW5mby5kZXB0aDtcbiAgICAgIHZhciBpbmRleCA9IGluZm8uaW5kZXg7XG4gICAgICB2YXIgZGVwdGhTaXplID0gZGVwdGhzW2RlcHRoXS5sZW5ndGg7XG5cbiAgICAgIHZhciBkaXN0YW5jZVggPSBNYXRoLm1heCggYmIudyAvIChkZXB0aFNpemUgKyAxKSwgbWluRGlzdGFuY2UgKTtcbiAgICAgIHZhciBkaXN0YW5jZVkgPSBNYXRoLm1heCggYmIuaCAvIChkZXB0aHMubGVuZ3RoICsgMSksIG1pbkRpc3RhbmNlICk7XG4gICAgICB2YXIgcmFkaXVzU3RlcFNpemUgPSBNYXRoLm1pbiggYmIudyAvIDIgLyBkZXB0aHMubGVuZ3RoLCBiYi5oIC8gMiAvIGRlcHRocy5sZW5ndGggKTtcbiAgICAgIHJhZGl1c1N0ZXBTaXplID0gTWF0aC5tYXgoIHJhZGl1c1N0ZXBTaXplLCBtaW5EaXN0YW5jZSApO1xuXG4gICAgICBpZiggIW9wdGlvbnMuY2lyY2xlICl7XG4gICAgICAgIFxuICAgICAgICB2YXIgZXBvcyA9IHtcbiAgICAgICAgICB4OiBjZW50ZXIueCArIChpbmRleCArIDEgLSAoZGVwdGhTaXplICsgMSkvMikgKiBkaXN0YW5jZVgsXG4gICAgICAgICAgeTogKGRlcHRoICsgMSkgKiBkaXN0YW5jZVlcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggaXNCb3R0b21EZXB0aCApe1xuICAgICAgICAgIHJldHVybiBlcG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFyIHN1Y2NzID0gc3VjY2Vzc29yc1sgZWxlLmlkKCkgXTtcbiAgICAgICAgLy8gaWYoIHN1Y2NzICl7XG4gICAgICAgIC8vICAgZXBvcy54ID0gMDtcbiAgICAgICAgLy8gXG4gICAgICAgIC8vICAgZm9yKCB2YXIgaSA9IDAgOyBpIDwgc3VjY3MubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgLy8gICAgIHZhciBzcG9zID0gcG9zWyBzdWNjc1tpXS5pZCgpIF07XG4gICAgICAgIC8vICAgICBcbiAgICAgICAgLy8gICAgIGVwb3MueCArPSBzcG9zLng7XG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyBcbiAgICAgICAgLy8gICBlcG9zLnggLz0gc3VjY3MubGVuZ3RoO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyAgIC8vZGVidWdnZXI7XG4gICAgICAgIC8vIH1cblxuICAgICAgICByZXR1cm4gZXBvcztcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoIG9wdGlvbnMuY2lyY2xlICl7XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IHJhZGl1c1N0ZXBTaXplICogZGVwdGggKyByYWRpdXNTdGVwU2l6ZSAtIChkZXB0aHMubGVuZ3RoID4gMCAmJiBkZXB0aHNbMF0ubGVuZ3RoIDw9IDMgPyByYWRpdXNTdGVwU2l6ZS8yIDogMCk7XG4gICAgICAgICAgdmFyIHRoZXRhID0gMiAqIE1hdGguUEkgLyBkZXB0aHNbZGVwdGhdLmxlbmd0aCAqIGluZGV4O1xuXG4gICAgICAgICAgaWYoIGRlcHRoID09PSAwICYmIGRlcHRoc1swXS5sZW5ndGggPT09IDEgKXtcbiAgICAgICAgICAgIHJhZGl1cyA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54ICsgcmFkaXVzICogTWF0aC5jb3ModGhldGEpLFxuICAgICAgICAgICAgeTogY2VudGVyLnkgKyByYWRpdXMgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgICAgICB9O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54ICsgKGluZGV4ICsgMSAtIChkZXB0aFNpemUgKyAxKS8yKSAqIGRpc3RhbmNlWCxcbiAgICAgICAgICAgIHk6IChkZXB0aCArIDEpICogZGlzdGFuY2VZXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgfTtcblxuICAgIC8vIGdldCBwb3NpdGlvbnMgaW4gcmV2ZXJzZSBkZXB0aCBvcmRlclxuICAgIHZhciBwb3MgPSB7fTtcbiAgICBmb3IoIHZhciBpID0gZGVwdGhzLmxlbmd0aCAtIDE7IGkgPj0wOyBpLS0gKXtcbiAgICAgIHZhciBkZXB0aCA9IGRlcHRoc1tpXTtcblxuICAgICAgZm9yKCB2YXIgaiA9IDA7IGogPCBkZXB0aC5sZW5ndGg7IGorKyApe1xuICAgICAgICB2YXIgbm9kZSA9IGRlcHRoW2pdO1xuXG4gICAgICAgIHBvc1sgbm9kZS5pZCgpIF0gPSBnZXRQb3NpdGlvbiggbm9kZSwgaSA9PT0gZGVwdGhzLmxlbmd0aCAtIDEgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBwb3NbIHRoaXMuaWQoKSBdO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdicmVhZHRoZmlyc3QnLCBCcmVhZHRoRmlyc3RMYXlvdXQpO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRoZSB2aWV3cG9ydCB0byB0aGUgZ3JhcGhcbiAgICBwYWRkaW5nOiAzMCwgLy8gdGhlIHBhZGRpbmcgb24gZml0XG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBhbmQgcmFkaXVzIGlmIG5vdCBlbm91Z2ggc3BhY2VcbiAgICByYWRpdXM6IHVuZGVmaW5lZCwgLy8gdGhlIHJhZGl1cyBvZiB0aGUgY2lyY2xlXG4gICAgc3RhcnRBbmdsZTogMy8yICogTWF0aC5QSSwgLy8gdGhlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBub2RlXG4gICAgY291bnRlcmNsb2Nrd2lzZTogZmFsc2UsIC8vIHdoZXRoZXIgdGhlIGxheW91dCBzaG91bGQgZ28gY291bnRlcmNsb2Nrd2lzZSAodHJ1ZSkgb3IgY2xvY2t3aXNlIChmYWxzZSlcbiAgICBzb3J0OiB1bmRlZmluZWQsIC8vIGEgc29ydGluZyBmdW5jdGlvbiB0byBvcmRlciB0aGUgbm9kZXM7IGUuZy4gZnVuY3Rpb24oYSwgYil7IHJldHVybiBhLmRhdGEoJ3dlaWdodCcpIC0gYi5kYXRhKCd3ZWlnaHQnKSB9XG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIENpcmNsZUxheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIENpcmNsZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICAgIFxuICAgIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICAgIFxuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcblxuICAgIGlmKCBvcHRpb25zLnNvcnQgKXtcbiAgICAgIG5vZGVzID0gbm9kZXMuc29ydCggb3B0aW9ucy5zb3J0ICk7XG4gICAgfVxuICAgIFxuICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICB9ICk7XG5cbiAgICB2YXIgY2VudGVyID0ge1xuICAgICAgeDogYmIueDEgKyBiYi53LzIsXG4gICAgICB5OiBiYi55MSArIGJiLmgvMlxuICAgIH07XG4gICAgXG4gICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlO1xuICAgIHZhciBkVGhldGEgPSAyICogTWF0aC5QSSAvIG5vZGVzLmxlbmd0aDtcbiAgICB2YXIgcjtcblxuICAgIHZhciBtaW5EaXN0YW5jZSA9IDA7XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHcgPSBub2Rlc1tpXS5vdXRlcldpZHRoKCk7XG4gICAgICB2YXIgaCA9IG5vZGVzW2ldLm91dGVySGVpZ2h0KCk7XG4gICAgICBcbiAgICAgIG1pbkRpc3RhbmNlID0gTWF0aC5tYXgobWluRGlzdGFuY2UsIHcsIGgpO1xuICAgIH1cblxuICAgIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5yYWRpdXMpICl7XG4gICAgICByID0gb3B0aW9ucy5yYWRpdXM7XG4gICAgfSBlbHNlIGlmKCBub2Rlcy5sZW5ndGggPD0gMSApe1xuICAgICAgciA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBNYXRoLm1pbiggYmIuaCwgYmIudyApLzIgLSBtaW5EaXN0YW5jZTtcbiAgICB9XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIHJhZGl1c1xuICAgIGlmKCBub2Rlcy5sZW5ndGggPiAxICYmIG9wdGlvbnMuYXZvaWRPdmVybGFwICl7IC8vIGJ1dCBvbmx5IGlmIG1vcmUgdGhhbiBvbmUgbm9kZSAoY2FuJ3Qgb3ZlcmxhcClcbiAgICAgIG1pbkRpc3RhbmNlICo9IDEuNzU7IC8vIGp1c3QgdG8gaGF2ZSBzb21lIG5pY2Ugc3BhY2luZ1xuXG4gICAgICB2YXIgZFRoZXRhID0gMiAqIE1hdGguUEkgLyBub2Rlcy5sZW5ndGg7XG4gICAgICB2YXIgZGNvcyA9IE1hdGguY29zKGRUaGV0YSkgLSBNYXRoLmNvcygwKTtcbiAgICAgIHZhciBkc2luID0gTWF0aC5zaW4oZFRoZXRhKSAtIE1hdGguc2luKDApO1xuICAgICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQoIG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UgLyAoIGRjb3MqZGNvcyArIGRzaW4qZHNpbiApICk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcbiAgICAgIHIgPSBNYXRoLm1heCggck1pbiwgciApO1xuICAgIH1cblxuICAgIHZhciBnZXRQb3MgPSBmdW5jdGlvbiggaSwgZWxlICl7XG4gICAgICB2YXIgcnggPSByICogTWF0aC5jb3MoIHRoZXRhICk7XG4gICAgICB2YXIgcnkgPSByICogTWF0aC5zaW4oIHRoZXRhICk7XG4gICAgICB2YXIgcG9zID0ge1xuICAgICAgICB4OiBjZW50ZXIueCArIHJ4LFxuICAgICAgICB5OiBjZW50ZXIueSArIHJ5XG4gICAgICB9O1xuXG4gICAgICB0aGV0YSA9IG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA/IHRoZXRhIC0gZFRoZXRhIDogdGhldGEgKyBkVGhldGE7XG4gICAgICByZXR1cm4gcG9zO1xuICAgIH07XG4gICAgXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBnZXRQb3MgKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdjaXJjbGUnLCBDaXJjbGVMYXlvdXQpO1xuICBcbn0pKCBjeXRvc2NhcGUgKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBhbmltYXRlOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHNob3cgdGhlIGxheW91dCBhcyBpdCdzIHJ1bm5pbmdcbiAgICByZWZyZXNoOiAxLCAvLyBudW1iZXIgb2YgdGlja3MgcGVyIGZyYW1lOyBoaWdoZXIgaXMgZmFzdGVyIGJ1dCBtb3JlIGplcmt5XG4gICAgbWF4U2ltdWxhdGlvblRpbWU6IDQwMDAsIC8vIG1heCBsZW5ndGggaW4gbXMgdG8gcnVuIHRoZSBsYXlvdXRcbiAgICB1bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmc6IGZhbHNlLCAvLyBzbyB5b3UgY2FuJ3QgZHJhZyBub2RlcyBkdXJpbmcgbGF5b3V0XG4gICAgZml0OiB0cnVlLCAvLyBvbiBldmVyeSBsYXlvdXQgcmVwb3NpdGlvbiBvZiBub2RlcywgZml0IHRoZSB2aWV3cG9ydFxuICAgIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIGFyb3VuZCB0aGUgc2ltdWxhdGlvblxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuXG4gICAgLy8gbGF5b3V0IGV2ZW50IGNhbGxiYWNrc1xuICAgIHJlYWR5OiBmdW5jdGlvbigpe30sIC8vIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogZnVuY3Rpb24oKXt9LCAvLyBvbiBsYXlvdXRzdG9wXG5cbiAgICAvLyBwb3NpdGlvbmluZyBvcHRpb25zXG4gICAgcmFuZG9taXplOiBmYWxzZSwgLy8gdXNlIHJhbmRvbSBub2RlIHBvc2l0aW9ucyBhdCBiZWdpbm5pbmcgb2YgbGF5b3V0XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBpZiB0cnVlLCBwcmV2ZW50cyBvdmVybGFwIG9mIG5vZGUgYm91bmRpbmcgYm94ZXNcbiAgICBoYW5kbGVEaXNjb25uZWN0ZWQ6IHRydWUsIC8vIGlmIHRydWUsIGF2b2lkcyBkaXNjb25uZWN0ZWQgY29tcG9uZW50cyBmcm9tIG92ZXJsYXBwaW5nXG4gICAgbm9kZVNwYWNpbmc6IGZ1bmN0aW9uKCBub2RlICl7IHJldHVybiAxMDsgfSwgLy8gZXh0cmEgc3BhY2luZyBhcm91bmQgbm9kZXNcbiAgICBmbG93OiB1bmRlZmluZWQsIC8vIHVzZSBEQUcvdHJlZSBmbG93IGxheW91dCBpZiBzcGVjaWZpZWQsIGUuZy4geyBheGlzOiAneScsIG1pblNlcGFyYXRpb246IDMwIH1cbiAgICBhbGlnbm1lbnQ6IHVuZGVmaW5lZCwgLy8gcmVsYXRpdmUgYWxpZ25tZW50IGNvbnN0cmFpbnRzIG9uIG5vZGVzLCBlLmcuIGZ1bmN0aW9uKCBub2RlICl7IHJldHVybiB7IHg6IDAsIHk6IDEgfSB9XG5cbiAgICAvLyBkaWZmZXJlbnQgbWV0aG9kcyBvZiBzcGVjaWZ5aW5nIGVkZ2UgbGVuZ3RoXG4gICAgLy8gZWFjaCBjYW4gYmUgYSBjb25zdGFudCBudW1lcmljYWwgdmFsdWUgb3IgYSBmdW5jdGlvbiBsaWtlIGBmdW5jdGlvbiggZWRnZSApeyByZXR1cm4gMjsgfWBcbiAgICBlZGdlTGVuZ3RoOiB1bmRlZmluZWQsIC8vIHNldHMgZWRnZSBsZW5ndGggZGlyZWN0bHkgaW4gc2ltdWxhdGlvblxuICAgIGVkZ2VTeW1EaWZmTGVuZ3RoOiB1bmRlZmluZWQsIC8vIHN5bW1ldHJpYyBkaWZmIGVkZ2UgbGVuZ3RoIGluIHNpbXVsYXRpb25cbiAgICBlZGdlSmFjY2FyZExlbmd0aDogdW5kZWZpbmVkLCAvLyBqYWNjYXJkIGVkZ2UgbGVuZ3RoIGluIHNpbXVsYXRpb25cblxuICAgIC8vIGl0ZXJhdGlvbnMgb2YgY29sYSBhbGdvcml0aG07IHVzZXMgZGVmYXVsdCB2YWx1ZXMgb24gdW5kZWZpbmVkXG4gICAgdW5jb25zdHJJdGVyOiB1bmRlZmluZWQsIC8vIHVuY29uc3RyYWluZWQgaW5pdGlhbCBsYXlvdXQgaXRlcmF0aW9uc1xuICAgIHVzZXJDb25zdEl0ZXI6IHVuZGVmaW5lZCwgLy8gaW5pdGlhbCBsYXlvdXQgaXRlcmF0aW9ucyB3aXRoIHVzZXItc3BlY2lmaWVkIGNvbnN0cmFpbnRzXG4gICAgYWxsQ29uc3RJdGVyOiB1bmRlZmluZWQsIC8vIGluaXRpYWwgbGF5b3V0IGl0ZXJhdGlvbnMgd2l0aCBhbGwgY29uc3RyYWludHMgaW5jbHVkaW5nIG5vbi1vdmVybGFwXG5cbiAgICAvLyBpbmZpbml0ZSBsYXlvdXQgb3B0aW9uc1xuICAgIGluZmluaXRlOiBmYWxzZSAvLyBvdmVycmlkZXMgYWxsIG90aGVyIG9wdGlvbnMgZm9yIGEgZm9yY2VzLWFsbC10aGUtdGltZSBtb2RlXG4gIH07XG5cbiAgLy8gY29uc3RydWN0b3JcbiAgLy8gb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gIGZ1bmN0aW9uIENvbGFMYXlvdXQoIG9wdGlvbnMgKXtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh0cnVlLCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMpOyBcbiAgfVxuXG4gIC8vIHJ1bnMgdGhlIGxheW91dFxuICBDb2xhTGF5b3V0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBsYXlvdXQgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIFxuICAgIGxheW91dC5tYW51YWxseVN0b3BwZWQgPSBmYWxzZTtcblxuICAgICQkLnV0aWwucmVxdWlyZSgnY29sYScsIGZ1bmN0aW9uKGNvbGEpe1xuXG4gICAgICB2YXIgY3kgPSBvcHRpb25zLmN5OyAvLyBjeSBpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlZCBmb3IgdXMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgICAgIHZhciBlZGdlcyA9IGVsZXMuZWRnZXMoKTtcbiAgICAgIHZhciByZWFkeSA9IGZhbHNlO1xuICAgICAgXG4gICAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICAgIH0gKTtcblxuICAgICAgdmFyIGdldE9wdFZhbCA9IGZ1bmN0aW9uKCB2YWwsIGVsZSApe1xuICAgICAgICBpZiggJCQuaXMuZm4odmFsKSApe1xuICAgICAgICAgIHZhciBmbiA9IHZhbDtcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkoIGVsZSwgWyBlbGUgXSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciB1cGRhdGVOb2RlUG9zaXRpb25zID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHggPSB7IG1pbjogSW5maW5pdHksIG1heDogLUluZmluaXR5IH07XG4gICAgICAgIHZhciB5ID0geyBtaW46IEluZmluaXR5LCBtYXg6IC1JbmZpbml0eSB9O1xuXG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIHZhciBzY3JhdGNoID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGE7XG5cbiAgICAgICAgICB4Lm1pbiA9IE1hdGgubWluKCB4Lm1pbiwgc2NyYXRjaC54IHx8IDAgKTtcbiAgICAgICAgICB4Lm1heCA9IE1hdGgubWF4KCB4Lm1heCwgc2NyYXRjaC54IHx8IDAgKTtcblxuICAgICAgICAgIHkubWluID0gTWF0aC5taW4oIHkubWluLCBzY3JhdGNoLnkgfHwgMCApO1xuICAgICAgICAgIHkubWF4ID0gTWF0aC5tYXgoIHkubWF4LCBzY3JhdGNoLnkgfHwgMCApO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZXMucG9zaXRpb25zKGZ1bmN0aW9uKGksIG5vZGUpe1xuICAgICAgICAgIHZhciBzY3JhdGNoID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGE7XG4gICAgICAgICAgdmFyIHJldFBvcztcblxuICAgICAgICAgIGlmKCAhbm9kZS5ncmFiYmVkKCkgJiYgIW5vZGUuaXNQYXJlbnQoKSApe1xuICAgICAgICAgICAgcmV0UG9zID0ge1xuICAgICAgICAgICAgICB4OiBiYi54MSArIHNjcmF0Y2gueCAtIHgubWluLFxuICAgICAgICAgICAgICB5OiBiYi55MSArIHNjcmF0Y2gueSAtIHkubWluXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiggISQkLmlzLm51bWJlcihyZXRQb3MueCkgfHwgISQkLmlzLm51bWJlcihyZXRQb3MueSkgKXtcbiAgICAgICAgICAgICAgcmV0UG9zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiByZXRQb3M7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG5vZGVzLnVwZGF0ZUNvbXBvdW5kQm91bmRzKCk7IC8vIGJlY2F1c2UgdGhlIHdheSB0aGlzIGxheW91dCBzZXRzIHBvc2l0aW9ucyBpcyBidWdneSBmb3Igc29tZSByZWFzb247IHJlZiAjODc4XG5cbiAgICAgICAgaWYoICFyZWFkeSApe1xuICAgICAgICAgIG9uUmVhZHkoKTtcbiAgICAgICAgICByZWFkeSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggb3B0aW9ucy5maXQgKXtcbiAgICAgICAgICBjeS5maXQoIG9wdGlvbnMucGFkZGluZyApO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgb25Eb25lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgICAgZ3JhYmJhYmxlTm9kZXMuZ3JhYmlmeSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZXMub2ZmKCdncmFiIGZyZWUgcG9zaXRpb24nLCBncmFiSGFuZGxlcik7XG4gICAgICAgIG5vZGVzLm9mZignbG9jayB1bmxvY2snLCBsb2NrSGFuZGxlcik7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcbiAgICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0b3AnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBvblJlYWR5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gdHJpZ2dlciBsYXlvdXRyZWFkeSB3aGVuIGVhY2ggbm9kZSBoYXMgaGFkIGl0cyBwb3NpdGlvbiBzZXQgYXQgbGVhc3Qgb25jZVxuICAgICAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIHRpY2tzUGVyRnJhbWUgPSBvcHRpb25zLnJlZnJlc2g7XG4gICAgICB2YXIgdGlja1NraXAgPSAxOyAvLyBmcmFtZXMgdW50aWwgYSB0aWNrOyB1c2VkIHRvIHNsb3cgZG93biBzaW0gZm9yIGRlYnVnZ2luZ1xuXG4gICAgICBpZiggb3B0aW9ucy5yZWZyZXNoIDwgMCApe1xuICAgICAgICB0aWNrU2tpcCA9IE1hdGguYWJzKCBvcHRpb25zLnJlZnJlc2ggKTtcbiAgICAgICAgdGlja3NQZXJGcmFtZSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWNrc1BlckZyYW1lID0gTWF0aC5tYXgoIDEsIHRpY2tzUGVyRnJhbWUgKTsgLy8gYXQgbGVhc3QgMVxuICAgICAgfVxuXG4gICAgICB2YXIgYWRhcHRvciA9IGxheW91dC5hZGFwdG9yID0gY29sYS5hZGFwdG9yKHtcbiAgICAgICAgdHJpZ2dlcjogZnVuY3Rpb24oIGUgKXsgLy8gb24gc2ltIGV2ZW50ICAgICAgXG4gICAgICAgICAgdmFyIFRJQ0sgPSBjb2xhLkV2ZW50VHlwZSA/IGNvbGEuRXZlbnRUeXBlLnRpY2sgOiBudWxsO1xuICAgICAgICAgIHZhciBFTkQgPSBjb2xhLkV2ZW50VHlwZSA/IGNvbGEuRXZlbnRUeXBlLmVuZCA6IG51bGw7XG4gICAgICAgICAgXG4gICAgICAgICAgc3dpdGNoKCBlLnR5cGUgKXtcbiAgICAgICAgICAgIGNhc2UgJ3RpY2snOlxuICAgICAgICAgICAgY2FzZSBUSUNLOlxuICAgICAgICAgICAgICBpZiggb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdlbmQnOlxuICAgICAgICAgICAgY2FzZSBFTkQ6XG4gICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoKTtcbiAgICAgICAgICAgICAgaWYoICFvcHRpb25zLmluZmluaXRlICl7IG9uRG9uZSgpOyB9ICAgICAgICAgICBcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGtpY2s6IGZ1bmN0aW9uKCl7IC8vIGtpY2sgb2ZmIHRoZSBzaW11bGF0aW9uXG4gICAgICAgICAgdmFyIHNraXAgPSAwO1xuXG4gICAgICAgICAgdmFyIGluZnRpY2sgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgaWYoIGxheW91dC5tYW51YWxseVN0b3BwZWQgKXtcbiAgICAgICAgICAgICAgb25Eb25lKCk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHJldCA9IGFkYXB0b3IudGljaygpO1xuXG4gICAgICAgICAgICBpZiggcmV0ICYmIG9wdGlvbnMuaW5maW5pdGUgKXsgLy8gcmVzdW1lIGxheW91dCBpZiBkb25lXG4gICAgICAgICAgICAgIGFkYXB0b3IucmVzdW1lKCk7IC8vIHJlc3VtZSA9PiBuZXcga2lja1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcmV0OyAvLyBhbGxvdyByZWd1bGFyIGZpbmlzaCBiL2Mgb2YgbmV3IGtpY2tcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIG11bHRpdGljayA9IGZ1bmN0aW9uKCl7IC8vIG11bHRpcGxlIHRpY2tzIGluIGEgcm93XG4gICAgICAgICAgICB2YXIgcmV0O1xuXG4gICAgICAgICAgICAvLyBza2lwIHRpY2tzIHRvIHNsb3cgZG93biBsYXlvdXQgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgICAgLy8gdmFyIHRoaXNTa2lwID0gc2tpcDtcbiAgICAgICAgICAgIC8vIHNraXAgPSAoc2tpcCArIDEpICUgdGlja1NraXA7XG4gICAgICAgICAgICAvLyBpZiggdGhpc1NraXAgIT09IDAgKXtcbiAgICAgICAgICAgIC8vICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRpY2tzUGVyRnJhbWUgJiYgIXJldDsgaSsrICl7XG4gICAgICAgICAgICAgIHJldCA9IHJldCB8fCBpbmZ0aWNrKCk7IC8vIHBpY2sgdXAgdHJ1ZSByZXQgdmFscyA9PiBzaW0gZG9uZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiggb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgICAgICB2YXIgZnJhbWUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBpZiggbXVsdGl0aWNrKCkgKXsgcmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZyYW1lICk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAkJC51dGlsLnJlcXVlc3RBbmltYXRpb25GcmFtZSggZnJhbWUgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hpbGUoICFpbmZ0aWNrKCkgKXt9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG9uOiBmdW5jdGlvbiggdHlwZSwgbGlzdGVuZXIgKXt9LCAvLyBkdW1teTsgbm90IG5lZWRlZFxuXG4gICAgICAgIGRyYWc6IGZ1bmN0aW9uKCl7fSAvLyBub3QgbmVlZGVkIGZvciBvdXIgY2FzZVxuICAgICAgfSk7XG4gICAgICBsYXlvdXQuYWRhcHRvciA9IGFkYXB0b3I7XG5cbiAgICAgIC8vIGlmIHNldCBubyBncmFiYmluZyBkdXJpbmcgbGF5b3V0XG4gICAgICB2YXIgZ3JhYmJhYmxlTm9kZXMgPSBub2Rlcy5maWx0ZXIoJzpncmFiYmFibGUnKTtcbiAgICAgIGlmKCBvcHRpb25zLnVuZ3JhYmlmeVdoaWxlU2ltdWxhdGluZyApe1xuICAgICAgICBncmFiYmFibGVOb2Rlcy51bmdyYWJpZnkoKTtcbiAgICAgIH1cblxuICAgICAgLy8gaGFuZGxlIG5vZGUgZHJhZ2dpbmdcbiAgICAgIHZhciBncmFiSGFuZGxlcjtcbiAgICAgIG5vZGVzLm9uKCdncmFiIGZyZWUgcG9zaXRpb24nLCBncmFiSGFuZGxlciA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXM7XG4gICAgICAgIHZhciBzY3JDb2xhID0gbm9kZS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGE7XG4gICAgICAgIHZhciBwb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuXG4gICAgICAgIGlmKCBub2RlLmdyYWJiZWQoKSApe1xuICAgICAgICAgIHNjckNvbGEueCA9IHBvcy54IC0gYmIueDE7XG4gICAgICAgICAgc2NyQ29sYS55ID0gcG9zLnkgLSBiYi55MTtcblxuICAgICAgICAgIGFkYXB0b3IuZHJhZ3N0YXJ0KCBzY3JDb2xhICk7XG4gICAgICAgIH0gZWxzZSBpZiggJCQuaXMubnVtYmVyKHNjckNvbGEueCkgJiYgJCQuaXMubnVtYmVyKHNjckNvbGEueSkgKXtcbiAgICAgICAgICBwb3MueCA9IHNjckNvbGEueCArIGJiLngxO1xuICAgICAgICAgIHBvcy55ID0gc2NyQ29sYS55ICsgYmIueTE7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2goIGUudHlwZSApe1xuICAgICAgICAgIGNhc2UgJ2dyYWInOlxuICAgICAgICAgICAgYWRhcHRvci5kcmFnc3RhcnQoIHNjckNvbGEgKTtcbiAgICAgICAgICAgIGFkYXB0b3IucmVzdW1lKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdmcmVlJzpcbiAgICAgICAgICAgIGFkYXB0b3IuZHJhZ2VuZCggc2NyQ29sYSApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICB9KTtcblxuICAgICAgdmFyIGxvY2tIYW5kbGVyO1xuICAgICAgbm9kZXMub24oJ2xvY2sgdW5sb2NrJywgbG9ja0hhbmRsZXIgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzO1xuICAgICAgICB2YXIgc2NyQ29sYSA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhO1xuICAgICAgXG4gICAgICAgIGlmKCBub2RlLmxvY2tlZCgpICl7XG4gICAgICAgICAgYWRhcHRvci5kcmFnc3RhcnQoIHNjckNvbGEgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGFwdG9yLmRyYWdlbmQoIHNjckNvbGEgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBub25wYXJlbnROb2RlcyA9IG5vZGVzLnN0ZEZpbHRlcihmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICByZXR1cm4gIW5vZGUuaXNQYXJlbnQoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBhZGQgbm9kZXMgdG8gY29sYVxuICAgICAgYWRhcHRvci5ub2Rlcyggbm9ucGFyZW50Tm9kZXMubWFwKGZ1bmN0aW9uKCBub2RlLCBpICl7XG4gICAgICAgIHZhciBwYWRkaW5nID0gZ2V0T3B0VmFsKCBvcHRpb25zLm5vZGVTcGFjaW5nLCBub2RlICk7XG4gICAgICAgIHZhciBwb3MgPSBub2RlLnBvc2l0aW9uKCk7XG5cbiAgICAgICAgdmFyIHN0cnVjdCA9IG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhID0ge1xuICAgICAgICAgIHg6IG9wdGlvbnMucmFuZG9taXplID8gTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIGJiLncgKSA6IHBvcy54LFxuICAgICAgICAgIHk6IG9wdGlvbnMucmFuZG9taXplID8gTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIGJiLmggKSA6IHBvcy55LFxuICAgICAgICAgIHdpZHRoOiBub2RlLm91dGVyV2lkdGgoKSArIDIqcGFkZGluZyxcbiAgICAgICAgICBoZWlnaHQ6IG5vZGUub3V0ZXJIZWlnaHQoKSArIDIqcGFkZGluZyxcbiAgICAgICAgICBpbmRleDogaVxuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBzdHJ1Y3Q7XG4gICAgICB9KSApO1xuXG4gICAgICBpZiggb3B0aW9ucy5hbGlnbm1lbnQgKXsgLy8gdGhlbiBzZXQgYWxpZ25tZW50IGNvbnN0cmFpbnRzXG5cbiAgICAgICAgdmFyIG9mZnNldHNYID0gW107XG4gICAgICAgIHZhciBvZmZzZXRzWSA9IFtdO1xuXG4gICAgICAgIG5vbnBhcmVudE5vZGVzLmZvckVhY2goZnVuY3Rpb24oIG5vZGUgKXtcbiAgICAgICAgICB2YXIgYWxpZ24gPSBnZXRPcHRWYWwoIG9wdGlvbnMuYWxpZ25tZW50LCBub2RlICk7XG4gICAgICAgICAgdmFyIHNjckNvbGEgPSBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBzY3JDb2xhLmluZGV4O1xuXG4gICAgICAgICAgaWYoICFhbGlnbiApeyByZXR1cm47IH1cblxuICAgICAgICAgIGlmKCBhbGlnbi54ICE9IG51bGwgKXtcbiAgICAgICAgICAgIG9mZnNldHNYLnB1c2goe1xuICAgICAgICAgICAgICBub2RlOiBpbmRleCxcbiAgICAgICAgICAgICAgb2Zmc2V0OiBhbGlnbi54XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggYWxpZ24ueSAhPSBudWxsICl7XG4gICAgICAgICAgICBvZmZzZXRzWS5wdXNoKHtcbiAgICAgICAgICAgICAgbm9kZTogaW5kZXgsXG4gICAgICAgICAgICAgIG9mZnNldDogYWxpZ24ueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgYWxpZ25tZW50IGNvbnN0cmFpbnRzIG9uIG5vZGVzXG4gICAgICAgIHZhciBjb25zdHJhaW50cyA9IFtdO1xuXG4gICAgICAgIGlmKCBvZmZzZXRzWC5sZW5ndGggPiAwICl7XG4gICAgICAgICAgY29uc3RyYWludHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYWxpZ25tZW50JyxcbiAgICAgICAgICAgIGF4aXM6ICd4JyxcbiAgICAgICAgICAgIG9mZnNldHM6IG9mZnNldHNYXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiggb2Zmc2V0c1kubGVuZ3RoID4gMCApe1xuICAgICAgICAgIGNvbnN0cmFpbnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2FsaWdubWVudCcsXG4gICAgICAgICAgICBheGlzOiAneScsXG4gICAgICAgICAgICBvZmZzZXRzOiBvZmZzZXRzWVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBhZGFwdG9yLmNvbnN0cmFpbnRzKCBjb25zdHJhaW50cyApO1xuXG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBjb21wb3VuZCBub2RlcyB0byBjb2xhXG4gICAgICBhZGFwdG9yLmdyb3Vwcyggbm9kZXMuc3RkRmlsdGVyKGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIHJldHVybiBub2RlLmlzUGFyZW50KCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oIG5vZGUsIGkgKXsgLy8gYWRkIGJhc2ljIGdyb3VwIGluY2wgbGVhZiBub2Rlc1xuICAgICAgICBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYSA9IHtcbiAgICAgICAgICBpbmRleDogaSxcblxuICAgICAgICAgIGxlYXZlczogbm9kZS5kZXNjZW5kYW50cygpLnN0ZEZpbHRlcihmdW5jdGlvbiggY2hpbGQgKXtcbiAgICAgICAgICAgIHJldHVybiAhY2hpbGQuaXNQYXJlbnQoKTtcbiAgICAgICAgICB9KS5tYXAoZnVuY3Rpb24oIGNoaWxkICl7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRbMF0uX3ByaXZhdGUuc2NyYXRjaC5jb2xhLmluZGV4O1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oIG5vZGUgKXsgLy8gYWRkIHN1Ymdyb3Vwc1xuICAgICAgICBub2RlLl9wcml2YXRlLnNjcmF0Y2guY29sYS5ncm91cHMgPSBub2RlLmRlc2NlbmRhbnRzKCkuc3RkRmlsdGVyKGZ1bmN0aW9uKCBjaGlsZCApe1xuICAgICAgICAgIHJldHVybiBjaGlsZC5pc1BhcmVudCgpO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24oIGNoaWxkICl7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkLl9wcml2YXRlLnNjcmF0Y2guY29sYS5pbmRleDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb2xhO1xuICAgICAgfSkgKTtcblxuICAgICAgLy8gZ2V0IHRoZSBlZGdlIGxlbmd0aCBzZXR0aW5nIG1lY2hhbmlzbVxuICAgICAgdmFyIGxlbmd0aDtcbiAgICAgIHZhciBsZW5ndGhGbk5hbWU7XG4gICAgICBpZiggb3B0aW9ucy5lZGdlTGVuZ3RoICE9IG51bGwgKXtcbiAgICAgICAgbGVuZ3RoID0gb3B0aW9ucy5lZGdlTGVuZ3RoO1xuICAgICAgICBsZW5ndGhGbk5hbWUgPSAnbGlua0Rpc3RhbmNlJztcbiAgICAgIH0gZWxzZSBpZiggb3B0aW9ucy5lZGdlU3ltRGlmZkxlbmd0aCAhPSBudWxsICl7XG4gICAgICAgIGxlbmd0aCA9IG9wdGlvbnMuZWRnZVN5bURpZmZMZW5ndGg7XG4gICAgICAgIGxlbmd0aEZuTmFtZSA9ICdzeW1tZXRyaWNEaWZmTGlua0xlbmd0aHMnO1xuICAgICAgfSBlbHNlIGlmKCBvcHRpb25zLmVkZ2VKYWNjYXJkTGVuZ3RoICE9IG51bGwgKXtcbiAgICAgICAgbGVuZ3RoID0gb3B0aW9ucy5lZGdlSmFjY2FyZExlbmd0aDtcbiAgICAgICAgbGVuZ3RoRm5OYW1lID0gJ2phY2NhcmRMaW5rTGVuZ3Rocyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW5ndGggPSAxMDA7XG4gICAgICAgIGxlbmd0aEZuTmFtZSA9ICdsaW5rRGlzdGFuY2UnO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoR2V0dGVyID0gZnVuY3Rpb24oIGxpbmsgKXtcbiAgICAgICAgcmV0dXJuIGxpbmsuY2FsY0xlbmd0aDtcbiAgICAgIH07XG5cbiAgICAgIC8vIGFkZCB0aGUgZWRnZXMgdG8gY29sYVxuICAgICAgYWRhcHRvci5saW5rcyggZWRnZXMuc3RkRmlsdGVyKGZ1bmN0aW9uKCBlZGdlICl7XG4gICAgICAgIHJldHVybiAhZWRnZS5zb3VyY2UoKS5pc1BhcmVudCgpICYmICFlZGdlLnRhcmdldCgpLmlzUGFyZW50KCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24oIGVkZ2UsIGkgKXtcbiAgICAgICAgdmFyIGMgPSBlZGdlLl9wcml2YXRlLnNjcmF0Y2guY29sYSA9IHtcbiAgICAgICAgICBzb3VyY2U6IGVkZ2Uuc291cmNlKClbMF0uX3ByaXZhdGUuc2NyYXRjaC5jb2xhLmluZGV4LFxuICAgICAgICAgIHRhcmdldDogZWRnZS50YXJnZXQoKVswXS5fcHJpdmF0ZS5zY3JhdGNoLmNvbGEuaW5kZXhcbiAgICAgICAgfTtcblxuICAgICAgICBpZiggbGVuZ3RoICE9IG51bGwgKXtcbiAgICAgICAgICBjLmNhbGNMZW5ndGggPSBnZXRPcHRWYWwoIGxlbmd0aCwgZWRnZSApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9KSApO1xuXG4gICAgICBhZGFwdG9yLnNpemUoWyBiYi53LCBiYi5oIF0pO1xuXG4gICAgICBpZiggbGVuZ3RoICE9IG51bGwgKXtcbiAgICAgICAgYWRhcHRvclsgbGVuZ3RoRm5OYW1lIF0oIGxlbmd0aEdldHRlciApO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIGZsb3cgb2YgY29sYVxuICAgICAgaWYoIG9wdGlvbnMuZmxvdyApe1xuICAgICAgICB2YXIgZmxvdztcbiAgICAgICAgdmFyIGRlZkF4aXMgPSAneSc7XG4gICAgICAgIHZhciBkZWZNaW5TZXAgPSA1MDtcblxuICAgICAgICBpZiggJCQuaXMuc3RyaW5nKG9wdGlvbnMuZmxvdykgKXtcbiAgICAgICAgICBmbG93ID0ge1xuICAgICAgICAgICAgYXhpczogb3B0aW9ucy5mbG93LFxuICAgICAgICAgICAgbWluU2VwYXJhdGlvbjogZGVmTWluU2VwXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5udW1iZXIob3B0aW9ucy5mbG93KSApe1xuICAgICAgICAgIGZsb3cgPSB7XG4gICAgICAgICAgICBheGlzOiBkZWZBeGlzLFxuICAgICAgICAgICAgbWluU2VwYXJhdGlvbjogb3B0aW9ucy5mbG93XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmKCAkJC5pcy5wbGFpbk9iamVjdChvcHRpb25zLmZsb3cpICl7XG4gICAgICAgICAgZmxvdyA9IG9wdGlvbnMuZmxvdztcblxuICAgICAgICAgIGZsb3cuYXhpcyA9IGZsb3cuYXhpcyB8fCBkZWZBeGlzO1xuICAgICAgICAgIGZsb3cubWluU2VwYXJhdGlvbiA9IGZsb3cubWluU2VwYXJhdGlvbiAhPSBudWxsID8gZmxvdy5taW5TZXBhcmF0aW9uIDogZGVmTWluU2VwO1xuICAgICAgICB9IGVsc2UgeyAvLyBlLmcuIG9wdGlvbnMuZmxvdzogdHJ1ZVxuICAgICAgICAgIGZsb3cgPSB7XG4gICAgICAgICAgICBheGlzOiBkZWZBeGlzLFxuICAgICAgICAgICAgbWluU2VwYXJhdGlvbjogZGVmTWluU2VwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkYXB0b3IuZmxvd0xheW91dCggZmxvdy5heGlzICwgZmxvdy5taW5TZXBhcmF0aW9uICk7XG4gICAgICB9XG5cbiAgICAgIGxheW91dC50cmlnZ2VyKHsgdHlwZTogJ2xheW91dHN0YXJ0JywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgIGFkYXB0b3JcbiAgICAgICAgLmF2b2lkT3ZlcmxhcHMoIG9wdGlvbnMuYXZvaWRPdmVybGFwIClcbiAgICAgICAgLmhhbmRsZURpc2Nvbm5lY3RlZCggb3B0aW9ucy5oYW5kbGVEaXNjb25uZWN0ZWQgKVxuICAgICAgICAuc3RhcnQoIG9wdGlvbnMudW5jb25zdHJJdGVyLCBvcHRpb25zLnVzZXJDb25zdEl0ZXIsIG9wdGlvbnMuYWxsQ29uc3RJdGVyKVxuICAgICAgO1xuXG4gICAgICBpZiggIW9wdGlvbnMuaW5maW5pdGUgKXtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIGlmKCAhbGF5b3V0Lm1hbnVhbGx5U3RvcHBlZCApe1xuICAgICAgICAgICAgYWRhcHRvci5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBvcHRpb25zLm1heFNpbXVsYXRpb25UaW1lKTtcbiAgICAgIH1cblxuICAgIH0pOyAvLyByZXF1aXJlXG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICAvLyBjYWxsZWQgb24gY29udGludW91cyBsYXlvdXRzIHRvIHN0b3AgdGhlbSBiZWZvcmUgdGhleSBmaW5pc2hcbiAgQ29sYUxheW91dC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gICAgaWYoIHRoaXMuYWRhcHRvciApe1xuICAgICAgdGhpcy5tYW51YWxseVN0b3BwZWQgPSB0cnVlO1xuICAgICAgdGhpcy5hZGFwdG9yLnN0b3AoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICAvLyByZWdpc3RlciB0aGUgbGF5b3V0XG4gICQkKCdsYXlvdXQnLCAnY29sYScsIENvbGFMYXlvdXQpO1xuXG59KShjeXRvc2NhcGUpO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIHBhZGRpbmc6IDMwLCAvLyB0aGUgcGFkZGluZyBvbiBmaXRcbiAgICBzdGFydEFuZ2xlOiAzLzIgKiBNYXRoLlBJLCAvLyB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG5vZGVcbiAgICBjb3VudGVyY2xvY2t3aXNlOiBmYWxzZSwgLy8gd2hldGhlciB0aGUgbGF5b3V0IHNob3VsZCBnbyBjb3VudGVyY2xvY2t3aXNlL2FudGljbG9ja3dpc2UgKHRydWUpIG9yIGNsb2Nrd2lzZSAoZmFsc2UpXG4gICAgbWluTm9kZVNwYWNpbmc6IDEwLCAvLyBtaW4gc3BhY2luZyBiZXR3ZWVuIG91dHNpZGUgb2Ygbm9kZXMgKHVzZWQgZm9yIHJhZGl1cyBhZGp1c3RtZW50KVxuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQsIC8vIGNvbnN0cmFpbiBsYXlvdXQgYm91bmRzOyB7IHgxLCB5MSwgeDIsIHkyIH0gb3IgeyB4MSwgeTEsIHcsIGggfVxuICAgIGF2b2lkT3ZlcmxhcDogdHJ1ZSwgLy8gcHJldmVudHMgbm9kZSBvdmVybGFwLCBtYXkgb3ZlcmZsb3cgYm91bmRpbmdCb3ggaWYgbm90IGVub3VnaCBzcGFjZVxuICAgIGhlaWdodDogdW5kZWZpbmVkLCAvLyBoZWlnaHQgb2YgbGF5b3V0IGFyZWEgKG92ZXJyaWRlcyBjb250YWluZXIgaGVpZ2h0KVxuICAgIHdpZHRoOiB1bmRlZmluZWQsIC8vIHdpZHRoIG9mIGxheW91dCBhcmVhIChvdmVycmlkZXMgY29udGFpbmVyIHdpZHRoKVxuICAgIGNvbmNlbnRyaWM6IGZ1bmN0aW9uKG5vZGUpeyAvLyByZXR1cm5zIG51bWVyaWMgdmFsdWUgZm9yIGVhY2ggbm9kZSwgcGxhY2luZyBoaWdoZXIgbm9kZXMgaW4gbGV2ZWxzIHRvd2FyZHMgdGhlIGNlbnRyZVxuICAgICAgcmV0dXJuIG5vZGUuZGVncmVlKCk7XG4gICAgfSxcbiAgICBsZXZlbFdpZHRoOiBmdW5jdGlvbihub2Rlcyl7IC8vIHRoZSB2YXJpYXRpb24gb2YgY29uY2VudHJpYyB2YWx1ZXMgaW4gZWFjaCBsZXZlbFxuICAgICAgcmV0dXJuIG5vZGVzLm1heERlZ3JlZSgpIC8gNDtcbiAgICB9LFxuICAgIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCAvLyBjYWxsYmFjayBvbiBsYXlvdXRzdG9wXG4gIH07XG4gIFxuICBmdW5jdGlvbiBDb25jZW50cmljTGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQoe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgfVxuICBcbiAgQ29uY2VudHJpY0xheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyYW1zID0gdGhpcy5vcHRpb25zO1xuICAgIHZhciBvcHRpb25zID0gcGFyYW1zO1xuICAgIFxuICAgIHZhciBjeSA9IHBhcmFtcy5jeTtcbiAgICBcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcbiAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgXG4gICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgIH0gKTtcblxuICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICB4OiBiYi54MSArIGJiLncvMixcbiAgICAgIHk6IGJiLnkxICsgYmIuaC8yXG4gICAgfTtcbiAgICBcbiAgICB2YXIgbm9kZVZhbHVlcyA9IFtdOyAvLyB7IG5vZGUsIHZhbHVlIH1cbiAgICB2YXIgdGhldGEgPSBvcHRpb25zLnN0YXJ0QW5nbGU7XG4gICAgdmFyIG1heE5vZGVTaXplID0gMDtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKysgKXtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICBcbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgbm9kZSB2YWx1ZVxuICAgICAgdmFsdWUgPSBvcHRpb25zLmNvbmNlbnRyaWMuYXBwbHkobm9kZSwgWyBub2RlIF0pO1xuICAgICAgbm9kZVZhbHVlcy5wdXNoKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBub2RlOiBub2RlXG4gICAgICB9KTtcblxuICAgICAgLy8gZm9yIHN0eWxlIG1hcHBpbmdcbiAgICAgIG5vZGUuX3ByaXZhdGUuc2NyYXRjaC5jb25jZW50cmljID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gaW4gY2FzZSB3ZSB1c2VkIHRoZSBgY29uY2VudHJpY2AgaW4gc3R5bGVcbiAgICBub2Rlcy51cGRhdGVTdHlsZSgpO1xuXG4gICAgLy8gY2FsY3VsYXRlIG1heCBzaXplIG5vdyBiYXNlZCBvbiBwb3RlbnRpYWxseSB1cGRhdGVkIG1hcHBlcnNcbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICBtYXhOb2RlU2l6ZSA9IE1hdGgubWF4KCBtYXhOb2RlU2l6ZSwgbm9kZS5vdXRlcldpZHRoKCksIG5vZGUub3V0ZXJIZWlnaHQoKSApO1xuICAgIH1cblxuICAgIC8vIHNvcnQgbm9kZSB2YWx1ZXMgaW4gZGVzY3JlYXNpbmcgb3JkZXJcbiAgICBub2RlVmFsdWVzLnNvcnQoZnVuY3Rpb24oYSwgYil7XG4gICAgICByZXR1cm4gYi52YWx1ZSAtIGEudmFsdWU7XG4gICAgfSk7XG5cbiAgICB2YXIgbGV2ZWxXaWR0aCA9IG9wdGlvbnMubGV2ZWxXaWR0aCggbm9kZXMgKTtcblxuICAgIC8vIHB1dCB0aGUgdmFsdWVzIGludG8gbGV2ZWxzXG4gICAgdmFyIGxldmVscyA9IFsgW10gXTtcbiAgICB2YXIgY3VycmVudExldmVsID0gbGV2ZWxzWzBdO1xuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbm9kZVZhbHVlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgdmFyIHZhbCA9IG5vZGVWYWx1ZXNbaV07XG5cbiAgICAgIGlmKCBjdXJyZW50TGV2ZWwubGVuZ3RoID4gMCApe1xuICAgICAgICB2YXIgZGlmZiA9IE1hdGguYWJzKCBjdXJyZW50TGV2ZWxbMF0udmFsdWUgLSB2YWwudmFsdWUgKTtcblxuICAgICAgICBpZiggZGlmZiA+PSBsZXZlbFdpZHRoICl7XG4gICAgICAgICAgY3VycmVudExldmVsID0gW107XG4gICAgICAgICAgbGV2ZWxzLnB1c2goIGN1cnJlbnRMZXZlbCApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnRMZXZlbC5wdXNoKCB2YWwgKTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgcG9zaXRpb25zIGZyb20gbGV2ZWxzXG5cbiAgICB2YXIgcG9zID0ge307IC8vIGlkID0+IHBvc2l0aW9uXG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBtaW5EaXN0ID0gbWF4Tm9kZVNpemUgKyBvcHRpb25zLm1pbk5vZGVTcGFjaW5nOyAvLyBtaW4gZGlzdCBiZXR3ZWVuIG5vZGVzXG5cbiAgICBpZiggIW9wdGlvbnMuYXZvaWRPdmVybGFwICl7IC8vIHRoZW4gc3RyaWN0bHkgY29uc3RyYWluIHRvIGJiXG4gICAgICB2YXIgZmlyc3RMdmxIYXNNdWx0aSA9IGxldmVscy5sZW5ndGggPiAwICYmIGxldmVsc1swXS5sZW5ndGggPiAxO1xuICAgICAgdmFyIG1heFIgPSAoIE1hdGgubWluKGJiLncsIGJiLmgpIC8gMiAtIG1pbkRpc3QgKTtcbiAgICAgIHZhciByU3RlcCA9IG1heFIgLyAoIGxldmVscy5sZW5ndGggKyBmaXJzdEx2bEhhc011bHRpID8gMSA6IDAgKTtcblxuICAgICAgbWluRGlzdCA9IE1hdGgubWluKCBtaW5EaXN0LCByU3RlcCApO1xuICAgIH1cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrICl7XG4gICAgICB2YXIgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICB2YXIgZFRoZXRhID0gMiAqIE1hdGguUEkgLyBsZXZlbC5sZW5ndGg7XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSB0aGUgcmFkaXVzXG4gICAgICBpZiggbGV2ZWwubGVuZ3RoID4gMSAmJiBvcHRpb25zLmF2b2lkT3ZlcmxhcCApeyAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgICAgIHZhciBkY29zID0gTWF0aC5jb3MoZFRoZXRhKSAtIE1hdGguY29zKDApO1xuICAgICAgICB2YXIgZHNpbiA9IE1hdGguc2luKGRUaGV0YSkgLSBNYXRoLnNpbigwKTtcbiAgICAgICAgdmFyIHJNaW4gPSBNYXRoLnNxcnQoIG1pbkRpc3QgKiBtaW5EaXN0IC8gKCBkY29zKmRjb3MgKyBkc2luKmRzaW4gKSApOyAvLyBzLnQuIG5vIG5vZGVzIG92ZXJsYXBwaW5nXG4gICAgICAgIHIgPSBNYXRoLm1heCggck1pbiwgciApO1xuICAgICAgfVxuXG4gICAgICBmb3IoIHZhciBqID0gMDsgaiA8IGxldmVsLmxlbmd0aDsgaisrICl7XG4gICAgICAgIHZhciB2YWwgPSBsZXZlbFtqXTtcbiAgICAgICAgdmFyIHRoZXRhID0gb3B0aW9ucy5zdGFydEFuZ2xlICsgKG9wdGlvbnMuY291bnRlcmNsb2Nrd2lzZSA/IC0xIDogMSkgKiBkVGhldGEgKiBqO1xuXG4gICAgICAgIHZhciBwID0ge1xuICAgICAgICAgIHg6IGNlbnRlci54ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgICB5OiBjZW50ZXIueSArIHIgKiBNYXRoLnNpbih0aGV0YSlcbiAgICAgICAgfTtcblxuICAgICAgICBwb3NbIHZhbC5ub2RlLmlkKCkgXSA9IHA7XG4gICAgICB9XG5cbiAgICAgIHIgKz0gbWluRGlzdDtcbiAgICAgIFxuICAgIH0gXG5cbiAgICAvLyBwb3NpdGlvbiB0aGUgbm9kZXNcbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24oKXtcbiAgICAgIHZhciBpZCA9IHRoaXMuaWQoKTtcblxuICAgICAgcmV0dXJuIHBvc1tpZF07XG4gICAgfSk7XG4gIFxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdjb25jZW50cmljJywgQ29uY2VudHJpY0xheW91dCk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG4vKlxuICBUaGUgQ29TRSBsYXlvdXQgd2FzIHdyaXR0ZW4gYnkgR2VyYXJkbyBIdWNrLlxuXG4gIE1vZGlmaWNhdGlvbnMgdHJhY2tlZCBvbiBHaXRodWIuXG4qL1xuXG47KGZ1bmN0aW9uKCQkKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgREVCVUc7XG5cbiAgLyoqXG4gICAqIEBicmllZiA6ICBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gICAqL1xuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgLy8gQ2FsbGVkIG9uIGBsYXlvdXRyZWFkeWBcbiAgICByZWFkeSAgICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8vIENhbGxlZCBvbiBgbGF5b3V0c3RvcGBcbiAgICBzdG9wICAgICAgICAgICAgICAgIDogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8vIFdoZXRoZXIgdG8gYW5pbWF0ZSB3aGlsZSBydW5uaW5nIHRoZSBsYXlvdXRcbiAgICBhbmltYXRlICAgICAgICAgICAgIDogdHJ1ZSxcblxuICAgIC8vIE51bWJlciBvZiBpdGVyYXRpb25zIGJldHdlZW4gY29uc2VjdXRpdmUgc2NyZWVuIHBvc2l0aW9ucyB1cGRhdGUgKDAgLT4gb25seSB1cGRhdGVkIG9uIHRoZSBlbmQpXG4gICAgcmVmcmVzaCAgICAgICAgICAgICA6IDQsXG4gICAgXG4gICAgLy8gV2hldGhlciB0byBmaXQgdGhlIG5ldHdvcmsgdmlldyBhZnRlciB3aGVuIGRvbmVcbiAgICBmaXQgICAgICAgICAgICAgICAgIDogdHJ1ZSwgXG5cbiAgICAvLyBQYWRkaW5nIG9uIGZpdFxuICAgIHBhZGRpbmcgICAgICAgICAgICAgOiAzMCwgXG5cbiAgICAvLyBDb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICBib3VuZGluZ0JveCAgICAgICAgIDogdW5kZWZpbmVkLFxuXG4gICAgLy8gV2hldGhlciB0byByYW5kb21pemUgbm9kZSBwb3NpdGlvbnMgb24gdGhlIGJlZ2lubmluZ1xuICAgIHJhbmRvbWl6ZSAgICAgICAgICAgOiB0cnVlLFxuICAgIFxuICAgIC8vIFdoZXRoZXIgdG8gdXNlIHRoZSBKUyBjb25zb2xlIHRvIHByaW50IGRlYnVnIG1lc3NhZ2VzXG4gICAgZGVidWcgICAgICAgICAgICAgICA6IGZhbHNlLFxuXG4gICAgLy8gTm9kZSByZXB1bHNpb24gKG5vbiBvdmVybGFwcGluZykgbXVsdGlwbGllclxuICAgIG5vZGVSZXB1bHNpb24gICAgICAgOiA0MDAwMDAsXG4gICAgXG4gICAgLy8gTm9kZSByZXB1bHNpb24gKG92ZXJsYXBwaW5nKSBtdWx0aXBsaWVyXG4gICAgbm9kZU92ZXJsYXAgICAgICAgICA6IDEwLFxuICAgIFxuICAgIC8vIElkZWFsIGVkZ2UgKG5vbiBuZXN0ZWQpIGxlbmd0aFxuICAgIGlkZWFsRWRnZUxlbmd0aCAgICAgOiAxMCxcbiAgICBcbiAgICAvLyBEaXZpc29yIHRvIGNvbXB1dGUgZWRnZSBmb3JjZXNcbiAgICBlZGdlRWxhc3RpY2l0eSAgICAgIDogMTAwLFxuICAgIFxuICAgIC8vIE5lc3RpbmcgZmFjdG9yIChtdWx0aXBsaWVyKSB0byBjb21wdXRlIGlkZWFsIGVkZ2UgbGVuZ3RoIGZvciBuZXN0ZWQgZWRnZXNcbiAgICBuZXN0aW5nRmFjdG9yICAgICAgIDogNSwgXG4gICAgXG4gICAgLy8gR3Jhdml0eSBmb3JjZSAoY29uc3RhbnQpXG4gICAgZ3Jhdml0eSAgICAgICAgICAgICA6IDI1MCwgXG4gICAgXG4gICAgLy8gTWF4aW11bSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtXG4gICAgbnVtSXRlciAgICAgICAgICAgICA6IDEwMCxcbiAgICBcbiAgICAvLyBJbml0aWFsIHRlbXBlcmF0dXJlIChtYXhpbXVtIG5vZGUgZGlzcGxhY2VtZW50KVxuICAgIGluaXRpYWxUZW1wICAgICAgICAgOiAyMDAsXG4gICAgXG4gICAgLy8gQ29vbGluZyBmYWN0b3IgKGhvdyB0aGUgdGVtcGVyYXR1cmUgaXMgcmVkdWNlZCBiZXR3ZWVuIGNvbnNlY3V0aXZlIGl0ZXJhdGlvbnNcbiAgICBjb29saW5nRmFjdG9yICAgICAgIDogMC45NSwgXG4gICAgXG4gICAgLy8gTG93ZXIgdGVtcGVyYXR1cmUgdGhyZXNob2xkIChiZWxvdyB0aGlzIHBvaW50IHRoZSBsYXlvdXQgd2lsbCBlbmQpXG4gICAgbWluVGVtcCAgICAgICAgICAgICA6IDEuMFxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiAgICAgICA6IGNvbnN0cnVjdG9yXG4gICAqIEBhcmcgb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gICAqL1xuICBmdW5jdGlvbiBDb3NlTGF5b3V0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSAkJC51dGlsLmV4dGVuZCh7fSwgZGVmYXVsdHMsIG9wdGlvbnMpOyBcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IHJ1bnMgdGhlIGxheW91dFxuICAgKi9cbiAgQ29zZUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGN5ICAgICAgPSBvcHRpb25zLmN5O1xuICAgIHZhciBsYXlvdXQgID0gdGhpcztcblxuICAgIGxheW91dC5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdGFydCcsIGxheW91dDogbGF5b3V0IH0pO1xuXG4gICAgLy8gU2V0IERFQlVHIC0gR2xvYmFsIHZhcmlhYmxlXG4gICAgaWYgKHRydWUgPT09IG9wdGlvbnMuZGVidWcpIHtcbiAgICAgIERFQlVHID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgREVCVUcgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBHZXQgc3RhcnQgdGltZVxuICAgIHZhciBzdGFydFRpbWUgPSBuZXcgRGF0ZSgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBsYXlvdXQgaW5mb1xuICAgIHZhciBsYXlvdXRJbmZvID0gY3JlYXRlTGF5b3V0SW5mbyhjeSwgbGF5b3V0LCBvcHRpb25zKTtcbiAgICBcbiAgICAvLyBTaG93IExheW91dEluZm8gY29udGVudHMgaWYgZGVidWdnaW5nXG4gICAgaWYgKERFQlVHKSB7XG4gICAgICBwcmludExheW91dEluZm8obGF5b3V0SW5mbyk7XG4gICAgfVxuXG4gICAgLy8gSWYgcmVxdWlyZWQsIHJhbmRvbWl6ZSBub2RlIHBvc2l0aW9uc1xuICAgIGlmICh0cnVlID09PSBvcHRpb25zLnJhbmRvbWl6ZSkge1xuICAgICAgcmFuZG9taXplUG9zaXRpb25zKGxheW91dEluZm8sIGN5KTtcbiAgICB9XG5cbiAgICB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuXG4gICAgdmFyIG1haW5Mb29wID0gZnVuY3Rpb24oaSl7XG4gICAgICBpZiggbGF5b3V0LnN0b3BwZWQgKXtcbiAgICAgICAgLy8gbG9nRGVidWcoXCJMYXlvdXQgbWFudWFsbHkgc3RvcHBlZC4gU3RvcHBpbmcgY29tcHV0YXRpb24gaW4gc3RlcCBcIiArIGkpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIERvIG9uZSBzdGVwIGluIHRoZSBwaGlzaWNhbCBzaW11bGF0aW9uXG4gICAgICBzdGVwKGxheW91dEluZm8sIGN5LCBvcHRpb25zLCBpKTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHRlbXBlcmF0dXJlXG4gICAgICBsYXlvdXRJbmZvLnRlbXBlcmF0dXJlID0gbGF5b3V0SW5mby50ZW1wZXJhdHVyZSAqIG9wdGlvbnMuY29vbGluZ0ZhY3RvcjtcbiAgICAgIC8vIGxvZ0RlYnVnKFwiTmV3IHRlbXBlcmF0dXJlOiBcIiArIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuXG4gICAgICBpZiAobGF5b3V0SW5mby50ZW1wZXJhdHVyZSA8IG9wdGlvbnMubWluVGVtcCkge1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlRlbXBlcmF0dXJlIGRyb3AgYmVsb3cgbWluaW11bSB0aHJlc2hvbGQuIFN0b3BwaW5nIGNvbXB1dGF0aW9uIGluIHN0ZXAgXCIgKyBpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGRvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgcmVmcmVzaFBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIEZpdCB0aGUgZ3JhcGggaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAodHJ1ZSA9PT0gb3B0aW9ucy5maXQpIHtcbiAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gR2V0IGVuZCB0aW1lXG4gICAgICB2YXIgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG5cbiAgICAgIGNvbnNvbGUuaW5mbygnTGF5b3V0IHRvb2sgJyArIChlbmRUaW1lIC0gc3RhcnRUaW1lKSArICcgbXMnKTtcblxuICAgICAgLy8gTGF5b3V0IGhhcyBmaW5pc2hlZFxuICAgICAgbGF5b3V0Lm9uZSgnbGF5b3V0c3RvcCcsIG9wdGlvbnMuc3RvcCk7XG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG4gICAgfTtcblxuICAgIGlmKCBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBmcmFtZSA9IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdmFyIGYgPSAwO1xuICAgICAgICB2YXIgbG9vcFJldDtcbiAgICAgICAgd2hpbGUoIGYgPCBvcHRpb25zLnJlZnJlc2ggJiYgaSA8IG9wdGlvbnMubnVtSXRlciApe1xuICAgICAgICAgIHZhciBsb29wUmV0ID0gbWFpbkxvb3AoaSk7XG4gICAgICAgICAgaWYoIGxvb3BSZXQgPT09IGZhbHNlICl7IGJyZWFrOyB9XG5cbiAgICAgICAgICBmKys7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVmcmVzaFBvc2l0aW9ucyhsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucyk7XG4gICAgICAgIGlmKCBvcHRpb25zLmZpdCApe1xuICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIGxvb3BSZXQgIT09IGZhbHNlICYmIGkgKyAxIDwgb3B0aW9ucy5udW1JdGVyICkge1xuICAgICAgICAgICQkLnV0aWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBmcmFtZSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJCQudXRpbC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZyYW1lICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5udW1JdGVyOyBpKyspIHtcbiAgICAgICAgaWYoIG1haW5Mb29wKGkpID09PSBmYWxzZSApeyBicmVhazsgfVxuICAgICAgfVxuXG4gICAgICBkb25lKCk7XG4gICAgfVxuICAgXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG4gICAqL1xuICBDb3NlTGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmICAgICA6IENyZWF0ZXMgYW4gb2JqZWN0IHdoaWNoIGlzIGNvbnRhaW5zIGFsbCB0aGUgZGF0YVxuICAgKiAgICAgICAgICAgICAgdXNlZCBpbiB0aGUgbGF5b3V0IHByb2Nlc3NcbiAgICogQGFyZyBjeSAgICA6IGN5dG9zY2FwZS5qcyBvYmplY3RcbiAgICogQHJldHVybiAgICA6IGxheW91dEluZm8gb2JqZWN0IGluaXRpYWxpemVkXG4gICAqL1xuICB2YXIgY3JlYXRlTGF5b3V0SW5mbyA9IGZ1bmN0aW9uKGN5LCBsYXlvdXQsIG9wdGlvbnMpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIHZhciBlZGdlcyA9IG9wdGlvbnMuZWxlcy5lZGdlcygpO1xuICAgIHZhciBub2RlcyA9IG9wdGlvbnMuZWxlcy5ub2RlcygpO1xuXG4gICAgdmFyIGxheW91dEluZm8gICA9IHtcbiAgICAgIGxheW91dCAgICAgICA6IGxheW91dCxcbiAgICAgIGxheW91dE5vZGVzICA6IFtdLCBcbiAgICAgIGlkVG9JbmRleCAgICA6IHt9LFxuICAgICAgbm9kZVNpemUgICAgIDogbm9kZXMuc2l6ZSgpLFxuICAgICAgZ3JhcGhTZXQgICAgIDogW10sXG4gICAgICBpbmRleFRvR3JhcGggOiBbXSwgXG4gICAgICBsYXlvdXRFZGdlcyAgOiBbXSxcbiAgICAgIGVkZ2VTaXplICAgICA6IGVkZ2VzLnNpemUoKSxcbiAgICAgIHRlbXBlcmF0dXJlICA6IG9wdGlvbnMuaW5pdGlhbFRlbXAsXG4gICAgICBjbGllbnRXaWR0aCAgOiBjeS53aWR0aCgpLFxuICAgICAgY2xpZW50SGVpZ2h0IDogY3kud2lkdGgoKSxcbiAgICAgIGJvdW5kaW5nQm94ICA6ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgICAgICAgICAgICAgICAgICAgfSApXG4gICAgfTsgXG4gICAgXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBub2RlcywgY3JlYXRpbmcgbGF5b3V0IG5vZGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciB0ZW1wTm9kZSAgICAgICAgPSB7fTtcbiAgICAgIHRlbXBOb2RlLmlkICAgICAgICAgPSBub2Rlc1tpXS5kYXRhKCdpZCcpO1xuICAgICAgdGVtcE5vZGUucGFyZW50SWQgICA9IG5vZGVzW2ldLmRhdGEoJ3BhcmVudCcpOyAgICAgIFxuICAgICAgdGVtcE5vZGUuY2hpbGRyZW4gICA9IFtdO1xuICAgICAgdGVtcE5vZGUucG9zaXRpb25YICA9IG5vZGVzW2ldLnBvc2l0aW9uKCd4Jyk7XG4gICAgICB0ZW1wTm9kZS5wb3NpdGlvblkgID0gbm9kZXNbaV0ucG9zaXRpb24oJ3knKTtcbiAgICAgIHRlbXBOb2RlLm9mZnNldFggICAgPSAwOyAgICAgIFxuICAgICAgdGVtcE5vZGUub2Zmc2V0WSAgICA9IDA7XG4gICAgICB0ZW1wTm9kZS5oZWlnaHQgICAgID0gbm9kZXNbaV0uaGVpZ2h0KCk7XG4gICAgICB0ZW1wTm9kZS53aWR0aCAgICAgID0gbm9kZXNbaV0ud2lkdGgoKTtcbiAgICAgIHRlbXBOb2RlLm1heFggICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblggKyB0ZW1wTm9kZS53aWR0aCAgLyAyO1xuICAgICAgdGVtcE5vZGUubWluWCAgICAgICA9IHRlbXBOb2RlLnBvc2l0aW9uWCAtIHRlbXBOb2RlLndpZHRoICAvIDI7XG4gICAgICB0ZW1wTm9kZS5tYXhZICAgICAgID0gdGVtcE5vZGUucG9zaXRpb25ZICsgdGVtcE5vZGUuaGVpZ2h0IC8gMjtcbiAgICAgIHRlbXBOb2RlLm1pblkgICAgICAgPSB0ZW1wTm9kZS5wb3NpdGlvblkgLSB0ZW1wTm9kZS5oZWlnaHQgLyAyO1xuICAgICAgdGVtcE5vZGUucGFkTGVmdCAgICA9IG5vZGVzW2ldLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLWxlZnQnXS5weFZhbHVlO1xuICAgICAgdGVtcE5vZGUucGFkUmlnaHQgICA9IG5vZGVzW2ldLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLXJpZ2h0J10ucHhWYWx1ZTtcbiAgICAgIHRlbXBOb2RlLnBhZFRvcCAgICAgPSBub2Rlc1tpXS5fcHJpdmF0ZS5zdHlsZVsncGFkZGluZy10b3AnXS5weFZhbHVlO1xuICAgICAgdGVtcE5vZGUucGFkQm90dG9tICA9IG5vZGVzW2ldLl9wcml2YXRlLnN0eWxlWydwYWRkaW5nLWJvdHRvbSddLnB4VmFsdWU7XG4gICAgICBcbiAgICAgIC8vIEFkZCBuZXcgbm9kZVxuICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlcy5wdXNoKHRlbXBOb2RlKTtcbiAgICAgIC8vIEFkZCBlbnRyeSB0byBpZC1pbmRleCBtYXBcbiAgICAgIGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBOb2RlLmlkXSA9IGk7XG4gICAgfVxuXG4gICAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHZhciBzdGFydCA9IDA7ICAgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcbiAgICB2YXIgZW5kICAgPSAtMTsgIC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gICAgdmFyIHRlbXBHcmFwaCA9IFtdO1xuXG4gICAgLy8gU2Vjb25kIHBhc3MgdG8gYWRkIGNoaWxkIGluZm9ybWF0aW9uIGFuZCBcbiAgICAvLyBpbml0aWFsaXplIHF1ZXVlIGZvciBoaWVyYXJjaGljYWwgdHJhdmVyc2FsXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgIHZhciBwX2lkID0gbi5wYXJlbnRJZDtcbiAgICAgIC8vIENoZWNrIGlmIG5vZGUgbiBoYXMgYSBwYXJlbnQgbm9kZVxuICAgICAgaWYgKG51bGwgIT0gcF9pZCkge1xuICAgICAgLy8gQWRkIG5vZGUgSWQgdG8gcGFyZW50J3MgbGlzdCBvZiBjaGlsZHJlblxuICAgICAgbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFtwX2lkXV0uY2hpbGRyZW4ucHVzaChuLmlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBhIG5vZGUgZG9lc24ndCBoYXZlIGEgcGFyZW50LCB0aGVuIGl0J3MgaW4gdGhlIHJvb3QgZ3JhcGhcbiAgICAgIHF1ZXVlWysrZW5kXSA9IG4uaWQ7XG4gICAgICB0ZW1wR3JhcGgucHVzaChuLmlkKTsgICAgXG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEFkZCByb290IGdyYXBoIHRvIGdyYXBoU2V0XG4gICAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKHRlbXBHcmFwaCk7XG5cbiAgICAvLyBUcmF2ZXJzZSB0aGUgZ3JhcGgsIGxldmVsIGJ5IGxldmVsLCBcbiAgICB3aGlsZSAoc3RhcnQgPD0gZW5kKSB7XG4gICAgICAvLyBHZXQgdGhlIG5vZGUgdG8gdmlzaXQgYW5kIHJlbW92ZSBpdCBmcm9tIHF1ZXVlXG4gICAgICB2YXIgbm9kZV9pZCAgPSBxdWV1ZVtzdGFydCsrXTtcbiAgICAgIHZhciBub2RlX2l4ICA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVfaWRdO1xuICAgICAgdmFyIG5vZGUgICAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlX2l4XTtcbiAgICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGRyZW47XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgLy8gQWRkIGNoaWxkcmVuIG5vZGVzIGFzIGEgbmV3IGdyYXBoIHRvIGdyYXBoIHNldFxuICAgICAgbGF5b3V0SW5mby5ncmFwaFNldC5wdXNoKGNoaWxkcmVuKTtcbiAgICAgIC8vIEFkZCBjaGlsZHJlbiB0byBxdWUgcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgaW5kZXhUb0dyYXBoIG1hcFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkrKykgeyAgICAgIFxuICAgICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ3JhcGgubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXTtcbiAgICAgIGxheW91dEluZm8uaW5kZXhUb0dyYXBoW2luZGV4XSA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEl0ZXJhdGUgb3ZlciBhbGwgZWRnZXMsIGNyZWF0aW5nIExheW91dCBFZGdlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5lZGdlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgZSA9IGVkZ2VzW2ldO1xuICAgICAgdmFyIHRlbXBFZGdlID0ge307ICAgICAgXG4gICAgICB0ZW1wRWRnZS5pZCAgICAgICA9IGUuZGF0YSgnaWQnKTtcbiAgICAgIHRlbXBFZGdlLnNvdXJjZUlkID0gZS5kYXRhKCdzb3VyY2UnKTtcbiAgICAgIHRlbXBFZGdlLnRhcmdldElkID0gZS5kYXRhKCd0YXJnZXQnKTtcblxuICAgICAgLy8gQ29tcHV0ZSBpZGVhbCBsZW5ndGhcbiAgICAgIHZhciBpZGVhbExlbmd0aCA9IG9wdGlvbnMuaWRlYWxFZGdlTGVuZ3RoO1xuXG4gICAgICAvLyBDaGVjayBpZiBpdCdzIGFuIGludGVyIGdyYXBoIGVkZ2VcbiAgICAgIHZhciBzb3VyY2VJeCAgICA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnNvdXJjZUlkXTtcbiAgICAgIHZhciB0YXJnZXRJeCAgICA9IGxheW91dEluZm8uaWRUb0luZGV4W3RlbXBFZGdlLnRhcmdldElkXTtcbiAgICAgIHZhciBzb3VyY2VHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3NvdXJjZUl4XTtcbiAgICAgIHZhciB0YXJnZXRHcmFwaCA9IGxheW91dEluZm8uaW5kZXhUb0dyYXBoW3RhcmdldEl4XTtcblxuICAgICAgaWYgKHNvdXJjZUdyYXBoICE9IHRhcmdldEdyYXBoKSB7XG4gICAgICAvLyBGaW5kIGxvd2VzdCBjb21tb24gZ3JhcGggYW5jZXN0b3JcbiAgICAgIHZhciBsY2EgPSBmaW5kTENBKHRlbXBFZGdlLnNvdXJjZUlkLCB0ZW1wRWRnZS50YXJnZXRJZCwgbGF5b3V0SW5mbyk7XG5cbiAgICAgIC8vIENvbXB1dGUgc3VtIG9mIG5vZGUgZGVwdGhzLCByZWxhdGl2ZSB0byBsY2EgZ3JhcGhcbiAgICAgIHZhciBsY2FHcmFwaCA9IGxheW91dEluZm8uZ3JhcGhTZXRbbGNhXTtcbiAgICAgIHZhciBkZXB0aCAgICA9IDA7XG5cbiAgICAgIC8vIFNvdXJjZSBkZXB0aFxuICAgICAgdmFyIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tzb3VyY2VJeF07XG4gICAgICB3aGlsZSAoLTEgPT09ICQuaW5BcnJheSh0ZW1wTm9kZS5pZCwgbGNhR3JhcGgpKSB7XG4gICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5wYXJlbnRJZF1dO1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBUYXJnZXQgZGVwdGhcbiAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1t0YXJnZXRJeF07XG4gICAgICB3aGlsZSAoLTEgPT09ICQuaW5BcnJheSh0ZW1wTm9kZS5pZCwgbGNhR3JhcGgpKSB7XG4gICAgICAgIHRlbXBOb2RlID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tsYXlvdXRJbmZvLmlkVG9JbmRleFt0ZW1wTm9kZS5wYXJlbnRJZF1dO1xuICAgICAgICBkZXB0aCsrO1xuICAgICAgfVxuXG4gICAgICAvLyBsb2dEZWJ1ZygnTENBIG9mIG5vZGVzICcgKyB0ZW1wRWRnZS5zb3VyY2VJZCArICcgYW5kICcgKyB0ZW1wRWRnZS50YXJnZXRJZCArICBcbiAgICAgICAgLy8gIFwiLiBJbmRleDogXCIgKyBsY2EgKyBcIiBDb250ZW50czogXCIgKyBsY2FHcmFwaC50b1N0cmluZygpICsgXG4gICAgICAgIC8vICBcIi4gRGVwdGg6IFwiICsgZGVwdGgpO1xuXG4gICAgICAvLyBVcGRhdGUgaWRlYWxMZW5ndGhcbiAgICAgIGlkZWFsTGVuZ3RoICo9IGRlcHRoICogb3B0aW9ucy5uZXN0aW5nRmFjdG9yO1xuICAgICAgfVxuXG4gICAgICB0ZW1wRWRnZS5pZGVhbExlbmd0aCA9IGlkZWFsTGVuZ3RoO1xuXG4gICAgICBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLnB1c2godGVtcEVkZ2UpO1xuICAgIH1cblxuICAgIC8vIEZpbmFsbHksIHJldHVybiBsYXlvdXRJbmZvIG9iamVjdFxuICAgIHJldHVybiBsYXlvdXRJbmZvO1xuICB9O1xuXG4gIFxuICAvKipcbiAgICogQGJyaWVmIDogVGhpcyBmdW5jdGlvbiBmaW5kcyB0aGUgaW5kZXggb2YgdGhlIGxvd2VzdCBjb21tb24gXG4gICAqICAgICAgICAgIGdyYXBoIGFuY2VzdG9yIGJldHdlZW4gMiBub2RlcyBpbiB0aGUgc3VidHJlZSBcbiAgICogICAgICAgICAgKGZyb20gdGhlIGdyYXBoIGhpZXJhcmNoeSBpbmR1Y2VkIHRyZWUpIHdob3NlXG4gICAqICAgICAgICAgIHJvb3QgaXMgZ3JhcGhJeFxuICAgKlxuICAgKiBAYXJnIG5vZGUxOiBub2RlMSdzIElEXG4gICAqIEBhcmcgbm9kZTI6IG5vZGUyJ3MgSURcbiAgICogQGFyZyBsYXlvdXRJbmZvOiBsYXlvdXRJbmZvIG9iamVjdFxuICAgKlxuICAgKi9cbiAgdmFyIGZpbmRMQ0EgPSBmdW5jdGlvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8pIHtcbiAgICAvLyBGaW5kIHRoZWlyIGNvbW1vbiBhbmNlc3Rlciwgc3RhcnRpbmcgZnJvbSB0aGUgcm9vdCBncmFwaFxuICAgIHZhciByZXMgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIDAsIGxheW91dEluZm8pO1xuICAgIGlmICgyID4gcmVzLmNvdW50KSB7XG4gICAgICAvLyBJZiBhdXggZnVuY3Rpb24gY291bGRuJ3QgZmluZCB0aGUgY29tbW9uIGFuY2VzdGVyLCBcbiAgICAgIC8vIHRoZW4gaXQgaXMgdGhlIHJvb3QgZ3JhcGhcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmVzLmdyYXBoO1xuICAgIH1cbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgICAgICAgICAgOiBBdXhpbGlhcnkgZnVuY3Rpb24gdXNlZCBmb3IgTENBIGNvbXB1dGF0aW9uXG4gICAqIFxuICAgKiBAYXJnIG5vZGUxICAgICAgOiBub2RlMSdzIElEXG4gICAqIEBhcmcgbm9kZTIgICAgICA6IG5vZGUyJ3MgSURcbiAgICogQGFyZyBncmFwaEl4ICAgIDogc3ViZ3JhcGggaW5kZXhcbiAgICogQGFyZyBsYXlvdXRJbmZvIDogbGF5b3V0SW5mbyBvYmplY3RcbiAgICpcbiAgICogQHJldHVybiAgICAgICAgIDogb2JqZWN0IG9mIHRoZSBmb3JtIHtjb3VudDogWCwgZ3JhcGg6IFl9LCB3aGVyZTpcbiAgICogICAgICAgICAgICAgICAgICAgWCBpcyB0aGUgbnVtYmVyIG9mIGFuY2VzdGVycyAobWF4OiAyKSBmb3VuZCBpbiBcbiAgICogICAgICAgICAgICAgICAgICAgZ3JhcGhJeCAoYW5kIGl0J3Mgc3ViZ3JhcGhzKSxcbiAgICogICAgICAgICAgICAgICAgICAgWSBpcyB0aGUgZ3JhcGggaW5kZXggb2YgdGhlIGxvd2VzdCBncmFwaCBjb250YWluaW5nIFxuICAgKiAgICAgICAgICAgICAgICAgICBhbGwgWCBub2Rlc1xuICAgKi9cbiAgdmFyIGZpbmRMQ0FfYXV4ID0gZnVuY3Rpb24obm9kZTEsIG5vZGUyLCBncmFwaEl4LCBsYXlvdXRJbmZvKSB7XG4gICAgdmFyIGdyYXBoID0gbGF5b3V0SW5mby5ncmFwaFNldFtncmFwaEl4XTtcbiAgICAvLyBJZiBib3RoIG5vZGVzIGJlbG9uZ3MgdG8gZ3JhcGhJeFxuICAgIGlmICgtMSA8ICQuaW5BcnJheShub2RlMSwgZ3JhcGgpICYmIC0xIDwgJC5pbkFycmF5KG5vZGUyLCBncmFwaCkpIHtcbiAgICAgIHJldHVybiB7Y291bnQ6MiwgZ3JhcGg6Z3JhcGhJeH07XG4gICAgfVxuXG4gICAgLy8gTWFrZSByZWN1cnNpdmUgY2FsbHMgZm9yIGFsbCBzdWJncmFwaHNcbiAgICB2YXIgYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncmFwaC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vZGVJZCAgID0gZ3JhcGhbaV07XG4gICAgICB2YXIgbm9kZUl4ICAgPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtub2RlSWRdO1xuICAgICAgdmFyIGNoaWxkcmVuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSXhdLmNoaWxkcmVuO1xuXG4gICAgICAvLyBJZiB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIHNraXAgaXRcbiAgICAgIGlmICgwID09PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hpbGRHcmFwaEl4ID0gbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5bMF1dXTtcbiAgICAgIHZhciByZXN1bHQgPSBmaW5kTENBX2F1eChub2RlMSwgbm9kZTIsIGNoaWxkR3JhcGhJeCwgbGF5b3V0SW5mbyk7XG4gICAgICBpZiAoMCA9PT0gcmVzdWx0LmNvdW50KSB7XG4gICAgICAvLyBOZWl0aGVyIG5vZGUxIG5vciBub2RlMiBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoMSA9PT0gcmVzdWx0LmNvdW50KSB7XG4gICAgICAvLyBPbmUgb2YgKG5vZGUxLCBub2RlMikgaXMgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICBjKys7XG4gICAgICBpZiAoMiA9PT0gYykge1xuICAgICAgICAvLyBXZSd2ZSBhbHJlYWR5IGZvdW5kIGJvdGggbm9kZXMsIG5vIG5lZWQgdG8ga2VlcCBzZWFyY2hpbmdcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgLy8gQm90aCBub2RlcyBhcmUgcHJlc2VudCBpbiB0aGlzIHN1YmdyYXBoXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSAgICAgIFxuICAgIH1cbiAgICBcbiAgICByZXR1cm4ge2NvdW50OmMsIGdyYXBoOmdyYXBoSXh9O1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZjogcHJpbnRzTGF5b3V0SW5mbyBpbnRvIGpzIGNvbnNvbGVcbiAgICogICAgICAgICBPbmx5IHVzZWQgZm9yIGRlYmJ1Z2luZyBcbiAgICovXG4gIHZhciBwcmludExheW91dEluZm8gPSBmdW5jdGlvbihsYXlvdXRJbmZvKSB7XG4gICAgaWYgKCFERUJVRykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmRlYnVnKFwibGF5b3V0Tm9kZXM6XCIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICB2YXIgcyA9IFxuICAgICAgXCJcXG5pbmRleDogXCIgICAgICsgaSArIFxuICAgICAgXCJcXG5JZDogXCIgICAgICAgICsgbi5pZCArIFxuICAgICAgXCJcXG5DaGlsZHJlbjogXCIgICsgbi5jaGlsZHJlbi50b1N0cmluZygpICsgIFxuICAgICAgXCJcXG5wYXJlbnRJZDogXCIgICsgbi5wYXJlbnRJZCAgKyBcbiAgICAgIFwiXFxucG9zaXRpb25YOiBcIiArIG4ucG9zaXRpb25YICsgXG4gICAgICBcIlxcbnBvc2l0aW9uWTogXCIgKyBuLnBvc2l0aW9uWSArXG4gICAgICBcIlxcbk9mZnNldFg6IFwiICsgbi5vZmZzZXRYICsgXG4gICAgICBcIlxcbk9mZnNldFk6IFwiICsgbi5vZmZzZXRZICsgXG4gICAgICBcIlxcbnBhZExlZnQ6IFwiICsgbi5wYWRMZWZ0ICsgXG4gICAgICBcIlxcbnBhZFJpZ2h0OiBcIiArIG4ucGFkUmlnaHQgKyBcbiAgICAgIFwiXFxucGFkVG9wOiBcIiArIG4ucGFkVG9wICsgXG4gICAgICBcIlxcbnBhZEJvdHRvbTogXCIgKyBuLnBhZEJvdHRvbTtcblxuICAgICAgY29uc29sZS5kZWJ1ZyhzKTsgICAgXG4gICAgfSAgXG4gICAgXG4gICAgY29uc29sZS5kZWJ1ZygnaWRUb0luZGV4Jyk7XG4gICAgZm9yICh2YXIgaSBpbiBsYXlvdXRJbmZvLmlkVG9JbmRleCkge1xuICAgICAgY29uc29sZS5kZWJ1ZyhcIklkOiBcIiArIGkgKyBcIlxcbkluZGV4OiBcIiArIGxheW91dEluZm8uaWRUb0luZGV4W2ldKTtcbiAgICB9XG5cbiAgICBjb25zb2xlLmRlYnVnKCdHcmFwaCBTZXQnKTtcbiAgICB2YXIgc2V0ID0gbGF5b3V0SW5mby5ncmFwaFNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkgKyspIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoXCJTZXQgOiBcIiArIGkgKyBcIjogXCIgKyBzZXRbaV0udG9TdHJpbmcoKSk7XG4gICAgfSBcblxuICAgIHZhciBzID0gJ0luZGV4VG9HcmFwaCc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmluZGV4VG9HcmFwaC5sZW5ndGg7IGkgKyspIHtcbiAgICAgIHMgKz0gXCJcXG5JbmRleCA6IFwiICsgaSArIFwiIEdyYXBoOiBcIisgbGF5b3V0SW5mby5pbmRleFRvR3JhcGhbaV07XG4gICAgfVxuICAgIGNvbnNvbGUuZGVidWcocyk7XG5cbiAgICBzID0gJ0xheW91dCBFZGdlcyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmxheW91dEVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZSA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbaV07XG4gICAgICBzICs9IFwiXFxuRWRnZSBJbmRleDogXCIgKyBpICsgXCIgSUQ6IFwiICsgZS5pZCArIFxuICAgICAgXCIgU291Y2VJRDogXCIgKyBlLnNvdXJjZUlkICsgXCIgVGFyZ2V0SWQ6IFwiICsgZS50YXJnZXRJZCArIFxuICAgICAgXCIgSWRlYWwgTGVuZ3RoOiBcIiArIGUuaWRlYWxMZW5ndGg7XG4gICAgfVxuICAgIGNvbnNvbGUuZGVidWcocyk7XG5cbiAgICBzID0gIFwibm9kZVNpemU6IFwiICsgbGF5b3V0SW5mby5ub2RlU2l6ZTtcbiAgICBzICs9IFwiXFxuZWRnZVNpemU6IFwiICsgbGF5b3V0SW5mby5lZGdlU2l6ZTtcbiAgICBzICs9IFwiXFxudGVtcGVyYXR1cmU6IFwiICsgbGF5b3V0SW5mby50ZW1wZXJhdHVyZTtcbiAgICBjb25zb2xlLmRlYnVnKHMpO1xuXG4gICAgcmV0dXJuO1xuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IFJhbmRvbWl6ZXMgdGhlIHBvc2l0aW9uIG9mIGFsbCBub2Rlc1xuICAgKi9cbiAgdmFyIHJhbmRvbWl6ZVBvc2l0aW9ucyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5KSB7XG4gICAgdmFyIHdpZHRoICAgICA9IGxheW91dEluZm8uY2xpZW50V2lkdGg7XG4gICAgdmFyIGhlaWdodCAgICA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLm5vZGVTaXplOyBpKyspIHtcbiAgICAgIHZhciBuID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tpXTtcbiAgICAgIC8vIE5vIG5lZWQgdG8gcmFuZG9taXplIGNvbXBvdW5kIG5vZGVzXG4gICAgICBpZiAodHJ1ZSB8fCAwID09PSBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBuLnBvc2l0aW9uWCA9IE1hdGgucmFuZG9tKCkgKiB3aWR0aDtcbiAgICAgICAgbi5wb3NpdGlvblkgPSBNYXRoLnJhbmRvbSgpICogaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBcbiAgLyoqXG4gICAqIEBicmllZiAgICAgICAgICA6IFVwZGF0ZXMgdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBpbiB0aGUgbmV0d29ya1xuICAgKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdFxuICAgKiBAYXJnIGN5ICAgICAgICAgOiBDeXRvc2NhcGUgb2JqZWN0XG4gICAqIEBhcmcgb3B0aW9ucyAgICA6IExheW91dCBvcHRpb25zXG4gICAqL1xuICB2YXIgcmVmcmVzaFBvc2l0aW9ucyA9IGZ1bmN0aW9uKGxheW91dEluZm8sIGN5LCBvcHRpb25zKSB7ICBcbiAgICAvLyB2YXIgcyA9ICdSZWZyZXNoaW5nIHBvc2l0aW9ucyc7XG4gICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICB2YXIgbGF5b3V0ID0gbGF5b3V0SW5mby5sYXlvdXQ7XG4gICAgdmFyIG5vZGVzID0gb3B0aW9ucy5lbGVzLm5vZGVzKCk7XG4gICAgdmFyIGJiID0gbGF5b3V0SW5mby5ib3VuZGluZ0JveDtcbiAgICB2YXIgY29zZUJCID0geyB4MTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkxOiBJbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9O1xuICAgIFxuICAgIGlmKCBvcHRpb25zLmJvdW5kaW5nQm94ICl7XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKCBub2RlICl7XG4gICAgICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbbm9kZS5kYXRhKCdpZCcpXV07XG5cbiAgICAgICAgY29zZUJCLngxID0gTWF0aC5taW4oIGNvc2VCQi54MSwgbG5vZGUucG9zaXRpb25YICk7XG4gICAgICAgIGNvc2VCQi54MiA9IE1hdGgubWF4KCBjb3NlQkIueDIsIGxub2RlLnBvc2l0aW9uWCApO1xuXG4gICAgICAgIGNvc2VCQi55MSA9IE1hdGgubWluKCBjb3NlQkIueTEsIGxub2RlLnBvc2l0aW9uWSApO1xuICAgICAgICBjb3NlQkIueTIgPSBNYXRoLm1heCggY29zZUJCLnkyLCBsbm9kZS5wb3NpdGlvblkgKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb3NlQkIudyA9IGNvc2VCQi54MiAtIGNvc2VCQi54MTtcbiAgICAgIGNvc2VCQi5oID0gY29zZUJCLnkyIC0gY29zZUJCLnkxO1xuICAgIH1cblxuICAgIG5vZGVzLnBvc2l0aW9ucyhmdW5jdGlvbihpLCBlbGUpIHtcbiAgICAgIHZhciBsbm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZWxlLmRhdGEoJ2lkJyldXTtcbiAgICAgIC8vIHMgPSBcIk5vZGU6IFwiICsgbG5vZGUuaWQgKyBcIi4gUmVmcmVzaGVkIHBvc2l0aW9uOiAoXCIgKyBcbiAgICAgIC8vIGxub2RlLnBvc2l0aW9uWCArIFwiLCBcIiArIGxub2RlLnBvc2l0aW9uWSArIFwiKS5cIjtcbiAgICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCApeyAvLyB0aGVuIGFkZCBleHRyYSBib3VuZGluZyBib3ggY29uc3RyYWludFxuICAgICAgICB2YXIgcGN0WCA9IChsbm9kZS5wb3NpdGlvblggLSBjb3NlQkIueDEpIC8gY29zZUJCLnc7XG4gICAgICAgIHZhciBwY3RZID0gKGxub2RlLnBvc2l0aW9uWSAtIGNvc2VCQi55MSkgLyBjb3NlQkIuaDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHg6IGJiLngxICsgcGN0WCAqIGJiLncsXG4gICAgICAgICAgeTogYmIueTEgKyBwY3RZICogYmIuaFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiBsbm9kZS5wb3NpdGlvblgsXG4gICAgICAgICAgeTogbG5vZGUucG9zaXRpb25ZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUcmlnZ2VyIGxheW91dFJlYWR5IG9ubHkgb24gZmlyc3QgY2FsbFxuICAgIGlmICh0cnVlICE9PSBsYXlvdXRJbmZvLnJlYWR5KSB7XG4gICAgICAvLyBzID0gJ1RyaWdnZXJpbmcgbGF5b3V0cmVhZHknO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICBsYXlvdXRJbmZvLnJlYWR5ID0gdHJ1ZTtcbiAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogdGhpcyB9KTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmICAgICAgICAgIDogUGVyZm9ybXMgb25lIGl0ZXJhdGlvbiBvZiB0aGUgcGh5c2ljYWwgc2ltdWxhdGlvblxuICAgKiBAYXJnIGxheW91dEluZm8gOiBMYXlvdXRJbmZvIG9iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkXG4gICAqIEBhcmcgY3kgICAgICAgICA6IEN5dG9zY2FwZSBvYmplY3RcbiAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICovXG4gIHZhciBzdGVwID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMsIHN0ZXApIHsgIFxuICAgIC8vIHZhciBzID0gXCJcXG5cXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjXCI7XG4gICAgLy8gcyArPSBcIlxcblNURVA6IFwiICsgc3RlcDtcbiAgICAvLyBzICs9IFwiXFxuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xcblwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgLy8gQ2FsY3VsYXRlIG5vZGUgcmVwdWxzaW9uc1xuICAgIGNhbGN1bGF0ZU5vZGVGb3JjZXMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICAgIC8vIENhbGN1bGF0ZSBlZGdlIGZvcmNlc1xuICAgIGNhbGN1bGF0ZUVkZ2VGb3JjZXMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICAgIC8vIENhbGN1bGF0ZSBncmF2aXR5IGZvcmNlc1xuICAgIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICAgIC8vIFByb3BhZ2F0ZSBmb3JjZXMgZnJvbSBwYXJlbnQgdG8gY2hpbGRcbiAgICBwcm9wYWdhdGVGb3JjZXMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICAgIC8vIFVwZGF0ZSBwb3NpdGlvbnMgYmFzZWQgb24gY2FsY3VsYXRlZCBmb3JjZXNcbiAgICB1cGRhdGVQb3NpdGlvbnMobGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpO1xuICB9O1xuXG4gIFxuICAvKipcbiAgICogQGJyaWVmIDogQ29tcHV0ZXMgdGhlIG5vZGUgcmVwdWxzaW9uIGZvcmNlc1xuICAgKi9cbiAgdmFyIGNhbGN1bGF0ZU5vZGVGb3JjZXMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAgIC8vIEdvIHRocm91Z2ggZWFjaCBvZiB0aGUgZ3JhcGhzIGluIGdyYXBoU2V0XG4gICAgLy8gTm9kZXMgb25seSByZXBlbCBlYWNoIG90aGVyIGlmIHRoZXkgYmVsb25nIHRvIHRoZSBzYW1lIGdyYXBoXG4gICAgLy8gdmFyIHMgPSAnY2FsY3VsYXRlTm9kZUZvcmNlcyc7XG4gICAgLy8gbG9nRGVidWcocyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmdyYXBoU2V0Lmxlbmd0aDsgaSArKykge1xuICAgICAgdmFyIGdyYXBoICAgID0gbGF5b3V0SW5mby5ncmFwaFNldFtpXTtcbiAgICAgIHZhciBudW1Ob2RlcyA9IGdyYXBoLmxlbmd0aDtcblxuICAgICAgLy8gcyA9IFwiU2V0OiBcIiArIGdyYXBoLnRvU3RyaW5nKCk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgLy8gTm93IGdldCBhbGwgdGhlIHBhaXJzIG9mIG5vZGVzIFxuICAgICAgLy8gT25seSBnZXQgZWFjaCBwYWlyIG9uY2UsIChBLCBCKSA9IChCLCBBKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBudW1Ob2RlczsgaisrKSB7XG4gICAgICB2YXIgbm9kZTEgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXV07XG4gICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBudW1Ob2RlczsgaysrKSB7XG4gICAgICAgIHZhciBub2RlMiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhba11dXTtcbiAgICAgICAgbm9kZVJlcHVsc2lvbihub2RlMSwgbm9kZTIsIGxheW91dEluZm8sIGN5LCBvcHRpb25zKTtcbiAgICAgIH0gXG4gICAgICB9XG4gICAgfSBcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBDb21wdXRlIHRoZSBub2RlIHJlcHVsc2lvbiBmb3JjZXMgYmV0d2VlbiBhIHBhaXIgb2Ygbm9kZXNcbiAgICovXG4gIHZhciBub2RlUmVwdWxzaW9uID0gZnVuY3Rpb24obm9kZTEsIG5vZGUyLCBsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAgIC8vIHZhciBzID0gXCJOb2RlIHJlcHVsc2lvbi4gTm9kZTE6IFwiICsgbm9kZTEuaWQgKyBcIiBOb2RlMjogXCIgKyBub2RlMi5pZDtcblxuICAgIC8vIEdldCBkaXJlY3Rpb24gb2YgbGluZSBjb25uZWN0aW5nIGJvdGggbm9kZSBjZW50ZXJzXG4gICAgdmFyIGRpcmVjdGlvblggPSBub2RlMi5wb3NpdGlvblggLSBub2RlMS5wb3NpdGlvblg7XG4gICAgdmFyIGRpcmVjdGlvblkgPSBub2RlMi5wb3NpdGlvblkgLSBub2RlMS5wb3NpdGlvblk7XG4gICAgLy8gcyArPSBcIlxcbmRpcmVjdGlvblg6IFwiICsgZGlyZWN0aW9uWCArIFwiLCBkaXJlY3Rpb25ZOiBcIiArIGRpcmVjdGlvblk7XG5cbiAgICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBhcHBseSBhIHJhbmRvbSBmb3JjZVxuICAgIGlmICgwID09PSBkaXJlY3Rpb25YICYmIDAgPT09IGRpcmVjdGlvblkpIHtcbiAgICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBoYXZlIHRoZSBzYW1lIHBvc2l0aW9uLlwiO1xuICAgICAgcmV0dXJuOyAvLyBUT0RPXG4gICAgfVxuXG4gICAgdmFyIG92ZXJsYXAgPSBub2Rlc092ZXJsYXAobm9kZTEsIG5vZGUyLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICBcbiAgICBpZiAob3ZlcmxhcCA+IDApIHtcbiAgICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBETyBvdmVybGFwLlwiO1xuICAgICAgLy8gcyArPSBcIlxcbk92ZXJsYXA6IFwiICsgb3ZlcmxhcDtcbiAgICAgIC8vIElmIG5vZGVzIG92ZXJsYXAsIHJlcHVsc2lvbiBmb3JjZSBpcyBwcm9wb3J0aW9uYWwgXG4gICAgICAvLyB0byB0aGUgb3ZlcmxhcFxuICAgICAgdmFyIGZvcmNlICAgID0gb3B0aW9ucy5ub2RlT3ZlcmxhcCAqIG92ZXJsYXA7XG5cbiAgICAgIC8vIENvbXB1dGUgdGhlIG1vZHVsZSBhbmQgY29tcG9uZW50cyBvZiB0aGUgZm9yY2UgdmVjdG9yXG4gICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoZGlyZWN0aW9uWCAqIGRpcmVjdGlvblggKyBkaXJlY3Rpb25ZICogZGlyZWN0aW9uWSk7XG4gICAgICAvLyBzICs9IFwiXFxuRGlzdGFuY2U6IFwiICsgZGlzdGFuY2U7XG4gICAgICB2YXIgZm9yY2VYICAgPSBmb3JjZSAqIGRpcmVjdGlvblggLyBkaXN0YW5jZTtcbiAgICAgIHZhciBmb3JjZVkgICA9IGZvcmNlICogZGlyZWN0aW9uWSAvIGRpc3RhbmNlO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHMgKz0gXCJcXG5Ob2RlcyBkbyBOT1Qgb3ZlcmxhcC5cIjtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gb3ZlcmxhcCwgZm9yY2UgaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCBcbiAgICAgIC8vIHRvIHNxdWFyZWQgZGlzdGFuY2VcblxuICAgICAgLy8gR2V0IGNsaXBwaW5nIHBvaW50cyBmb3IgYm90aCBub2Rlc1xuICAgICAgdmFyIHBvaW50MSA9IGZpbmRDbGlwcGluZ1BvaW50KG5vZGUxLCBkaXJlY3Rpb25YLCBkaXJlY3Rpb25ZKTtcbiAgICAgIHZhciBwb2ludDIgPSBmaW5kQ2xpcHBpbmdQb2ludChub2RlMiwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpO1xuXG4gICAgICAvLyBVc2UgY2xpcHBpbmcgcG9pbnRzIHRvIGNvbXB1dGUgZGlzdGFuY2VcbiAgICAgIHZhciBkaXN0YW5jZVggICA9IHBvaW50Mi54IC0gcG9pbnQxLng7XG4gICAgICB2YXIgZGlzdGFuY2VZICAgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgICAgdmFyIGRpc3RhbmNlU3FyID0gZGlzdGFuY2VYICogZGlzdGFuY2VYICsgZGlzdGFuY2VZICogZGlzdGFuY2VZO1xuICAgICAgdmFyIGRpc3RhbmNlICAgID0gTWF0aC5zcXJ0KGRpc3RhbmNlU3FyKTtcbiAgICAgIC8vIHMgKz0gXCJcXG5EaXN0YW5jZTogXCIgKyBkaXN0YW5jZTtcblxuICAgICAgLy8gQ29tcHV0ZSB0aGUgbW9kdWxlIGFuZCBjb21wb25lbnRzIG9mIHRoZSBmb3JjZSB2ZWN0b3JcbiAgICAgIHZhciBmb3JjZSAgPSBvcHRpb25zLm5vZGVSZXB1bHNpb24gLyBkaXN0YW5jZVNxcjtcbiAgICAgIHZhciBmb3JjZVggPSBmb3JjZSAqIGRpc3RhbmNlWCAvIGRpc3RhbmNlO1xuICAgICAgdmFyIGZvcmNlWSA9IGZvcmNlICogZGlzdGFuY2VZIC8gZGlzdGFuY2U7XG4gICAgfVxuXG4gICAgLy8gQXBwbHkgZm9yY2VcbiAgICBub2RlMS5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICBub2RlMS5vZmZzZXRZIC09IGZvcmNlWTtcbiAgICBub2RlMi5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICBub2RlMi5vZmZzZXRZICs9IGZvcmNlWTtcblxuICAgIC8vIHMgKz0gXCJcXG5Gb3JjZVg6IFwiICsgZm9yY2VYICsgXCIgRm9yY2VZOiBcIiArIGZvcmNlWTtcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgIHJldHVybjtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBGaW5kcyB0aGUgcG9pbnQgaW4gd2hpY2ggYW4gZWRnZSAoZGlyZWN0aW9uIGRYLCBkWSkgaW50ZXJzZWN0cyBcbiAgICogICAgICAgICAgdGhlIHJlY3Rhbmd1bGFyIGJvdW5kaW5nIGJveCBvZiBpdCdzIHNvdXJjZS90YXJnZXQgbm9kZSBcbiAgICovXG4gIHZhciBmaW5kQ2xpcHBpbmdQb2ludCA9IGZ1bmN0aW9uKG5vZGUsIGRYLCBkWSkge1xuXG4gICAgLy8gU2hvcmN1dHNcbiAgICB2YXIgWCA9IG5vZGUucG9zaXRpb25YO1xuICAgIHZhciBZID0gbm9kZS5wb3NpdGlvblk7XG4gICAgdmFyIEggPSBub2RlLmhlaWdodDtcbiAgICB2YXIgVyA9IG5vZGUud2lkdGg7XG4gICAgdmFyIGRpclNsb3BlICAgICA9IGRZIC8gZFg7XG4gICAgdmFyIG5vZGVTbG9wZSAgICA9IEggLyBXO1xuXG4gICAgLy8gdmFyIHMgPSAnQ29tcHV0aW5nIGNsaXBwaW5nIHBvaW50IG9mIG5vZGUgJyArIG5vZGUuaWQgKyBcbiAgICAvLyAgIFwiIC4gSGVpZ2h0OiAgXCIgKyBIICsgXCIsIFdpZHRoOiBcIiArIFcgKyBcbiAgICAvLyAgIFwiXFxuRGlyZWN0aW9uIFwiICsgZFggKyBcIiwgXCIgKyBkWTsgXG4gICAgLy8gXG4gICAgLy8gQ29tcHV0ZSBpbnRlcnNlY3Rpb25cbiAgICB2YXIgcmVzID0ge307XG4gICAgZG8ge1xuICAgICAgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uICh1cClcbiAgICAgIGlmICgwID09PSBkWCAmJiAwIDwgZFkpIHtcbiAgICAgICAgcmVzLnggPSBYO1xuICAgICAgICAvLyBzICs9IFwiXFxuVXAgZGlyZWN0aW9uXCI7XG4gICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQ2FzZTogVmVydGljYWwgZGlyZWN0aW9uIChkb3duKVxuICAgICAgaWYgKDAgPT09IGRYICYmIDAgPiBkWSkge1xuICAgICAgICByZXMueCA9IFg7XG4gICAgICAgIHJlcy55ID0gWSArIEggLyAyO1xuICAgICAgICAvLyBzICs9IFwiXFxuRG93biBkaXJlY3Rpb25cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9ICAgICAgXG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHJpZ2h0IGJvcmRlclxuICAgICAgaWYgKDAgPCBkWCAmJiBcbiAgICAgIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmIFxuICAgICAgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgICAgIHJlcy54ID0gWCArIFcgLyAyO1xuICAgICAgICByZXMueSA9IFkgKyAoVyAqIGRZIC8gMiAvIGRYKTtcbiAgICAgICAgLy8gcyArPSBcIlxcblJpZ2h0Ym9yZGVyXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBDYXNlOiBJbnRlcnNlY3RzIHRoZSBsZWZ0IGJvcmRlclxuICAgICAgaWYgKDAgPiBkWCAmJiBcbiAgICAgIC0xICogbm9kZVNsb3BlIDw9IGRpclNsb3BlICYmIFxuICAgICAgZGlyU2xvcGUgPD0gbm9kZVNsb3BlKSB7XG4gICAgICAgIHJlcy54ID0gWCAtIFcgLyAyO1xuICAgICAgICByZXMueSA9IFkgLSAoVyAqIGRZIC8gMiAvIGRYKTtcbiAgICAgICAgLy8gcyArPSBcIlxcbkxlZnRib3JkZXJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIHRvcCBib3JkZXJcbiAgICAgIGlmICgwIDwgZFkgJiYgXG4gICAgICAoIGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8XG4gICAgICAgIGRpclNsb3BlID49IG5vZGVTbG9wZSApKSB7XG4gICAgICAgIHJlcy54ID0gWCArIChIICogZFggLyAyIC8gZFkpO1xuICAgICAgICByZXMueSA9IFkgKyBIIC8gMjtcbiAgICAgICAgLy8gcyArPSBcIlxcblRvcCBib3JkZXJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIENhc2U6IEludGVyc2VjdHMgdGhlIGJvdHRvbSBib3JkZXJcbiAgICAgIGlmICgwID4gZFkgJiYgXG4gICAgICAoIGRpclNsb3BlIDw9IC0xICogbm9kZVNsb3BlIHx8XG4gICAgICAgIGRpclNsb3BlID49IG5vZGVTbG9wZSApKSB7XG4gICAgICAgIHJlcy54ID0gWCAtIChIICogZFggLyAyIC8gZFkpO1xuICAgICAgICByZXMueSA9IFkgLSBIIC8gMjtcbiAgICAgICAgLy8gcyArPSBcIlxcbkJvdHRvbSBib3JkZXJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICB9IHdoaWxlIChmYWxzZSk7XG5cbiAgICAvLyBzICs9IFwiXFxuQ2xpcHBpbmcgcG9pbnQgZm91bmQgYXQgXCIgKyByZXMueCArIFwiLCBcIiArIHJlcy55O1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmICA6IERldGVybWluZXMgd2hldGhlciB0d28gbm9kZXMgb3ZlcmxhcCBvciBub3RcbiAgICogQHJldHVybiA6IEFtb3VudCBvZiBvdmVybGFwcGluZyAoMCA9PiBubyBvdmVybGFwKVxuICAgKi9cbiAgdmFyIG5vZGVzT3ZlcmxhcCA9IGZ1bmN0aW9uKG5vZGUxLCBub2RlMiwgZFgsIGRZKSB7XG5cbiAgICBpZiAoZFggPiAwKSB7XG4gICAgICB2YXIgb3ZlcmxhcFggPSBub2RlMS5tYXhYIC0gbm9kZTIubWluWDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG92ZXJsYXBYID0gbm9kZTIubWF4WCAtIG5vZGUxLm1pblg7XG4gICAgfVxuXG4gICAgaWYgKGRZID4gMCkge1xuICAgICAgdmFyIG92ZXJsYXBZID0gbm9kZTEubWF4WSAtIG5vZGUyLm1pblk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBvdmVybGFwWSA9IG5vZGUyLm1heFkgLSBub2RlMS5taW5ZO1xuICAgIH1cblxuICAgIGlmIChvdmVybGFwWCA+PSAwICYmIG92ZXJsYXBZID49IDApIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQob3ZlcmxhcFggKiBvdmVybGFwWCArIG92ZXJsYXBZICogb3ZlcmxhcFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH07XG4gICAgXG4gIFxuICAvKipcbiAgICogQGJyaWVmIDogQ2FsY3VsYXRlcyBhbGwgZWRnZSBmb3JjZXNcbiAgICovXG4gIHZhciBjYWxjdWxhdGVFZGdlRm9yY2VzID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYWxsIGVkZ2VzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXlvdXRJbmZvLmVkZ2VTaXplOyBpKyspIHtcbiAgICAgIC8vIEdldCBlZGdlLCBzb3VyY2UgJiB0YXJnZXQgbm9kZXNcbiAgICAgIHZhciBlZGdlICAgICA9IGxheW91dEluZm8ubGF5b3V0RWRnZXNbaV07XG4gICAgICB2YXIgc291cmNlSXggPSBsYXlvdXRJbmZvLmlkVG9JbmRleFtlZGdlLnNvdXJjZUlkXTtcbiAgICAgIHZhciBzb3VyY2UgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbc291cmNlSXhdO1xuICAgICAgdmFyIHRhcmdldEl4ID0gbGF5b3V0SW5mby5pZFRvSW5kZXhbZWRnZS50YXJnZXRJZF07XG4gICAgICB2YXIgdGFyZ2V0ICAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW3RhcmdldEl4XTtcblxuICAgICAgLy8gR2V0IGRpcmVjdGlvbiBvZiBsaW5lIGNvbm5lY3RpbmcgYm90aCBub2RlIGNlbnRlcnNcbiAgICAgIHZhciBkaXJlY3Rpb25YID0gdGFyZ2V0LnBvc2l0aW9uWCAtIHNvdXJjZS5wb3NpdGlvblg7XG4gICAgICB2YXIgZGlyZWN0aW9uWSA9IHRhcmdldC5wb3NpdGlvblkgLSBzb3VyY2UucG9zaXRpb25ZO1xuICAgICAgXG4gICAgICAvLyBJZiBib3RoIGNlbnRlcnMgYXJlIHRoZSBzYW1lLCBkbyBub3RoaW5nLlxuICAgICAgLy8gQSByYW5kb20gZm9yY2UgaGFzIGFscmVhZHkgYmVlbiBhcHBsaWVkIGFzIG5vZGUgcmVwdWxzaW9uXG4gICAgICBpZiAoMCA9PT0gZGlyZWN0aW9uWCAmJiAwID09PSBkaXJlY3Rpb25ZKSB7XG4gICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBjbGlwcGluZyBwb2ludHMgZm9yIGJvdGggbm9kZXNcbiAgICAgIHZhciBwb2ludDEgPSBmaW5kQ2xpcHBpbmdQb2ludChzb3VyY2UsIGRpcmVjdGlvblgsIGRpcmVjdGlvblkpO1xuICAgICAgdmFyIHBvaW50MiA9IGZpbmRDbGlwcGluZ1BvaW50KHRhcmdldCwgLTEgKiBkaXJlY3Rpb25YLCAtMSAqIGRpcmVjdGlvblkpO1xuXG5cbiAgICAgIHZhciBseCA9IHBvaW50Mi54IC0gcG9pbnQxLng7XG4gICAgICB2YXIgbHkgPSBwb2ludDIueSAtIHBvaW50MS55O1xuICAgICAgdmFyIGwgID0gTWF0aC5zcXJ0KGx4ICogbHggKyBseSAqIGx5KTtcblxuICAgICAgdmFyIGZvcmNlICA9IE1hdGgucG93KGVkZ2UuaWRlYWxMZW5ndGggLSBsLCAyKSAvIG9wdGlvbnMuZWRnZUVsYXN0aWNpdHk7IFxuXG4gICAgICBpZiAoMCAhPT0gbCkge1xuICAgICAgICB2YXIgZm9yY2VYID0gZm9yY2UgKiBseCAvIGw7XG4gICAgICAgIHZhciBmb3JjZVkgPSBmb3JjZSAqIGx5IC8gbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmb3JjZVggPSAwO1xuICAgICAgICB2YXIgZm9yY2VZID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoaXMgZm9yY2UgdG8gdGFyZ2V0IGFuZCBzb3VyY2Ugbm9kZXNcbiAgICAgIHNvdXJjZS5vZmZzZXRYICs9IGZvcmNlWDtcbiAgICAgIHNvdXJjZS5vZmZzZXRZICs9IGZvcmNlWTtcbiAgICAgIHRhcmdldC5vZmZzZXRYIC09IGZvcmNlWDtcbiAgICAgIHRhcmdldC5vZmZzZXRZIC09IGZvcmNlWTtcblxuICAgICAgLy8gdmFyIHMgPSAnRWRnZSBmb3JjZSBiZXR3ZWVuIG5vZGVzICcgKyBzb3VyY2UuaWQgKyAnIGFuZCAnICsgdGFyZ2V0LmlkO1xuICAgICAgLy8gcyArPSBcIlxcbkRpc3RhbmNlOiBcIiArIGwgKyBcIiBGb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpXCI7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogQ29tcHV0ZXMgZ3Jhdml0eSBmb3JjZXMgZm9yIGFsbCBub2Rlc1xuICAgKi9cbiAgdmFyIGNhbGN1bGF0ZUdyYXZpdHlGb3JjZXMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykge1xuICAgIC8vIHZhciBzID0gJ2NhbGN1bGF0ZUdyYXZpdHlGb3JjZXMnO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ncmFwaFNldC5sZW5ndGg7IGkgKyspIHtcbiAgICAgIHZhciBncmFwaCAgICA9IGxheW91dEluZm8uZ3JhcGhTZXRbaV07XG4gICAgICB2YXIgbnVtTm9kZXMgPSBncmFwaC5sZW5ndGg7XG5cbiAgICAgIC8vIHMgPSBcIlNldDogXCIgKyBncmFwaC50b1N0cmluZygpO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICAgICAgXG4gICAgICAvLyBDb21wdXRlIGdyYXBoIGNlbnRlclxuICAgICAgaWYgKDAgPT09IGkpIHtcbiAgICAgICAgdmFyIGNlbnRlclggICA9IGxheW91dEluZm8uY2xpZW50SGVpZ2h0IC8gMjtcbiAgICAgICAgdmFyIGNlbnRlclkgICA9IGxheW91dEluZm8uY2xpZW50V2lkdGggIC8gMjsgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBHZXQgUGFyZW50IG5vZGUgZm9yIHRoaXMgZ3JhcGgsIGFuZCB1c2UgaXRzIHBvc2l0aW9uIGFzIGNlbnRlclxuICAgICAgICB2YXIgdGVtcCAgICA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbZ3JhcGhbMF1dXTtcbiAgICAgICAgdmFyIHBhcmVudCAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3RlbXAucGFyZW50SWRdXTtcbiAgICAgICAgdmFyIGNlbnRlclggPSBwYXJlbnQucG9zaXRpb25YO1xuICAgICAgICB2YXIgY2VudGVyWSA9IHBhcmVudC5wb3NpdGlvblk7XG4gICAgICB9XG4gICAgICAvLyBzID0gXCJDZW50ZXIgZm91bmQgYXQ6IFwiICsgY2VudGVyWCArIFwiLCBcIiArIGNlbnRlclk7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcblxuICAgICAgLy8gQXBwbHkgZm9yY2UgdG8gYWxsIG5vZGVzIGluIGdyYXBoXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bU5vZGVzOyBqKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W2dyYXBoW2pdXV07XG4gICAgICAgIC8vIHMgPSBcIk5vZGU6IFwiICsgbm9kZS5pZDtcbiAgICAgICAgdmFyIGR4ID0gY2VudGVyWCAtIG5vZGUucG9zaXRpb25YO1xuICAgICAgICB2YXIgZHkgPSBjZW50ZXJZIC0gbm9kZS5wb3NpdGlvblk7XG4gICAgICAgIHZhciBkICA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgIGlmIChkID4gMS4wKSB7IC8vIFRPRE86IFVzZSBnbG9iYWwgdmFyaWFibGUgZm9yIGRpc3RhbmNlIHRocmVzaG9sZFxuICAgICAgICAgIHZhciBmeCA9IG9wdGlvbnMuZ3Jhdml0eSAqIGR4IC8gZDtcbiAgICAgICAgICB2YXIgZnkgPSBvcHRpb25zLmdyYXZpdHkgKiBkeSAvIGQ7XG4gICAgICAgICAgbm9kZS5vZmZzZXRYICs9IGZ4O1xuICAgICAgICAgIG5vZGUub2Zmc2V0WSArPSBmeTtcbiAgICAgICAgICAvLyBzICs9IFwiOiBBcHBsaWVkIGZvcmNlOiBcIiArIGZ4ICsgXCIsIFwiICsgZnk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gcyArPSBcIjogc2t5cHBlZCBzaW5jZSBpdCdzIHRvbyBjbG9zZSB0byBjZW50ZXJcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmICAgICAgICAgIDogVGhpcyBmdW5jdGlvbiBwcm9wYWdhdGVzIHRoZSBleGlzdGluZyBvZmZzZXRzIGZyb20gXG4gICAqICAgICAgICAgICAgICAgICAgIHBhcmVudCBub2RlcyB0byBpdHMgZGVzY2VuZGVudHMuXG4gICAqIEBhcmcgbGF5b3V0SW5mbyA6IGxheW91dEluZm8gT2JqZWN0XG4gICAqIEBhcmcgY3kgICAgICAgICA6IGN5dG9zY2FwZSBPYmplY3RcbiAgICogQGFyZyBvcHRpb25zICAgIDogTGF5b3V0IG9wdGlvbnNcbiAgICovXG4gIHZhciBwcm9wYWdhdGVGb3JjZXMgPSBmdW5jdGlvbihsYXlvdXRJbmZvLCBjeSwgb3B0aW9ucykgeyAgXG4gICAgLy8gSW5saW5lIGltcGxlbWVudGF0aW9uIG9mIGEgcXVldWUsIHVzZWQgZm9yIHRyYXZlcnNpbmcgdGhlIGdyYXBoIGluIEJGUyBvcmRlclxuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIHZhciBzdGFydCA9IDA7ICAgLy8gUG9pbnRzIHRvIHRoZSBzdGFydCB0aGUgcXVldWVcbiAgICB2YXIgZW5kICAgPSAtMTsgIC8vIFBvaW50cyB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZVxuXG4gICAgLy8gbG9nRGVidWcoJ3Byb3BhZ2F0ZUZvcmNlcycpO1xuXG4gICAgLy8gU3RhcnQgYnkgdmlzaXRpbmcgdGhlIG5vZGVzIGluIHRoZSByb290IGdyYXBoXG4gICAgcXVldWUucHVzaC5hcHBseShxdWV1ZSwgbGF5b3V0SW5mby5ncmFwaFNldFswXSk7XG4gICAgZW5kICs9IGxheW91dEluZm8uZ3JhcGhTZXRbMF0ubGVuZ3RoO1xuXG4gICAgLy8gVHJhdmVyc2UgdGhlIGdyYXBoLCBsZXZlbCBieSBsZXZlbCwgXG4gICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgLy8gR2V0IHRoZSBub2RlIHRvIHZpc2l0IGFuZCByZW1vdmUgaXQgZnJvbSBxdWV1ZVxuICAgICAgdmFyIG5vZGVJZCAgICA9IHF1ZXVlW3N0YXJ0KytdO1xuICAgICAgdmFyIG5vZGVJbmRleCA9IGxheW91dEluZm8uaWRUb0luZGV4W25vZGVJZF07XG4gICAgICB2YXIgbm9kZSAgICAgID0gbGF5b3V0SW5mby5sYXlvdXROb2Rlc1tub2RlSW5kZXhdO1xuICAgICAgdmFyIGNoaWxkcmVuICA9IG5vZGUuY2hpbGRyZW47XG5cbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBub2RlIGlmIGl0J3MgY29tcG91bmRcbiAgICAgIGlmICgwIDwgY2hpbGRyZW4ubGVuZ3RoKSB7ICAgIFxuICAgICAgdmFyIG9mZlggPSBub2RlLm9mZnNldFg7XG4gICAgICB2YXIgb2ZmWSA9IG5vZGUub2Zmc2V0WTtcblxuICAgICAgLy8gdmFyIHMgPSBcIlByb3BhZ2F0aW5nIG9mZnNldCBmcm9tIHBhcmVudCBub2RlIDogXCIgKyBub2RlLmlkICsgXG4gICAgICAvLyAgIFwiLiBPZmZzZXRYOiBcIiArIG9mZlggKyBcIi4gT2Zmc2V0WTogXCIgKyBvZmZZO1xuICAgICAgLy8gcyArPSBcIlxcbiBDaGlsZHJlbjogXCIgKyBjaGlsZHJlbi50b1N0cmluZygpO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbbGF5b3V0SW5mby5pZFRvSW5kZXhbY2hpbGRyZW5baV1dXTtcbiAgICAgICAgLy8gUHJvcGFnYXRlIG9mZnNldFxuICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WCArPSBvZmZYO1xuICAgICAgICBjaGlsZE5vZGUub2Zmc2V0WSArPSBvZmZZO1xuICAgICAgICAvLyBBZGQgY2hpbGRyZW4gdG8gcXVldWUgdG8gYmUgdmlzaXRlZFxuICAgICAgICBxdWV1ZVsrK2VuZF0gPSBjaGlsZHJlbltpXTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gUmVzZXQgcGFyZW50IG9mZnNldHNcbiAgICAgIG5vZGUub2Zmc2V0WCA9IDA7XG4gICAgICBub2RlLm9mZnNldFkgPSAwO1xuICAgICAgfVxuICAgICAgXG4gICAgfVxuICB9O1xuXG5cbiAgLyoqXG4gICAqIEBicmllZiA6IFVwZGF0ZXMgdGhlIGxheW91dCBtb2RlbCBwb3NpdGlvbnMsIGJhc2VkIG9uIFxuICAgKiAgICAgICAgICB0aGUgYWNjdW11bGF0ZWQgZm9yY2VzXG4gICAqL1xuICB2YXIgdXBkYXRlUG9zaXRpb25zID0gZnVuY3Rpb24obGF5b3V0SW5mbywgY3ksIG9wdGlvbnMpIHtcbiAgICAvLyB2YXIgcyA9ICdVcGRhdGluZyBwb3NpdGlvbnMnO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgLy8gUmVzZXQgYm91bmRhcmllcyBmb3IgY29tcG91bmQgbm9kZXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAvLyBsb2dEZWJ1ZyhcIlJlc2V0dGluZyBib3VuZGFyaWVzIG9mIGNvbXBvdW5kIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICAgIG4ubWF4WCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbi5taW5YID0gdW5kZWZpbmVkO1xuICAgICAgICBuLm1heFkgPSB1bmRlZmluZWQ7XG4gICAgICAgIG4ubWluWSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheW91dEluZm8ubm9kZVNpemU7IGkrKykge1xuICAgICAgdmFyIG4gPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2ldO1xuICAgICAgaWYgKDAgPCBuLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIHNldCBjb21wb3VuZCBub2RlIHBvc2l0aW9uXG4gICAgICAgIC8vIGxvZ0RlYnVnKFwiU2tpcHBpbmcgcG9zaXRpb24gdXBkYXRlIG9mIG5vZGU6IFwiICsgbi5pZCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gcyA9IFwiTm9kZTogXCIgKyBuLmlkICsgXCIgUHJldmlvdXMgcG9zaXRpb246IChcIiArIFxuICAgICAgLy8gbi5wb3NpdGlvblggKyBcIiwgXCIgKyBuLnBvc2l0aW9uWSArIFwiKS5cIjsgXG5cbiAgICAgIC8vIExpbWl0IGRpc3BsYWNlbWVudCBpbiBvcmRlciB0byBpbXByb3ZlIHN0YWJpbGl0eVxuICAgICAgdmFyIHRlbXBGb3JjZSA9IGxpbWl0Rm9yY2Uobi5vZmZzZXRYLCBuLm9mZnNldFksIGxheW91dEluZm8udGVtcGVyYXR1cmUpO1xuICAgICAgbi5wb3NpdGlvblggKz0gdGVtcEZvcmNlLng7IFxuICAgICAgbi5wb3NpdGlvblkgKz0gdGVtcEZvcmNlLnk7XG4gICAgICBuLm9mZnNldFggPSAwO1xuICAgICAgbi5vZmZzZXRZID0gMDtcbiAgICAgIG4ubWluWCAgICA9IG4ucG9zaXRpb25YIC0gbi53aWR0aDsgXG4gICAgICBuLm1heFggICAgPSBuLnBvc2l0aW9uWCArIG4ud2lkdGg7IFxuICAgICAgbi5taW5ZICAgID0gbi5wb3NpdGlvblkgLSBuLmhlaWdodDsgXG4gICAgICBuLm1heFkgICAgPSBuLnBvc2l0aW9uWSArIG4uaGVpZ2h0OyBcbiAgICAgIC8vIHMgKz0gXCIgTmV3IFBvc2l0aW9uOiAoXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBcIiArIG4ucG9zaXRpb25ZICsgXCIpLlwiO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG5cbiAgICAgIC8vIFVwZGF0ZSBhbmNlc3RyeSBib3VkYXJpZXNcbiAgICAgIHVwZGF0ZUFuY2VzdHJ5Qm91bmRhcmllcyhuLCBsYXlvdXRJbmZvKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc2l6ZSwgcG9zaXRpb24gb2YgY29tcHVuZCBub2Rlc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5b3V0SW5mby5ub2RlU2l6ZTsgaSsrKSB7XG4gICAgICB2YXIgbiA9IGxheW91dEluZm8ubGF5b3V0Tm9kZXNbaV07XG4gICAgICBpZiAoMCA8IG4uY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIG4ucG9zaXRpb25YID0gKG4ubWF4WCArIG4ubWluWCkgLyAyO1xuICAgICAgICBuLnBvc2l0aW9uWSA9IChuLm1heFkgKyBuLm1pblkpIC8gMjtcbiAgICAgICAgbi53aWR0aCAgICAgPSBuLm1heFggLSBuLm1pblg7XG4gICAgICAgIG4uaGVpZ2h0ICAgID0gbi5tYXhZIC0gbi5taW5ZO1xuICAgICAgICAvLyBzID0gXCJVcGRhdGluZyBwb3NpdGlvbiwgc2l6ZSBvZiBjb21wb3VuZCBub2RlIFwiICsgbi5pZDtcbiAgICAgICAgLy8gcyArPSBcIlxcblBvc2l0aW9uWDogXCIgKyBuLnBvc2l0aW9uWCArIFwiLCBQb3NpdGlvblk6IFwiICsgbi5wb3NpdGlvblk7XG4gICAgICAgIC8vIHMgKz0gXCJcXG5XaWR0aDogXCIgKyBuLndpZHRoICsgXCIsIEhlaWdodDogXCIgKyBuLmhlaWdodDtcbiAgICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICB9XG4gICAgfSAgXG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogTGltaXRzIGEgZm9yY2UgKGZvcmNlWCwgZm9yY2VZKSB0byBiZSBub3QgXG4gICAqICAgICAgICAgIGdyZWF0ZXIgKGluIG1vZHVsbykgdGhhbiBtYXguIFxuICAgOCAgICAgICAgICBQcmVzZXJ2ZXMgZm9yY2UgZGlyZWN0aW9uLiBcbiAgICovXG4gIHZhciBsaW1pdEZvcmNlID0gZnVuY3Rpb24oZm9yY2VYLCBmb3JjZVksIG1heCkge1xuICAgIC8vIHZhciBzID0gXCJMaW1pdGluZyBmb3JjZTogKFwiICsgZm9yY2VYICsgXCIsIFwiICsgZm9yY2VZICsgXCIpLiBNYXg6IFwiICsgbWF4O1xuICAgIHZhciBmb3JjZSA9IE1hdGguc3FydChmb3JjZVggKiBmb3JjZVggKyBmb3JjZVkgKiBmb3JjZVkpO1xuXG4gICAgaWYgKGZvcmNlID4gbWF4KSB7XG4gICAgICB2YXIgcmVzID0ge1xuICAgICAgeCA6IG1heCAqIGZvcmNlWCAvIGZvcmNlLFxuICAgICAgeSA6IG1heCAqIGZvcmNlWSAvIGZvcmNlXG4gICAgICB9OyAgICAgIFxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSB7XG4gICAgICB4IDogZm9yY2VYLFxuICAgICAgeSA6IGZvcmNlWVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBzICs9IFwiLlxcblJlc3VsdDogKFwiICsgcmVzLnggKyBcIiwgXCIgKyByZXMueSArIFwiKVwiO1xuICAgIC8vIGxvZ0RlYnVnKHMpO1xuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBAYnJpZWYgOiBGdW5jdGlvbiB1c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGNvbXBvdW5kIG5vZGUgXG4gICAqICAgICAgICAgIHNpemVzLCBzaW5jZSB0aGV5IHNob3VsZCBib3VuZCBhbGwgdGhlaXIgc3Vibm9kZXMuXG4gICAqL1xuICB2YXIgdXBkYXRlQW5jZXN0cnlCb3VuZGFyaWVzID0gZnVuY3Rpb24obm9kZSwgbGF5b3V0SW5mbykge1xuICAgIC8vIHZhciBzID0gXCJQcm9wYWdhdGluZyBuZXcgcG9zaXRpb24vc2l6ZSBvZiBub2RlIFwiICsgbm9kZS5pZDtcbiAgICB2YXIgcGFyZW50SWQgPSBub2RlLnBhcmVudElkO1xuICAgIGlmIChudWxsID09IHBhcmVudElkKSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UgYXJlIGRvbmVcbiAgICAgIC8vIHMgKz0gXCIuIE5vIHBhcmVudCBub2RlLlwiO1xuICAgICAgLy8gbG9nRGVidWcocyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IFBhcmVudCBOb2RlXG4gICAgdmFyIHAgPSBsYXlvdXRJbmZvLmxheW91dE5vZGVzW2xheW91dEluZm8uaWRUb0luZGV4W3BhcmVudElkXV07XG4gICAgdmFyIGZsYWcgPSBmYWxzZTtcblxuICAgIC8vIE1heFhcbiAgICBpZiAobnVsbCA9PSBwLm1heFggfHwgbm9kZS5tYXhYICsgcC5wYWRSaWdodCA+IHAubWF4WCkge1xuICAgICAgcC5tYXhYID0gbm9kZS5tYXhYICsgcC5wYWRSaWdodDtcbiAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgLy8gcyArPSBcIlxcbk5ldyBtYXhYIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1heFg7XG4gICAgfVxuXG4gICAgLy8gTWluWFxuICAgIGlmIChudWxsID09IHAubWluWCB8fCBub2RlLm1pblggLSBwLnBhZExlZnQgPCBwLm1pblgpIHtcbiAgICAgIHAubWluWCA9IG5vZGUubWluWCAtIHAucGFkTGVmdDtcbiAgICAgIGZsYWcgPSB0cnVlO1xuICAgICAgLy8gcyArPSBcIlxcbk5ldyBtaW5YIGZvciBwYXJlbnQgbm9kZSBcIiArIHAuaWQgKyBcIjogXCIgKyBwLm1pblg7XG4gICAgfVxuXG4gICAgLy8gTWF4WVxuICAgIGlmIChudWxsID09IHAubWF4WSB8fCBub2RlLm1heFkgKyBwLnBhZEJvdHRvbSA+IHAubWF4WSkge1xuICAgICAgcC5tYXhZID0gbm9kZS5tYXhZICsgcC5wYWRCb3R0b207XG4gICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgIC8vIHMgKz0gXCJcXG5OZXcgbWF4WSBmb3IgcGFyZW50IG5vZGUgXCIgKyBwLmlkICsgXCI6IFwiICsgcC5tYXhZO1xuICAgIH1cblxuICAgIC8vIE1pbllcbiAgICBpZiAobnVsbCA9PSBwLm1pblkgfHwgbm9kZS5taW5ZIC0gcC5wYWRUb3AgPCBwLm1pblkpIHtcbiAgICAgIHAubWluWSA9IG5vZGUubWluWSAtIHAucGFkVG9wO1xuICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAvLyBzICs9IFwiXFxuTmV3IG1pblkgZm9yIHBhcmVudCBub2RlIFwiICsgcC5pZCArIFwiOiBcIiArIHAubWluWTtcbiAgICB9XG5cbiAgICAvLyBJZiB1cGRhdGVkIGJvdW5kYXJpZXMsIHByb3BhZ2F0ZSBjaGFuZ2VzIHVwd2FyZFxuICAgIGlmIChmbGFnKSB7XG4gICAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICAgIHJldHVybiB1cGRhdGVBbmNlc3RyeUJvdW5kYXJpZXMocCwgbGF5b3V0SW5mbyk7XG4gICAgfSBcblxuICAgIC8vIHMgKz0gXCIuIE5vIGNoYW5nZXMgaW4gYm91bmRhcmllcy9wb3NpdGlvbiBvZiBwYXJlbnQgbm9kZSBcIiArIHAuaWQ7ICBcbiAgICAvLyBsb2dEZWJ1ZyhzKTtcbiAgICByZXR1cm47XG4gIH07XG5cblxuICAvKipcbiAgICogQGJyaWVmIDogTG9ncyBhIGRlYnVnIG1lc3NhZ2UgaW4gSlMgY29uc29sZSwgaWYgREVCVUcgaXMgT05cbiAgICovXG4gIC8vIHZhciBsb2dEZWJ1ZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgLy8gICBpZiAoREVCVUcpIHtcbiAgLy8gICAgIGNvbnNvbGUuZGVidWcodGV4dCk7XG4gIC8vICAgfVxuICAvLyB9O1xuXG5cbiAgLy8gcmVnaXN0ZXIgdGhlIGxheW91dFxuICAkJCgnbGF5b3V0JywgJ2Nvc2UnLCBDb3NlTGF5b3V0KTtcblxufSkoY3l0b3NjYXBlKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcblxuICAvLyBkZWZhdWx0IGxheW91dCBvcHRpb25zXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICAvLyBkYWdyZSBhbGdvIG9wdGlvbnMsIHVzZXMgZGVmYXVsdCB2YWx1ZSBvbiB1bmRlZmluZWRcbiAgICBub2RlU2VwOiB1bmRlZmluZWQsIC8vIHRoZSBzZXBhcmF0aW9uIGJldHdlZW4gYWRqYWNlbnQgbm9kZXMgaW4gdGhlIHNhbWUgcmFua1xuICAgIGVkZ2VTZXA6IHVuZGVmaW5lZCwgLy8gdGhlIHNlcGFyYXRpb24gYmV0d2VlbiBhZGphY2VudCBlZGdlcyBpbiB0aGUgc2FtZSByYW5rXG4gICAgcmFua1NlcDogdW5kZWZpbmVkLCAvLyB0aGUgc2VwYXJhdGlvbiBiZXR3ZWVuIGFkamFjZW50IG5vZGVzIGluIHRoZSBzYW1lIHJhbmtcbiAgICByYW5rRGlyOiB1bmRlZmluZWQsIC8vICdUQicgZm9yIHRvcCB0byBib3R0b20gZmxvdywgJ0xSJyBmb3IgbGVmdCB0byByaWdodFxuICAgIG1pbkxlbjogZnVuY3Rpb24oIGVkZ2UgKXsgcmV0dXJuIDE7IH0sIC8vIG51bWJlciBvZiByYW5rcyB0byBrZWVwIGJldHdlZW4gdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IG9mIHRoZSBlZGdlXG4gICAgZWRnZVdlaWdodDogZnVuY3Rpb24oIGVkZ2UgKXsgcmV0dXJuIDE7IH0sIC8vIGhpZ2hlciB3ZWlnaHQgZWRnZXMgYXJlIGdlbmVyYWxseSBtYWRlIHNob3J0ZXIgYW5kIHN0cmFpZ2h0ZXIgdGhhbiBsb3dlciB3ZWlnaHQgZWRnZXNcbiAgICBcbiAgICAvLyBnZW5lcmFsIGxheW91dCBvcHRpb25zXG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0byB2aWV3cG9ydFxuICAgIHBhZGRpbmc6IDMwLCAvLyBmaXQgcGFkZGluZ1xuICAgIGFuaW1hdGU6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHRyYW5zaXRpb24gdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgYW5pbWF0aW9uRHVyYXRpb246IDUwMCwgLy8gZHVyYXRpb24gb2YgYW5pbWF0aW9uIGluIG1zIGlmIGVuYWJsZWRcbiAgICBib3VuZGluZ0JveDogdW5kZWZpbmVkLCAvLyBjb25zdHJhaW4gbGF5b3V0IGJvdW5kczsgeyB4MSwgeTEsIHgyLCB5MiB9IG9yIHsgeDEsIHkxLCB3LCBoIH1cbiAgICByZWFkeTogZnVuY3Rpb24oKXt9LCAvLyBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IGZ1bmN0aW9uKCl7fSAvLyBvbiBsYXlvdXRzdG9wXG4gIH07XG5cbiAgLy8gY29uc3RydWN0b3JcbiAgLy8gb3B0aW9ucyA6IG9iamVjdCBjb250YWluaW5nIGxheW91dCBvcHRpb25zXG4gIGZ1bmN0aW9uIERhZ3JlTGF5b3V0KCBvcHRpb25zICl7XG4gICAgdGhpcy5vcHRpb25zID0gJCQudXRpbC5leHRlbmQodHJ1ZSwge30sIGRlZmF1bHRzLCBvcHRpb25zKTsgXG4gIH1cblxuICAvLyBydW5zIHRoZSBsYXlvdXRcbiAgRGFncmVMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGxheW91dCA9IHRoaXM7XG5cbiAgICAkJC51dGlsLnJlcXVpcmUoJ2RhZ3JlJywgZnVuY3Rpb24oZGFncmUpe1xuXG4gICAgICB2YXIgY3kgPSBvcHRpb25zLmN5OyAvLyBjeSBpcyBhdXRvbWF0aWNhbGx5IHBvcHVsYXRlZCBmb3IgdXMgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcblxuICAgICAgdmFyIGdldFZhbCA9IGZ1bmN0aW9uKCBlbGUsIHZhbCApe1xuICAgICAgICByZXR1cm4gJCQuaXMuZm4odmFsKSA/IHZhbC5hcHBseSggZWxlLCBbIGVsZSBdICkgOiB2YWw7XG4gICAgICB9O1xuXG4gICAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICAgIHgxOiAwLCB5MTogMCwgdzogY3kud2lkdGgoKSwgaDogY3kuaGVpZ2h0KClcbiAgICAgIH0gKTtcblxuICAgICAgdmFyIGcgPSBuZXcgZGFncmUuZ3JhcGhsaWIuR3JhcGgoe1xuICAgICAgICBtdWx0aWdyYXBoOiB0cnVlLFxuICAgICAgICBjb21wb3VuZDogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIHZhciBnT2JqID0ge307XG4gICAgICB2YXIgc2V0R09iaiA9IGZ1bmN0aW9uKCBuYW1lLCB2YWwgKXtcbiAgICAgICAgaWYoIHZhbCAhPSBudWxsICl7XG4gICAgICAgICAgZ09ialsgbmFtZSBdID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICBzZXRHT2JqKCAnbm9kZXNlcCcsIG9wdGlvbnMubm9kZVNlcCApO1xuICAgICAgc2V0R09iaiggJ2VkZ2VzZXAnLCBvcHRpb25zLmVkZ2VTZXAgKTtcbiAgICAgIHNldEdPYmooICdyYW5rc2VwJywgb3B0aW9ucy5yYW5rU2VwICk7XG4gICAgICBzZXRHT2JqKCAncmFua2RpcicsIG9wdGlvbnMucmFua0RpciApO1xuXG4gICAgICBnLnNldEdyYXBoKCBnT2JqICk7XG5cbiAgICAgIGcuc2V0RGVmYXVsdEVkZ2VMYWJlbChmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9KTtcbiAgICAgIGcuc2V0RGVmYXVsdE5vZGVMYWJlbChmdW5jdGlvbigpIHsgcmV0dXJuIHt9OyB9KTtcblxuICAgICAgLy8gYWRkIG5vZGVzIHRvIGRhZ3JlXG4gICAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCk7XG4gICAgICBmb3IoIHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrICl7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgICAgZy5zZXROb2RlKCBub2RlLmlkKCksIHtcbiAgICAgICAgICB3aWR0aDogbm9kZS53aWR0aCgpLFxuICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHQoKSxcbiAgICAgICAgICBuYW1lOiBub2RlLmlkKClcbiAgICAgICAgfSApO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBnLm5vZGUobm9kZS5pZCgpKSApO1xuICAgICAgfVxuXG4gICAgICAvLyBzZXQgY29tcG91bmQgcGFyZW50c1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgICAgIGlmKCBub2RlLmlzQ2hpbGQoKSApe1xuICAgICAgICAgIGcuc2V0UGFyZW50KCBub2RlLmlkKCksIG5vZGUucGFyZW50KCkuaWQoKSApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZCBlZGdlcyB0byBkYWdyZVxuICAgICAgdmFyIGVkZ2VzID0gZWxlcy5lZGdlcygpLnN0ZEZpbHRlcihmdW5jdGlvbiggZWRnZSApe1xuICAgICAgICByZXR1cm4gIWVkZ2Uuc291cmNlKCkuaXNQYXJlbnQoKSAmJiAhZWRnZS50YXJnZXQoKS5pc1BhcmVudCgpOyAvLyBkYWdyZSBjYW4ndCBoYW5kbGUgZWRnZXMgb24gY29tcG91bmQgbm9kZXNcbiAgICAgIH0pO1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBlZGdlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW2ldO1xuXG4gICAgICAgIGcuc2V0RWRnZSggZWRnZS5zb3VyY2UoKS5pZCgpLCBlZGdlLnRhcmdldCgpLmlkKCksIHtcbiAgICAgICAgICBtaW5sZW46IGdldFZhbCggZWRnZSwgb3B0aW9ucy5taW5MZW4gKSxcbiAgICAgICAgICB3ZWlnaHQ6IGdldFZhbCggZWRnZSwgb3B0aW9ucy5lZGdlV2VpZ2h0ICksXG4gICAgICAgICAgbmFtZTogZWRnZS5pZCgpXG4gICAgICAgIH0sIGVkZ2UuaWQoKSApO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBnLmVkZ2UoZWRnZS5zb3VyY2UoKS5pZCgpLCBlZGdlLnRhcmdldCgpLmlkKCksIGVkZ2UuaWQoKSkgKTtcbiAgICAgIH1cblxuICAgICAgZGFncmUubGF5b3V0KCBnICk7XG5cbiAgICAgIHZhciBnTm9kZUlkcyA9IGcubm9kZXMoKTtcbiAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZ05vZGVJZHMubGVuZ3RoOyBpKysgKXtcbiAgICAgICAgdmFyIGlkID0gZ05vZGVJZHNbaV07XG4gICAgICAgIHZhciBuID0gZy5ub2RlKCBpZCApO1xuXG4gICAgICAgIGN5LmdldEVsZW1lbnRCeUlkKGlkKS5zY3JhdGNoKCkuZGFncmUgPSBuO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGFncmVCQjtcblxuICAgICAgaWYoIG9wdGlvbnMuYm91bmRpbmdCb3ggKXtcbiAgICAgICAgZGFncmVCQiA9IHsgeDE6IEluZmluaXR5LCB4MjogLUluZmluaXR5LCB5MTogSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiggbm9kZSApe1xuICAgICAgICAgIHZhciBkTW9kZWwgPSBub2RlLnNjcmF0Y2goKS5kYWdyZTtcblxuICAgICAgICAgIGRhZ3JlQkIueDEgPSBNYXRoLm1pbiggZGFncmVCQi54MSwgZE1vZGVsLnggKTtcbiAgICAgICAgICBkYWdyZUJCLngyID0gTWF0aC5tYXgoIGRhZ3JlQkIueDIsIGRNb2RlbC54ICk7XG5cbiAgICAgICAgICBkYWdyZUJCLnkxID0gTWF0aC5taW4oIGRhZ3JlQkIueTEsIGRNb2RlbC55ICk7XG4gICAgICAgICAgZGFncmVCQi55MiA9IE1hdGgubWF4KCBkYWdyZUJCLnkyLCBkTW9kZWwueSApO1xuICAgICAgICB9KTtcblxuICAgICAgICBkYWdyZUJCLncgPSBkYWdyZUJCLngyIC0gZGFncmVCQi54MTtcbiAgICAgICAgZGFncmVCQi5oID0gZGFncmVCQi55MiAtIGRhZ3JlQkIueTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYWdyZUJCID0gYmI7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb25zdHJhaW5Qb3MgPSBmdW5jdGlvbiggcCApe1xuICAgICAgICBpZiggb3B0aW9ucy5ib3VuZGluZ0JveCApe1xuICAgICAgICAgIHZhciB4UGN0ID0gKHAueCAtIGRhZ3JlQkIueDEpIC8gZGFncmVCQi53O1xuICAgICAgICAgIHZhciB5UGN0ID0gKHAueSAtIGRhZ3JlQkIueTEpIC8gZGFncmVCQi5oO1xuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGJiLngxICsgeFBjdCAqIGJiLncsXG4gICAgICAgICAgICB5OiBiYi55MSArIHlQY3QgKiBiYi5oXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKGxheW91dCwgb3B0aW9ucywgZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGRNb2RlbCA9IHRoaXMuc2NyYXRjaCgpLmRhZ3JlO1xuXG4gICAgICAgIHJldHVybiBjb25zdHJhaW5Qb3Moe1xuICAgICAgICAgIHg6IGRNb2RlbC54LFxuICAgICAgICAgIHk6IGRNb2RlbC55XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICB9KTsgLy8gcmVxdWlyZVxuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gcmVnaXN0ZXIgdGhlIGxheW91dFxuICAkJCgnbGF5b3V0JywgJ2RhZ3JlJywgRGFncmVMYXlvdXQpO1xuXG59KShjeXRvc2NhcGUpO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGZpdDogdHJ1ZSwgLy8gd2hldGhlciB0byBmaXQgdGhlIHZpZXdwb3J0IHRvIHRoZSBncmFwaFxuICAgIHBhZGRpbmc6IDMwLCAvLyBwYWRkaW5nIHVzZWQgb24gZml0XG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYXZvaWRPdmVybGFwOiB0cnVlLCAvLyBwcmV2ZW50cyBub2RlIG92ZXJsYXAsIG1heSBvdmVyZmxvdyBib3VuZGluZ0JveCBpZiBub3QgZW5vdWdoIHNwYWNlXG4gICAgcm93czogdW5kZWZpbmVkLCAvLyBmb3JjZSBudW0gb2Ygcm93cyBpbiB0aGUgZ3JpZFxuICAgIGNvbHVtbnM6IHVuZGVmaW5lZCwgLy8gZm9yY2UgbnVtIG9mIGNvbHMgaW4gdGhlIGdyaWRcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24oIG5vZGUgKXt9LCAvLyByZXR1cm5zIHsgcm93LCBjb2wgfSBmb3IgZWxlbWVudFxuICAgIHNvcnQ6IHVuZGVmaW5lZCwgLy8gYSBzb3J0aW5nIGZ1bmN0aW9uIHRvIG9yZGVyIHRoZSBub2RlczsgZS5nLiBmdW5jdGlvbihhLCBiKXsgcmV0dXJuIGEuZGF0YSgnd2VpZ2h0JykgLSBiLmRhdGEoJ3dlaWdodCcpIH1cbiAgICBhbmltYXRlOiBmYWxzZSwgLy8gd2hldGhlciB0byB0cmFuc2l0aW9uIHRoZSBub2RlIHBvc2l0aW9uc1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIC8vIGR1cmF0aW9uIG9mIGFuaW1hdGlvbiBpbiBtcyBpZiBlbmFibGVkXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICB9O1xuICBcbiAgZnVuY3Rpb24gR3JpZExheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIEdyaWRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIHBhcmFtcyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgb3B0aW9ucyA9IHBhcmFtcztcbiAgICBcbiAgICB2YXIgY3kgPSBwYXJhbXMuY3k7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgdmFyIG5vZGVzID0gZWxlcy5ub2RlcygpLm5vdCgnOnBhcmVudCcpO1xuXG4gICAgaWYoIG9wdGlvbnMuc29ydCApe1xuICAgICAgbm9kZXMgPSBub2Rlcy5zb3J0KCBvcHRpb25zLnNvcnQgKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGJiID0gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggPyBvcHRpb25zLmJvdW5kaW5nQm94IDoge1xuICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgIH0gKTtcblxuICAgIGlmKCBiYi5oID09PSAwIHx8IGJiLncgPT09IDApe1xuICAgICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKHRoaXMsIG9wdGlvbnMsIGZ1bmN0aW9uKCl7XG4gICAgICAgIHJldHVybiB7IHg6IGJiLngxLCB5OiBiYi55MSB9O1xuICAgICAgfSk7XG4gICAgICBcbiAgICB9IGVsc2Uge1xuICAgICAgXG4gICAgICAvLyB3aWR0aC9oZWlnaHQgKiBzcGxpdHNeMiA9IGNlbGxzIHdoZXJlIHNwbGl0cyBpcyBudW1iZXIgb2YgdGltZXMgdG8gc3BsaXQgd2lkdGhcbiAgICAgIHZhciBjZWxscyA9IG5vZGVzLnNpemUoKTtcbiAgICAgIHZhciBzcGxpdHMgPSBNYXRoLnNxcnQoIGNlbGxzICogYmIuaC9iYi53ICk7XG4gICAgICB2YXIgcm93cyA9IE1hdGgucm91bmQoIHNwbGl0cyApO1xuICAgICAgdmFyIGNvbHMgPSBNYXRoLnJvdW5kKCBiYi53L2JiLmggKiBzcGxpdHMgKTtcblxuICAgICAgdmFyIHNtYWxsID0gZnVuY3Rpb24odmFsKXtcbiAgICAgICAgaWYoIHZhbCA9PSBudWxsICl7XG4gICAgICAgICAgcmV0dXJuIE1hdGgubWluKHJvd3MsIGNvbHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgICAgICBpZiggbWluID09IHJvd3MgKXtcbiAgICAgICAgICAgIHJvd3MgPSB2YWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbHMgPSB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgXG4gICAgICB2YXIgbGFyZ2UgPSBmdW5jdGlvbih2YWwpe1xuICAgICAgICBpZiggdmFsID09IG51bGwgKXtcbiAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocm93cywgY29scyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHJvd3MsIGNvbHMpO1xuICAgICAgICAgIGlmKCBtYXggPT0gcm93cyApe1xuICAgICAgICAgICAgcm93cyA9IHZhbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29scyA9IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBcbiAgICAgIC8vIGlmIHJvd3Mgb3IgY29sdW1ucyB3ZXJlIHNldCBpbiBvcHRpb25zLCB1c2UgdGhvc2UgdmFsdWVzXG4gICAgICBpZiggb3B0aW9ucy5yb3dzICE9IG51bGwgJiYgb3B0aW9ucy5jb2x1bW5zICE9IG51bGwgKXtcbiAgICAgICAgcm93cyA9IG9wdGlvbnMucm93cztcbiAgICAgICAgY29scyA9IG9wdGlvbnMuY29sdW1ucztcbiAgICAgIH0gZWxzZSBpZiggb3B0aW9ucy5yb3dzICE9IG51bGwgJiYgb3B0aW9ucy5jb2x1bW5zID09IG51bGwgKXtcbiAgICAgICAgcm93cyA9IG9wdGlvbnMucm93cztcbiAgICAgICAgY29scyA9IE1hdGguY2VpbCggY2VsbHMgLyByb3dzICk7XG4gICAgICB9IGVsc2UgaWYoIG9wdGlvbnMucm93cyA9PSBudWxsICYmIG9wdGlvbnMuY29sdW1ucyAhPSBudWxsICl7XG4gICAgICAgIGNvbHMgPSBvcHRpb25zLmNvbHVtbnM7XG4gICAgICAgIHJvd3MgPSBNYXRoLmNlaWwoIGNlbGxzIC8gY29scyApO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBhdXRvbWF0aWMgdmFsdWVzIGFuZCBhZGp1c3QgYWNjb3JkaW5nbHlcbiAgICAgIFxuICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHVwLCBzZWUgaWYgd2UgY2FuIHJlZHVjZSByb3dzIG9yIGNvbHVtbnNcbiAgICAgIGVsc2UgaWYoIGNvbHMgKiByb3dzID4gY2VsbHMgKXtcbiAgICAgICAgdmFyIHNtID0gc21hbGwoKTtcbiAgICAgICAgdmFyIGxnID0gbGFyZ2UoKTtcbiAgICAgICAgXG4gICAgICAgIC8vIHJlZHVjaW5nIHRoZSBzbWFsbCBzaWRlIHRha2VzIGF3YXkgdGhlIG1vc3QgY2VsbHMsIHNvIHRyeSBpdCBmaXJzdFxuICAgICAgICBpZiggKHNtIC0gMSkgKiBsZyA+PSBjZWxscyApe1xuICAgICAgICAgIHNtYWxsKHNtIC0gMSk7XG4gICAgICAgIH0gZWxzZSBpZiggKGxnIC0gMSkgKiBzbSA+PSBjZWxscyApe1xuICAgICAgICAgIGxhcmdlKGxnIC0gMSk7XG4gICAgICAgIH0gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBcbiAgICAgICAgLy8gaWYgcm91bmRpbmcgd2FzIHRvbyBsb3csIGFkZCByb3dzIG9yIGNvbHVtbnNcbiAgICAgICAgd2hpbGUoIGNvbHMgKiByb3dzIDwgY2VsbHMgKXtcbiAgICAgICAgICB2YXIgc20gPSBzbWFsbCgpO1xuICAgICAgICAgIHZhciBsZyA9IGxhcmdlKCk7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gdHJ5IHRvIGFkZCB0byBsYXJnZXIgc2lkZSBmaXJzdCAoYWRkcyBsZXNzIGluIG11bHRpcGxpY2F0aW9uKVxuICAgICAgICAgIGlmKCAobGcgKyAxKSAqIHNtID49IGNlbGxzICl7XG4gICAgICAgICAgICBsYXJnZShsZyArIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbWFsbChzbSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgY2VsbFdpZHRoID0gYmIudyAvIGNvbHM7XG4gICAgICB2YXIgY2VsbEhlaWdodCA9IGJiLmggLyByb3dzO1xuXG4gICAgICBpZiggb3B0aW9ucy5hdm9pZE92ZXJsYXAgKXtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgdmFyIHcgPSBub2RlLm91dGVyV2lkdGgoKTtcbiAgICAgICAgICB2YXIgaCA9IG5vZGUub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgICAgIGNlbGxXaWR0aCA9IE1hdGgubWF4KCBjZWxsV2lkdGgsIHcgKTtcbiAgICAgICAgICBjZWxsSGVpZ2h0ID0gTWF0aC5tYXgoIGNlbGxIZWlnaHQsIGggKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgY2VsbFVzZWQgPSB7fTsgLy8gZS5nLiAnYy0wLTInID0+IHRydWVcbiAgICAgIFxuICAgICAgdmFyIHVzZWQgPSBmdW5jdGlvbihyb3csIGNvbCl7XG4gICAgICAgIHJldHVybiBjZWxsVXNlZFsnYy0nICsgcm93ICsgJy0nICsgY29sXSA/IHRydWUgOiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHZhciB1c2UgPSBmdW5jdGlvbihyb3csIGNvbCl7XG4gICAgICAgIGNlbGxVc2VkWydjLScgKyByb3cgKyAnLScgKyBjb2xdID0gdHJ1ZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIHRvIGtlZXAgdHJhY2sgb2YgY3VycmVudCBjZWxsIHBvc2l0aW9uXG4gICAgICB2YXIgcm93ID0gMDtcbiAgICAgIHZhciBjb2wgPSAwO1xuICAgICAgdmFyIG1vdmVUb05leHRDZWxsID0gZnVuY3Rpb24oKXtcbiAgICAgICAgY29sKys7XG4gICAgICAgIGlmKCBjb2wgPj0gY29scyApe1xuICAgICAgICAgIGNvbCA9IDA7XG4gICAgICAgICAgcm93Kys7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGdldCBhIGNhY2hlIG9mIGFsbCB0aGUgbWFudWFsIHBvc2l0aW9uc1xuICAgICAgdmFyIGlkMm1hblBvcyA9IHt9O1xuICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgcmNQb3MgPSBvcHRpb25zLnBvc2l0aW9uKCBub2RlICk7XG5cbiAgICAgICAgaWYoIHJjUG9zICYmIChyY1Bvcy5yb3cgIT09IHVuZGVmaW5lZCB8fCByY1Bvcy5jb2wgIT09IHVuZGVmaW5lZCkgKXsgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHJvdyBvciBjb2wgZGVmJ2RcbiAgICAgICAgICB2YXIgcG9zID0ge1xuICAgICAgICAgICAgcm93OiByY1Bvcy5yb3csXG4gICAgICAgICAgICBjb2w6IHJjUG9zLmNvbFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiggcG9zLmNvbCA9PT0gdW5kZWZpbmVkICl7IC8vIGZpbmQgdW51c2VkIGNvbFxuICAgICAgICAgICAgcG9zLmNvbCA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlKCB1c2VkKHBvcy5yb3csIHBvcy5jb2wpICl7XG4gICAgICAgICAgICAgIHBvcy5jb2wrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoIHBvcy5yb3cgPT09IHVuZGVmaW5lZCApeyAvLyBmaW5kIHVudXNlZCByb3dcbiAgICAgICAgICAgIHBvcy5yb3cgPSAwO1xuXG4gICAgICAgICAgICB3aGlsZSggdXNlZChwb3Mucm93LCBwb3MuY29sKSApe1xuICAgICAgICAgICAgICBwb3Mucm93Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWQybWFuUG9zWyBub2RlLmlkKCkgXSA9IHBvcztcbiAgICAgICAgICB1c2UoIHBvcy5yb3csIHBvcy5jb2wgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZ2V0UG9zID0gZnVuY3Rpb24oaSwgZWxlbWVudCl7XG4gICAgICAgIHZhciB4LCB5O1xuXG4gICAgICAgIGlmKCBlbGVtZW50LmxvY2tlZCgpIHx8IGVsZW1lbnQuaXNGdWxsQXV0b1BhcmVudCgpICl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VlIGlmIHdlIGhhdmUgYSBtYW51YWwgcG9zaXRpb24gc2V0XG4gICAgICAgIHZhciByY1BvcyA9IGlkMm1hblBvc1sgZWxlbWVudC5pZCgpIF07XG4gICAgICAgIGlmKCByY1BvcyApe1xuICAgICAgICAgIHggPSByY1Bvcy5jb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGgvMiArIGJiLngxO1xuICAgICAgICAgIHkgPSByY1Bvcy5yb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodC8yICsgYmIueTE7XG4gICAgICAgIFxuICAgICAgICB9IGVsc2UgeyAvLyBvdGhlcndpc2Ugc2V0IGF1dG9tYXRpY2FsbHlcbiAgICAgICAgXG4gICAgICAgICAgd2hpbGUoIHVzZWQocm93LCBjb2wpICl7XG4gICAgICAgICAgICBtb3ZlVG9OZXh0Q2VsbCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHggPSBjb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGgvMiArIGJiLngxO1xuICAgICAgICAgIHkgPSByb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodC8yICsgYmIueTE7XG4gICAgICAgICAgdXNlKCByb3csIGNvbCApO1xuICAgICAgICAgIFxuICAgICAgICAgIG1vdmVUb05leHRDZWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgICAgICAgXG4gICAgICB9O1xuXG4gICAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnMoIHRoaXMsIG9wdGlvbnMsIGdldFBvcyApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICAgIFxuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdncmlkJywgR3JpZExheW91dCk7XG4gIFxufSkoIGN5dG9zY2FwZSApO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIGRlZmF1bHQgbGF5b3V0IG9wdGlvbnNcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIHJlYWR5OiBmdW5jdGlvbigpe30sIC8vIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogZnVuY3Rpb24oKXt9IC8vIG9uIGxheW91dHN0b3BcbiAgfTtcblxuICAvLyBjb25zdHJ1Y3RvclxuICAvLyBvcHRpb25zIDogb2JqZWN0IGNvbnRhaW5pbmcgbGF5b3V0IG9wdGlvbnNcbiAgZnVuY3Rpb24gTnVsbExheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7IFxuICB9XG5cbiAgLy8gcnVucyB0aGUgbGF5b3V0XG4gIE51bGxMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7IC8vIGVsZW1lbnRzIHRvIGNvbnNpZGVyIGluIHRoZSBsYXlvdXRcbiAgICB2YXIgbGF5b3V0ID0gdGhpcztcblxuICAgIC8vIGN5IGlzIGF1dG9tYXRpY2FsbHkgcG9wdWxhdGVkIGZvciB1cyBpbiB0aGUgY29uc3RydWN0b3JcbiAgICB2YXIgY3kgPSBvcHRpb25zLmN5OyAvLyBqc2hpbnQgaWdub3JlOmxpbmVcblxuICAgIGxheW91dC50cmlnZ2VyKCdsYXlvdXRzdGFydCcpO1xuXG4gICAgLy8gcHV0cyBhbGwgbm9kZXMgYXQgKDAsIDApXG4gICAgZWxlcy5ub2RlcygpLnBvc2l0aW9ucyhmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIHRyaWdnZXIgbGF5b3V0cmVhZHkgd2hlbiBlYWNoIG5vZGUgaGFzIGhhZCBpdHMgcG9zaXRpb24gc2V0IGF0IGxlYXN0IG9uY2VcbiAgICBsYXlvdXQub25lKCdsYXlvdXRyZWFkeScsIG9wdGlvbnMucmVhZHkpO1xuICAgIGxheW91dC50cmlnZ2VyKCdsYXlvdXRyZWFkeScpO1xuXG4gICAgLy8gdHJpZ2dlciBsYXlvdXRzdG9wIHdoZW4gdGhlIGxheW91dCBzdG9wcyAoZS5nLiBmaW5pc2hlcylcbiAgICBsYXlvdXQub25lKCdsYXlvdXRzdG9wJywgb3B0aW9ucy5zdG9wKTtcbiAgICBsYXlvdXQudHJpZ2dlcignbGF5b3V0c3RvcCcpO1xuXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG5cbiAgLy8gY2FsbGVkIG9uIGNvbnRpbnVvdXMgbGF5b3V0cyB0byBzdG9wIHRoZW0gYmVmb3JlIHRoZXkgZmluaXNoXG4gIE51bGxMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuXG4gIC8vIHJlZ2lzdGVyIHRoZSBsYXlvdXRcbiAgJCQoJ2xheW91dCcsICdudWxsJywgTnVsbExheW91dCk7XG5cbn0pKGN5dG9zY2FwZSk7XG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICBcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIHBvc2l0aW9uczogdW5kZWZpbmVkLCAvLyBtYXAgb2YgKG5vZGUgaWQpID0+IChwb3NpdGlvbiBvYmopOyBvciBmdW5jdGlvbihub2RlKXsgcmV0dXJuIHNvbVBvczsgfVxuICAgIHpvb206IHVuZGVmaW5lZCwgLy8gdGhlIHpvb20gbGV2ZWwgdG8gc2V0IChwcm9iIHdhbnQgZml0ID0gZmFsc2UgaWYgc2V0KVxuICAgIHBhbjogdW5kZWZpbmVkLCAvLyB0aGUgcGFuIGxldmVsIHRvIHNldCAocHJvYiB3YW50IGZpdCA9IGZhbHNlIGlmIHNldClcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIFByZXNldExheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIFByZXNldExheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgZWxlcyA9IG9wdGlvbnMuZWxlcztcblxuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKTtcbiAgICB2YXIgcG9zSXNGbiA9ICQkLmlzLmZuKCBvcHRpb25zLnBvc2l0aW9ucyApO1xuXG4gICAgZnVuY3Rpb24gZ2V0UG9zaXRpb24obm9kZSl7XG4gICAgICBpZiggb3B0aW9ucy5wb3NpdGlvbnMgPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYoIHBvc0lzRm4gKXtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucG9zaXRpb25zLmFwcGx5KCBub2RlLCBbIG5vZGUgXSApO1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgcG9zID0gb3B0aW9ucy5wb3NpdGlvbnNbbm9kZS5fcHJpdmF0ZS5kYXRhLmlkXTtcblxuICAgICAgaWYoIHBvcyA9PSBudWxsICl7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgXG4gICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBcbiAgICBub2Rlcy5sYXlvdXRQb3NpdGlvbnModGhpcywgb3B0aW9ucywgZnVuY3Rpb24oaSwgbm9kZSl7XG4gICAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbihub2RlKTtcbiAgICAgIFxuICAgICAgaWYoIG5vZGUubG9ja2VkKCkgfHwgcG9zaXRpb24gPT0gbnVsbCApe1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBcbiAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9KTtcbiAgICAgICAgXG4gICAgcmV0dXJuIHRoaXM7IC8vIGNoYWluaW5nXG4gIH07XG4gIFxuICAkJCgnbGF5b3V0JywgJ3ByZXNldCcsIFByZXNldExheW91dCk7XG4gIFxufSkoY3l0b3NjYXBlKTtcblxuOyhmdW5jdGlvbigkJCl7ICd1c2Ugc3RyaWN0JztcbiAgXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBmaXQ6IHRydWUsIC8vIHdoZXRoZXIgdG8gZml0IHRvIHZpZXdwb3J0XG4gICAgcGFkZGluZzogMzAsIC8vIGZpdCBwYWRkaW5nXG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgYW5pbWF0ZTogZmFsc2UsIC8vIHdoZXRoZXIgdG8gdHJhbnNpdGlvbiB0aGUgbm9kZSBwb3NpdGlvbnNcbiAgICBhbmltYXRpb25EdXJhdGlvbjogNTAwLCAvLyBkdXJhdGlvbiBvZiBhbmltYXRpb24gaW4gbXMgaWYgZW5hYmxlZFxuICAgIHJlYWR5OiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHJlYWR5XG4gICAgc3RvcDogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcbiAgfTtcbiAgXG4gIGZ1bmN0aW9uIFJhbmRvbUxheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIFJhbmRvbUxheW91dC5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgIHZhciBlbGVzID0gb3B0aW9ucy5lbGVzO1xuICAgIHZhciBub2RlcyA9IGVsZXMubm9kZXMoKS5ub3QoJzpwYXJlbnQnKTtcbiAgICBcbiAgICB2YXIgYmIgPSAkJC51dGlsLm1ha2VCb3VuZGluZ0JveCggb3B0aW9ucy5ib3VuZGluZ0JveCA/IG9wdGlvbnMuYm91bmRpbmdCb3ggOiB7XG4gICAgICB4MTogMCwgeTE6IDAsIHc6IGN5LndpZHRoKCksIGg6IGN5LmhlaWdodCgpXG4gICAgfSApO1xuXG4gICAgdmFyIGdldFBvcyA9IGZ1bmN0aW9uKCBpLCBub2RlICl7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYi54MSArIE1hdGgucm91bmQoIE1hdGgucmFuZG9tKCkgKiBiYi53ICksXG4gICAgICAgIHk6IGJiLnkxICsgTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIGJiLmggKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgbm9kZXMubGF5b3V0UG9zaXRpb25zKCB0aGlzLCBvcHRpb25zLCBnZXRQb3MgKTtcblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgLy8gcmVnaXN0ZXIgdGhlIGxheW91dFxuICAkJChcbiAgICAnbGF5b3V0JywgLy8gd2UncmUgcmVnaXN0ZXJpbmcgYSBsYXlvdXRcbiAgICAncmFuZG9tJywgLy8gdGhlIGxheW91dCBuYW1lXG4gICAgUmFuZG9tTGF5b3V0IC8vIHRoZSBsYXlvdXQgcHJvdG90eXBlXG4gICk7XG4gIFxufSkoY3l0b3NjYXBlKTtcblxuOyggZnVuY3Rpb24oICQkICl7ICd1c2Ugc3RyaWN0JztcblxuICAvKlxuICAgKiBUaGlzIGxheW91dCBjb21iaW5lcyBzZXZlcmFsIGFsZ29yaXRobXM6XG4gICAqXG4gICAqIC0gSXQgZ2VuZXJhdGVzIGFuIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIG5vZGVzIGJ5IHVzaW5nIHRoZVxuICAgKiAgIEZydWNodGVybWFuLVJlaW5nb2xkIGFsZ29yaXRobSAoZG9pOjEwLjEwMDIvc3BlLjQzODAyMTExMDIpXG4gICAqXG4gICAqIC0gRmluYWxseSBpdCBlbGltaW5hdGVzIG92ZXJsYXBzIGJ5IHVzaW5nIHRoZSBtZXRob2QgZGVzY3JpYmVkIGJ5XG4gICAqICAgR2Fuc25lciBhbmQgTm9ydGggKGRvaToxMC4xMDA3LzMtNTQwLTM3NjIzLTJfMjgpXG4gICAqL1xuXG4gIHZhciBkZWZhdWx0cyA9IHtcbiAgICBhbmltYXRlOiB0cnVlLCAvLyB3aGV0aGVyIHRvIHNob3cgdGhlIGxheW91dCBhcyBpdCdzIHJ1bm5pbmdcbiAgICByZWFkeTogdW5kZWZpbmVkLCAvLyBDYWxsYmFjayBvbiBsYXlvdXRyZWFkeVxuICAgIHN0b3A6IHVuZGVmaW5lZCwgLy8gQ2FsbGJhY2sgb24gbGF5b3V0c3RvcFxuICAgIGZpdDogdHJ1ZSwgLy8gUmVzZXQgdmlld3BvcnQgdG8gZml0IGRlZmF1bHQgc2ltdWxhdGlvbkJvdW5kc1xuICAgIG1pbkRpc3Q6IDIwLCAvLyBNaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gbm9kZXNcbiAgICBwYWRkaW5nOiAyMCwgLy8gUGFkZGluZ1xuICAgIGV4cGFuZGluZ0ZhY3RvcjogLTEuMCwgLy8gSWYgdGhlIG5ldHdvcmsgZG9lcyBub3Qgc2F0aXNmeSB0aGUgbWluRGlzdFxuICAgIC8vIGNyaXRlcml1bSB0aGVuIGl0IGV4cGFuZHMgdGhlIG5ldHdvcmsgb2YgdGhpcyBhbW91bnRcbiAgICAvLyBJZiBpdCBpcyBzZXQgdG8gLTEuMCB0aGUgYW1vdW50IG9mIGV4cGFuc2lvbiBpcyBhdXRvbWF0aWNhbGx5XG4gICAgLy8gY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgbWluRGlzdCwgdGhlIGFzcGVjdCByYXRpbyBhbmQgdGhlXG4gICAgLy8gbnVtYmVyIG9mIG5vZGVzXG4gICAgbWF4RnJ1Y2h0ZXJtYW5SZWluZ29sZEl0ZXJhdGlvbnM6IDUwLCAvLyBNYXhpbXVtIG51bWJlciBvZiBpbml0aWFsIGZvcmNlLWRpcmVjdGVkIGl0ZXJhdGlvbnNcbiAgICBtYXhFeHBhbmRJdGVyYXRpb25zOiA0LCAvLyBNYXhpbXVtIG51bWJlciBvZiBleHBhbmRpbmcgaXRlcmF0aW9uc1xuICAgIGJvdW5kaW5nQm94OiB1bmRlZmluZWQgLy8gQ29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU3ByZWFkTGF5b3V0KCBvcHRpb25zICkge1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKCB7fSwgZGVmYXVsdHMsIG9wdGlvbnMgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNlbGxDZW50cm9pZCggY2VsbCApIHtcbiAgICB2YXIgaGVzID0gY2VsbC5oYWxmZWRnZXM7XG4gICAgdmFyIGFyZWEgPSAwLFxuICAgICAgeCA9IDAsXG4gICAgICB5ID0gMDtcbiAgICB2YXIgcDEsIHAyLCBmO1xuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBoZXMubGVuZ3RoOyArK2kgKSB7XG4gICAgICBwMSA9IGhlc1sgaSBdLmdldEVuZHBvaW50KCk7XG4gICAgICBwMiA9IGhlc1sgaSBdLmdldFN0YXJ0cG9pbnQoKTtcblxuICAgICAgYXJlYSArPSBwMS54ICogcDIueTtcbiAgICAgIGFyZWEgLT0gcDEueSAqIHAyLng7XG5cbiAgICAgIGYgPSBwMS54ICogcDIueSAtIHAyLnggKiBwMS55O1xuICAgICAgeCArPSAoIHAxLnggKyBwMi54ICkgKiBmO1xuICAgICAgeSArPSAoIHAxLnkgKyBwMi55ICkgKiBmO1xuICAgIH1cblxuICAgIGFyZWEgLz0gMjtcbiAgICBmID0gYXJlYSAqIDY7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggLyBmLFxuICAgICAgeTogeSAvIGZcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc2l0ZXNEaXN0YW5jZSggbHMsIHJzICkge1xuICAgIHZhciBkeCA9IGxzLnggLSBycy54O1xuICAgIHZhciBkeSA9IGxzLnkgLSBycy55O1xuICAgIHJldHVybiBNYXRoLnNxcnQoIGR4ICogZHggKyBkeSAqIGR5ICk7XG4gIH1cblxuICBTcHJlYWRMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGxheW91dCA9IHRoaXM7XG4gICAgLy8gdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgJCQudXRpbC5yZXF1aXJlcyhbJ2Zvb2dyYXBoJywgJ1Zvcm9ub2knXSwgZnVuY3Rpb24oZm9vZ3JhcGgsIFZvcm9ub2kpe1xuXG4gICAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgICAgLy8gdmFyIGFsbE5vZGVzID0gY3kubm9kZXMoKTtcbiAgICAgIHZhciBub2RlcyA9IGN5Lm5vZGVzKCk7XG4gICAgICAvL3ZhciBhbGxFZGdlcyA9IGN5LmVkZ2VzKCk7XG4gICAgICB2YXIgZWRnZXMgPSBjeS5lZGdlcygpO1xuICAgICAgdmFyIGNXaWR0aCA9IGN5LndpZHRoKCk7XG4gICAgICB2YXIgY0hlaWdodCA9IGN5LmhlaWdodCgpO1xuICAgICAgdmFyIHNpbXVsYXRpb25Cb3VuZHMgPSBvcHRpb25zLmJvdW5kaW5nQm94ID8gJCQudXRpbC5tYWtlQm91bmRpbmdCb3goIG9wdGlvbnMuYm91bmRpbmdCb3ggKSA6IG51bGw7XG4gICAgICB2YXIgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZztcbiAgICAgIHZhciBzaW1CQkZhY3RvciA9IE1hdGgubWF4KCAxLCBNYXRoLmxvZyhub2Rlcy5sZW5ndGgpICogMC44ICk7XG4gICAgICBcbiAgICAgIGlmKCBub2Rlcy5sZW5ndGggPCAxMDAgKXtcbiAgICAgICAgc2ltQkJGYWN0b3IgLz0gMjtcbiAgICAgIH1cblxuICAgICAgbGF5b3V0LnRyaWdnZXIoIHtcbiAgICAgICAgdHlwZTogJ2xheW91dHN0YXJ0JyxcbiAgICAgICAgbGF5b3V0OiBsYXlvdXRcbiAgICAgIH0gKTtcblxuICAgICAgdmFyIHNpbUJCID0ge1xuICAgICAgICB4MTogMCxcbiAgICAgICAgeTE6IDAsXG4gICAgICAgIHgyOiBjV2lkdGggKiBzaW1CQkZhY3RvcixcbiAgICAgICAgeTI6IGNIZWlnaHQgKiBzaW1CQkZhY3RvclxuICAgICAgfTtcblxuICAgICAgaWYoIHNpbXVsYXRpb25Cb3VuZHMgKSB7XG4gICAgICAgIHNpbUJCLngxID0gc2ltdWxhdGlvbkJvdW5kcy54MTtcbiAgICAgICAgc2ltQkIueTEgPSBzaW11bGF0aW9uQm91bmRzLnkxO1xuICAgICAgICBzaW1CQi54MiA9IHNpbXVsYXRpb25Cb3VuZHMueDI7XG4gICAgICAgIHNpbUJCLnkyID0gc2ltdWxhdGlvbkJvdW5kcy55MjtcbiAgICAgIH1cblxuICAgICAgc2ltQkIueDEgKz0gcGFkZGluZztcbiAgICAgIHNpbUJCLnkxICs9IHBhZGRpbmc7XG4gICAgICBzaW1CQi54MiAtPSBwYWRkaW5nO1xuICAgICAgc2ltQkIueTIgLT0gcGFkZGluZztcblxuICAgICAgdmFyIHdpZHRoID0gc2ltQkIueDIgLSBzaW1CQi54MTtcbiAgICAgIHZhciBoZWlnaHQgPSBzaW1CQi55MiAtIHNpbUJCLnkxO1xuXG4gICAgICAvLyBHZXQgc3RhcnQgdGltZVxuICAgICAgdmFyIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAgIC8vIGxheW91dCBkb2Vzbid0IHdvcmsgd2l0aCBqdXN0IDEgbm9kZVxuICAgICAgaWYoIG5vZGVzLnNpemUoKSA8PSAxICkge1xuICAgICAgICBub2Rlcy5wb3NpdGlvbnMoIHtcbiAgICAgICAgICB4OiBNYXRoLnJvdW5kKCAoIHNpbUJCLngxICsgc2ltQkIueDIgKSAvIDIgKSxcbiAgICAgICAgICB5OiBNYXRoLnJvdW5kKCAoIHNpbUJCLnkxICsgc2ltQkIueTIgKSAvIDIgKVxuICAgICAgICB9ICk7XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICkge1xuICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgZW5kIHRpbWVcbiAgICAgICAgdmFyIGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zb2xlLmluZm8oIFwiTGF5b3V0IG9uIFwiICsgbm9kZXMuc2l6ZSgpICsgXCIgbm9kZXMgdG9vayBcIiArICggZW5kVGltZSAtIHN0YXJ0VGltZSApICsgXCIgbXNcIiApO1xuXG4gICAgICAgIGxheW91dC5vbmUoIFwibGF5b3V0cmVhZHlcIiwgb3B0aW9ucy5yZWFkeSApO1xuICAgICAgICBsYXlvdXQudHJpZ2dlciggXCJsYXlvdXRyZWFkeVwiICk7XG5cbiAgICAgICAgbGF5b3V0Lm9uZSggXCJsYXlvdXRzdG9wXCIsIG9wdGlvbnMuc3RvcCApO1xuICAgICAgICBsYXlvdXQudHJpZ2dlciggXCJsYXlvdXRzdG9wXCIgKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0IEkgbmVlZCB0byBjcmVhdGUgdGhlIGRhdGEgc3RydWN0dXJlIHRvIHBhc3MgdG8gdGhlIHdvcmtlclxuICAgICAgdmFyIHBEYXRhID0ge1xuICAgICAgICAnd2lkdGgnOiB3aWR0aCxcbiAgICAgICAgJ2hlaWdodCc6IGhlaWdodCxcbiAgICAgICAgJ21pbkRpc3QnOiBvcHRpb25zLm1pbkRpc3QsXG4gICAgICAgICdleHBGYWN0Jzogb3B0aW9ucy5leHBhbmRpbmdGYWN0b3IsXG4gICAgICAgICdleHBJdCc6IDAsXG4gICAgICAgICdtYXhFeHBJdCc6IG9wdGlvbnMubWF4RXhwYW5kSXRlcmF0aW9ucyxcbiAgICAgICAgJ3ZlcnRpY2VzJzogW10sXG4gICAgICAgICdlZGdlcyc6IFtdLFxuICAgICAgICAnc3RhcnRUaW1lJzogc3RhcnRUaW1lLFxuICAgICAgICAnbWF4RnJ1Y2h0ZXJtYW5SZWluZ29sZEl0ZXJhdGlvbnMnOiBvcHRpb25zLm1heEZydWNodGVybWFuUmVpbmdvbGRJdGVyYXRpb25zXG4gICAgICB9O1xuXG4gICAgICBub2Rlcy5lYWNoKFxuICAgICAgICBmdW5jdGlvbiggaSwgbm9kZSApIHtcbiAgICAgICAgICB2YXIgbm9kZUlkID0gdGhpcy5fcHJpdmF0ZS5kYXRhLmlkO1xuICAgICAgICAgIHBEYXRhWyAndmVydGljZXMnIF0ucHVzaCgge1xuICAgICAgICAgICAgaWQ6IG5vZGVJZCxcbiAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICB5OiAwXG4gICAgICAgICAgfSApO1xuICAgICAgICB9ICk7XG5cbiAgICAgIGVkZ2VzLmVhY2goXG4gICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBzcmNOb2RlSWQgPSB0aGlzLnNvdXJjZSgpLmlkKCk7XG4gICAgICAgICAgdmFyIHRndE5vZGVJZCA9IHRoaXMudGFyZ2V0KCkuaWQoKTtcbiAgICAgICAgICBwRGF0YVsgJ2VkZ2VzJyBdLnB1c2goIHtcbiAgICAgICAgICAgIHNyYzogc3JjTm9kZUlkLFxuICAgICAgICAgICAgdGd0OiB0Z3ROb2RlSWRcbiAgICAgICAgICB9ICk7XG4gICAgICAgIH0gKTtcblxuICAgICAgLy9EZWNsZXJhdGlvblxuICAgICAgdmFyIHQxID0gJCQuVGhyZWFkKCk7XG4gICAgICAvLyBBbmQgdG8gYWRkIHRoZSByZXF1aXJlZCBzY3JpcHRzXG4gICAgICAvL0VYVEVSTkFMIDFcbiAgICAgIHQxLnJlcXVpcmUoIGZvb2dyYXBoLCAnZm9vZ3JhcGgnICk7XG4gICAgICAvL0VYVEVSTkFMIDJcbiAgICAgIHQxLnJlcXVpcmUoIFZvcm9ub2kgKTtcblxuICAgICAgLy9Mb2NhbCBmdW5jdGlvblxuICAgICAgdDEucmVxdWlyZSggc2l0ZXNEaXN0YW5jZSApO1xuICAgICAgdDEucmVxdWlyZSggY2VsbENlbnRyb2lkICk7XG5cbiAgICAgIGZ1bmN0aW9uIHNldFBvc2l0aW9ucyggcERhdGEgKXsgLy9jb25zb2xlLmxvZygnc2V0IHBvc25zJylcbiAgICAgICAgLy8gRmlyc3Qgd2UgcmV0cmlldmUgdGhlIGltcG9ydGFudCBkYXRhXG4gICAgICAgIC8vIHZhciBleHBhbmRJdGVyYXRpb24gPSBwRGF0YVsgJ2V4cEl0JyBdO1xuICAgICAgICB2YXIgZGF0YVZlcnRpY2VzID0gcERhdGFbICd2ZXJ0aWNlcycgXTtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gW107XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgZGF0YVZlcnRpY2VzLmxlbmd0aDsgKytpICkge1xuICAgICAgICAgIHZhciBkdiA9IGRhdGFWZXJ0aWNlc1sgaSBdO1xuICAgICAgICAgIHZlcnRpY2VzWyBkdi5pZCBdID0ge1xuICAgICAgICAgICAgeDogZHYueCxcbiAgICAgICAgICAgIHk6IGR2LnlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8qXG4gICAgICAgICAqIEZJTkFMTFk6XG4gICAgICAgICAqXG4gICAgICAgICAqIFdlIHBvc2l0aW9uIHRoZSBub2RlcyBiYXNlZCBvbiB0aGUgY2FsY3VsYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIG5vZGVzLnBvc2l0aW9ucyhcbiAgICAgICAgICBmdW5jdGlvbiggaSwgbm9kZSApIHtcbiAgICAgICAgICAgIHZhciBpZCA9IG5vZGUuX3ByaXZhdGUuZGF0YS5pZDtcbiAgICAgICAgICAgIC8vIHZhciBwb3MgPSBub2RlLl9wcml2YXRlLnBvc2l0aW9uO1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHZlcnRpY2VzWyBpZCBdO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICB4OiBNYXRoLnJvdW5kKCBzaW1CQi54MSArIHZlcnRleC54ICksXG4gICAgICAgICAgICAgIHk6IE1hdGgucm91bmQoIHNpbUJCLnkxICsgdmVydGV4LnkgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9ICk7XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICkge1xuICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgIH1cblxuICAgICAgICBjeS5ub2RlcygpLnJ0cmlnZ2VyKCBcInBvc2l0aW9uXCIgKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpZExheW91dFJlYWR5ID0gZmFsc2U7XG4gICAgICB0MS5vbignbWVzc2FnZScsIGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgcERhdGEgPSBlLm1lc3NhZ2U7IC8vY29uc29sZS5sb2coJ21lc3NhZ2UnLCBlKVxuXG4gICAgICAgIGlmKCAhb3B0aW9ucy5hbmltYXRlICl7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0UG9zaXRpb25zKCBwRGF0YSApO1xuXG4gICAgICAgIGlmKCAhZGlkTGF5b3V0UmVhZHkgKXtcbiAgICAgICAgICBsYXlvdXQudHJpZ2dlciggXCJsYXlvdXRyZWFkeVwiICk7XG5cbiAgICAgICAgICBkaWRMYXlvdXRSZWFkeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBsYXlvdXQub25lKCBcImxheW91dHJlYWR5XCIsIG9wdGlvbnMucmVhZHkgKTtcblxuICAgICAgdDEucGFzcyggcERhdGEgKS5ydW4oIGZ1bmN0aW9uKCBwRGF0YSApIHtcbiAgICAgICAgXG4gICAgICAgIGZvb2dyYXBoID0gZXZhbCgnZm9vZ3JhcGgnKTtcbiAgICAgICAgVm9yb25vaSA9IGV2YWwoJ1Zvcm9ub2knKTtcbiAgICAgICAgXG4gICAgICAgIC8vIEkgbmVlZCB0byByZXRyaWV2ZSB0aGUgaW1wb3J0YW50IGRhdGFcbiAgICAgICAgdmFyIGxXaWR0aCA9IHBEYXRhWyAnd2lkdGgnIF07XG4gICAgICAgIHZhciBsSGVpZ2h0ID0gcERhdGFbICdoZWlnaHQnIF07XG4gICAgICAgIHZhciBsTWluRGlzdCA9IHBEYXRhWyAnbWluRGlzdCcgXTtcbiAgICAgICAgdmFyIGxFeHBGYWN0ID0gcERhdGFbICdleHBGYWN0JyBdO1xuICAgICAgICB2YXIgbE1heEV4cEl0ID0gcERhdGFbICdtYXhFeHBJdCcgXTtcbiAgICAgICAgdmFyIGxNYXhGcnVjaHRlcm1hblJlaW5nb2xkSXRlcmF0aW9ucyA9IHBEYXRhWyAnbWF4RnJ1Y2h0ZXJtYW5SZWluZ29sZEl0ZXJhdGlvbnMnIF07XG5cbiAgICAgICAgLy8gUHJlcGFyZSB0aGUgZGF0YSB0byBvdXRwdXRcbiAgICAgICAgdmFyIHNhdmVQb3NpdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgICAgICAgIHBEYXRhWyAnd2lkdGgnIF0gPSBsV2lkdGg7XG4gICAgICAgICAgcERhdGFbICdoZWlnaHQnIF0gPSBsSGVpZ2h0O1xuICAgICAgICAgIHBEYXRhWyAnZXhwSXQnIF0gPSBleHBhbmRJdGVyYXRpb247XG4gICAgICAgICAgcERhdGFbICdleHBGYWN0JyBdID0gbEV4cEZhY3Q7XG5cbiAgICAgICAgICBwRGF0YVsgJ3ZlcnRpY2VzJyBdID0gW107XG4gICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBmdi5sZW5ndGg7ICsraSApIHtcbiAgICAgICAgICAgIHBEYXRhWyAndmVydGljZXMnIF0ucHVzaCgge1xuICAgICAgICAgICAgICBpZDogZnZbIGkgXS5sYWJlbCxcbiAgICAgICAgICAgICAgeDogZnZbIGkgXS54LFxuICAgICAgICAgICAgICB5OiBmdlsgaSBdLnlcbiAgICAgICAgICAgIH0gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQb3NpdGlvbnMgPSBmdW5jdGlvbigpe1xuICAgICAgICAgIGJyb2FkY2FzdCggcERhdGEgKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBGSVJTVCBTVEVQOiBBcHBsaWNhdGlvbiBvZiB0aGUgRnJ1Y2h0ZXJtYW4tUmVpbmdvbGQgYWxnb3JpdGhtXG4gICAgICAgICAqXG4gICAgICAgICAqIFdlIHVzZSB0aGUgdmVyc2lvbiBpbXBsZW1lbnRlZCBieSB0aGUgZm9vZ3JhcGggbGlicmFyeVxuICAgICAgICAgKlxuICAgICAgICAgKiBSZWYuOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Zvb2dyYXBoL1xuICAgICAgICAgKi9cblxuICAgICAgICAvLyBXZSBuZWVkIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZSBvZiBhIGdyYXBoIGNvbXBhdGlibGUgd2l0aCB0aGUgbGlicmFyeVxuICAgICAgICB2YXIgZnJnID0gbmV3IGZvb2dyYXBoLkdyYXBoKCBcIkZSZ3JhcGhcIiwgZmFsc2UgKTtcblxuICAgICAgICB2YXIgZnJnTm9kZXMgPSB7fTtcblxuICAgICAgICAvLyBUaGVuIHdlIGhhdmUgdG8gYWRkIHRoZSB2ZXJ0aWNlc1xuICAgICAgICB2YXIgZGF0YVZlcnRpY2VzID0gcERhdGFbICd2ZXJ0aWNlcycgXTtcbiAgICAgICAgZm9yKCB2YXIgbmkgPSAwOyBuaSA8IGRhdGFWZXJ0aWNlcy5sZW5ndGg7ICsrbmkgKSB7XG4gICAgICAgICAgdmFyIGlkID0gZGF0YVZlcnRpY2VzWyBuaSBdWyAnaWQnIF07XG4gICAgICAgICAgdmFyIHYgPSBuZXcgZm9vZ3JhcGguVmVydGV4KCBpZCwgTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIGxIZWlnaHQgKSwgTWF0aC5yb3VuZCggTWF0aC5yYW5kb20oKSAqIGxIZWlnaHQgKSApO1xuICAgICAgICAgIGZyZ05vZGVzWyBpZCBdID0gdjtcbiAgICAgICAgICBmcmcuaW5zZXJ0VmVydGV4KCB2ICk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YUVkZ2VzID0gcERhdGFbICdlZGdlcycgXTtcbiAgICAgICAgZm9yKCB2YXIgZWkgPSAwOyBlaSA8IGRhdGFFZGdlcy5sZW5ndGg7ICsrZWkgKSB7XG4gICAgICAgICAgdmFyIHNyY05vZGVJZCA9IGRhdGFFZGdlc1sgZWkgXVsgJ3NyYycgXTtcbiAgICAgICAgICB2YXIgdGd0Tm9kZUlkID0gZGF0YUVkZ2VzWyBlaSBdWyAndGd0JyBdO1xuICAgICAgICAgIGZyZy5pbnNlcnRFZGdlKCBcIlwiLCAxLCBmcmdOb2Rlc1sgc3JjTm9kZUlkIF0sIGZyZ05vZGVzWyB0Z3ROb2RlSWQgXSApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZ2ID0gZnJnLnZlcnRpY2VzO1xuXG4gICAgICAgIC8vIFRoZW4gd2UgYXBwbHkgdGhlIGxheW91dFxuICAgICAgICB2YXIgaXRlcmF0aW9ucyA9IGxNYXhGcnVjaHRlcm1hblJlaW5nb2xkSXRlcmF0aW9ucztcbiAgICAgICAgdmFyIGZyTGF5b3V0TWFuYWdlciA9IG5ldyBmb29ncmFwaC5Gb3JjZURpcmVjdGVkVmVydGV4TGF5b3V0KCBsV2lkdGgsIGxIZWlnaHQsIGl0ZXJhdGlvbnMsIGZhbHNlLCBsTWluRGlzdCApO1xuXG4gICAgICAgIGZyTGF5b3V0TWFuYWdlci5jYWxsYmFjayA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgc2F2ZVBvc2l0aW9ucygpO1xuICAgICAgICAgIG1lc3NhZ2VQb3NpdGlvbnMoKTtcbiAgICAgICAgfTtcblxuICAgICAgICBmckxheW91dE1hbmFnZXIubGF5b3V0KCBmcmcgKTtcblxuICAgICAgICBzYXZlUG9zaXRpb25zKCk7XG4gICAgICAgIG1lc3NhZ2VQb3NpdGlvbnMoKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBTRUNPTkQgU1RFUDogVGlkaW5nIHVwIG9mIHRoZSBncmFwaC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2UgdXNlIHRoZSBtZXRob2QgZGVzY3JpYmVkIGJ5IEdhbnNuZXIgYW5kIE5vcnRoLCBiYXNlZCBvbiBWb3Jvbm9pXG4gICAgICAgICAqIGRpYWdyYW1zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBSZWY6IGRvaToxMC4xMDA3LzMtNTQwLTM3NjIzLTJfMjhcbiAgICAgICAgICovXG5cbiAgICAgICAgLy8gV2UgY2FsY3VsYXRlIHRoZSBWb3Jvbm9pIGRpYWdyYW0gZG9yIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZXNcbiAgICAgICAgdmFyIHZvcm9ub2kgPSBuZXcgVm9yb25vaSgpO1xuICAgICAgICB2YXIgYmJveCA9IHtcbiAgICAgICAgICB4bDogMCxcbiAgICAgICAgICB4cjogbFdpZHRoLFxuICAgICAgICAgIHl0OiAwLFxuICAgICAgICAgIHliOiBsSGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIHZhciB2U2l0ZXMgPSBbXTtcbiAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBmdi5sZW5ndGg7ICsraSApIHtcbiAgICAgICAgICB2U2l0ZXNbIGZ2WyBpIF0ubGFiZWwgXSA9IGZ2WyBpIF07XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjaGVja01pbkRpc3QoIGVlICkge1xuICAgICAgICAgIHZhciBpbmZyYWN0aW9ucyA9IDA7XG4gICAgICAgICAgLy8gVGhlbiB3ZSBjaGVjayBpZiB0aGUgbWluaW11bSBkaXN0YW5jZSBpcyBzYXRpc2ZpZWRcbiAgICAgICAgICBmb3IoIHZhciBlZWkgPSAwOyBlZWkgPCBlZS5sZW5ndGg7ICsrZWVpICkge1xuICAgICAgICAgICAgdmFyIGUgPSBlZVsgZWVpIF07XG4gICAgICAgICAgICBpZiggKCBlLmxTaXRlICE9IG51bGwgKSAmJiAoIGUuclNpdGUgIT0gbnVsbCApICYmIHNpdGVzRGlzdGFuY2UoIGUubFNpdGUsIGUuclNpdGUgKSA8IGxNaW5EaXN0ICkge1xuICAgICAgICAgICAgICArK2luZnJhY3Rpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaW5mcmFjdGlvbnM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlhZ3JhbSA9IHZvcm9ub2kuY29tcHV0ZSggZnYsIGJib3ggKTtcblxuICAgICAgICAvLyBUaGVuIHdlIHJlcG9zaXRpb24gdGhlIG5vZGVzIGF0IHRoZSBjZW50cm9pZCBvZiB0aGVpciBWb3Jvbm9pIGNlbGxzXG4gICAgICAgIHZhciBjZWxscyA9IGRpYWdyYW0uY2VsbHM7XG4gICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyArK2kgKSB7XG4gICAgICAgICAgdmFyIGNlbGwgPSBjZWxsc1sgaSBdO1xuICAgICAgICAgIHZhciBzaXRlID0gY2VsbC5zaXRlO1xuICAgICAgICAgIHZhciBjZW50cm9pZCA9IGNlbGxDZW50cm9pZCggY2VsbCApO1xuICAgICAgICAgIHZhciBjdXJydiA9IHZTaXRlc1sgc2l0ZS5sYWJlbCBdO1xuICAgICAgICAgIGN1cnJ2LnggPSBjZW50cm9pZC54O1xuICAgICAgICAgIGN1cnJ2LnkgPSBjZW50cm9pZC55O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIGxFeHBGYWN0IDwgMC4wICkge1xuICAgICAgICAgIC8vIENhbGN1bGF0ZXMgdGhlIGV4cGFuZGluZyBmYWN0b3JcbiAgICAgICAgICBsRXhwRmFjdCA9IE1hdGgubWF4KCAwLjA1LCBNYXRoLm1pbiggMC4xMCwgbE1pbkRpc3QgLyBNYXRoLnNxcnQoICggbFdpZHRoICogbEhlaWdodCApIC8gZnYubGVuZ3RoICkgKiAwLjUgKSApO1xuICAgICAgICAgIC8vY29uc29sZS5pbmZvKFwiRXhwYW5kaW5nIGZhY3RvciBpcyBcIiArIChvcHRpb25zLmV4cGFuZGluZ0ZhY3RvciAqIDEwMC4wKSArIFwiJVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2SW5mcmFjdGlvbnMgPSBjaGVja01pbkRpc3QoIGRpYWdyYW0uZWRnZXMgKTtcbiAgICAgICAgLy9jb25zb2xlLmluZm8oXCJJbml0aWFsIGluZnJhY3Rpb25zIFwiICsgcHJldkluZnJhY3Rpb25zKTtcblxuICAgICAgICB2YXIgYlN0b3AgPSAoIHByZXZJbmZyYWN0aW9ucyA8PSAwICk7XG5cbiAgICAgICAgdmFyIHZvcm9ub2lJdGVyYXRpb24gPSAwO1xuICAgICAgICB2YXIgZXhwYW5kSXRlcmF0aW9uID0gMDtcblxuICAgICAgICAvLyB2YXIgaW5pdFdpZHRoID0gbFdpZHRoO1xuXG4gICAgICAgIHdoaWxlKCAhYlN0b3AgKSB7XG4gICAgICAgICAgKyt2b3Jvbm9pSXRlcmF0aW9uO1xuICAgICAgICAgIGZvciggdmFyIGl0ID0gMDsgaXQgPD0gNDsgKytpdCApIHtcbiAgICAgICAgICAgIHZvcm9ub2kucmVjeWNsZSggZGlhZ3JhbSApO1xuICAgICAgICAgICAgZGlhZ3JhbSA9IHZvcm9ub2kuY29tcHV0ZSggZnYsIGJib3ggKTtcblxuICAgICAgICAgICAgLy8gVGhlbiB3ZSByZXBvc2l0aW9uIHRoZSBub2RlcyBhdCB0aGUgY2VudHJvaWQgb2YgdGhlaXIgVm9yb25vaSBjZWxsc1xuICAgICAgICAgICAgY2VsbHMgPSBkaWFncmFtLmNlbGxzO1xuICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7ICsraSApIHtcbiAgICAgICAgICAgICAgdmFyIGNlbGwgPSBjZWxsc1sgaSBdO1xuICAgICAgICAgICAgICB2YXIgc2l0ZSA9IGNlbGwuc2l0ZTtcbiAgICAgICAgICAgICAgdmFyIGNlbnRyb2lkID0gY2VsbENlbnRyb2lkKCBjZWxsICk7XG4gICAgICAgICAgICAgIHZhciBjdXJydiA9IHZTaXRlc1sgc2l0ZS5sYWJlbCBdO1xuICAgICAgICAgICAgICBjdXJydi54ID0gY2VudHJvaWQueDtcbiAgICAgICAgICAgICAgY3VycnYueSA9IGNlbnRyb2lkLnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGN1cnJJbmZyYWN0aW9ucyA9IGNoZWNrTWluRGlzdCggZGlhZ3JhbS5lZGdlcyApO1xuICAgICAgICAgIC8vY29uc29sZS5pbmZvKFwiQ3VycmVudCBpbmZyYWN0aW9ucyBcIiArIGN1cnJJbmZyYWN0aW9ucyk7XG5cbiAgICAgICAgICBpZiggY3VyckluZnJhY3Rpb25zIDw9IDAgKSB7XG4gICAgICAgICAgICBiU3RvcCA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCBjdXJySW5mcmFjdGlvbnMgPj0gcHJldkluZnJhY3Rpb25zIHx8IHZvcm9ub2lJdGVyYXRpb24gPj0gNCApIHtcbiAgICAgICAgICAgICAgaWYoIGV4cGFuZEl0ZXJhdGlvbiA+PSBsTWF4RXhwSXQgKSB7XG4gICAgICAgICAgICAgICAgYlN0b3AgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxXaWR0aCArPSBsV2lkdGggKiBsRXhwRmFjdDtcbiAgICAgICAgICAgICAgICBsSGVpZ2h0ICs9IGxIZWlnaHQgKiBsRXhwRmFjdDtcbiAgICAgICAgICAgICAgICBiYm94ID0ge1xuICAgICAgICAgICAgICAgICAgeGw6IDAsXG4gICAgICAgICAgICAgICAgICB4cjogbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgeXQ6IDAsXG4gICAgICAgICAgICAgICAgICB5YjogbEhlaWdodFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgKytleHBhbmRJdGVyYXRpb247XG4gICAgICAgICAgICAgICAgdm9yb25vaUl0ZXJhdGlvbiA9IDA7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmluZm8oXCJFeHBhbmRlZCB0byAoXCIrd2lkdGgrXCIsXCIraGVpZ2h0K1wiKVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2SW5mcmFjdGlvbnMgPSBjdXJySW5mcmFjdGlvbnM7XG5cbiAgICAgICAgICBzYXZlUG9zaXRpb25zKCk7XG4gICAgICAgICAgbWVzc2FnZVBvc2l0aW9ucygpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2F2ZVBvc2l0aW9ucygpO1xuICAgICAgICByZXR1cm4gcERhdGE7XG5cbiAgICAgIH0gKS50aGVuKCBmdW5jdGlvbiggcERhdGEgKSB7XG4gICAgICAgIC8vIHZhciBleHBhbmRJdGVyYXRpb24gPSBwRGF0YVsgJ2V4cEl0JyBdO1xuICAgICAgICB2YXIgZGF0YVZlcnRpY2VzID0gcERhdGFbICd2ZXJ0aWNlcycgXTtcblxuICAgICAgICBzZXRQb3NpdGlvbnMoIHBEYXRhICk7XG5cbiAgICAgICAgLy8gR2V0IGVuZCB0aW1lXG4gICAgICAgIHZhciBzdGFydFRpbWUgPSBwRGF0YVsgJ3N0YXJ0VGltZScgXTtcbiAgICAgICAgdmFyIGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zb2xlLmluZm8oIFwiTGF5b3V0IG9uIFwiICsgZGF0YVZlcnRpY2VzLmxlbmd0aCArIFwiIG5vZGVzIHRvb2sgXCIgKyAoIGVuZFRpbWUgLSBzdGFydFRpbWUgKSArIFwiIG1zXCIgKTtcblxuICAgICAgICBsYXlvdXQub25lKCBcImxheW91dHN0b3BcIiwgb3B0aW9ucy5zdG9wICk7XG5cbiAgICAgICAgaWYoICFvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgICBsYXlvdXQudHJpZ2dlciggXCJsYXlvdXRyZWFkeVwiICk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXlvdXQudHJpZ2dlciggXCJsYXlvdXRzdG9wXCIgKTtcblxuICAgICAgICB0MS5zdG9wKCk7XG4gICAgICB9ICk7XG5cbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBydW5cblxuICBTcHJlYWRMYXlvdXQucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHt9O1xuXG4gICQkKCAnbGF5b3V0JywgJ3NwcmVhZCcsIFNwcmVhZExheW91dCApO1xuXG5cbn0gKSggY3l0b3NjYXBlICk7XG5cbjsoZnVuY3Rpb24oJCQpeyAndXNlIHN0cmljdCc7XG4gIFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgYW5pbWF0ZTogdHJ1ZSwgLy8gd2hldGhlciB0byBzaG93IHRoZSBsYXlvdXQgYXMgaXQncyBydW5uaW5nXG4gICAgbWF4U2ltdWxhdGlvblRpbWU6IDQwMDAsIC8vIG1heCBsZW5ndGggaW4gbXMgdG8gcnVuIHRoZSBsYXlvdXRcbiAgICB1bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmc6IGZhbHNlLCAvLyBzbyB5b3UgY2FuJ3QgZHJhZyBub2RlcyBkdXJpbmcgbGF5b3V0XG4gICAgZml0OiB0cnVlLCAvLyB3aGV0aGVyIHRvIGZpdCB0aGUgdmlld3BvcnQgdG8gdGhlIGdyYXBoXG4gICAgcGFkZGluZzogMzAsIC8vIHBhZGRpbmcgb24gZml0XG4gICAgYm91bmRpbmdCb3g6IHVuZGVmaW5lZCwgLy8gY29uc3RyYWluIGxheW91dCBib3VuZHM7IHsgeDEsIHkxLCB4MiwgeTIgfSBvciB7IHgxLCB5MSwgdywgaCB9XG4gICAgcmFuZG9tOiBmYWxzZSwgLy8gd2hldGhlciB0byB1c2UgcmFuZG9tIGluaXRpYWwgcG9zaXRpb25zXG4gICAgaW5maW5pdGU6IGZhbHNlLCAvLyBvdmVycmlkZXMgYWxsIG90aGVyIG9wdGlvbnMgZm9yIGEgZm9yY2VzLWFsbC10aGUtdGltZSBtb2RlXG4gICAgcmVhZHk6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgb24gbGF5b3V0cmVhZHlcbiAgICBzdG9wOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIG9uIGxheW91dHN0b3BcblxuICAgIC8vIHNwcmluZ3kgZm9yY2VzXG4gICAgc3RpZmZuZXNzOiA0MDAsXG4gICAgcmVwdWxzaW9uOiA0MDAsXG4gICAgZGFtcGluZzogMC41XG4gIH07XG5cbiAgZnVuY3Rpb24gU3ByaW5neUxheW91dCggb3B0aW9ucyApe1xuICAgIHRoaXMub3B0aW9ucyA9ICQkLnV0aWwuZXh0ZW5kKHRydWUsIHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gIH1cbiAgXG4gIFNwcmluZ3lMYXlvdXQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGxheW91dCA9IHRoaXM7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuXG4gICAgJCQudXRpbC5yZXF1aXJlKCdTcHJpbmd5JywgZnVuY3Rpb24oU3ByaW5neSl7XG5cbiAgICAgIHZhciBzaW1VcGRhdGluZ1BvcyA9IGZhbHNlO1xuXG4gICAgICB2YXIgY3kgPSBvcHRpb25zLmN5O1xuICAgICAgbGF5b3V0LnRyaWdnZXIoeyB0eXBlOiAnbGF5b3V0c3RhcnQnLCBsYXlvdXQ6IGxheW91dCB9KTtcbiAgICAgIFxuICAgICAgdmFyIGVsZXMgPSBvcHRpb25zLmVsZXM7XG4gICAgICB2YXIgbm9kZXMgPSBlbGVzLm5vZGVzKCkubm90KCc6cGFyZW50Jyk7XG4gICAgICB2YXIgZWRnZXMgPSBlbGVzLmVkZ2VzKCk7XG4gICBcbiAgICAgIHZhciBiYiA9ICQkLnV0aWwubWFrZUJvdW5kaW5nQm94KCBvcHRpb25zLmJvdW5kaW5nQm94ID8gb3B0aW9ucy5ib3VuZGluZ0JveCA6IHtcbiAgICAgICAgeDE6IDAsIHkxOiAwLCB3OiBjeS53aWR0aCgpLCBoOiBjeS5oZWlnaHQoKVxuICAgICAgfSApO1xuICAgICAgXG4gICAgICAvLyBtYWtlIGEgbmV3IGdyYXBoXG4gICAgICB2YXIgZ3JhcGggPSBuZXcgU3ByaW5neS5HcmFwaCgpO1xuXG4gICAgICAvLyBtYWtlIHNvbWUgbm9kZXNcbiAgICAgIG5vZGVzLmVhY2goZnVuY3Rpb24oaSwgbm9kZSl7XG4gICAgICAgIG5vZGUuc2NyYXRjaCgnc3ByaW5neScsIHtcbiAgICAgICAgICBtb2RlbDogZ3JhcGgubmV3Tm9kZSh7XG4gICAgICAgICAgICBlbGVtZW50OiBub2RlXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gY29ubmVjdCB0aGVtIHdpdGggZWRnZXNcbiAgICAgIGVkZ2VzLmVhY2goZnVuY3Rpb24oaSwgZWRnZSl7XG4gICAgICAgIHZhciBmZFNyYyA9IGVkZ2Uuc291cmNlKCkuc2NyYXRjaCgnc3ByaW5neScpLm1vZGVsO1xuICAgICAgICB2YXIgZmRUZ3QgPSBlZGdlLnRhcmdldCgpLnNjcmF0Y2goJ3NwcmluZ3knKS5tb2RlbDtcbiAgICAgICAgXG4gICAgICAgIGVkZ2Uuc2NyYXRjaCgnc3ByaW5neScsIHtcbiAgICAgICAgICBtb2RlbDogZ3JhcGgubmV3RWRnZShmZFNyYywgZmRUZ3QsIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGVkZ2VcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICB2YXIgc2ltID0gd2luZG93LnNpbSA9IG5ldyBTcHJpbmd5LkxheW91dC5Gb3JjZURpcmVjdGVkKGdyYXBoLCBvcHRpb25zLnN0aWZmbmVzcywgb3B0aW9ucy5yZXB1bHNpb24sIG9wdGlvbnMuZGFtcGluZyk7XG5cbiAgICAgIGlmKCBvcHRpb25zLmluZmluaXRlICl7XG4gICAgICAgIHNpbS5taW5FbmVyZ3lUaHJlc2hvbGQgPSAtSW5maW5pdHk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50QkIgPSBzaW0uZ2V0Qm91bmRpbmdCb3goKTtcbiAgICAgIC8vIHZhciB0YXJnZXRCQiA9IHtib3R0b21sZWZ0OiBuZXcgU3ByaW5neS5WZWN0b3IoLTIsIC0yKSwgdG9wcmlnaHQ6IG5ldyBTcHJpbmd5LlZlY3RvcigyLCAyKX07XG4gICAgICBcbiAgICAgIC8vIGNvbnZlcnQgdG8vZnJvbSBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAgIHZhciB0b1NjcmVlbiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgY3VycmVudEJCID0gc2ltLmdldEJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgdmFyIHNpemUgPSBjdXJyZW50QkIudG9wcmlnaHQuc3VidHJhY3QoY3VycmVudEJCLmJvdHRvbWxlZnQpO1xuICAgICAgICB2YXIgc3ggPSBwLnN1YnRyYWN0KGN1cnJlbnRCQi5ib3R0b21sZWZ0KS5kaXZpZGUoc2l6ZS54KS54ICogYmIudyArIGJiLngxO1xuICAgICAgICB2YXIgc3kgPSBwLnN1YnRyYWN0KGN1cnJlbnRCQi5ib3R0b21sZWZ0KS5kaXZpZGUoc2l6ZS55KS55ICogYmIuaCArIGJiLngxO1xuXG4gICAgICAgIHJldHVybiBuZXcgU3ByaW5neS5WZWN0b3Ioc3gsIHN5KTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBmcm9tU2NyZWVuID0gZnVuY3Rpb24ocykge1xuICAgICAgICBjdXJyZW50QkIgPSBzaW0uZ2V0Qm91bmRpbmdCb3goKTtcblxuICAgICAgICB2YXIgc2l6ZSA9IGN1cnJlbnRCQi50b3ByaWdodC5zdWJ0cmFjdChjdXJyZW50QkIuYm90dG9tbGVmdCk7XG4gICAgICAgIHZhciBweCA9ICgocy54IC0gYmIueDEpIC8gYmIudykgKiBzaXplLnggKyBjdXJyZW50QkIuYm90dG9tbGVmdC54O1xuICAgICAgICB2YXIgcHkgPSAoKHMueSAtIGJiLnkxKSAvIGJiLmgpICogc2l6ZS55ICsgY3VycmVudEJCLmJvdHRvbWxlZnQueTtcblxuICAgICAgICByZXR1cm4gbmV3IFNwcmluZ3kuVmVjdG9yKHB4LCBweSk7XG4gICAgICB9O1xuICAgICAgXG4gICAgICB2YXIgbW92ZWROb2RlcyA9IGN5LmNvbGxlY3Rpb24oKTtcbiAgICAgIFxuICAgICAgdmFyIG51bU5vZGVzID0gY3kubm9kZXMoKS5zaXplKCk7XG4gICAgICB2YXIgZHJhd25Ob2RlcyA9IDE7XG4gICAgICB2YXIgZmRSZW5kZXJlciA9IG5ldyBTcHJpbmd5LlJlbmRlcmVyKHNpbSxcbiAgICAgICAgZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICAgICAgaWYoIHNlbGYuc3RvcHBlZCApeyByZXR1cm47IH0gLy8gYmVjYXVzZSBzcHJpbmd5IGlzIGEgYnVnZ3kgbGF5b3V0XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIG1vdmVkTm9kZXMubGVuZ3RoID4gMCAmJiBvcHRpb25zLmFuaW1hdGUgKXtcbiAgICAgICAgICAgIHNpbVVwZGF0aW5nUG9zID0gdHJ1ZTtcblxuICAgICAgICAgICAgbW92ZWROb2Rlcy5ydHJpZ2dlcigncG9zaXRpb24nKTtcblxuICAgICAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgICAgIGN5LmZpdCggb3B0aW9ucy5wYWRkaW5nICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdmVkTm9kZXMgPSBjeS5jb2xsZWN0aW9uKCk7XG5cbiAgICAgICAgICAgIHNpbVVwZGF0aW5nUG9zID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdFZGdlKGVkZ2UsIHAxLCBwMikge1xuICAgICAgICAgIC8vIGRyYXcgYW4gZWRnZVxuICAgICAgICB9LFxuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXdOb2RlKG5vZGUsIHApIHtcbiAgICAgICAgICBpZiggc2VsZi5zdG9wcGVkICl7IHJldHVybjsgfSAvLyBiZWNhdXNlIHNwcmluZ3kgaXMgYSBidWdneSBsYXlvdXRcblxuICAgICAgICAgIHZhciB2ID0gdG9TY3JlZW4ocCk7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSBub2RlLmRhdGEuZWxlbWVudDtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggIWVsZW1lbnQubG9ja2VkKCkgJiYgIWVsZW1lbnQuZ3JhYmJlZCgpICl7XG4gICAgICAgICAgICAgIGVsZW1lbnQuX3ByaXZhdGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgeDogdi54LFxuICAgICAgICAgICAgICAgIHk6IHYueVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBtb3ZlZE5vZGVzLm1lcmdlKGVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL3NldExheW91dFBvc2l0aW9uRm9yRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGRyYXduTm9kZXMgPT0gbnVtTm9kZXMgKXtcbiAgICAgICAgICAgIGxheW91dC5vbmUoJ2xheW91dHJlYWR5Jywgb3B0aW9ucy5yZWFkeSk7XG4gICAgICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRyZWFkeScsIGxheW91dDogbGF5b3V0IH0pO1xuICAgICAgICAgIH0gXG4gICAgICAgICAgXG4gICAgICAgICAgZHJhd25Ob2RlcysrO1xuICAgICAgICBcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIFxuICAgICAgLy8gc2V0IGluaXRpYWwgbm9kZSBwb2ludHNcbiAgICAgIG5vZGVzLmVhY2goZnVuY3Rpb24oaSwgZWxlKXtcbiAgICAgICAgaWYoICFvcHRpb25zLnJhbmRvbSApe1xuICAgICAgICAgIHNldExheW91dFBvc2l0aW9uRm9yRWxlbWVudChlbGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgLy8gdXBkYXRlIG5vZGUgcG9zaXRpb25zIHdoZW4gZHJhZ2dpbmdcbiAgICAgIHZhciBkcmFnSGFuZGxlcjtcbiAgICAgIG5vZGVzLm9uKCdwb3NpdGlvbicsIGRyYWdIYW5kbGVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIHNpbVVwZGF0aW5nUG9zICl7IHJldHVybjsgfVxuXG4gICAgICAgIHNldExheW91dFBvc2l0aW9uRm9yRWxlbWVudCh0aGlzKTtcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICBmdW5jdGlvbiBzZXRMYXlvdXRQb3NpdGlvbkZvckVsZW1lbnQoZWxlbWVudCl7XG4gICAgICAgIHZhciBmZElkID0gZWxlbWVudC5zY3JhdGNoKCdzcHJpbmd5JykubW9kZWwuaWQ7XG4gICAgICAgIHZhciBmZFAgPSBmZFJlbmRlcmVyLmxheW91dC5ub2RlUG9pbnRzW2ZkSWRdLnA7XG4gICAgICAgIHZhciBwb3MgPSBlbGVtZW50LnBvc2l0aW9uKCk7XG4gICAgICAgIHZhciBwb3NpdGlvbkluRmQgPSAocG9zLnggIT0gbnVsbCAmJiBwb3MueSAhPSBudWxsKSA/IGZyb21TY3JlZW4oZWxlbWVudC5wb3NpdGlvbigpKSA6IHtcbiAgICAgICAgICB4OiBNYXRoLnJhbmRvbSgpICogNCAtIDIsXG4gICAgICAgICAgeTogTWF0aC5yYW5kb20oKSAqIDQgLSAyXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBmZFAueCA9IHBvc2l0aW9uSW5GZC54O1xuICAgICAgICBmZFAueSA9IHBvc2l0aW9uSW5GZC55O1xuICAgICAgfVxuICAgICAgXG4gICAgICB2YXIgZ3JhYmJhYmxlTm9kZXMgPSBub2Rlcy5maWx0ZXIoXCI6Z3JhYmJhYmxlXCIpO1xuICAgICAgXG4gICAgICBmdW5jdGlvbiBzdGFydCgpe1xuICAgICAgICBzZWxmLnN0b3BwZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBkaXNhYmxlIGdyYWJiaW5nIGlmIHNvIHNldFxuICAgICAgICBpZiggb3B0aW9ucy51bmdyYWJpZnlXaGlsZVNpbXVsYXRpbmcgKXtcbiAgICAgICAgICBncmFiYmFibGVOb2Rlcy51bmdyYWJpZnkoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZmRSZW5kZXJlci5zdGFydCgpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBzZWxmLnN0b3BTeXN0ZW0gPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLnN0b3BwZWQgPSB0cnVlO1xuXG4gICAgICAgIGdyYXBoLmZpbHRlck5vZGVzKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyByZW1vdmUgYWxsIG5vZGVzXG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYoIG9wdGlvbnMudW5ncmFiaWZ5V2hpbGVTaW11bGF0aW5nICl7XG4gICAgICAgICAgZ3JhYmJhYmxlTm9kZXMuZ3JhYmlmeSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIG9wdGlvbnMuZml0ICl7XG4gICAgICAgICAgY3kuZml0KCBvcHRpb25zLnBhZGRpbmcgKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbm9kZXMub2ZmKCdkcmFnIHBvc2l0aW9uJywgZHJhZ0hhbmRsZXIpO1xuXG4gICAgICAgIGxheW91dC5vbmUoJ2xheW91dHN0b3AnLCBvcHRpb25zLnN0b3ApO1xuICAgICAgICBsYXlvdXQudHJpZ2dlcih7IHR5cGU6ICdsYXlvdXRzdG9wJywgbGF5b3V0OiBsYXlvdXQgfSk7XG5cbiAgICAgICAgc2VsZi5zdG9wU3lzdGVtID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBcbiAgICAgIHN0YXJ0KCk7XG4gICAgICBpZiggIW9wdGlvbnMuaW5maW5pdGUgKXtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgIHNlbGYuc3RvcCgpO1xuICAgICAgICB9LCBvcHRpb25zLm1heFNpbXVsYXRpb25UaW1lKTtcbiAgICAgIH1cblxuICAgIH0pOyAvLyByZXF1aXJlXG5cbiAgICByZXR1cm4gdGhpczsgLy8gY2hhaW5pbmdcbiAgfTtcblxuICBTcHJpbmd5TGF5b3V0LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgICBpZiggdGhpcy5zdG9wU3lzdGVtICE9IG51bGwgKXtcbiAgICAgIHRoaXMuc3RvcFN5c3RlbSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzOyAvLyBjaGFpbmluZ1xuICB9O1xuICBcbiAgJCQoJ2xheW91dCcsICdzcHJpbmd5JywgU3ByaW5neUxheW91dCk7XG5cbiAgXG59KShjeXRvc2NhcGUpO1xuXG47KGZ1bmN0aW9uKCQkKXsgJ3VzZSBzdHJpY3QnO1xuICAgIFxuICBmdW5jdGlvbiBOdWxsUmVuZGVyZXIob3B0aW9ucyl7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBcbiAgTnVsbFJlbmRlcmVyLnByb3RvdHlwZS5yZWNhbGN1bGF0ZVJlbmRlcmVkU3R5bGUgPSBmdW5jdGlvbigpe1xuICB9O1xuXG4gIE51bGxSZW5kZXJlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24oKXtcbiAgICAvLyB0aGUgbnVsbCByZW5kZXJlciBkb2VzIG5vdGhpbmdcbiAgfTtcbiAgXG4gICQkKCdyZW5kZXJlcicsICdudWxsJywgTnVsbFJlbmRlcmVyKTtcbiAgXG59KSggY3l0b3NjYXBlICk7XG4iLCIvKiEgaW1qcyAtIHYzLjEzLjAgLSAyMDE1LTA1LTA4ICovXG5cbi8vIFRoaXMgbGlicmFyeSBpcyBvcGVuIHNvdXJjZSBzb2Z0d2FyZSBhY2NvcmRpbmcgdG8gdGhlIGRlZmluaXRpb24gb2YgdGhlXG4vLyBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2VuY2UsIFZlcnNpb24gMywgKExHUEx2MykgYSBjb3B5IG9mIHdoaWNoIGlzXG4vLyBpbmNsdWRlZCB3aXRoIHRoaXMgc29mdHdhcmUuIEFsbCB1c2Ugb2YgdGhpcyBzb2Z0d2FyZSBpcyBjb3ZlcmVkIGFjY29yZGluZyB0b1xuLy8gdGhlIHRlcm1zIG9mIHRoZSBMR1BMdjMuXG4vLyBcbi8vIFRoZSBjb3B5cmlnaHQgaXMgaGVsZCBieSBJbnRlck1pbmUgKHd3dy5pbnRlcm1pbmUub3JnKSBhbmQgQWxleCBLYWxkZXJpbWlzIChhbGV4QGludGVybWluZS5vcmcpLlxuXG4oZnVuY3Rpb24gKGludGVybWluZSkge1xuIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuaW1qcz1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgZXhwb3J0cy5BQ0NFUFRfSEVBREVSID0ge1xuICAgICd4bWwnOiAnYXBwbGljYXRpb24veG1sJyxcbiAgICAnanNvbic6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAndHN2JzogJ3RleHQvdGFiLXNlcGFyYXRlZC12YWx1ZXMnLFxuICAgICd0YWInOiAndGV4dC90YWItc2VwYXJhdGVkLXZhbHVlcycsXG4gICAgJ2Nzdic6ICd0ZXh0L2NvbW1hLXNlcGFyYXRlZC12YWx1ZXMnLFxuICAgICdmYXN0YSc6ICd0ZXh0L3gtZmFzdGEnLFxuICAgICdnZmYzJzogJ3RleHQveC1nZmYzJyxcbiAgICAnYmVkJzogJ3RleHQveC1iZWQnLFxuICAgICdvYmplY3RzJzogJ2FwcGxpY2F0aW9uL2pzb247dHlwZT1vYmplY3RzJyxcbiAgICAnanNvbm9iamVjdHMnOiAnYXBwbGljYXRpb24vanNvbjt0eXBlPW9iamVjdHMnLFxuICAgICdqc29udGFibGUnOiAnYXBwbGljYXRpb24vanNvbjt0eXBlPXRhYmxlJyxcbiAgICAnanNvbnJvd3MnOiAnYXBwbGljYXRpb24vanNvbjt0eXBlPXJvd3MnLFxuICAgICdqc29uY291bnQnOiAnYXBwbGljYXRpb24vanNvbjt0eXBlPWNvdW50JyxcbiAgICAnanNvbnAnOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXG4gICAgJ2pzb25wb2JqZWN0cyc6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0O3R5cGU9b2JqZWN0cycsXG4gICAgJ2pzb25wdGFibGUnOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdDt0eXBlPXRhYmxlJyxcbiAgICAnanNvbnByb3dzJzogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQ7dHlwZT1yb3dzJyxcbiAgICAnanNvbnBjb3VudCc6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0O3R5cGU9Y291bnQnXG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se31dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgZXhwb3NlLCBpbWpzLCBtZXJnZTtcblxuICBfZGVyZXFfKCcuL3NoaXYnKTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGltanMgPSBfZGVyZXFfKCcuL3NlcnZpY2UnKTtcblxuICBtZXJnZSA9IGltanMudXRpbHMubWVyZ2U7XG5cbiAgZXhwb3NlID0gZnVuY3Rpb24obmFtZSwgdGhpbmcpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICByZXR1cm4gZGVmaW5lKG5hbWUsIFtdLCB0aGluZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnbG9iYWxbbmFtZV0gPSB0aGluZztcbiAgICB9XG4gIH07XG5cbiAgZXhwb3NlKCdpbWpzJywgaW1qcyk7XG5cbiAgaWYgKHR5cGVvZiBpbnRlcm1pbmUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3NlKCdpbnRlcm1pbmUnLCBpbWpzKTtcbiAgfSBlbHNlIHtcbiAgICBleHBvc2UoJ2ludGVybWluZScsIG1lcmdlKGludGVybWluZSwgaW1qcykpO1xuICB9XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL3NlcnZpY2VcIjoxMCxcIi4vc2hpdlwiOjEyfV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBBQ0NFUFRfSEVBREVSLCBKU09OU3RyZWFtLCBQRVNLWV9DT01NQSwgVVJMLCBVUkxFTkMsIFVTRVJfQUdFTlQsIFZFUlNJT04sIGJsb2NraW5nLCBkZWZlciwgZXJyb3IsIGdldE1zZywgaHR0cCwgaW52b2tlLCBtZXJnZSwgcGFyc2VPcHRpb25zLCByZWplY3RBZnRlciwgc3RyZWFtaW5nLCB1dGlscywgX3JlZjtcblxuICBVUkwgPSBfZGVyZXFfKCd1cmwnKTtcblxuICBKU09OU3RyZWFtID0gX2RlcmVxXygnSlNPTlN0cmVhbScpO1xuXG4gIGh0dHAgPSBfZGVyZXFfKCdodHRwJyk7XG5cbiAgQUNDRVBUX0hFQURFUiA9IF9kZXJlcV8oJy4vY29uc3RhbnRzJykuQUNDRVBUX0hFQURFUjtcblxuICBWRVJTSU9OID0gX2RlcmVxXygnLi92ZXJzaW9uJykuVkVSU0lPTjtcblxuICBfcmVmID0gdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWwnKSwgZXJyb3IgPSBfcmVmLmVycm9yLCBkZWZlciA9IF9yZWYuZGVmZXIsIG1lcmdlID0gX3JlZi5tZXJnZSwgaW52b2tlID0gX3JlZi5pbnZva2U7XG5cbiAgVVNFUl9BR0VOVCA9IFwibm9kZS1odHRwL2ltanMtXCIgKyBWRVJTSU9OO1xuXG4gIFBFU0tZX0NPTU1BID0gLyxcXHMqJC87XG5cbiAgVVJMRU5DID0gXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjtcblxuICBleHBvcnRzLnN1cHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgc3RyZWFtaW5nID0gZnVuY3Rpb24ob3B0cywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgIHZhciBlcnJvcnMsIHJlc3VsdHM7XG4gICAgICBpZiAocmVzcC5waXBlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ3Jlc3BvbnNlIGlzIG5vdCBhIHN0cmVhbScpKTtcbiAgICAgIH1cbiAgICAgIHJlc3Aub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgIGlmICgocmVzcC5zdGF0dXNDb2RlICE9IG51bGwpICYmIHJlc3Auc3RhdHVzQ29kZSAhPT0gMjAwKSB7XG4gICAgICAgIGVycm9ycyA9IEpTT05TdHJlYW0ucGFyc2UoJ2Vycm9yJyk7XG4gICAgICAgIGVycm9ycy5wYXVzZSgpO1xuICAgICAgICByZXNwLnBpcGUoZXJyb3JzKTtcbiAgICAgICAgcmV0dXJuIHJlamVjdChbcmVzcC5zdGF0dXNDb2RlLCBlcnJvcnNdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHMgPSBKU09OU3RyZWFtLnBhcnNlKCdyZXN1bHRzLionKTtcbiAgICAgICAgcmVzdWx0cy5wYXVzZSgpO1xuICAgICAgICByZXNwLnBpcGUocmVzdWx0cyk7XG4gICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZ2V0TXNnID0gZnVuY3Rpb24oX2FyZywgdGV4dCwgZSwgY29kZSkge1xuICAgIHZhciB0eXBlLCB1cmw7XG4gICAgdHlwZSA9IF9hcmcudHlwZSwgdXJsID0gX2FyZy51cmw7XG4gICAgcmV0dXJuIFwiQ291bGQgbm90IHBhcnNlIHJlc3BvbnNlIHRvIFwiICsgdHlwZSArIFwiIFwiICsgdXJsICsgXCI6IFxcXCJcIiArIHRleHQgKyBcIlxcXCIgKFwiICsgY29kZSArIFwiOiBcIiArIGUgKyBcIilcIjtcbiAgfTtcblxuICBibG9ja2luZyA9IGZ1bmN0aW9uKG9wdHMsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbihyZXNwKSB7XG4gICAgICB2YXIgY29udGFpbmVyQnVmZmVyO1xuICAgICAgY29udGFpbmVyQnVmZmVyID0gJyc7XG4gICAgICByZXNwLm9uKCdkYXRhJywgZnVuY3Rpb24oY2h1bmspIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lckJ1ZmZlciArPSBjaHVuaztcbiAgICAgIH0pO1xuICAgICAgcmVzcC5vbignZXJyb3InLCByZWplY3QpO1xuICAgICAgcmV0dXJuIHJlc3Aub24oJ2VuZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3QsIGUsIGVyciwgZiwgbWF0Y2gsIHBhcnNlZCwgX3JlZjE7XG4gICAgICAgIGN0ID0gcmVzcC5oZWFkZXJzWydjb250ZW50LXR5cGUnXTtcbiAgICAgICAgaWYgKCdhcHBsaWNhdGlvbi9qc29uJyA9PT0gY3QgfHwgL2pzb24vLnRlc3Qob3B0cy5kYXRhVHlwZSkgfHwgL2pzb24vLnRlc3Qob3B0cy5kYXRhLmZvcm1hdCkpIHtcbiAgICAgICAgICBpZiAoJycgPT09IGNvbnRhaW5lckJ1ZmZlciAmJiByZXNwLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcGFyc2VkID0gSlNPTi5wYXJzZShjb250YWluZXJCdWZmZXIpO1xuICAgICAgICAgICAgICBpZiAoZXJyID0gcGFyc2VkLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocGFyc2VkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoX2Vycm9yKSB7XG4gICAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICAgIGlmIChyZXNwLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IocmVzcC5zdGF0dXNDb2RlKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoZ2V0TXNnKG9wdHMsIGNvbnRhaW5lckJ1ZmZlciwgZSwgcmVzcC5zdGF0dXNDb2RlKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChtYXRjaCA9IGNvbnRhaW5lckJ1ZmZlci5tYXRjaCgvXFxbRVJST1JcXF0gKFxcZCspKFtcXHNcXFNdKikvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IobWF0Y2hbMl0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZiA9ICgyMDAgPD0gKF9yZWYxID0gcmVzcC5zdGF0dXNDb2RlKSAmJiBfcmVmMSA8IDQwMCkgPyByZXNvbHZlIDogcmVqZWN0O1xuICAgICAgICAgICAgcmV0dXJuIGYoY29udGFpbmVyQnVmZmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgZXhwb3J0cy5pdGVyUmVxID0gZnVuY3Rpb24obWV0aG9kLCBwYXRoLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocSwgcGFnZSwgY2IsIGViLCBvbkVuZCkge1xuICAgICAgdmFyIGF0dGFjaCwgcHJvbWlzZSwgcmVhZEVycm9ycywgcmVxLCBfcmVmMTtcbiAgICAgIGlmIChwYWdlID09IG51bGwpIHtcbiAgICAgICAgcGFnZSA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGNiID09IG51bGwpIHtcbiAgICAgICAgY2IgPSAoZnVuY3Rpb24oKSB7fSk7XG4gICAgICB9XG4gICAgICBpZiAoZWIgPT0gbnVsbCkge1xuICAgICAgICBlYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvbkVuZCA9PSBudWxsKSB7XG4gICAgICAgIG9uRW5kID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFnZSkpIHtcbiAgICAgICAgX3JlZjEgPSBbe30sIHBhZ2UsIGNiLCBlYl0sIHBhZ2UgPSBfcmVmMVswXSwgY2IgPSBfcmVmMVsxXSwgZWIgPSBfcmVmMVsyXSwgb25FbmQgPSBfcmVmMVszXTtcbiAgICAgIH1cbiAgICAgIHJlcSA9IG1lcmdlKHtcbiAgICAgICAgZm9ybWF0OiBmb3JtYXRcbiAgICAgIH0sIHBhZ2UsIHtcbiAgICAgICAgcXVlcnk6IHEudG9YTUwoKVxuICAgICAgfSk7XG4gICAgICBhdHRhY2ggPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgY2IpO1xuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgZWIpO1xuICAgICAgICBzdHJlYW0ub24oJ2VuZCcsIG9uRW5kKTtcbiAgICAgICAgc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHN0cmVhbS5yZXN1bWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmVhbS5yZXN1bWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCAzKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICAgIH07XG4gICAgICByZWFkRXJyb3JzID0gZnVuY3Rpb24oX2FyZykge1xuICAgICAgICB2YXIgZXJyb3JzLCBzYztcbiAgICAgICAgc2MgPSBfYXJnWzBdLCBlcnJvcnMgPSBfYXJnWzFdO1xuICAgICAgICBlcnJvcnMub24oJ2RhdGEnLCBlYik7XG4gICAgICAgIGVycm9ycy5vbignZXJyb3InLCBlYik7XG4gICAgICAgIGVycm9ycy5vbignZW5kJywgb25FbmQpO1xuICAgICAgICBpZiAoZXJyb3JzLnJlc3VtZSAhPSBudWxsKSB7XG4gICAgICAgICAgZXJyb3JzLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcihzYyk7XG4gICAgICB9O1xuICAgICAgcHJvbWlzZSA9IHRoaXMubWFrZVJlcXVlc3QobWV0aG9kLCBwYXRoLCByZXEsIG51bGwsIHRydWUpO1xuICAgICAgcHJvbWlzZS50aGVuKGF0dGFjaCwgcmVhZEVycm9ycyk7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuICB9O1xuXG4gIHJlamVjdEFmdGVyID0gZnVuY3Rpb24odGltZW91dCwgcmVqZWN0LCBwcm9taXNlKSB7XG4gICAgdmFyIHRvO1xuICAgIHRvID0gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KFwiUmVxdWVzdCB0aW1lZCBvdXQuXCIpO1xuICAgIH0pLCB0aW1lb3V0KTtcbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGNhbmNlbFRpbWVvdXQodG8pO1xuICAgIH0pO1xuICB9O1xuXG4gIHBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICB2YXIgaywgcGFyc2VkLCBwb3N0ZGF0YSwgc2VwLCB2LCBfcmVmMSwgX3JlZjIsIF9yZWYzO1xuICAgIGlmICghb3B0cy51cmwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHVybCBwcm92aWRlZCBpbiBcIiArIChKU09OLnN0cmluZ2lmeShvcHRzKSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHBvc3RkYXRhID0gb3B0cy5kYXRhO1xuICAgICAgaWYgKChfcmVmMSA9IG9wdHMudHlwZSkgPT09ICdHRVQnIHx8IF9yZWYxID09PSAnREVMRVRFJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJlcXVlc3QuIFwiICsgb3B0cy50eXBlICsgXCIgcmVxdWVzdHMgbXVzdCBub3QgaGF2ZSBib2RpZXNcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc3RkYXRhID0gdXRpbHMucXVlcnlzdHJpbmcob3B0cy5kYXRhKTtcbiAgICB9XG4gICAgcGFyc2VkID0gVVJMLnBhcnNlKG9wdHMudXJsLCB0cnVlKTtcbiAgICBwYXJzZWQud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgcGFyc2VkLm1ldGhvZCA9IG9wdHMudHlwZSB8fCAnR0VUJztcbiAgICBpZiAob3B0cy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHBhcnNlZC5wb3J0ID0gb3B0cy5wb3J0O1xuICAgIH1cbiAgICBwYXJzZWQuaGVhZGVycyA9IHtcbiAgICAgICdVc2VyLUFnZW50JzogVVNFUl9BR0VOVCxcbiAgICAgICdBY2NlcHQnOiBBQ0NFUFRfSEVBREVSW29wdHMuZGF0YVR5cGVdXG4gICAgfTtcbiAgICBpZiAoKChfcmVmMiA9IHBhcnNlZC5tZXRob2QpID09PSAnR0VUJyB8fCBfcmVmMiA9PT0gJ0RFTEVURScpICYmIChwb3N0ZGF0YSAhPSBudWxsID8gcG9zdGRhdGEubGVuZ3RoIDogdm9pZCAwKSkge1xuICAgICAgc2VwID0gL1xcPy8udGVzdChwYXJzZWQucGF0aCkgPyAnJicgOiAnPyc7XG4gICAgICBwYXJzZWQucGF0aCArPSBzZXAgKyBwb3N0ZGF0YTtcbiAgICAgIHBvc3RkYXRhID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gKG9wdHMuY29udGVudFR5cGUgfHwgVVJMRU5DKSArICc7IGNoYXJzZXQ9VVRGLTgnO1xuICAgICAgcGFyc2VkLmhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSBwb3N0ZGF0YS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChvcHRzLmhlYWRlcnMgIT0gbnVsbCkge1xuICAgICAgX3JlZjMgPSBvcHRzLmhlYWRlcnM7XG4gICAgICBmb3IgKGsgaW4gX3JlZjMpIHtcbiAgICAgICAgdiA9IF9yZWYzW2tdO1xuICAgICAgICBwYXJzZWQuaGVhZGVyc1trXSA9IHY7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRzLmF1dGggIT0gbnVsbCkge1xuICAgICAgcGFyc2VkLmF1dGggPSBvcHRzLmF1dGg7XG4gICAgfVxuICAgIHJldHVybiBbcGFyc2VkLCBwb3N0ZGF0YV07XG4gIH07XG5cbiAgZXhwb3J0cy5kb1JlcSA9IGZ1bmN0aW9uKG9wdHMsIGl0ZXIpIHtcbiAgICB2YXIgZSwgaGFuZGxlciwgcG9zdGRhdGEsIHByb21pc2UsIHJlamVjdCwgcmVxLCByZXNvbHZlLCB0aW1lb3V0LCB1cmwsIF9yZWYxLCBfcmVmMjtcbiAgICBfcmVmMSA9IGRlZmVyKCksIHByb21pc2UgPSBfcmVmMS5wcm9taXNlLCByZXNvbHZlID0gX3JlZjEucmVzb2x2ZSwgcmVqZWN0ID0gX3JlZjEucmVqZWN0O1xuICAgIHByb21pc2UudGhlbihudWxsLCBvcHRzLmVycm9yKTtcbiAgICB0cnkge1xuICAgICAgX3JlZjIgPSBwYXJzZU9wdGlvbnMob3B0cyksIHVybCA9IF9yZWYyWzBdLCBwb3N0ZGF0YSA9IF9yZWYyWzFdO1xuICAgICAgaGFuZGxlciA9IChpdGVyID8gc3RyZWFtaW5nIDogYmxvY2tpbmcpKG9wdHMsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICByZXEgPSBodHRwLnJlcXVlc3QodXJsLCBoYW5kbGVyKTtcbiAgICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJFcnJvcjogXCIgKyB1cmwubWV0aG9kICsgXCIgXCIgKyBvcHRzLnVybCArIFwiOiBcIiArIGVycikpO1xuICAgICAgfSk7XG4gICAgICBpZiAocG9zdGRhdGEgIT0gbnVsbCkge1xuICAgICAgICByZXEud3JpdGUocG9zdGRhdGEpO1xuICAgICAgfVxuICAgICAgcmVxLmVuZCgpO1xuICAgICAgdGltZW91dCA9IG9wdHMudGltZW91dDtcbiAgICAgIGlmICh0aW1lb3V0ID4gMCkge1xuICAgICAgICByZWplY3RBZnRlcih0aW1lb3V0LCByZWplY3QsIHByb21pc2UpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgZSA9IF9lcnJvcjtcbiAgICAgIHJlamVjdChlKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi9jb25zdGFudHNcIjoxLFwiLi91dGlsXCI6MTUsXCIuL3ZlcnNpb25cIjoxNixcIkpTT05TdHJlYW1cIjoxOCxcImh0dHBcIjo1MCxcInVybFwiOjQ3fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBDYXRlZ29yeVJlc3VsdHMsIElEUmVzb2x1dGlvbkpvYiwgSWRSZXN1bHRzLCBPTkVfTUlOVVRFLCBjb25jYXRNYXAsIGRlZmVyLCBkaWZmZXJlbmNlLCBmb2xkLCBmdW5jdXRpbHMsIGdldCwgaWQsIGludGVybWluZSwgdW5pcUJ5LCB3aXRoQ0IsXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH0sXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuICBmdW5jdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWwnKTtcblxuICBpbnRlcm1pbmUgPSBleHBvcnRzO1xuXG4gIHVuaXFCeSA9IGZ1bmN1dGlscy51bmlxQnksIGRpZmZlcmVuY2UgPSBmdW5jdXRpbHMuZGlmZmVyZW5jZSwgZGVmZXIgPSBmdW5jdXRpbHMuZGVmZXIsIHdpdGhDQiA9IGZ1bmN1dGlscy53aXRoQ0IsIGlkID0gZnVuY3V0aWxzLmlkLCBnZXQgPSBmdW5jdXRpbHMuZ2V0LCBmb2xkID0gZnVuY3V0aWxzLmZvbGQsIGNvbmNhdE1hcCA9IGZ1bmN1dGlscy5jb25jYXRNYXA7XG5cbiAgT05FX01JTlVURSA9IDYwICogMTAwMDtcblxuICBDYXRlZ29yeVJlc3VsdHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGdldElzc3VlTWF0Y2hlcztcblxuICAgIGZ1bmN0aW9uIENhdGVnb3J5UmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICB2YXIgaywgdjtcbiAgICAgIGZvciAoayBpbiByZXN1bHRzKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwocmVzdWx0cywgaykpIGNvbnRpbnVlO1xuICAgICAgICB2ID0gcmVzdWx0c1trXTtcbiAgICAgICAgdGhpc1trXSA9IHY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQ2F0ZWdvcnlSZXN1bHRzLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHNbdHlwZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0cztcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZ2V0SXNzdWVNYXRjaGVzID0gY29uY2F0TWFwKGdldCgnbWF0Y2hlcycpKTtcblxuICAgIENhdGVnb3J5UmVzdWx0cy5wcm90b3R5cGUuZ2V0TWF0Y2hlcyA9IGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBfcmVmO1xuICAgICAgaWYgKGsgPT09ICdNQVRDSCcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0Y2hlc1trXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoX3JlZiA9IGdldElzc3VlTWF0Y2hlcyh0aGlzLm1hdGNoZXNba10pKSAhPSBudWxsID8gX3JlZiA6IFtdO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBDYXRlZ29yeVJlc3VsdHMucHJvdG90eXBlLmdldE1hdGNoSWRzID0gZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGVzKGspLm1hcChnZXQoJ2lkJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsTWF0Y2hJZHMoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgQ2F0ZWdvcnlSZXN1bHRzLnByb3RvdHlwZS5nb29kTWF0Y2hJZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1hdGNoSWRzKCdNQVRDSCcpO1xuICAgIH07XG5cbiAgICBDYXRlZ29yeVJlc3VsdHMucHJvdG90eXBlLmFsbE1hdGNoSWRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY29tYmluZUlkcztcbiAgICAgIGNvbWJpbmVJZHMgPSBmb2xkKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocmVzLCBpc3N1ZVNldCkge1xuICAgICAgICAgIHJldHVybiByZXMuY29uY2F0KF90aGlzLmdldE1hdGNoSWRzKGlzc3VlU2V0KSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICByZXR1cm4gY29tYmluZUlkcyh0aGlzLmdvb2RNYXRjaElkcygpLCBbJ0RVUExJQ0FURScsICdXSUxEQ0FSRCcsICdUWVBFX0NPTlZFUlRFRCcsICdPVEhFUiddKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENhdGVnb3J5UmVzdWx0cztcblxuICB9KSgpO1xuXG4gIElkUmVzdWx0cyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZmxhdHRlbiwgZ2V0UmVhc29ucywgaXNHb29kLCB1bmlxdWU7XG5cbiAgICB1bmlxdWUgPSB1bmlxQnkoaWQpO1xuXG4gICAgZmxhdHRlbiA9IGNvbmNhdE1hcChpZCk7XG5cbiAgICBnZXRSZWFzb25zID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHZhciBrLCB2YWxzO1xuICAgICAgcmV0dXJuIGZsYXR0ZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSBtYXRjaC5pZGVudGlmaWVycztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChrIGluIF9yZWYpIHtcbiAgICAgICAgICB2YWxzID0gX3JlZltrXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHZhbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpO1xuICAgIH07XG5cbiAgICBpc0dvb2QgPSBmdW5jdGlvbihtYXRjaCwgaykge1xuICAgICAgcmV0dXJuIChrID09IG51bGwpIHx8IF9faW5kZXhPZi5jYWxsKGdldFJlYXNvbnMobWF0Y2gpLCBrKSA+PSAwO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBJZFJlc3VsdHMocmVzdWx0cykge1xuICAgICAgdmFyIGssIHY7XG4gICAgICBmb3IgKGsgaW4gcmVzdWx0cykge1xuICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKHJlc3VsdHMsIGspKSBjb250aW51ZTtcbiAgICAgICAgdiA9IHJlc3VsdHNba107XG4gICAgICAgIHRoaXNba10gPSB2O1xuICAgICAgfVxuICAgIH1cblxuICAgIElkUmVzdWx0cy5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnb2JqZWN0cyc6XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0T2JqZWN0U3RhdHMoKTtcbiAgICAgICAgY2FzZSAnaWRlbnRpZmllcnMnOlxuICAgICAgICAgIHJldHVybiB0aGlzLmdldElkZW50aWZpZXJTdGF0cygpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBvYmplY3RzOiB0aGlzLmdldE9iamVjdFN0YXRzKCksXG4gICAgICAgICAgICBpZGVudGlmaWVyczogdGhpcy5nZXRJZGVudGlmaWVyU3RhdHMoKVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIElkUmVzdWx0cy5wcm90b3R5cGUuZ2V0SWRlbnRpZmllclN0YXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYWxsLCBhbGxJZGVudHMsIGlzc3VlcywgbWF0Y2hJZGVudHMsIG1hdGNoZXMsIHRvSWRlbnRzO1xuICAgICAgdG9JZGVudHMgPSBmdW5jdGlvbihtcykge1xuICAgICAgICB2YXIgaWRlbnQsIG1hdGNoO1xuICAgICAgICByZXR1cm4gdW5pcXVlKGZsYXR0ZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG1zLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICBtYXRjaCA9IG1zW19pXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgX3Jlc3VsdHMxO1xuICAgICAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgICAgZm9yIChpZGVudCBpbiBtYXRjaCAhPSBudWxsID8gbWF0Y2guaWRlbnRpZmllcnMgOiB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaChpZGVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzMTtcbiAgICAgICAgICAgIH0pKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pKCkpKTtcbiAgICAgIH07XG4gICAgICBtYXRjaElkZW50cyA9IHRvSWRlbnRzKHRoaXMuZ2V0TWF0Y2hlcygnTUFUQ0gnKSk7XG4gICAgICBhbGxJZGVudHMgPSB0b0lkZW50cyh0aGlzLmdldE1hdGNoZXMoKSk7XG4gICAgICBtYXRjaGVzID0gbWF0Y2hJZGVudHMubGVuZ3RoO1xuICAgICAgYWxsID0gYWxsSWRlbnRzLmxlbmd0aDtcbiAgICAgIGlzc3VlcyA9IChkaWZmZXJlbmNlKGFsbElkZW50cywgbWF0Y2hJZGVudHMpKS5sZW5ndGg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBtYXRjaGVzLFxuICAgICAgICBhbGw6IGFsbCxcbiAgICAgICAgaXNzdWVzOiBpc3N1ZXNcbiAgICAgIH07XG4gICAgfTtcblxuICAgIElkUmVzdWx0cy5wcm90b3R5cGUuZ2V0T2JqZWN0U3RhdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhbGwsIGlzc3VlcywgbWF0Y2gsIG1hdGNoZXM7XG4gICAgICBtYXRjaGVzID0gdGhpcy5nb29kTWF0Y2hJZHMoKS5sZW5ndGg7XG4gICAgICBhbGwgPSB0aGlzLmFsbE1hdGNoSWRzKCkubGVuZ3RoO1xuICAgICAgaXNzdWVzID0gKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGlkIGluIHRoaXMpIHtcbiAgICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKHRoaXMsIGlkKSkgY29udGludWU7XG4gICAgICAgICAgbWF0Y2ggPSB0aGlzW2lkXTtcbiAgICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoZ2V0UmVhc29ucyhtYXRjaCksICdNQVRDSCcpIDwgMCkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcykpLmxlbmd0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXM6IG1hdGNoZXMsXG4gICAgICAgIGFsbDogYWxsLFxuICAgICAgICBpc3N1ZXM6IGlzc3Vlc1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgSWRSZXN1bHRzLnByb3RvdHlwZS5nZXRNYXRjaGVzID0gZnVuY3Rpb24oaykge1xuICAgICAgdmFyIG1hdGNoLCBfcmVzdWx0cztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKGlkIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbCh0aGlzLCBpZCkpIGNvbnRpbnVlO1xuICAgICAgICBtYXRjaCA9IHRoaXNbaWRdO1xuICAgICAgICBpZiAoaXNHb29kKG1hdGNoLCBrKSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobWF0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIElkUmVzdWx0cy5wcm90b3R5cGUuZ2V0TWF0Y2hJZHMgPSBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIgbWF0Y2gsIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoaWQgaW4gdGhpcykge1xuICAgICAgICBpZiAoIV9faGFzUHJvcC5jYWxsKHRoaXMsIGlkKSkgY29udGludWU7XG4gICAgICAgIG1hdGNoID0gdGhpc1tpZF07XG4gICAgICAgIGlmIChpc0dvb2QobWF0Y2gsIGspKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChpZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuXG4gICAgSWRSZXN1bHRzLnByb3RvdHlwZS5nb29kTWF0Y2hJZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldE1hdGNoSWRzKCdNQVRDSCcpO1xuICAgIH07XG5cbiAgICBJZFJlc3VsdHMucHJvdG90eXBlLmFsbE1hdGNoSWRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNYXRjaElkcygpO1xuICAgIH07XG5cbiAgICByZXR1cm4gSWRSZXN1bHRzO1xuXG4gIH0pKCk7XG5cbiAgSURSZXNvbHV0aW9uSm9iID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIElEUmVzb2x1dGlvbkpvYih1aWQsIHNlcnZpY2UpIHtcbiAgICAgIHRoaXMudWlkID0gdWlkO1xuICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgIHRoaXMuZGVsID0gX19iaW5kKHRoaXMuZGVsLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hSZXN1bHRzID0gX19iaW5kKHRoaXMuZmV0Y2hSZXN1bHRzLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hFcnJvck1lc3NhZ2UgPSBfX2JpbmQodGhpcy5mZXRjaEVycm9yTWVzc2FnZSwgdGhpcyk7XG4gICAgICB0aGlzLmZldGNoU3RhdHVzID0gX19iaW5kKHRoaXMuZmV0Y2hTdGF0dXMsIHRoaXMpO1xuICAgIH1cblxuICAgIElEUmVzb2x1dGlvbkpvYi5wcm90b3R5cGUuZmV0Y2hTdGF0dXMgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLmdldChcImlkcy9cIiArIHRoaXMudWlkICsgXCIvc3RhdHVzXCIpLnRoZW4oZ2V0KCdzdGF0dXMnKSkpO1xuICAgIH07XG5cbiAgICBJRFJlc29sdXRpb25Kb2IucHJvdG90eXBlLmZldGNoRXJyb3JNZXNzYWdlID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5nZXQoXCJpZHMvXCIgKyB0aGlzLnVpZCArIFwiL3N0YXR1c1wiKS50aGVuKGdldCgnbWVzc2FnZScpKSk7XG4gICAgfTtcblxuICAgIElEUmVzb2x1dGlvbkpvYi5wcm90b3R5cGUuZmV0Y2hSZXN1bHRzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHZhciBnZXR0aW5nUmVzLCBnZXR0aW5nVmVyO1xuICAgICAgZ2V0dGluZ1JlcyA9IHRoaXMuc2VydmljZS5nZXQoXCJpZHMvXCIgKyB0aGlzLnVpZCArIFwiL3Jlc3VsdFwiKS50aGVuKGdldCgncmVzdWx0cycpKTtcbiAgICAgIGdldHRpbmdWZXIgPSB0aGlzLnNlcnZpY2UuZmV0Y2hWZXJzaW9uKCk7XG4gICAgICByZXR1cm4gZ2V0dGluZ1Zlci50aGVuKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIGdldHRpbmdSZXMudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgICAgaWYgKHYgPj0gMTYpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2F0ZWdvcnlSZXN1bHRzKHJlc3VsdHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IElkUmVzdWx0cyhyZXN1bHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIElEUmVzb2x1dGlvbkpvYi5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5tYWtlUmVxdWVzdCgnREVMRVRFJywgXCJpZHMvXCIgKyB0aGlzLnVpZCkpO1xuICAgIH07XG5cbiAgICBJRFJlc29sdXRpb25Kb2IucHJvdG90eXBlLmRlY2F5ID0gNTA7XG5cbiAgICBJRFJlc29sdXRpb25Kb2IucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbihvblN1Y2Nlc3MsIG9uRXJyb3IsIG9uUHJvZ3Jlc3MpIHtcbiAgICAgIHZhciBiYWNrT2ZmLCBub3RpZnksIHByb21pc2UsIHJlamVjdCwgcmVzb2x2ZSwgcmVzcCwgX3JlZjtcbiAgICAgIF9yZWYgPSBkZWZlcigpLCBwcm9taXNlID0gX3JlZi5wcm9taXNlLCByZXNvbHZlID0gX3JlZi5yZXNvbHZlLCByZWplY3QgPSBfcmVmLnJlamVjdDtcbiAgICAgIHByb21pc2UudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgICAgbm90aWZ5ID0gb25Qcm9ncmVzcyAhPSBudWxsID8gb25Qcm9ncmVzcyA6IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIHJlc3AgPSB0aGlzLmZldGNoU3RhdHVzKCk7XG4gICAgICByZXNwLnRoZW4obnVsbCwgcmVqZWN0KTtcbiAgICAgIGJhY2tPZmYgPSB0aGlzLmRlY2F5O1xuICAgICAgdGhpcy5kZWNheSA9IE1hdGgubWluKE9ORV9NSU5VVEUsIGJhY2tPZmYgKiAxLjI1KTtcbiAgICAgIHJlc3AudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgIG5vdGlmeShzdGF0dXMpO1xuICAgICAgICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICAgICAgICBjYXNlICdTVUNDRVNTJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZldGNoUmVzdWx0cygpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIGNhc2UgJ0VSUk9SJzpcbiAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmZldGNoRXJyb3JNZXNzYWdlKCkudGhlbihyZWplY3QsIHJlamVjdCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBvbGwocmVzb2x2ZSwgcmVqZWN0LCBub3RpZnkpO1xuICAgICAgICAgICAgICB9KSwgYmFja09mZik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIHJldHVybiBJRFJlc29sdXRpb25Kb2I7XG5cbiAgfSkoKTtcblxuICBJRFJlc29sdXRpb25Kb2IucHJvdG90eXBlLndhaXQgPSBJRFJlc29sdXRpb25Kb2IucHJvdG90eXBlLnBvbGw7XG5cbiAgSURSZXNvbHV0aW9uSm9iLmNyZWF0ZSA9IGZ1bmN0aW9uKHNlcnZpY2UpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odWlkKSB7XG4gICAgICByZXR1cm4gbmV3IElEUmVzb2x1dGlvbkpvYih1aWQsIHNlcnZpY2UpO1xuICAgIH07XG4gIH07XG5cbiAgaW50ZXJtaW5lLklEUmVzb2x1dGlvbkpvYiA9IElEUmVzb2x1dGlvbkpvYjtcblxuICBpbnRlcm1pbmUuQ2F0ZWdvcnlSZXN1bHRzID0gQ2F0ZWdvcnlSZXN1bHRzO1xuXG4gIGludGVybWluZS5JZFJlc3VsdHMgPSBJZFJlc3VsdHM7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi91dGlsXCI6MTV9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIElOVklURVMsIExpc3QsIFJFUVVJUkVTX1ZFUlNJT04sIFNIQVJFUywgVEFHU19QQVRILCBkZWpvaW4sIGdldCwgZ2V0Rm9sZGVyTmFtZSwgaW50ZXJtaW5lLCBpbnZva2UsIGlzRm9sZGVyLCBtZXJnZSwgc2V0LCB1dGlscywgd2l0aENCLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgX19oYXNQcm9wID0ge30uaGFzT3duUHJvcGVydHksXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgdXRpbHMgPSBfZGVyZXFfKCcuL3V0aWwnKTtcblxuICBpbnRlcm1pbmUgPSBleHBvcnRzO1xuXG4gIG1lcmdlID0gdXRpbHMubWVyZ2UsIHdpdGhDQiA9IHV0aWxzLndpdGhDQiwgZ2V0ID0gdXRpbHMuZ2V0LCBpbnZva2UgPSB1dGlscy5pbnZva2UsIFJFUVVJUkVTX1ZFUlNJT04gPSB1dGlscy5SRVFVSVJFU19WRVJTSU9OLCBzZXQgPSB1dGlscy5zZXQsIGRlam9pbiA9IHV0aWxzLmRlam9pbjtcblxuICBUQUdTX1BBVEggPSBcImxpc3QvdGFnc1wiO1xuXG4gIFNIQVJFUyA9IFwibGlzdHMvc2hhcmVzXCI7XG5cbiAgSU5WSVRFUyA9ICdsaXN0cy9pbnZpdGF0aW9ucyc7XG5cbiAgaXNGb2xkZXIgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuc3Vic3RyKDAsIHQuaW5kZXhPZignOicpKSA9PT0gJ19fZm9sZGVyX18nO1xuICB9O1xuXG4gIGdldEZvbGRlck5hbWUgPSBmdW5jdGlvbih0KSB7XG4gICAgcmV0dXJuIHQuc3Vic3RyKHQuaW5kZXhPZignOicpICsgMSk7XG4gIH07XG5cbiAgTGlzdCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgZ2V0VGFncztcblxuICAgIGZ1bmN0aW9uIExpc3QocHJvcGVydGllcywgc2VydmljZSkge1xuICAgICAgdmFyIGssIHY7XG4gICAgICB0aGlzLnNlcnZpY2UgPSBzZXJ2aWNlO1xuICAgICAgdGhpcy5fdXBkYXRlVGFncyA9IF9fYmluZCh0aGlzLl91cGRhdGVUYWdzLCB0aGlzKTtcbiAgICAgIHRoaXMuaGFzVGFnID0gX19iaW5kKHRoaXMuaGFzVGFnLCB0aGlzKTtcbiAgICAgIGZvciAoayBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwocHJvcGVydGllcywgaykpIGNvbnRpbnVlO1xuICAgICAgICB2ID0gcHJvcGVydGllc1trXTtcbiAgICAgICAgdGhpc1trXSA9IHY7XG4gICAgICB9XG4gICAgICB0aGlzLmRhdGVDcmVhdGVkID0gKHRoaXMuZGF0ZUNyZWF0ZWQgIT0gbnVsbCkgPyBuZXcgRGF0ZSh0aGlzLmRhdGVDcmVhdGVkKSA6IG51bGw7XG4gICAgICB0aGlzLmZvbGRlcnMgPSB0aGlzLnRhZ3MuZmlsdGVyKGlzRm9sZGVyKS5tYXAoZ2V0Rm9sZGVyTmFtZSk7XG4gICAgfVxuXG4gICAgTGlzdC5wcm90b3R5cGUuaGFzVGFnID0gZnVuY3Rpb24odCkge1xuICAgICAgcmV0dXJuIF9faW5kZXhPZi5jYWxsKHRoaXMudGFncywgdCkgPj0gMDtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbih2aWV3KSB7XG4gICAgICBpZiAodmlldyA9PSBudWxsKSB7XG4gICAgICAgIHZpZXcgPSBbJyonXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNlcnZpY2UucXVlcnkoe1xuICAgICAgICBzZWxlY3Q6IHZpZXcsXG4gICAgICAgIGZyb206IHRoaXMudHlwZSxcbiAgICAgICAgd2hlcmU6IFtbdGhpcy50eXBlLCAnSU4nLCB0aGlzLm5hbWVdXVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLm1ha2VSZXF1ZXN0KCdERUxFVEUnLCAnbGlzdHMnLCB7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZVxuICAgICAgfSwgY2IpO1xuICAgIH07XG5cbiAgICBnZXRUYWdzID0gZnVuY3Rpb24oX2FyZykge1xuICAgICAgdmFyIHRhZ3M7XG4gICAgICB0YWdzID0gX2FyZy50YWdzO1xuICAgICAgcmV0dXJuIHRhZ3M7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLl91cGRhdGVUYWdzID0gZnVuY3Rpb24oZXJyLCB0YWdzKSB7XG4gICAgICBpZiAoZXJyICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy50YWdzID0gdGFncy5zbGljZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9sZGVycyA9IHRoaXMudGFncy5maWx0ZXIoaXNGb2xkZXIpLm1hcChnZXRGb2xkZXJOYW1lKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuZmV0Y2hUYWdzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IodGhpcy5fdXBkYXRlVGFncywgY2IsIHRoaXMuc2VydmljZS5tYWtlUmVxdWVzdCgnR0VUJywgJ2xpc3QvdGFncycsIHtcbiAgICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgICB9KS50aGVuKGdldFRhZ3MpKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuYWRkVGFncyA9IGZ1bmN0aW9uKHRhZ3MsIGNiKSB7XG4gICAgICB2YXIgcmVxO1xuICAgICAgcmVxID0ge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIHRhZ3M6IHRhZ3NcbiAgICAgIH07XG4gICAgICByZXR1cm4gd2l0aENCKHRoaXMuX3VwZGF0ZVRhZ3MsIGNiLCB0aGlzLnNlcnZpY2UubWFrZVJlcXVlc3QoJ1BPU1QnLCAnbGlzdC90YWdzJywgcmVxKS50aGVuKGdldFRhZ3MpKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucmVtb3ZlVGFncyA9IGZ1bmN0aW9uKHRhZ3MsIGNiKSB7XG4gICAgICB2YXIgcmVxO1xuICAgICAgcmVxID0ge1xuICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgIHRhZ3M6IHRhZ3NcbiAgICAgIH07XG4gICAgICByZXR1cm4gd2l0aENCKHRoaXMuX3VwZGF0ZVRhZ3MsIGNiLCB0aGlzLnNlcnZpY2UubWFrZVJlcXVlc3QoJ0RFTEVURScsICdsaXN0L3RhZ3MnLCByZXEpLnRoZW4oZ2V0VGFncykpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5jb250ZW50cyA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLnF1ZXJ5KCkudGhlbihkZWpvaW4pLnRoZW4oaW52b2tlKCdyZWNvcmRzJykpKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUucmVuYW1lID0gZnVuY3Rpb24obmV3TmFtZSwgY2IpIHtcbiAgICAgIHZhciBwcm9taXNlO1xuICAgICAgcHJvbWlzZSA9IHRoaXMuc2VydmljZS5wb3N0KCdsaXN0cy9yZW5hbWUnLCB7XG4gICAgICAgIG9sZG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgbmV3bmFtZTogbmV3TmFtZVxuICAgICAgfSkudGhlbihnZXQoJ2xpc3ROYW1lJykpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLm5hbWUgPSBuO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpLnRoZW4odGhpcy5zZXJ2aWNlLmZldGNoTGlzdCk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCBwcm9taXNlKTtcbiAgICB9O1xuXG4gICAgTGlzdC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKG9wdHMsIGNiKSB7XG4gICAgICB2YXIgYmFzZU5hbWUsIG5hbWUsIHF1ZXJ5LCB0YWdzLCBfcmVmLCBfcmVmMSwgX3JlZjI7XG4gICAgICBpZiAob3B0cyA9PSBudWxsKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgdXRpbHMuaXNGdW5jdGlvbihvcHRzKSkge1xuICAgICAgICBfcmVmID0gW3t9LCBvcHRzXSwgb3B0cyA9IF9yZWZbMF0sIGNiID0gX3JlZlsxXTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICBuYW1lOiBvcHRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBuYW1lID0gYmFzZU5hbWUgPSAoX3JlZjEgPSBvcHRzLm5hbWUpICE9IG51bGwgPyBfcmVmMSA6IFwiXCIgKyB0aGlzLm5hbWUgKyBcIl9jb3B5XCI7XG4gICAgICB0YWdzID0gdGhpcy50YWdzLmNvbmNhdCgoX3JlZjIgPSBvcHRzLnRhZ3MpICE9IG51bGwgPyBfcmVmMiA6IFtdKTtcbiAgICAgIHF1ZXJ5ID0gdGhpcy5xdWVyeShbJ2lkJ10pO1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLmZldGNoTGlzdHMoKS50aGVuKGludm9rZSgnbWFwJywgZ2V0KCduYW1lJykpKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24obmFtZXMpIHtcbiAgICAgICAgICB2YXIgYztcbiAgICAgICAgICBjID0gMTtcbiAgICAgICAgICB3aGlsZSAoX19pbmRleE9mLmNhbGwobmFtZXMsIG5hbWUpID49IDApIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIlwiICsgYmFzZU5hbWUgKyBcIi1cIiArIChjKyspO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcXVlcnkudGhlbihpbnZva2UoJ3NhdmVBc0xpc3QnLCB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgdGFnczogdGFncyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBfdGhpcy5kZXNjcmlwdGlvblxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKSk7XG4gICAgfTtcblxuICAgIExpc3QucHJvdG90eXBlLmVucmljaG1lbnQgPSBmdW5jdGlvbihvcHRzLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5lbnJpY2htZW50KG1lcmdlKHtcbiAgICAgICAgbGlzdDogdGhpcy5uYW1lXG4gICAgICB9LCBvcHRzKSwgY2IpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5zaGFyZVdpdGhVc2VyID0gZnVuY3Rpb24ocmVjaXBpZW50LCBjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLnBvc3QoU0hBUkVTLCB7XG4gICAgICAgICdsaXN0JzogdGhpcy5uYW1lLFxuICAgICAgICAnd2l0aCc6IHJlY2lwaWVudFxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBMaXN0LnByb3RvdHlwZS5pbnZpdGVVc2VyVG9TaGFyZSA9IGZ1bmN0aW9uKHJlY2lwaWVudCwgbm90aWZ5LCBjYikge1xuICAgICAgaWYgKG5vdGlmeSA9PSBudWxsKSB7XG4gICAgICAgIG5vdGlmeSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5wb3N0KElOVklURVMsIHtcbiAgICAgICAgbGlzdDogdGhpcy5uYW1lLFxuICAgICAgICB0bzogcmVjaXBpZW50LFxuICAgICAgICBub3RpZnk6ICEhbm90aWZ5XG4gICAgICB9KSk7XG4gICAgfTtcblxuICAgIHJldHVybiBMaXN0O1xuXG4gIH0pKCk7XG5cbiAgaW50ZXJtaW5lLkxpc3QgPSBMaXN0O1xuXG59KS5jYWxsKHRoaXMpO1xuXG59LHtcIi4vdXRpbFwiOjE1fV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBKQVZBX0xBTkdfT0JKLCBNb2RlbCwgUGF0aEluZm8sIFRhYmxlLCBlcnJvciwgZmluZCwgZmxhdHRlbiwgaW50ZXJtaW5lLCBvbWFwLCBfcmVmLFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgX19pbmRleE9mID0gW10uaW5kZXhPZiB8fCBmdW5jdGlvbihpdGVtKSB7IGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHsgaWYgKGkgaW4gdGhpcyAmJiB0aGlzW2ldID09PSBpdGVtKSByZXR1cm4gaTsgfSByZXR1cm4gLTE7IH07XG5cbiAgVGFibGUgPSBfZGVyZXFfKCcuL3RhYmxlJykuVGFibGU7XG5cbiAgUGF0aEluZm8gPSBfZGVyZXFfKCcuL3BhdGgnKS5QYXRoSW5mbztcblxuICBfcmVmID0gX2RlcmVxXygnLi91dGlsJyksIGZsYXR0ZW4gPSBfcmVmLmZsYXR0ZW4sIGZpbmQgPSBfcmVmLmZpbmQsIGVycm9yID0gX3JlZi5lcnJvciwgb21hcCA9IF9yZWYub21hcDtcblxuICBpbnRlcm1pbmUgPSBleHBvcnRzO1xuXG4gIEpBVkFfTEFOR19PQkogPSBuZXcgVGFibGUoe1xuICAgIG5hbWU6ICdPYmplY3QnLFxuICAgIHRhZ3M6IFtdLFxuICAgIGRpc3BsYXlOYW1lOiAnT2JqZWN0JyxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICByZWZlcmVuY2VzOiB7fSxcbiAgICBjb2xsZWN0aW9uczoge31cbiAgfSk7XG5cbiAgTW9kZWwgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gTW9kZWwoX2FyZykge1xuICAgICAgdmFyIGNsYXNzZXMsIGxpZnRUb1RhYmxlO1xuICAgICAgdGhpcy5uYW1lID0gX2FyZy5uYW1lLCBjbGFzc2VzID0gX2FyZy5jbGFzc2VzO1xuICAgICAgdGhpcy5maW5kQ29tbW9uVHlwZSA9IF9fYmluZCh0aGlzLmZpbmRDb21tb25UeXBlLCB0aGlzKTtcbiAgICAgIHRoaXMuZmluZFNoYXJlZEFuY2VzdG9yID0gX19iaW5kKHRoaXMuZmluZFNoYXJlZEFuY2VzdG9yLCB0aGlzKTtcbiAgICAgIHRoaXMuZ2V0QW5jZXN0b3JzT2YgPSBfX2JpbmQodGhpcy5nZXRBbmNlc3RvcnNPZiwgdGhpcyk7XG4gICAgICB0aGlzLmdldFN1YmNsYXNzZXNPZiA9IF9fYmluZCh0aGlzLmdldFN1YmNsYXNzZXNPZiwgdGhpcyk7XG4gICAgICB0aGlzLmdldFBhdGhJbmZvID0gX19iaW5kKHRoaXMuZ2V0UGF0aEluZm8sIHRoaXMpO1xuICAgICAgbGlmdFRvVGFibGUgPSBvbWFwKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaywgdikge1xuICAgICAgICAgIHJldHVybiBbaywgbmV3IFRhYmxlKHYsIF90aGlzKV07XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgICB0aGlzLmNsYXNzZXMgPSBsaWZ0VG9UYWJsZShjbGFzc2VzKTtcbiAgICAgIHRoaXMuY2xhc3Nlc1snamF2YS5sYW5nLk9iamVjdCddID0gSkFWQV9MQU5HX09CSjtcbiAgICB9XG5cbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0UGF0aEluZm8gPSBmdW5jdGlvbihwYXRoLCBzdWJjbHMpIHtcbiAgICAgIHJldHVybiBQYXRoSW5mby5wYXJzZSh0aGlzLCBwYXRoLCBzdWJjbHMpO1xuICAgIH07XG5cbiAgICBNb2RlbC5wcm90b3R5cGUuZ2V0U3ViY2xhc3Nlc09mID0gZnVuY3Rpb24oY2xzKSB7XG4gICAgICB2YXIgY2QsIGNsYXp6LCByZXQsIF8sIF9yZWYxLCBfcmVmMjtcbiAgICAgIGNsYXp6ID0gY2xzICYmIGNscy5uYW1lID8gY2xzIDogdGhpcy5jbGFzc2VzW2Nsc107XG4gICAgICBpZiAoY2xhenogPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIGNscyArIFwiIGlzIG5vdCBhIHRhYmxlXCIpO1xuICAgICAgfVxuICAgICAgcmV0ID0gW2NsYXp6Lm5hbWVdO1xuICAgICAgX3JlZjEgPSB0aGlzLmNsYXNzZXM7XG4gICAgICBmb3IgKF8gaW4gX3JlZjEpIHtcbiAgICAgICAgY2QgPSBfcmVmMVtfXTtcbiAgICAgICAgaWYgKF9yZWYyID0gY2xhenoubmFtZSwgX19pbmRleE9mLmNhbGwoY2QucGFyZW50cygpLCBfcmVmMikgPj0gMCkge1xuICAgICAgICAgIHJldCA9IHJldC5jb25jYXQodGhpcy5nZXRTdWJjbGFzc2VzT2YoY2QpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuXG4gICAgTW9kZWwucHJvdG90eXBlLmdldEFuY2VzdG9yc09mID0gZnVuY3Rpb24oY2xzKSB7XG4gICAgICB2YXIgY2xhenosIHBhcmVudHM7XG4gICAgICBjbGF6eiA9IGNscyAmJiBjbHMubmFtZSA/IGNscyA6IHRoaXMuY2xhc3Nlc1tjbHNdO1xuICAgICAgaWYgKGNsYXp6ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIgKyBjbHMgKyBcIiBpcyBub3QgYSB0YWJsZVwiKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudHMgPSBjbGF6ei5wYXJlbnRzKCk7XG4gICAgICByZXR1cm4gcGFyZW50cy5maWx0ZXIoKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmNsYXNzZXNbcF07XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSkucmVkdWNlKCgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFzLCBwKSB7XG4gICAgICAgICAgcmV0dXJuIGFzLmNvbmNhdChfdGhpcy5nZXRBbmNlc3RvcnNPZihwKSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSksIHBhcmVudHMpO1xuICAgIH07XG5cbiAgICBNb2RlbC5wcm90b3R5cGUuZmluZFNoYXJlZEFuY2VzdG9yID0gZnVuY3Rpb24oY2xhc3NBLCBjbGFzc0IpIHtcbiAgICAgIHZhciBhX2FuY2VzdHJ5LCBiX2FuY2VzdHJ5LCBmaXJzdENvbW1vbjtcbiAgICAgIGlmIChjbGFzc0IgPT09IG51bGwgfHwgY2xhc3NBID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGNsYXNzQSA9PT0gY2xhc3NCKSB7XG4gICAgICAgIHJldHVybiBjbGFzc0E7XG4gICAgICB9XG4gICAgICBhX2FuY2VzdHJ5ID0gdGhpcy5nZXRBbmNlc3RvcnNPZihjbGFzc0EpO1xuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKGFfYW5jZXN0cnksIGNsYXNzQikgPj0gMCkge1xuICAgICAgICByZXR1cm4gY2xhc3NCO1xuICAgICAgfVxuICAgICAgYl9hbmNlc3RyeSA9IHRoaXMuZ2V0QW5jZXN0b3JzT2YoY2xhc3NCKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChiX2FuY2VzdHJ5LCBjbGFzc0EpID49IDApIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzQTtcbiAgICAgIH1cbiAgICAgIGZpcnN0Q29tbW9uID0gZmluZChhX2FuY2VzdHJ5LCBmdW5jdGlvbihhKSB7XG4gICAgICAgIHJldHVybiBfX2luZGV4T2YuY2FsbChiX2FuY2VzdHJ5LCBhKSA+PSAwO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gZmlyc3RDb21tb247XG4gICAgfTtcblxuICAgIE1vZGVsLnByb3RvdHlwZS5maW5kQ29tbW9uVHlwZSA9IGZ1bmN0aW9uKHhzKSB7XG4gICAgICBpZiAoeHMgPT0gbnVsbCkge1xuICAgICAgICB4cyA9IFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHhzLnJlZHVjZSh0aGlzLmZpbmRTaGFyZWRBbmNlc3Rvcik7XG4gICAgfTtcblxuICAgIHJldHVybiBNb2RlbDtcblxuICB9KSgpO1xuXG4gIE1vZGVsLnByb3RvdHlwZS5tYWtlUGF0aCA9IE1vZGVsLnByb3RvdHlwZS5nZXRQYXRoSW5mbztcblxuICBNb2RlbC5wcm90b3R5cGUuZmluZENvbW1vblR5cGVPZk11bHRpcGxlQ2xhc3NlcyA9IE1vZGVsLnByb3RvdHlwZS5maW5kQ29tbW9uVHlwZTtcblxuICBNb2RlbC5sb2FkID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IE1vZGVsKGRhdGEpO1xuICAgIH0gY2F0Y2ggKF9lcnJvcikge1xuICAgICAgZSA9IF9lcnJvcjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGxvYWRpbmcgbW9kZWw6IFwiICsgZSk7XG4gICAgfVxuICB9O1xuXG4gIE1vZGVsLklOVEVHUkFMX1RZUEVTID0gW1wiaW50XCIsIFwiSW50ZWdlclwiLCBcImxvbmdcIiwgXCJMb25nXCJdO1xuXG4gIE1vZGVsLkZSQUNUSU9OQUxfVFlQRVMgPSBbXCJkb3VibGVcIiwgXCJEb3VibGVcIiwgXCJmbG9hdFwiLCBcIkZsb2F0XCJdO1xuXG4gIE1vZGVsLk5VTUVSSUNfVFlQRVMgPSBNb2RlbC5JTlRFR1JBTF9UWVBFUy5jb25jYXQoTW9kZWwuRlJBQ1RJT05BTF9UWVBFUyk7XG5cbiAgTW9kZWwuQk9PTEVBTl9UWVBFUyA9IFtcImJvb2xlYW5cIiwgXCJCb29sZWFuXCJdO1xuXG4gIGludGVybWluZS5Nb2RlbCA9IE1vZGVsO1xuXG59KS5jYWxsKHRoaXMpO1xuXG59LHtcIi4vcGF0aFwiOjcsXCIuL3RhYmxlXCI6MTMsXCIuL3V0aWxcIjoxNX1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgTkFNRVMsIFBBUlNFRCwgUGF0aEluZm8sIGFueSwgY29uY2F0TWFwLCBjb3B5LCBlcnJvciwgZ2V0LCBpbnRlcm1pbmUsIG1ha2VLZXksIHNldCwgc3VjY2VzcywgdXRpbHMsIHdpdGhDQixcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuICAgIF9fc2xpY2UgPSBbXS5zbGljZSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfTtcblxuICBpbnRlcm1pbmUgPSBleHBvcnRzO1xuXG4gIHV0aWxzID0gX2RlcmVxXygnLi91dGlsJyk7XG5cbiAgd2l0aENCID0gdXRpbHMud2l0aENCLCBjb25jYXRNYXAgPSB1dGlscy5jb25jYXRNYXAsIGdldCA9IHV0aWxzLmdldCwgYW55ID0gdXRpbHMuYW55LCBzZXQgPSB1dGlscy5zZXQsIGNvcHkgPSB1dGlscy5jb3B5LCBzdWNjZXNzID0gdXRpbHMuc3VjY2VzcywgZXJyb3IgPSB1dGlscy5lcnJvcjtcblxuICBOQU1FUyA9IHt9O1xuXG4gIFBBUlNFRCA9IHt9O1xuXG4gIG1ha2VLZXkgPSBmdW5jdGlvbihtb2RlbCwgcGF0aCwgc3ViY2xhc3Nlcykge1xuICAgIHZhciBrLCB2LCBfcmVmO1xuICAgIHJldHVybiBcIlwiICsgKG1vZGVsICE9IG51bGwgPyBtb2RlbC5uYW1lIDogdm9pZCAwKSArIFwifFwiICsgKG1vZGVsICE9IG51bGwgPyAoX3JlZiA9IG1vZGVsLnNlcnZpY2UpICE9IG51bGwgPyBfcmVmLnJvb3QgOiB2b2lkIDAgOiB2b2lkIDApICsgXCJ8XCIgKyBwYXRoICsgXCI6XCIgKyAoKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoayBpbiBzdWJjbGFzc2VzKSB7XG4gICAgICAgIHYgPSBzdWJjbGFzc2VzW2tdO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKFwiXCIgKyBrICsgXCI9XCIgKyB2KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpKTtcbiAgfTtcblxuICBQYXRoSW5mbyA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBQYXRoSW5mbyhfYXJnKSB7XG4gICAgICB2YXIgX2ksIF9yZWY7XG4gICAgICB0aGlzLnJvb3QgPSBfYXJnLnJvb3QsIHRoaXMubW9kZWwgPSBfYXJnLm1vZGVsLCB0aGlzLmRlc2NyaXB0b3JzID0gX2FyZy5kZXNjcmlwdG9ycywgdGhpcy5zdWJjbGFzc2VzID0gX2FyZy5zdWJjbGFzc2VzLCB0aGlzLmRpc3BsYXlOYW1lID0gX2FyZy5kaXNwbGF5TmFtZSwgdGhpcy5pZGVudCA9IF9hcmcuaWRlbnQ7XG4gICAgICB0aGlzLmFsbERlc2NyaXB0b3JzID0gX19iaW5kKHRoaXMuYWxsRGVzY3JpcHRvcnMsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRDaGlsZE5vZGVzID0gX19iaW5kKHRoaXMuZ2V0Q2hpbGROb2RlcywgdGhpcyk7XG4gICAgICB0aGlzLmdldERpc3BsYXlOYW1lID0gX19iaW5kKHRoaXMuZ2V0RGlzcGxheU5hbWUsIHRoaXMpO1xuICAgICAgdGhpcy5pc2EgPSBfX2JpbmQodGhpcy5pc2EsIHRoaXMpO1xuICAgICAgdGhpcy5hcHBlbmQgPSBfX2JpbmQodGhpcy5hcHBlbmQsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRQYXJlbnQgPSBfX2JpbmQodGhpcy5nZXRQYXJlbnQsIHRoaXMpO1xuICAgICAgdGhpcy5nZXRFbmRDbGFzcyA9IF9fYmluZCh0aGlzLmdldEVuZENsYXNzLCB0aGlzKTtcbiAgICAgIHRoaXMuY29udGFpbnNDb2xsZWN0aW9uID0gX19iaW5kKHRoaXMuY29udGFpbnNDb2xsZWN0aW9uLCB0aGlzKTtcbiAgICAgIHRoaXMuaXNDb2xsZWN0aW9uID0gX19iaW5kKHRoaXMuaXNDb2xsZWN0aW9uLCB0aGlzKTtcbiAgICAgIHRoaXMuaXNSZXZlcnNlUmVmZXJlbmNlID0gX19iaW5kKHRoaXMuaXNSZXZlcnNlUmVmZXJlbmNlLCB0aGlzKTtcbiAgICAgIHRoaXMuaXNSZWZlcmVuY2UgPSBfX2JpbmQodGhpcy5pc1JlZmVyZW5jZSwgdGhpcyk7XG4gICAgICB0aGlzLmlzQ2xhc3MgPSBfX2JpbmQodGhpcy5pc0NsYXNzLCB0aGlzKTtcbiAgICAgIHRoaXMuaXNBdHRyaWJ1dGUgPSBfX2JpbmQodGhpcy5pc0F0dHJpYnV0ZSwgdGhpcyk7XG4gICAgICB0aGlzLmlzUm9vdCA9IF9fYmluZCh0aGlzLmlzUm9vdCwgdGhpcyk7XG4gICAgICBfcmVmID0gdGhpcy5kZXNjcmlwdG9ycywgdGhpcy5taWQgPSAyIDw9IF9yZWYubGVuZ3RoID8gX19zbGljZS5jYWxsKF9yZWYsIDAsIF9pID0gX3JlZi5sZW5ndGggLSAxKSA6IChfaSA9IDAsIFtdKSwgdGhpcy5lbmQgPSBfcmVmW19pKytdO1xuICAgICAgaWYgKHRoaXMuaWRlbnQgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmlkZW50ID0gbWFrZUtleSh0aGlzLm1vZGVsLCB0aGlzLCB0aGlzLnN1YmNsYXNzZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5pc1Jvb3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0b3JzLmxlbmd0aCA9PT0gMDtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmlzQXR0cmlidXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKHRoaXMuZW5kICE9IG51bGwpICYmICF0aGlzLmlzUmVmZXJlbmNlKCk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5pc0NsYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc1Jvb3QoKSB8fCB0aGlzLmlzUmVmZXJlbmNlKCk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5pc1JlZmVyZW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICByZXR1cm4gKChfcmVmID0gdGhpcy5lbmQpICE9IG51bGwgPyBfcmVmLnJlZmVyZW5jZWRUeXBlIDogdm9pZCAwKSAhPSBudWxsO1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUuaXNSZXZlcnNlUmVmZXJlbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZ3AsIHAsIHJlZmVyZW5jZWRUeXBlLCByZXZlcnNlUmVmZXJlbmNlLCBfcmVmO1xuICAgICAgaWYgKHRoaXMuaXNSZWZlcmVuY2UoKSAmJiAodGhpcy5taWQubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgX3JlZiA9IHRoaXMuZW5kLCByZXZlcnNlUmVmZXJlbmNlID0gX3JlZi5yZXZlcnNlUmVmZXJlbmNlLCByZWZlcmVuY2VkVHlwZSA9IF9yZWYucmVmZXJlbmNlZFR5cGU7XG4gICAgICAgIHAgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgICAgICBncCA9IHAuZ2V0UGFyZW50KCk7XG4gICAgICAgIHJldHVybiAocmVmZXJlbmNlZFR5cGUgIT0gbnVsbCkgJiYgKGdwLmlzYShyZWZlcmVuY2VkVHlwZSkpICYmIChwLmVuZC5uYW1lID09PSByZXZlcnNlUmVmZXJlbmNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmlzQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9yZWYsIF9yZWYxO1xuICAgICAgcmV0dXJuIChfcmVmID0gKF9yZWYxID0gdGhpcy5lbmQpICE9IG51bGwgPyBfcmVmMS5pc0NvbGxlY3Rpb24gOiB2b2lkIDApICE9IG51bGwgPyBfcmVmIDogZmFsc2U7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5jb250YWluc0NvbGxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBhbnkodGhpcy5kZXNjcmlwdG9ycywgZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4geC5pc0NvbGxlY3Rpb247XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLmdldEVuZENsYXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIHJldHVybiB0aGlzLm1vZGVsLmNsYXNzZXNbdGhpcy5zdWJjbGFzc2VzW3RoaXMudG9TdHJpbmcoKV0gfHwgKChfcmVmID0gdGhpcy5lbmQpICE9IG51bGwgPyBfcmVmLnJlZmVyZW5jZWRUeXBlIDogdm9pZCAwKV0gfHwgdGhpcy5yb290O1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUuZ2V0UGFyZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIGlmICh0aGlzLmlzUm9vdCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJvb3QgcGF0aHMgZG8gbm90IGhhdmUgcGFyZW50c1wiKTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIHJvb3Q6IHRoaXMucm9vdCxcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgIGRlc2NyaXB0b3JzOiB0aGlzLm1pZC5zbGljZSgpLFxuICAgICAgICBzdWJjbGFzc2VzOiB0aGlzLnN1YmNsYXNzZXNcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV3IFBhdGhJbmZvKGRhdGEpO1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24oYXR0cikge1xuICAgICAgdmFyIGRhdGEsIGZsZDtcbiAgICAgIGlmICh0aGlzLmlzQXR0cmlidXRlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIgKyB0aGlzICsgXCIgaXMgYW4gYXR0cmlidXRlLlwiKTtcbiAgICAgIH1cbiAgICAgIGZsZCA9IHR5cGVvZiBhdHRyID09PSAnc3RyaW5nJyA/IHRoaXMuZ2V0VHlwZSgpLmZpZWxkc1thdHRyXSA6IGF0dHI7XG4gICAgICBpZiAoZmxkID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIgKyBhdHRyICsgXCIgaXMgbm90IGEgZmllbGQgb2YgXCIgKyAodGhpcy5nZXRUeXBlKCkpKTtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB7XG4gICAgICAgIHJvb3Q6IHRoaXMucm9vdCxcbiAgICAgICAgbW9kZWw6IHRoaXMubW9kZWwsXG4gICAgICAgIGRlc2NyaXB0b3JzOiB0aGlzLmRlc2NyaXB0b3JzLmNvbmNhdChbZmxkXSksXG4gICAgICAgIHN1YmNsYXNzZXM6IHRoaXMuc3ViY2xhc3Nlc1xuICAgICAgfTtcbiAgICAgIHJldHVybiBuZXcgUGF0aEluZm8oZGF0YSk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5pc2EgPSBmdW5jdGlvbihjbGF6eikge1xuICAgICAgdmFyIG5hbWUsIHR5cGU7XG4gICAgICBpZiAoY2xhenogPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0F0dHJpYnV0ZSgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFR5cGUoKSA9PT0gY2xheno7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuYW1lID0gY2xhenoubmFtZSA/IGNsYXp6Lm5hbWUgOiAnJyArIGNsYXp6O1xuICAgICAgICB0eXBlID0gdGhpcy5nZXRUeXBlKCk7XG4gICAgICAgIHJldHVybiAobmFtZSA9PT0gdHlwZS5uYW1lKSB8fCAoX19pbmRleE9mLmNhbGwodGhpcy5tb2RlbC5nZXRBbmNlc3RvcnNPZih0eXBlKSwgbmFtZSkgPj0gMCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5nZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICB2YXIgY2FjaGVkLCBjdXN0b20sIHBhcmFtcywgcGF0aDtcbiAgICAgIGlmIChjdXN0b20gPSB0aGlzLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHJldHVybiBzdWNjZXNzKGN1c3RvbSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uYW1lUHJvbWlzZSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMubmFtZVByb21pc2UgPSAoY2FjaGVkID0gTkFNRVNbdGhpcy5pZGVudF0pID8gc3VjY2VzcyhjYWNoZWQpIDogdGhpcy5pc1Jvb3QoKSAmJiB0aGlzLnJvb3QuZGlzcGxheU5hbWUgPyBzdWNjZXNzKHRoaXMucm9vdC5kaXNwbGF5TmFtZSkgOiB0aGlzLm1vZGVsLnNlcnZpY2UgPT0gbnVsbCA/IGVycm9yKFwiTm8gc2VydmljZVwiKSA6IChwYXRoID0gJ21vZGVsJyArIChjb25jYXRNYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHJldHVybiAnLycgKyBkLm5hbWU7XG4gICAgICAgIH0pKSh0aGlzLmFsbERlc2NyaXB0b3JzKCkpLCBwYXJhbXMgPSAoc2V0KHtcbiAgICAgICAgICBmb3JtYXQ6ICdqc29uJ1xuICAgICAgICB9KSkoY29weSh0aGlzLnN1YmNsYXNzZXMpKSwgdGhpcy5tb2RlbC5zZXJ2aWNlLmdldChwYXRoLCBwYXJhbXMpLnRoZW4oZ2V0KCdkaXNwbGF5JykpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHZhciBfbmFtZTtcbiAgICAgICAgICAgIHJldHVybiBOQU1FU1tfbmFtZSA9IF90aGlzLmlkZW50XSAhPSBudWxsID8gTkFNRVNbX25hbWVdIDogTkFNRVNbX25hbWVdID0gbjtcbiAgICAgICAgICB9O1xuICAgICAgICB9KSh0aGlzKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5uYW1lUHJvbWlzZSk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5nZXRDaGlsZE5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmxkLCBuYW1lLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICBfcmVmMSA9ICgoX3JlZiA9IHRoaXMuZ2V0RW5kQ2xhc3MoKSkgIT0gbnVsbCA/IF9yZWYuZmllbGRzIDogdm9pZCAwKSB8fCB7fTtcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKG5hbWUgaW4gX3JlZjEpIHtcbiAgICAgICAgZmxkID0gX3JlZjFbbmFtZV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2godGhpcy5hcHBlbmQoZmxkKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5hbGxEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLnJvb3RdLmNvbmNhdCh0aGlzLmRlc2NyaXB0b3JzKTtcbiAgICB9O1xuXG4gICAgUGF0aEluZm8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5hbGxEZXNjcmlwdG9ycygpLm1hcChnZXQoJ25hbWUnKSkuam9pbignLicpO1xuICAgIH07XG5cbiAgICBQYXRoSW5mby5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzID09PSBvdGhlciB8fCAodGhpcy5pZGVudCAmJiAob3RoZXIgIT0gbnVsbCA/IG90aGVyLmlkZW50IDogdm9pZCAwKSA9PT0gdGhpcy5pZGVudCk7XG4gICAgfTtcblxuICAgIFBhdGhJbmZvLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZiwgX3JlZjE7XG4gICAgICByZXR1cm4gKChfcmVmID0gdGhpcy5lbmQpICE9IG51bGwgPyAoX3JlZjEgPSBfcmVmLnR5cGUpICE9IG51bGwgPyBfcmVmMS5yZXBsYWNlKC9qYXZhXFwubGFuZ1xcLi8sICcnKSA6IHZvaWQgMCA6IHZvaWQgMCkgfHwgdGhpcy5nZXRFbmRDbGFzcygpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGF0aEluZm87XG5cbiAgfSkoKTtcblxuICBQYXRoSW5mby5wcm90b3R5cGUudG9QYXRoU3RyaW5nID0gUGF0aEluZm8ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gIFBhdGhJbmZvLnBhcnNlID0gZnVuY3Rpb24obW9kZWwsIHBhdGgsIHN1YmNsYXNzZXMpIHtcbiAgICB2YXIgY2FjaGVkLCBjZCwgZGVzY3JpcHRvcnMsIGZsZCwgaWRlbnQsIGtleVBhdGgsIHBhcnQsIHBhcnRzLCByb290O1xuICAgIGlmIChzdWJjbGFzc2VzID09IG51bGwpIHtcbiAgICAgIHN1YmNsYXNzZXMgPSB7fTtcbiAgICB9XG4gICAgaWRlbnQgPSBtYWtlS2V5KG1vZGVsLCBwYXRoLCBzdWJjbGFzc2VzKTtcbiAgICBpZiAoY2FjaGVkID0gUEFSU0VEW2lkZW50XSkge1xuICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICB9XG4gICAgcGFydHMgPSAocGF0aCArICcnKS5zcGxpdCgnLicpO1xuICAgIHJvb3QgPSBjZCA9IG1vZGVsLmNsYXNzZXNbcGFydHMuc2hpZnQoKV07XG4gICAga2V5UGF0aCA9IHJvb3QubmFtZTtcbiAgICBkZXNjcmlwdG9ycyA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBwYXJ0cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYXJ0ID0gcGFydHNbX2ldO1xuICAgICAgICBmbGQgPSAoY2QgIT0gbnVsbCA/IGNkLmZpZWxkc1twYXJ0XSA6IHZvaWQgMCkgfHwgKChfcmVmID0gKGNkID0gbW9kZWwuY2xhc3Nlc1tzdWJjbGFzc2VzW2tleVBhdGhdXSkpICE9IG51bGwgPyBfcmVmLmZpZWxkc1twYXJ0XSA6IHZvaWQgMCk7XG4gICAgICAgIGlmICghZmxkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgXCIgKyBwYXJ0ICsgXCIgaW4gXCIgKyBjZCArIFwiIHdoZW4gcGFyc2luZyBcIiArIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGtleVBhdGggKz0gXCIuXCIgKyBwYXJ0O1xuICAgICAgICBjZCA9IG1vZGVsLmNsYXNzZXNbZmxkLnR5cGUgfHwgZmxkLnJlZmVyZW5jZWRUeXBlXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChmbGQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIFBBUlNFRFtpZGVudF0gPSBuZXcgUGF0aEluZm8oe1xuICAgICAgcm9vdDogcm9vdCxcbiAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgIGRlc2NyaXB0b3JzOiBkZXNjcmlwdG9ycyxcbiAgICAgIHN1YmNsYXNzZXM6IHN1YmNsYXNzZXMsXG4gICAgICBpZGVudDogaWRlbnRcbiAgICB9KTtcbiAgfTtcblxuICBQYXRoSW5mby5mbHVzaENhY2hlID0gZnVuY3Rpb24oKSB7XG4gICAgUEFSU0VEID0ge307XG4gICAgcmV0dXJuIE5BTUVTID0ge307XG4gIH07XG5cbiAgaW50ZXJtaW5lLlBhdGhJbmZvID0gUGF0aEluZm87XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi91dGlsXCI6MTV9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIFByb21pc2U7XG5cbiAgUHJvbWlzZSA9IF9kZXJlcV8oJ2VzNi1wcm9taXNlJykuUHJvbWlzZTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiZXM2LXByb21pc2VcIjoyMn1dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgQkFTSUNfQVRUUlMsIENPREVTLCBFdmVudHMsIExJU1RfUElQRSwgUXVlcnksIFJFUVVJUkVTX1ZFUlNJT04sIFJFU1VMVFNfTUVUSE9EUywgU0lNUExFX0FUVFJTLCBiaW9VcmlBcmdzLCBjb25BdHRycywgY29uU3RyLCBjb25Ub0pTT04sIGNvblZhbFN0ciwgY29uY2F0TWFwLCBjb3B5Q29uLCBkZWNhcGl0YXRlLCBkaWRudFJlbW92ZSwgZiwgZmlsdGVyLCBmb2xkLCBnZXQsIGdldF9jYW5vbmljYWxfb3AsIGhlYWRMZXNzLCBpZCwgaWRDb25TdHIsIGludGVybWluZSwgaW50ZXJwcmV0Q29uQXJyYXksIGludGVycHJldENvbnN0cmFpbnQsIGludm9rZSwgbWVyZ2UsIG10aCwgbXVsdGlDb25TdHIsIG5vVW5kZWZWYWxzLCBub1ZhbHVlQ29uU3RyLCBwYXJ0aXRpb24sIHJlbW92ZUlycmVsZXZhbnRTb3J0T3JkZXJzLCBzaW1wbGVDb25TdHIsIHN0cmluZ1RvU29ydE9yZGVyLCBzdHJpbmdpZnlTb3J0T3JkZXIsIHRvUXVlcnlTdHJpbmcsIHR5cGVDb25TdHIsIHVuaW9uLCB1dGlscywgd2l0aENCLCBfZm4sIF9nZXRfZGF0YV9mZXRjaGVyLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmLFxuICAgIF9faW5kZXhPZiA9IFtdLmluZGV4T2YgfHwgZnVuY3Rpb24oaXRlbSkgeyBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7IGlmIChpIGluIHRoaXMgJiYgdGhpc1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7IH0gcmV0dXJuIC0xOyB9LFxuICAgIF9fYmluZCA9IGZ1bmN0aW9uKGZuLCBtZSl7IHJldHVybiBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkobWUsIGFyZ3VtZW50cyk7IH07IH0sXG4gICAgX19zbGljZSA9IFtdLnNsaWNlLFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5O1xuXG4gIEV2ZW50cyA9IF9kZXJlcV8oJ2JhY2tib25lLWV2ZW50cy1zdGFuZGFsb25lJyk7XG5cbiAgaW50ZXJtaW5lID0gZXhwb3J0cztcblxuICBpbnRlcm1pbmUueG1sID0gX2RlcmVxXygnLi94bWwnKTtcblxuICB1dGlscyA9IF9kZXJlcV8oJy4vdXRpbCcpO1xuXG4gIFJFUVVJUkVTX1ZFUlNJT04gPSB1dGlscy5SRVFVSVJFU19WRVJTSU9OLCB3aXRoQ0IgPSB1dGlscy53aXRoQ0IsIG1lcmdlID0gdXRpbHMubWVyZ2UsIGZpbHRlciA9IHV0aWxzLmZpbHRlciwgcGFydGl0aW9uID0gdXRpbHMucGFydGl0aW9uLCBmb2xkID0gdXRpbHMuZm9sZCwgY29uY2F0TWFwID0gdXRpbHMuY29uY2F0TWFwLCBpZCA9IHV0aWxzLmlkLCBnZXQgPSB1dGlscy5nZXQsIGludm9rZSA9IHV0aWxzLmludm9rZTtcblxuICB0b1F1ZXJ5U3RyaW5nID0gdXRpbHMucXVlcnlzdHJpbmc7XG5cbiAgZ2V0X2Nhbm9uaWNhbF9vcCA9IGZ1bmN0aW9uKG9yaWcpIHtcbiAgICB2YXIgY2Fub25pY2FsO1xuICAgIGNhbm9uaWNhbCA9IChvcmlnICE9IG51bGwgPyBvcmlnLnRvTG93ZXJDYXNlIDogdm9pZCAwKSAhPSBudWxsID8gUXVlcnkuT1BfRElDVFtvcmlnLnRvTG93ZXJDYXNlKCldIDogbnVsbDtcbiAgICBpZiAoIWNhbm9uaWNhbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBjb25zdHJhaW50IG9wZXJhdG9yOiBcIiArIG9yaWcpO1xuICAgIH1cbiAgICByZXR1cm4gY2Fub25pY2FsO1xuICB9O1xuXG4gIEJBU0lDX0FUVFJTID0gWydwYXRoJywgJ29wJywgJ2NvZGUnXTtcblxuICBTSU1QTEVfQVRUUlMgPSBCQVNJQ19BVFRSUy5jb25jYXQoWyd2YWx1ZScsICdleHRyYVZhbHVlJ10pO1xuXG4gIFJFU1VMVFNfTUVUSE9EUyA9IFsncm93QnlSb3cnLCAnZWFjaFJvdycsICdyZWNvcmRCeVJlY29yZCcsICdlYWNoUmVjb3JkJywgJ3JlY29yZHMnLCAncm93cycsICd0YWJsZScsICd0YWJsZVJvd3MnLCAndmFsdWVzJ107XG5cbiAgTElTVF9QSVBFID0gZnVuY3Rpb24oc2VydmljZSkge1xuICAgIHJldHVybiB1dGlscy5jb21wb3NlKHNlcnZpY2UuZmV0Y2hMaXN0LCBnZXQoJ2xpc3ROYW1lJykpO1xuICB9O1xuXG4gIENPREVTID0gWydBJywgJ0InLCAnQycsICdEJywgJ0UnLCAnRicsICdHJywgJ0gnLCAnSScsICdKJywgJ0snLCAnTCcsICdNJywgJ04nLCAnTycsICdQJywgJ1EnLCAnUicsICdTJywgJ1QnLCAnVScsICdWJywgJ1cnLCAnWCcsICdZJywgJ1onXTtcblxuICBkZWNhcGl0YXRlID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09IG51bGwpIHtcbiAgICAgIHggPSAnJztcbiAgICB9XG4gICAgcmV0dXJuIHguc3Vic3RyKHguaW5kZXhPZignLicpKTtcbiAgfTtcblxuICBjb25WYWxTdHIgPSBmdW5jdGlvbih2KSB7XG4gICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFwiPHZhbHVlPlwiICsgKHV0aWxzLmVzY2FwZSh2KSkgKyBcIjwvdmFsdWU+XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcIjxudWxsVmFsdWUvPlwiO1xuICAgIH1cbiAgfTtcblxuICBjb25BdHRycyA9IGZ1bmN0aW9uKGMsIG5hbWVzKSB7XG4gICAgdmFyIGssIHY7XG4gICAgcmV0dXJuICgoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChrIGluIGMpIHtcbiAgICAgICAgdiA9IGNba107XG4gICAgICAgIGlmICgoX19pbmRleE9mLmNhbGwobmFtZXMsIGspID49IDApKSB7XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaChcIlwiICsgayArIFwiPVxcXCJcIiArICh1dGlscy5lc2NhcGUodikpICsgXCJcXFwiIFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pKCkpLmpvaW4oJycpO1xuICB9O1xuXG4gIG5vVmFsdWVDb25TdHIgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIFwiPGNvbnN0cmFpbnQgXCIgKyAoY29uQXR0cnMoYywgQkFTSUNfQVRUUlMpKSArIFwiLz5cIjtcbiAgfTtcblxuICB0eXBlQ29uU3RyID0gZnVuY3Rpb24oYykge1xuICAgIHJldHVybiBcIjxjb25zdHJhaW50IFwiICsgKGNvbkF0dHJzKGMsIFsncGF0aCcsICd0eXBlJ10pKSArIFwiLz5cIjtcbiAgfTtcblxuICBzaW1wbGVDb25TdHIgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIFwiPGNvbnN0cmFpbnQgXCIgKyAoY29uQXR0cnMoYywgU0lNUExFX0FUVFJTKSkgKyBcIi8+XCI7XG4gIH07XG5cbiAgbXVsdGlDb25TdHIgPSBmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuIFwiPGNvbnN0cmFpbnQgXCIgKyAoY29uQXR0cnMoYywgQkFTSUNfQVRUUlMpKSArIFwiPlwiICsgKGNvbmNhdE1hcChjb25WYWxTdHIpKGMudmFsdWVzKSkgKyBcIjwvY29uc3RyYWludD5cIjtcbiAgfTtcblxuICBpZENvblN0ciA9IGZ1bmN0aW9uKGMpIHtcbiAgICByZXR1cm4gXCI8Y29uc3RyYWludCBcIiArIChjb25BdHRycyhjLCBCQVNJQ19BVFRSUykpICsgXCJpZHM9XFxcIlwiICsgKGMuaWRzLmpvaW4oJywnKSkgKyBcIlxcXCIvPlwiO1xuICB9O1xuXG4gIGNvblN0ciA9IGZ1bmN0aW9uKGMpIHtcbiAgICB2YXIgX3JlZjtcbiAgICBpZiAoYy52YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG11bHRpQ29uU3RyKGMpO1xuICAgIH0gZWxzZSBpZiAoYy5pZHMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGlkQ29uU3RyKGMpO1xuICAgIH0gZWxzZSBpZiAoYy5vcCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHlwZUNvblN0cihjKTtcbiAgICB9IGVsc2UgaWYgKF9yZWYgPSBjLm9wLCBfX2luZGV4T2YuY2FsbChRdWVyeS5OVUxMX09QUywgX3JlZikgPj0gMCkge1xuICAgICAgcmV0dXJuIG5vVmFsdWVDb25TdHIoYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzaW1wbGVDb25TdHIoYyk7XG4gICAgfVxuICB9O1xuXG4gIGhlYWRMZXNzID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHJldHVybiBwYXRoLnJlcGxhY2UoL15bXlxcLl0rXFwuLywgJycpO1xuICB9O1xuXG4gIGNvcHlDb24gPSBmdW5jdGlvbihjb24pIHtcbiAgICB2YXIgY29kZSwgZWRpdGFibGUsIGV4dHJhVmFsdWUsIGlkcywgb3AsIHBhdGgsIHN3aXRjaGFibGUsIHN3aXRjaGVkLCB0eXBlLCB2YWx1ZSwgdmFsdWVzO1xuICAgIHBhdGggPSBjb24ucGF0aCwgdHlwZSA9IGNvbi50eXBlLCBvcCA9IGNvbi5vcCwgdmFsdWUgPSBjb24udmFsdWUsIHZhbHVlcyA9IGNvbi52YWx1ZXMsIGV4dHJhVmFsdWUgPSBjb24uZXh0cmFWYWx1ZSwgaWRzID0gY29uLmlkcywgY29kZSA9IGNvbi5jb2RlLCBlZGl0YWJsZSA9IGNvbi5lZGl0YWJsZSwgc3dpdGNoZWQgPSBjb24uc3dpdGNoZWQsIHN3aXRjaGFibGUgPSBjb24uc3dpdGNoYWJsZTtcbiAgICBpZHMgPSBpZHMgIT0gbnVsbCA/IGlkcy5zbGljZSgpIDogdm9pZCAwO1xuICAgIHZhbHVlcyA9IHZhbHVlcyAhPSBudWxsID8gdmFsdWVzLnNsaWNlKCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG5vVW5kZWZWYWxzKHtcbiAgICAgIHBhdGg6IHBhdGgsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgb3A6IG9wLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICBleHRyYVZhbHVlOiBleHRyYVZhbHVlLFxuICAgICAgaWRzOiBpZHMsXG4gICAgICBjb2RlOiBjb2RlLFxuICAgICAgZWRpdGFibGU6IGVkaXRhYmxlLFxuICAgICAgc3dpdGNoZWQ6IHN3aXRjaGVkLFxuICAgICAgc3dpdGNoYWJsZTogc3dpdGNoYWJsZVxuICAgIH0pO1xuICB9O1xuXG4gIGNvblRvSlNPTiA9IGZ1bmN0aW9uKGNvbikge1xuICAgIHZhciBjb3B5O1xuICAgIGNvcHkgPSBjb3B5Q29uKGNvbik7XG4gICAgY29weS5wYXRoID0gaGVhZExlc3MoY29weS5wYXRoKTtcbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICBub1VuZGVmVmFscyA9IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgaywgdjtcbiAgICBmb3IgKGsgaW4geCkge1xuICAgICAgdiA9IHhba107XG4gICAgICBpZiAodiA9PSBudWxsKSB7XG4gICAgICAgIGRlbGV0ZSB4W2tdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geDtcbiAgfTtcblxuICBkaWRudFJlbW92ZSA9IGZ1bmN0aW9uKG9yaWcsIHJlZHVjZWQpIHtcbiAgICByZXR1cm4gXCJEaWQgbm90IHJlbW92ZSBhIHNpbmdsZSBjb25zdHJhaW50LiBvcmlnaW5hbCA9IFwiICsgb3JpZyArIFwiLCByZWR1Y2VkID0gXCIgKyByZWR1Y2VkO1xuICB9O1xuXG4gIGludGVycHJldENvbnN0cmFpbnQgPSBmdW5jdGlvbihwYXRoLCBjb24pIHtcbiAgICB2YXIgY29uc3RyYWludCwgaywga2V5cywgdiwgeCwgX3JlZiwgX3JlZjE7XG4gICAgY29uc3RyYWludCA9IHtcbiAgICAgIHBhdGg6IHBhdGhcbiAgICB9O1xuICAgIGlmIChjb24gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0cmFpbnQub3AgPSAnSVMgTlVMTCc7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KGNvbikpIHtcbiAgICAgIGNvbnN0cmFpbnQub3AgPSAnT05FIE9GJztcbiAgICAgIGNvbnN0cmFpbnQudmFsdWVzID0gY29uO1xuICAgIH0gZWxzZSBpZiAoKF9yZWYgPSB0eXBlb2YgY29uKSA9PT0gJ3N0cmluZycgfHwgX3JlZiA9PT0gJ251bWJlcicgfHwgX3JlZiA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBpZiAoX3JlZjEgPSB0eXBlb2YgY29uLnRvVXBwZXJDYXNlID09PSBcImZ1bmN0aW9uXCIgPyBjb24udG9VcHBlckNhc2UoKSA6IHZvaWQgMCwgX19pbmRleE9mLmNhbGwoUXVlcnkuTlVMTF9PUFMsIF9yZWYxKSA+PSAwKSB7XG4gICAgICAgIGNvbnN0cmFpbnQub3AgPSBjb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdHJhaW50Lm9wID0gJz0nO1xuICAgICAgICBjb25zdHJhaW50LnZhbHVlID0gY29uO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoayBpbiBjb24pIHtcbiAgICAgICAgICB4ID0gY29uW2tdO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChrZXlzLCAnaXNhJykgPj0gMCkge1xuICAgICAgICBpZiAodXRpbHMuaXNBcnJheShjb24uaXNhKSkge1xuICAgICAgICAgIGNvbnN0cmFpbnQub3AgPSBrO1xuICAgICAgICAgIGNvbnN0cmFpbnQudmFsdWVzID0gY29uLmlzYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdHJhaW50LnR5cGUgPSBjb24uaXNhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX19pbmRleE9mLmNhbGwoa2V5cywgJ2V4dHJhVmFsdWUnKSA+PSAwKSB7XG4gICAgICAgICAgY29uc3RyYWludC5leHRyYVZhbHVlID0gY29uLmV4dHJhVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChrIGluIGNvbikge1xuICAgICAgICAgIHYgPSBjb25ba107XG4gICAgICAgICAgaWYgKCEoayAhPT0gJ2V4dHJhVmFsdWUnKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0cmFpbnQub3AgPSBrO1xuICAgICAgICAgIGlmICh1dGlscy5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICBjb25zdHJhaW50LnZhbHVlcyA9IHY7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbnQudmFsdWUgPSB2O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludDtcbiAgfTtcblxuICBpbnRlcnByZXRDb25BcnJheSA9IGZ1bmN0aW9uKGNvbkFyZ3MpIHtcbiAgICB2YXIgYTAsIGNvbnN0cmFpbnQsIHYsIF9yZWY7XG4gICAgY29uQXJncyA9IGNvbkFyZ3Muc2xpY2UoKTtcbiAgICBjb25zdHJhaW50ID0ge1xuICAgICAgcGF0aDogY29uQXJncy5zaGlmdCgpXG4gICAgfTtcbiAgICBpZiAoY29uQXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGEwID0gY29uQXJnc1swXTtcbiAgICAgIGlmIChfcmVmID0gdHlwZW9mIGEwLnRvVXBwZXJDYXNlID09PSBcImZ1bmN0aW9uXCIgPyBhMC50b1VwcGVyQ2FzZSgpIDogdm9pZCAwLCBfX2luZGV4T2YuY2FsbChRdWVyeS5OVUxMX09QUywgX3JlZikgPj0gMCkge1xuICAgICAgICBjb25zdHJhaW50Lm9wID0gYTA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdHJhaW50LnR5cGUgPSBhMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNvbkFyZ3MubGVuZ3RoID49IDIpIHtcbiAgICAgIGNvbnN0cmFpbnQub3AgPSBjb25BcmdzWzBdO1xuICAgICAgdiA9IGNvbkFyZ3NbMV07XG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2KSkge1xuICAgICAgICBjb25zdHJhaW50LnZhbHVlcyA9IHY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdHJhaW50LnZhbHVlID0gdjtcbiAgICAgIH1cbiAgICAgIGlmIChjb25BcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgICBjb25zdHJhaW50LmV4dHJhVmFsdWUgPSBjb25BcmdzWzJdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uc3RyYWludDtcbiAgfTtcblxuICBzdHJpbmdpZnlTb3J0T3JkZXIgPSBmdW5jdGlvbihzb3J0T3JkZXIpIHtcbiAgICB2YXIgb2U7XG4gICAgcmV0dXJuICgoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gc29ydE9yZGVyLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG9lID0gc29ydE9yZGVyW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChcIlwiICsgb2UucGF0aCArIFwiIFwiICsgb2UuZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpKS5qb2luKCcgJyk7XG4gIH07XG5cbiAgc3RyaW5nVG9Tb3J0T3JkZXIgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgaSwgcGFydHMsIHBhdGhJbmRpY2VzLCB4LCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHBhcnRzID0gc3RyLnNwbGl0KC9cXHMrLyk7XG4gICAgcGF0aEluZGljZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2ksIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoeCA9IF9pID0gMCwgX3JlZiA9IHBhcnRzLmxlbmd0aCAvIDI7IDAgPD0gX3JlZiA/IF9pIDwgX3JlZiA6IF9pID4gX3JlZjsgeCA9IDAgPD0gX3JlZiA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgIF9yZXN1bHRzLnB1c2goeCAqIDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pKCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHBhdGhJbmRpY2VzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICBpID0gcGF0aEluZGljZXNbX2ldO1xuICAgICAgX3Jlc3VsdHMucHVzaChbcGFydHNbaV0sIHBhcnRzW2kgKyAxXV0pO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgcmVtb3ZlSXJyZWxldmFudFNvcnRPcmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2UsIG9sZE9yZGVyO1xuICAgIG9sZE9yZGVyID0gdGhpcy5zb3J0T3JkZXI7XG4gICAgdGhpcy5zb3J0T3JkZXIgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gb2xkT3JkZXIubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgb2UgPSBvbGRPcmRlcltfaV07XG4gICAgICAgIGlmICh0aGlzLmlzUmVsZXZhbnQob2UucGF0aCkpIHtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKG9lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH0pLmNhbGwodGhpcyk7XG4gICAgaWYgKG9sZE9yZGVyLmxlbmd0aCAhPT0gdGhpcy5zb3J0T3JkZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmlnZ2VyKCdjaGFuZ2U6c29ydG9yZGVyIGNoYW5nZTpvcmRlcmJ5JywgdGhpcy5zb3J0T3JkZXIuc2xpY2UoKSk7XG4gICAgfVxuICB9O1xuXG4gIFF1ZXJ5ID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBhZGRQSSwgY0F0dHJzLCBraWRzLCBwYXJzZVN1bW1hcnksIHFBdHRycywgc2NGb2xkLCB0b0F0dHJQYWlycywgdG9QYXRoQW5kVHlwZSwgeG1sQXR0cjtcblxuICAgIFF1ZXJ5LkpPSU5fU1RZTEVTID0gWydJTk5FUicsICdPVVRFUiddO1xuXG4gICAgUXVlcnkuQklPX0ZPUk1BVFMgPSBbJ2dmZjMnLCAnZmFzdGEnLCAnYmVkJ107XG5cbiAgICBRdWVyeS5OVUxMX09QUyA9IFsnSVMgTlVMTCcsICdJUyBOT1QgTlVMTCddO1xuXG4gICAgUXVlcnkuQVRUUklCVVRFX1ZBTFVFX09QUyA9IFtcIj1cIiwgXCIhPVwiLCBcIj5cIiwgXCI+PVwiLCBcIjxcIiwgXCI8PVwiLCBcIkNPTlRBSU5TXCIsIFwiTElLRVwiLCBcIk5PVCBMSUtFXCJdO1xuXG4gICAgUXVlcnkuTVVMVElWQUxVRV9PUFMgPSBbJ09ORSBPRicsICdOT05FIE9GJ107XG5cbiAgICBRdWVyeS5SQU5HRV9PUFMgPSBbJ09WRVJMQVBTJywgJ0RPRVMgTk9UIE9WRVJMQVAnLCAnT1VUU0lERScsICdXSVRISU4nLCAnQ09OVEFJTlMnLCAnRE9FUyBOT1QgQ09OVEFJTiddO1xuXG4gICAgUXVlcnkuVEVSTkFSWV9PUFMgPSBbJ0xPT0tVUCddO1xuXG4gICAgUXVlcnkuTE9PUF9PUFMgPSBbJz0nLCAnIT0nXTtcblxuICAgIFF1ZXJ5LkxJU1RfT1BTID0gWydJTicsICdOT1QgSU4nXTtcblxuICAgIFF1ZXJ5Lk9QX0RJQ1QgPSB7XG4gICAgICAnPSc6ICc9JyxcbiAgICAgICc9PSc6ICc9PScsXG4gICAgICAnZXEnOiAnPScsXG4gICAgICAnZXFxJzogJz09JyxcbiAgICAgICchPSc6ICchPScsXG4gICAgICAnbmUnOiAnIT0nLFxuICAgICAgJz4nOiAnPicsXG4gICAgICAnZ3QnOiAnPicsXG4gICAgICAnPj0nOiAnPj0nLFxuICAgICAgJ2dlJzogJz49JyxcbiAgICAgICc8JzogJzwnLFxuICAgICAgJ2x0JzogJzwnLFxuICAgICAgJzw9JzogJzw9JyxcbiAgICAgICdsZSc6ICc8PScsXG4gICAgICAnY29udGFpbnMnOiAnQ09OVEFJTlMnLFxuICAgICAgJ0NPTlRBSU5TJzogJ0NPTlRBSU5TJyxcbiAgICAgICdkb2VzIG5vdCBjb250YWluJzogJ0RPRVMgTk9UIENPTlRBSU4nLFxuICAgICAgJ0RPRVMgTk9UIENPTlRBSU4nOiAnRE9FUyBOT1QgQ09OVEFJTicsXG4gICAgICAnbGlrZSc6ICdMSUtFJyxcbiAgICAgICdMSUtFJzogJ0xJS0UnLFxuICAgICAgJ25vdCBsaWtlJzogJ05PVCBMSUtFJyxcbiAgICAgICdOT1QgTElLRSc6ICdOT1QgTElLRScsXG4gICAgICAnbG9va3VwJzogJ0xPT0tVUCcsXG4gICAgICAnSVMgTlVMTCc6ICdJUyBOVUxMJyxcbiAgICAgICdpcyBudWxsJzogJ0lTIE5VTEwnLFxuICAgICAgJ0lTIE5PVCBOVUxMJzogJ0lTIE5PVCBOVUxMJyxcbiAgICAgICdpcyBub3QgbnVsbCc6ICdJUyBOT1QgTlVMTCcsXG4gICAgICAnT05FIE9GJzogJ09ORSBPRicsXG4gICAgICAnb25lIG9mJzogJ09ORSBPRicsXG4gICAgICAnTk9ORSBPRic6ICdOT05FIE9GJyxcbiAgICAgICdub25lIG9mJzogJ05PTkUgT0YnLFxuICAgICAgJ2luJzogJ0lOJyxcbiAgICAgICdub3QgaW4nOiAnTk9UIElOJyxcbiAgICAgICdJTic6ICdJTicsXG4gICAgICAnTk9UIElOJzogJ05PVCBJTicsXG4gICAgICAnV0lUSElOJzogJ1dJVEhJTicsXG4gICAgICAnd2l0aGluJzogJ1dJVEhJTicsXG4gICAgICAnT1ZFUkxBUFMnOiAnT1ZFUkxBUFMnLFxuICAgICAgJ292ZXJsYXBzJzogJ09WRVJMQVBTJyxcbiAgICAgICdET0VTIE5PVCBPVkVSTEFQJzogJ0RPRVMgTk9UIE9WRVJMQVAnLFxuICAgICAgJ2RvZXMgbm90IG92ZXJsYXAnOiAnRE9FUyBOT1QgT1ZFUkxBUCcsXG4gICAgICAnT1VUU0lERSc6ICdPVVRTSURFJyxcbiAgICAgICdvdXRzaWRlJzogJ09VVFNJREUnLFxuICAgICAgJ0lTQSc6ICdJU0EnLFxuICAgICAgJ2lzYSc6ICdJU0EnXG4gICAgfTtcblxuICAgIHFBdHRycyA9IFsnbmFtZScsICd2aWV3JywgJ3NvcnRPcmRlcicsICdjb25zdHJhaW50TG9naWMnLCAndGl0bGUnLCAnZGVzY3JpcHRpb24nLCAnY29tbWVudCddO1xuXG4gICAgY0F0dHJzID0gWydwYXRoJywgJ3R5cGUnLCAnb3AnLCAnY29kZScsICd2YWx1ZScsICdpZHMnXTtcblxuICAgIHRvQXR0clBhaXJzID0gZnVuY3Rpb24oZWwsIGF0dHJzKSB7XG4gICAgICB2YXIgeCwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gYXR0cnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgeCA9IGF0dHJzW19pXTtcbiAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSh4KSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goW3gsIGVsLmdldEF0dHJpYnV0ZSh4KV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcblxuICAgIGtpZHMgPSBmdW5jdGlvbihlbCwgbmFtZSkge1xuICAgICAgdmFyIGtpZCwgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgX3JlZiA9IGVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBraWQgPSBfcmVmW19pXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChraWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgIH07XG5cbiAgICB4bWxBdHRyID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBRdWVyeS5mcm9tWE1MID0gZnVuY3Rpb24oeG1sKSB7XG4gICAgICB2YXIgY29uLCBkb20sIGosIHBhdGhPZiwgcSwgcXVlcnksIHN0eWxlT2Y7XG4gICAgICBkb20gPSBpbnRlcm1pbmUueG1sLnBhcnNlKHhtbCk7XG4gICAgICBxdWVyeSA9IGtpZHMoZG9tLCAncXVlcnknKVswXSB8fCBraWRzKGRvbSwgJ3RlbXBsYXRlJylbMF07XG4gICAgICBpZiAoIXF1ZXJ5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIHF1ZXJ5IGluIHhtbFwiKTtcbiAgICAgIH1cbiAgICAgIHBhdGhPZiA9IHhtbEF0dHIoJ3BhdGgnKTtcbiAgICAgIHN0eWxlT2YgPSB4bWxBdHRyKCdzdHlsZScpO1xuICAgICAgcSA9IHV0aWxzLnBhaXJzVG9PYmoodG9BdHRyUGFpcnMocXVlcnksIHFBdHRycykpO1xuICAgICAgcS52aWV3ID0gcS52aWV3LnNwbGl0KC9cXHMrLyk7XG4gICAgICBxLnNvcnRPcmRlciA9IHN0cmluZ1RvU29ydE9yZGVyKHEuc29ydE9yZGVyKTtcbiAgICAgIHEuam9pbnMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSBraWRzKHF1ZXJ5LCAnam9pbicpO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBqID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKHN0eWxlT2YoaikgPT09ICdPVVRFUicpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gocGF0aE9mKGopKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKTtcbiAgICAgIHEuY29uc3RyYWludHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSBraWRzKHF1ZXJ5LCAnY29uc3RyYWludCcpO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBjb24gPSBfcmVmW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKChmdW5jdGlvbihjb24pIHtcbiAgICAgICAgICAgIHZhciBjLCB0biwgdiwgdmFsdWVzLCB4O1xuICAgICAgICAgICAgYyA9IHV0aWxzLnBhaXJzVG9PYmoodG9BdHRyUGFpcnMoY29uLCBjQXR0cnMpKTtcbiAgICAgICAgICAgIGlmIChjLmlkcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGMuaWRzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZWYxLCBfcmVzdWx0czE7XG4gICAgICAgICAgICAgICAgX3JlZjEgPSBjLmlkcy5zcGxpdCgnLCcpO1xuICAgICAgICAgICAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYxLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICAgICAgeCA9IF9yZWYxW19qXTtcbiAgICAgICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHBhcnNlSW50KHgsIDEwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZXMgPSBraWRzKGNvbiwgJ3ZhbHVlJyk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjLnZhbHVlcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2osIF9sZW4xLCBfcmVzdWx0czE7XG4gICAgICAgICAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gdmFsdWVzLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICAgICAgdiA9IHZhbHVlc1tfal07XG4gICAgICAgICAgICAgICAgICBfcmVzdWx0czEucHVzaCgoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ssIF9sZW4yLCBfcmVmMSwgX3Jlc3VsdHMyO1xuICAgICAgICAgICAgICAgICAgICBfcmVmMSA9IHYuY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMyID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IF9yZWYxLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgICAgICAgICAgICAgIHRuID0gX3JlZjFbX2tdO1xuICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHRzMi5wdXNoKHRuLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0czI7XG4gICAgICAgICAgICAgICAgICB9KSgpKS5qb2luKCcnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgICB9KShjb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpO1xuICAgICAgcmV0dXJuIHE7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5jb25zdHJhaW50cyA9IFtdO1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnZpZXdzID0gW107XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuam9pbnMgPSB7fTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5jb25zdHJhaW50TG9naWMgPSAnJztcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5zb3J0T3JkZXIgPSAnJztcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5uYW1lID0gbnVsbDtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS50aXRsZSA9IG51bGw7XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuY29tbWVudCA9IG51bGw7XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZGVzY3JpcHRpb24gPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gUXVlcnkocHJvcGVydGllcywgc2VydmljZSwgX2FyZykge1xuICAgICAgdmFyIG1vZGVsLCBwcm9wLCBzdW1tYXJ5RmllbGRzLCBfaSwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZWYxMCwgX3JlZjIsIF9yZWYzLCBfcmVmNCwgX3JlZjUsIF9yZWY2LCBfcmVmNywgX3JlZjgsIF9yZWY5O1xuICAgICAgX3JlZiA9IF9hcmcgIT0gbnVsbCA/IF9hcmcgOiB7fSwgbW9kZWwgPSBfcmVmLm1vZGVsLCBzdW1tYXJ5RmllbGRzID0gX3JlZi5zdW1tYXJ5RmllbGRzO1xuICAgICAgdGhpcy5hZGRDb25zdHJhaW50ID0gX19iaW5kKHRoaXMuYWRkQ29uc3RyYWludCwgdGhpcyk7XG4gICAgICB0aGlzLmV4cGFuZFN0YXIgPSBfX2JpbmQodGhpcy5leHBhbmRTdGFyLCB0aGlzKTtcbiAgICAgIHRoaXMuYWRqdXN0UGF0aCA9IF9fYmluZCh0aGlzLmFkanVzdFBhdGgsIHRoaXMpO1xuICAgICAgdGhpcy5zZWxlY3QgPSBfX2JpbmQodGhpcy5zZWxlY3QsIHRoaXMpO1xuICAgICAgaWYgKHByb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnN0cmFpbnRzID0gW107XG4gICAgICB0aGlzLnZpZXdzID0gW107XG4gICAgICB0aGlzLmpvaW5zID0ge307XG4gICAgICB0aGlzLmRpc3BsYXlOYW1lcyA9IHV0aWxzLmNvcHkoKF9yZWYxID0gKF9yZWYyID0gcHJvcGVydGllcy5kaXNwbGF5TmFtZXMpICE9IG51bGwgPyBfcmVmMiA6IHByb3BlcnRpZXMuYWxpYXNlcykgIT0gbnVsbCA/IF9yZWYxIDoge30pO1xuICAgICAgX3JlZjMgPSBbJ25hbWUnLCAndGl0bGUnLCAnY29tbWVudCcsICdkZXNjcmlwdGlvbicsICd0eXBlJ107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIHByb3AgPSBfcmVmM1tfaV07XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzW3Byb3BdICE9IG51bGwpIHtcbiAgICAgICAgICB0aGlzW3Byb3BdID0gcHJvcGVydGllc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZSAhPSBudWxsID8gc2VydmljZSA6IHt9O1xuICAgICAgdGhpcy5tb2RlbCA9IChfcmVmNCA9IG1vZGVsICE9IG51bGwgPyBtb2RlbCA6IHByb3BlcnRpZXMubW9kZWwpICE9IG51bGwgPyBfcmVmNCA6IHt9O1xuICAgICAgdGhpcy5zdW1tYXJ5RmllbGRzID0gKF9yZWY1ID0gc3VtbWFyeUZpZWxkcyAhPSBudWxsID8gc3VtbWFyeUZpZWxkcyA6IHByb3BlcnRpZXMuc3VtbWFyeUZpZWxkcykgIT0gbnVsbCA/IF9yZWY1IDoge307XG4gICAgICB0aGlzLnJvb3QgPSAoX3JlZjYgPSBwcm9wZXJ0aWVzLnJvb3QpICE9IG51bGwgPyBfcmVmNiA6IHByb3BlcnRpZXMuZnJvbTtcbiAgICAgIHRoaXMubWF4Um93cyA9IChfcmVmNyA9IChfcmVmOCA9IHByb3BlcnRpZXMuc2l6ZSkgIT0gbnVsbCA/IF9yZWY4IDogcHJvcGVydGllcy5saW1pdCkgIT0gbnVsbCA/IF9yZWY3IDogcHJvcGVydGllcy5tYXhSb3dzO1xuICAgICAgdGhpcy5zdGFydCA9IChfcmVmOSA9IChfcmVmMTAgPSBwcm9wZXJ0aWVzLnN0YXJ0KSAhPSBudWxsID8gX3JlZjEwIDogcHJvcGVydGllcy5vZmZzZXQpICE9IG51bGwgPyBfcmVmOSA6IDA7XG4gICAgICB0aGlzLnNlbGVjdChwcm9wZXJ0aWVzLnZpZXdzIHx8IHByb3BlcnRpZXMudmlldyB8fCBwcm9wZXJ0aWVzLnNlbGVjdCB8fCBbXSk7XG4gICAgICB0aGlzLmFkZENvbnN0cmFpbnRzKHByb3BlcnRpZXMuY29uc3RyYWludHMgfHwgcHJvcGVydGllcy53aGVyZSB8fCBbXSk7XG4gICAgICB0aGlzLmFkZEpvaW5zKHByb3BlcnRpZXMuam9pbnMgfHwgcHJvcGVydGllcy5qb2luIHx8IFtdKTtcbiAgICAgIHRoaXMub3JkZXJCeShwcm9wZXJ0aWVzLnNvcnRPcmRlciB8fCBwcm9wZXJ0aWVzLm9yZGVyQnkgfHwgW10pO1xuICAgICAgaWYgKHByb3BlcnRpZXMuY29uc3RyYWludExvZ2ljICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50TG9naWMgPSBwcm9wZXJ0aWVzLmNvbnN0cmFpbnRMb2dpYztcbiAgICAgIH1cbiAgICAgIHRoaXMub24oJ2NoYW5nZTp2aWV3cycsIHJlbW92ZUlycmVsZXZhbnRTb3J0T3JkZXJzLCB0aGlzKTtcbiAgICB9XG5cbiAgICBRdWVyeS5wcm90b3R5cGUucmVtb3ZlRnJvbVNlbGVjdCA9IGZ1bmN0aW9uKHVud2FudGVkKSB7XG4gICAgICB2YXIgbWFwRm4sIHNvLCB1dywgdjtcbiAgICAgIGlmICh1bndhbnRlZCA9PSBudWxsKSB7XG4gICAgICAgIHVud2FudGVkID0gW107XG4gICAgICB9XG4gICAgICB1bndhbnRlZCA9IHV0aWxzLnN0cmluZ0xpc3QodW53YW50ZWQpO1xuICAgICAgbWFwRm4gPSB1dGlscy5jb21wb3NlKHRoaXMuZXhwYW5kU3RhciwgdGhpcy5hZGp1c3RQYXRoKTtcbiAgICAgIHVud2FudGVkID0gdXRpbHMuZmxhdHRlbigoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdW53YW50ZWQubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICB1dyA9IHVud2FudGVkW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKG1hcEZuKHV3KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKSk7XG4gICAgICB0aGlzLnNvcnRPcmRlciA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLnNvcnRPcmRlcjtcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgc28gPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAoIShfcmVmMSA9IHNvLnBhdGgsIF9faW5kZXhPZi5jYWxsKHVud2FudGVkLCBfcmVmMSkgPj0gMCkpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goc28pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy52aWV3cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMudmlld3M7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHYgPSBfcmVmW19pXTtcbiAgICAgICAgICBpZiAoIShfX2luZGV4T2YuY2FsbCh1bndhbnRlZCwgdikgPj0gMCkpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2godik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ3JlbW92ZTp2aWV3JywgdW53YW50ZWQpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6dmlld3MnLCB0aGlzLnZpZXdzKTtcbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHRoaXMudmlld3MpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUucmVtb3ZlQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbiwgc2lsZW50KSB7XG4gICAgICB2YXIgYywgaXNjb24sIG9yaWcsIHJlZHVjZWQ7XG4gICAgICBpZiAoc2lsZW50ID09IG51bGwpIHtcbiAgICAgICAgc2lsZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBvcmlnID0gdGhpcy5jb25zdHJhaW50cztcbiAgICAgIGlzY29uID0gdHlwZW9mIGNvbiA9PT0gJ3N0cmluZycgPyAoZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gYy5jb2RlID09PSBjb247XG4gICAgICB9KSA6IChmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciBfcmVmLCBfcmVmMTtcbiAgICAgICAgcmV0dXJuIChjLnBhdGggPT09IGNvbi5wYXRoKSAmJiAoYy5vcCA9PT0gY29uLm9wKSAmJiAoYy52YWx1ZSA9PT0gY29uLnZhbHVlKSAmJiAoYy5leHRyYVZhbHVlID09PSBjb24uZXh0cmFWYWx1ZSkgJiYgKGNvbi50eXBlID09PSBjLnR5cGUpICYmICgoKF9yZWYgPSBjLnZhbHVlcykgIT0gbnVsbCA/IF9yZWYuam9pbignJSUnKSA6IHZvaWQgMCkgPT09ICgoX3JlZjEgPSBjb24udmFsdWVzKSAhPSBudWxsID8gX3JlZjEuam9pbignJSUnKSA6IHZvaWQgMCkpO1xuICAgICAgfSk7XG4gICAgICByZWR1Y2VkID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG9yaWcubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBjID0gb3JpZ1tfaV07XG4gICAgICAgICAgaWYgKCFpc2NvbihjKSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkoKTtcbiAgICAgIGlmIChyZWR1Y2VkLmxlbmd0aCAhPT0gb3JpZy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihkaWRudFJlbW92ZShvcmlnLCByZWR1Y2VkKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNvbnN0cmFpbnRzID0gcmVkdWNlZDtcbiAgICAgIGlmICghc2lsZW50KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOmNvbnN0cmFpbnRzJyk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ3JlbW92ZWQ6Y29uc3RyYWludCcsIHV0aWxzLmZpbmQob3JpZywgaXNjb24pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFkZFRvU2VsZWN0ID0gZnVuY3Rpb24odmlld3MsIG9wdHMpIHtcbiAgICAgIHZhciBkdXBzLCBtYXBGbiwgcCwgdG9BZGQsIHYsIHgsIF9yZWYsIF9yZWYxO1xuICAgICAgaWYgKHZpZXdzID09IG51bGwpIHtcbiAgICAgICAgdmlld3MgPSBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzID09IG51bGwpIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgfVxuICAgICAgdmlld3MgPSB1dGlscy5zdHJpbmdMaXN0KHZpZXdzKTtcbiAgICAgIG1hcEZuID0gdXRpbHMuY29tcG9zZSh0aGlzLmV4cGFuZFN0YXIsIHRoaXMuYWRqdXN0UGF0aCk7XG4gICAgICB0b0FkZCA9IHV0aWxzLmZsYXR0ZW4oKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHZpZXdzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgdiA9IHZpZXdzW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKG1hcEZuKHYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpKTtcbiAgICAgIGR1cHMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdG9BZGQubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBwID0gdG9BZGRbX2ldO1xuICAgICAgICAgIGlmIChfX2luZGV4T2YuY2FsbCh0aGlzLnZpZXdzLCBwKSA+PSAwKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKGR1cHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiICsgZHVwcyArIFwiIGFscmVhZHkgaW4gdGhlIHNlbGVjdCBsaXN0XCIpO1xuICAgICAgfVxuICAgICAgZHVwcyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB0b0FkZC5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHAgPSB0b0FkZFtfaV07XG4gICAgICAgICAgaWYgKCgoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgX2osIF9sZW4xLCBfcmVzdWx0czE7XG4gICAgICAgICAgICBfcmVzdWx0czEgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IHRvQWRkLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgICAgICB4ID0gdG9BZGRbX2pdO1xuICAgICAgICAgICAgICBpZiAoeCA9PT0gcCkge1xuICAgICAgICAgICAgICAgIF9yZXN1bHRzMS5wdXNoKHgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHMxO1xuICAgICAgICAgIH0pKCkpLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gocCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCk7XG4gICAgICBpZiAoZHVwcy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiXCIgKyBkdXBzICsgXCIgc3BlY2lmaWVkIG11bHRpcGxlIHRpbWVzIGFzIGFyZ3VtZW50cyB0byBhZGRUb1NlbGVjdFwiKTtcbiAgICAgIH1cbiAgICAgIChfcmVmID0gdGhpcy52aWV3cykucHVzaC5hcHBseShfcmVmLCB0b0FkZCk7XG4gICAgICBpZiAob3B0cy5zaWxlbnQpIHtcbiAgICAgICAgb3B0cy5ldmVudHMgPSAoKF9yZWYxID0gb3B0cy5ldmVudHMpICE9IG51bGwgPyBfcmVmMSA6IFtdKS5jb25jYXQoWydjaGFuZ2UnLCAnYWRkOnZpZXcnLCAnY2hhbmdlOnZpZXdzJ10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdhZGQ6dmlldyBjaGFuZ2U6dmlld3MnLCB0b0FkZCk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uKHZpZXdzLCBvcHRzKSB7XG4gICAgICB2YXIgZSwgb2xkVmlld3M7XG4gICAgICBvbGRWaWV3cyA9IHRoaXMudmlld3Muc2xpY2UoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudmlld3MgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRUb1NlbGVjdCh2aWV3cywgb3B0cyk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgdGhpcy52aWV3cyA9IG9sZFZpZXdzO1xuICAgICAgICB1dGlscy5lcnJvcihlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuYWRqdXN0UGF0aCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHBhdGggPSBwYXRoICYmIHBhdGgubmFtZSA/IHBhdGgubmFtZSA6IFwiXCIgKyBwYXRoO1xuICAgICAgaWYgKHRoaXMucm9vdCAhPSBudWxsKSB7XG4gICAgICAgIGlmICghcGF0aC5tYXRjaChcIl5cIiArIHRoaXMucm9vdCkpIHtcbiAgICAgICAgICBwYXRoID0gdGhpcy5yb290ICsgXCIuXCIgKyBwYXRoO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJvb3QgPSBwYXRoLnNwbGl0KCcuJylbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldFBvc3NpYmxlUGF0aHMgPSBmdW5jdGlvbihkZXB0aCwgYWxsb3dSZXZlcnNlUmVmZXJlbmNlcywgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgZ2V0UGF0aHMsIGtleSwgcmV0LCB0ZXN0LCBfYmFzZTtcbiAgICAgIGlmIChkZXB0aCA9PSBudWxsKSB7XG4gICAgICAgIGRlcHRoID0gMztcbiAgICAgIH1cbiAgICAgIGlmIChhbGxvd1JldmVyc2VSZWZlcmVuY2VzID09IG51bGwpIHtcbiAgICAgICAgYWxsb3dSZXZlcnNlUmVmZXJlbmNlcyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAocHJlZGljYXRlID09IG51bGwpIHtcbiAgICAgICAgcHJlZGljYXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRlc3QgPSB0eXBlb2YgcHJlZGljYXRlID09PSAnc3RyaW5nJyA/IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcmV0dXJuIHBbcHJlZGljYXRlXSgpO1xuICAgICAgfSA6IHByZWRpY2F0ZTtcbiAgICAgIGdldFBhdGhzID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihyb290LCBkKSB7XG4gICAgICAgICAgdmFyIGNkLCBmaWVsZCwgbmFtZSwgb3RoZXJzLCBwYXRoLCBzdWJQYXRocztcbiAgICAgICAgICBwYXRoID0gX3RoaXMuZ2V0UGF0aEluZm8ocm9vdCk7XG4gICAgICAgICAgaWYgKCghYWxsb3dSZXZlcnNlUmVmZXJlbmNlcykgJiYgcGF0aC5pc1JldmVyc2VSZWZlcmVuY2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH0gZWxzZSBpZiAocGF0aC5pc0F0dHJpYnV0ZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3BhdGhdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZCA9IHBhdGguZ2V0VHlwZSgpO1xuICAgICAgICAgICAgc3ViUGF0aHMgPSBjb25jYXRNYXAoZnVuY3Rpb24ocmVmKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRQYXRocyhcIlwiICsgcm9vdCArIFwiLlwiICsgcmVmLm5hbWUsIGQgLSAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb3RoZXJzID0gY2QgJiYgKGQgPiAwKSA/IHN1YlBhdGhzKChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICAgICAgICBfcmVmID0gY2QuZmllbGRzO1xuICAgICAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKG5hbWUgaW4gX3JlZikge1xuICAgICAgICAgICAgICAgIGZpZWxkID0gX3JlZltuYW1lXTtcbiAgICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgICAgICB9KSgpKSA6IFtdO1xuICAgICAgICAgICAgcmV0dXJuIFtwYXRoXS5jb25jYXQob3RoZXJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIGtleSA9IFwiXCIgKyBkZXB0aCArIFwiLVwiICsgYWxsb3dSZXZlcnNlUmVmZXJlbmNlcztcbiAgICAgIGlmICh0aGlzLl9wb3NzaWJsZVBhdGhzID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcG9zc2libGVQYXRocyA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0ID0gKChfYmFzZSA9IHRoaXMuX3Bvc3NpYmxlUGF0aHMpW2tleV0gIT0gbnVsbCA/IF9iYXNlW2tleV0gOiBfYmFzZVtrZXldID0gZ2V0UGF0aHModGhpcy5yb290LCBkZXB0aCkpLnNsaWNlKCk7XG4gICAgICBpZiAodGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXQuZmlsdGVyKHRlc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldFBhdGhJbmZvID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdmFyIGFkanVzdGVkLCBwaSwgX3JlZjtcbiAgICAgIGFkanVzdGVkID0gdGhpcy5hZGp1c3RQYXRoKHBhdGgpO1xuICAgICAgcGkgPSAoX3JlZiA9IHRoaXMubW9kZWwpICE9IG51bGwgPyB0eXBlb2YgX3JlZi5nZXRQYXRoSW5mbyA9PT0gXCJmdW5jdGlvblwiID8gX3JlZi5nZXRQYXRoSW5mbyhhZGp1c3RlZCwgdGhpcy5nZXRTdWJjbGFzc2VzKCkpIDogdm9pZCAwIDogdm9pZCAwO1xuICAgICAgaWYgKHBpICYmIGFkanVzdGVkIGluIHRoaXMuZGlzcGxheU5hbWVzKSB7XG4gICAgICAgIHBpLmRpc3BsYXlOYW1lID0gdGhpcy5kaXNwbGF5TmFtZXNbYWRqdXN0ZWRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUubWFrZVBhdGggPSBRdWVyeS5wcm90b3R5cGUuZ2V0UGF0aEluZm87XG5cbiAgICB0b1BhdGhBbmRUeXBlID0gZnVuY3Rpb24oYykge1xuICAgICAgcmV0dXJuIFtjLnBhdGgsIGMudHlwZV07XG4gICAgfTtcblxuICAgIHNjRm9sZCA9IHV0aWxzLmNvbXBvc2UodXRpbHMucGFpcnNUb09iaiwgdXRpbHMubWFwKHRvUGF0aEFuZFR5cGUpLCBmaWx0ZXIoZ2V0KCd0eXBlJykpKTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5nZXRTdWJjbGFzc2VzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc2NGb2xkKHRoaXMuY29uc3RyYWludHMpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFBhdGhJbmZvKHBhdGgpLmdldFR5cGUoKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldFZpZXdOb2RlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAsIHRvUGFyZW50Tm9kZTtcbiAgICAgIHRvUGFyZW50Tm9kZSA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5nZXRQYXRoSW5mbyh2KS5nZXRQYXJlbnQoKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgICAgcmV0dXJuIHV0aWxzLnVuaXFCeShTdHJpbmcsIChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMudmlld3M7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHAgPSBfcmVmW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRvUGFyZW50Tm9kZShwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5pc0luVmlldyA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHZhciBwaSwgcHN0ciwgX3JlZjtcbiAgICAgIHBpID0gdGhpcy5nZXRQYXRoSW5mbyhwYXRoKTtcbiAgICAgIGlmICghcGkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhdGgpO1xuICAgICAgfVxuICAgICAgaWYgKHBpLmlzQXR0cmlidXRlKCkpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYgPSBwaS50b1N0cmluZygpLCBfX2luZGV4T2YuY2FsbCh0aGlzLnZpZXdzLCBfcmVmKSA+PSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHN0ciA9IHBpLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB1dGlscy5hbnkodGhpcy5nZXRWaWV3Tm9kZXMoKSwgZnVuY3Rpb24obikge1xuICAgICAgICAgIHJldHVybiBuLnRvU3RyaW5nKCkgPT09IHBzdHI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuaXNDb25zdHJhaW5lZCA9IGZ1bmN0aW9uKHBhdGgsIGluY2x1ZGVBdHRycykge1xuICAgICAgdmFyIHBpLCB0ZXN0O1xuICAgICAgaWYgKGluY2x1ZGVBdHRycyA9PSBudWxsKSB7XG4gICAgICAgIGluY2x1ZGVBdHRycyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcGkgPSB0aGlzLmdldFBhdGhJbmZvKHBhdGgpO1xuICAgICAgaWYgKCFwaSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGF0aCk7XG4gICAgICB9XG4gICAgICB0ZXN0ID0gZnVuY3Rpb24oYykge1xuICAgICAgICByZXR1cm4gKGMub3AgIT0gbnVsbCkgJiYgYy5wYXRoID09PSBwaS50b1N0cmluZygpO1xuICAgICAgfTtcbiAgICAgIGlmICgoIXBpLmlzQXR0cmlidXRlKCkpICYmIGluY2x1ZGVBdHRycykge1xuICAgICAgICB0ZXN0ID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIHJldHVybiAoYy5vcCAhPSBudWxsKSAmJiAoYy5wYXRoID09PSBwaS50b1N0cmluZygpIHx8IHBpLmVxdWFscyhfdGhpcy5nZXRQYXRoSW5mbyhjLnBhdGgpLmdldFBhcmVudCgpKSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSkodGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXRpbHMuYW55KHRoaXMuY29uc3RyYWludHMsIHRlc3QpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuY2FuSGF2ZU11bHRpcGxlVmFsdWVzID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0UGF0aEluZm8ocGF0aCkuY29udGFpbnNDb2xsZWN0aW9uKCk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5nZXRRdWVyeU5vZGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYywgY29uc3RyYWluZWROb2RlcywgcGksIHZpZXdOb2RlcztcbiAgICAgIHZpZXdOb2RlcyA9IHRoaXMuZ2V0Vmlld05vZGVzKCk7XG4gICAgICBjb25zdHJhaW5lZE5vZGVzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX2ksIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICBfcmVmID0gdGhpcy5jb25zdHJhaW50cztcbiAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgYyA9IF9yZWZbX2ldO1xuICAgICAgICAgIGlmICghKGMudHlwZSA9PSBudWxsKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBpID0gdGhpcy5nZXRQYXRoSW5mbyhjLnBhdGgpO1xuICAgICAgICAgIGlmIChwaS5pc0F0dHJpYnV0ZSgpKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKHBpLmdldFBhcmVudCgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChwaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICByZXR1cm4gdXRpbHMudW5pcUJ5KFN0cmluZywgdmlld05vZGVzLmNvbmNhdChjb25zdHJhaW5lZE5vZGVzKSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5pc0luUXVlcnkgPSBmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgYywgcGksIHBzdHIsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgcGkgPSB0aGlzLmdldFBhdGhJbmZvKHApO1xuICAgICAgaWYgKHBpKSB7XG4gICAgICAgIHBzdHIgPSBwaS50b1BhdGhTdHJpbmcoKTtcbiAgICAgICAgX3JlZiA9IHRoaXMudmlld3MuY29uY2F0KChmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX2osIF9sZW4sIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZWYgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2ogPCBfbGVuOyBfaisrKSB7XG4gICAgICAgICAgICBjID0gX3JlZltfal07XG4gICAgICAgICAgICBpZiAoYy50eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChjLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcykpO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBwID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKDAgPT09IHAuaW5kZXhPZihwc3RyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuaXNSZWxldmFudCA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHZhciBub2RlcywgcGksIHNvdWdodDtcbiAgICAgIHBpID0gdGhpcy5nZXRQYXRoSW5mbyhwYXRoKTtcbiAgICAgIGlmIChwaS5pc0F0dHJpYnV0ZSgpKSB7XG4gICAgICAgIHBpID0gcGkuZ2V0UGFyZW50KCk7XG4gICAgICB9XG4gICAgICBzb3VnaHQgPSBwaS50b1N0cmluZygpO1xuICAgICAgbm9kZXMgPSB0aGlzLmdldFZpZXdOb2RlcygpO1xuICAgICAgcmV0dXJuIHV0aWxzLmFueShub2RlcywgZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gbi50b1BhdGhTdHJpbmcoKSA9PT0gc291Z2h0O1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5leHBhbmRTdGFyID0gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgdmFyIGF0dHJWaWV3cywgY2QsIGV4cGFuZCwgZm4sIG4sIG5hbWUsIHBhdGhTdGVtLCBzdGFyVmlld3M7XG4gICAgICBpZiAoL1xcKiQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgcGF0aFN0ZW0gPSBwYXRoLnN1YnN0cigwLCBwYXRoLmxhc3RJbmRleE9mKCcuJykpO1xuICAgICAgICBleHBhbmQgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIHBhdGhTdGVtICsgeDtcbiAgICAgICAgfTtcbiAgICAgICAgY2QgPSB0aGlzLmdldFR5cGUocGF0aFN0ZW0pO1xuICAgICAgICBpZiAoL1xcLlxcKiQvLnRlc3QocGF0aCkpIHtcbiAgICAgICAgICBpZiAoY2QgJiYgdGhpcy5zdW1tYXJ5RmllbGRzW2NkLm5hbWVdKSB7XG4gICAgICAgICAgICBmbiA9IHV0aWxzLmNvbXBvc2UoZXhwYW5kLCBkZWNhcGl0YXRlKTtcbiAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgICAgICAgIF9yZWYgPSB0aGlzLnN1bW1hcnlGaWVsZHNbY2QubmFtZV07XG4gICAgICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgICAgIG4gPSBfcmVmW19pXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzVmlldyhuKSkge1xuICAgICAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChmbihuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKC9cXC5cXCpcXCokLy50ZXN0KHBhdGgpKSB7XG4gICAgICAgICAgc3RhclZpZXdzID0gdGhpcy5leHBhbmRTdGFyKHBhdGhTdGVtICsgJy4qJyk7XG4gICAgICAgICAgYXR0clZpZXdzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobmFtZSBpbiBjZC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goZXhwYW5kKFwiLlwiICsgbmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgcmV0dXJuIHV0aWxzLnVuaXFCeShpZCwgc3RhclZpZXdzLmNvbmNhdChhdHRyVmlld3MpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5pc091dGVySm9pbiA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiB0aGlzLmpvaW5zW3RoaXMuYWRqdXN0UGF0aChwKV0gPT09ICdPVVRFUic7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5oYXNWaWV3ID0gZnVuY3Rpb24odikge1xuICAgICAgdmFyIF9yZWY7XG4gICAgICByZXR1cm4gdGhpcy52aWV3cyAmJiAoX3JlZiA9IHRoaXMuYWRqdXN0UGF0aCh2KSwgX19pbmRleE9mLmNhbGwodGhpcy52aWV3cywgX3JlZikgPj0gMCk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uKGNvbnQpIHtcbiAgICAgIGlmICh0aGlzLnNlcnZpY2UuY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VydmljZS5jb3VudCh0aGlzLCBjb250KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgcXVlcnkgaGFzIG5vIHNlcnZpY2Ugd2l0aCBjb3VudCBmdW5jdGlvbmFsaXR5IGF0dGFjaGVkLlwiKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFwcGVuZFRvTGlzdCA9IGZ1bmN0aW9uKHRhcmdldCwgY2IpIHtcbiAgICAgIHZhciBuYW1lLCBwcm9jZXNzb3IsIHJlcSwgdG9SdW4sIHVwZGF0ZVRhcmdldDtcbiAgICAgIGlmICh0YXJnZXQgIT0gbnVsbCA/IHRhcmdldC5uYW1lIDogdm9pZCAwKSB7XG4gICAgICAgIG5hbWUgPSB0YXJnZXQubmFtZTtcbiAgICAgICAgdXBkYXRlVGFyZ2V0ID0gZnVuY3Rpb24oZXJyLCBsaXN0KSB7XG4gICAgICAgICAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LnNpemUgPSBsaXN0LnNpemU7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IFN0cmluZyh0YXJnZXQpO1xuICAgICAgICB1cGRhdGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdG9SdW4gPSB0aGlzLm1ha2VMaXN0UXVlcnkoKTtcbiAgICAgIHJlcSA9IHtcbiAgICAgICAgbGlzdE5hbWU6IG5hbWUsXG4gICAgICAgIHF1ZXJ5OiB0b1J1bi50b1hNTCgpXG4gICAgICB9O1xuICAgICAgcHJvY2Vzc29yID0gTElTVF9QSVBFKHRoaXMuc2VydmljZSk7XG4gICAgICByZXR1cm4gd2l0aENCKHVwZGF0ZVRhcmdldCwgY2IsIHRoaXMuc2VydmljZS5wb3N0KCdxdWVyeS9hcHBlbmQvdG9saXN0JywgcmVxKS50aGVuKHByb2Nlc3NvcikpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuc2VsZWN0UHJlc2VydmluZ0ltcGxpZWRDb25zdHJhaW50cyA9IGZ1bmN0aW9uKHBhdGhzKSB7XG4gICAgICB2YXIgbiwgdG9SdW4sIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgaWYgKHBhdGhzID09IG51bGwpIHtcbiAgICAgICAgcGF0aHMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHRvUnVuID0gdGhpcy5jbG9uZSgpO1xuICAgICAgdG9SdW4uc2VsZWN0KHBhdGhzKTtcbiAgICAgIF9yZWYgPSB0aGlzLmdldFZpZXdOb2RlcygpO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIG4gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3V0ZXJKb2luZWQobikpIHtcbiAgICAgICAgICBpZiAoISh0b1J1bi5pc0luVmlldyhuIHx8IHRvUnVuLmlzQ29uc3RyYWluZWQobikpKSAmJiAobi5nZXRFbmRDbGFzcygpLmZpZWxkcy5pZCAhPSBudWxsKSkge1xuICAgICAgICAgICAgdG9SdW4uYWRkQ29uc3RyYWludChbbi5hcHBlbmQoJ2lkJyksICdJUyBOT1QgTlVMTCddKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0b1J1bjtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLm1ha2VMaXN0UXVlcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwYXRocywgX3JlZjtcbiAgICAgIHBhdGhzID0gdGhpcy52aWV3cy5zbGljZSgpO1xuICAgICAgaWYgKHBhdGhzLmxlbmd0aCAhPT0gMSB8fCAhKChfcmVmID0gcGF0aHNbMF0pICE9IG51bGwgPyBfcmVmLm1hdGNoKC9cXC5pZCQvKSA6IHZvaWQgMCkpIHtcbiAgICAgICAgcGF0aHMgPSBbJ2lkJ107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RQcmVzZXJ2aW5nSW1wbGllZENvbnN0cmFpbnRzKHBhdGhzKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnNhdmVBc0xpc3QgPSBmdW5jdGlvbihvcHRpb25zLCBjYikge1xuICAgICAgdmFyIHJlcSwgdG9SdW47XG4gICAgICB0b1J1biA9IHRoaXMubWFrZUxpc3RRdWVyeSgpO1xuICAgICAgcmVxID0gdXRpbHMuY29weShvcHRpb25zKTtcbiAgICAgIHJlcS5saXN0TmFtZSA9IHJlcS5saXN0TmFtZSB8fCByZXEubmFtZTtcbiAgICAgIHJlcS5xdWVyeSA9IHRvUnVuLnRvWE1MKCk7XG4gICAgICBpZiAob3B0aW9ucy50YWdzKSB7XG4gICAgICAgIHJlcS50YWdzID0gb3B0aW9ucy50YWdzLmpvaW4oJzsnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5wb3N0KCdxdWVyeS90b2xpc3QnLCByZXEpLnRoZW4oTElTVF9QSVBFKHRoaXMuc2VydmljZSkpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnN1bW1hcmlzZSA9IGZ1bmN0aW9uKHBhdGgsIGxpbWl0LCBjb250KSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXJTdW1tYXJ5KHBhdGgsICcnLCBsaW1pdCwgY29udCk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5zdW1tYXJpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzO1xuICAgICAgYXJncyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICByZXR1cm4gdGhpcy5zdW1tYXJpc2UuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIHBhcnNlU3VtbWFyeSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBpc051bWVyaWMsIHIsIHN0YXRzLCBfaSwgX2xlbiwgX3JlZiwgX3JlZjE7XG4gICAgICBpc051bWVyaWMgPSAoKF9yZWYgPSBkYXRhLnJlc3VsdHNbMF0pICE9IG51bGwgPyBfcmVmLm1heCA6IHZvaWQgMCkgIT0gbnVsbDtcbiAgICAgIF9yZWYxID0gZGF0YS5yZXN1bHRzO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICByID0gX3JlZjFbX2ldO1xuICAgICAgICByLmNvdW50ID0gcGFyc2VJbnQoci5jb3VudCwgMTApO1xuICAgICAgfVxuICAgICAgc3RhdHMgPSB7XG4gICAgICAgIHVuaXF1ZVZhbHVlczogZGF0YS51bmlxdWVWYWx1ZXMsXG4gICAgICAgIGZpbHRlcmVkQ291bnQ6IGRhdGEuZmlsdGVyZWRDb3VudFxuICAgICAgfTtcbiAgICAgIGlmIChpc051bWVyaWMpIHtcbiAgICAgICAgc3RhdHMgPSBtZXJnZShzdGF0cywgZGF0YS5yZXN1bHRzWzBdKTtcbiAgICAgIH1cbiAgICAgIGRhdGEuc3RhdHMgPSBzdGF0cztcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZmlsdGVyU3VtbWFyeSA9IGZ1bmN0aW9uKHBhdGgsIHRlcm0sIGxpbWl0LCBjb250KSB7XG4gICAgICB2YXIgcmVxLCB0b1J1biwgX3JlZjtcbiAgICAgIGlmIChjb250ID09IG51bGwpIHtcbiAgICAgICAgY29udCA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGxpbWl0KSkge1xuICAgICAgICBfcmVmID0gW2xpbWl0LCBudWxsXSwgY29udCA9IF9yZWZbMF0sIGxpbWl0ID0gX3JlZlsxXTtcbiAgICAgIH1cbiAgICAgIHBhdGggPSB0aGlzLmFkanVzdFBhdGgocGF0aCk7XG4gICAgICB0b1J1biA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbCh0b1J1bi52aWV3cywgcGF0aCkgPCAwKSB7XG4gICAgICAgIHRvUnVuLnZpZXdzLnB1c2gocGF0aCk7XG4gICAgICB9XG4gICAgICByZXEgPSB7XG4gICAgICAgIHF1ZXJ5OiB0b1J1bi50b1hNTCgpLFxuICAgICAgICBzdW1tYXJ5UGF0aDogcGF0aCxcbiAgICAgICAgZm9ybWF0OiAnanNvbnJvd3MnXG4gICAgICB9O1xuICAgICAgaWYgKGxpbWl0KSB7XG4gICAgICAgIHJlcS5zaXplID0gbGltaXQ7XG4gICAgICB9XG4gICAgICBpZiAodGVybSkge1xuICAgICAgICByZXEuZmlsdGVyVGVybSA9IHRlcm07XG4gICAgICB9XG4gICAgICByZXR1cm4gd2l0aENCKGNvbnQsIHRoaXMuc2VydmljZS5wb3N0KCdxdWVyeS9yZXN1bHRzJywgcmVxKS50aGVuKHBhcnNlU3VtbWFyeSkpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbihjbG9uZUV2ZW50cykge1xuICAgICAgdmFyIGNsb25lZCwgaywgdiwgX3JlZjtcbiAgICAgIGNsb25lZCA9IG5ldyBRdWVyeSh0aGlzLCB0aGlzLnNlcnZpY2UpO1xuICAgICAgaWYgKGNsb25lZC5fY2FsbGJhY2tzID09IG51bGwpIHtcbiAgICAgICAgY2xvbmVkLl9jYWxsYmFja3MgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChjbG9uZUV2ZW50cykge1xuICAgICAgICBfcmVmID0gdGhpcy5fY2FsbGJhY2tzO1xuICAgICAgICBmb3IgKGsgaW4gX3JlZikge1xuICAgICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwoX3JlZiwgaykpIGNvbnRpbnVlO1xuICAgICAgICAgIHYgPSBfcmVmW2tdO1xuICAgICAgICAgIGNsb25lZC5fY2FsbGJhY2tzW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgICBjbG9uZWQub2ZmKCdjaGFuZ2U6dmlld3MnLCByZW1vdmVJcnJlbGV2YW50U29ydE9yZGVycywgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNsb25lO1xuICAgICAgY2xvbmUgPSB0aGlzLmNsb25lKCk7XG4gICAgICBpZiAodGhpcy5tYXhSb3dzKSB7XG4gICAgICAgIGNsb25lLnN0YXJ0ID0gdGhpcy5zdGFydCArIHRoaXMubWF4Um93cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjbG9uZTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnByZXZpb3VzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2xvbmU7XG4gICAgICBjbG9uZSA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGlmICh0aGlzLm1heFJvd3MpIHtcbiAgICAgICAgY2xvbmUuc3RhcnQgPSB0aGlzLnN0YXJ0IC0gdGhpcy5tYXhSb3dzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xvbmUuc3RhcnQgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0U29ydERpcmVjdGlvbiA9IGZ1bmN0aW9uKHNvcnRlZCkge1xuICAgICAgdmFyIGEsIHNvO1xuICAgICAgYSA9IHRoaXMuYWRqdXN0UGF0aChzb3J0ZWQpO1xuICAgICAgaWYgKCEodGhpcy5pc0luUXVlcnkoYSkgfHwgdGhpcy5pc1JlbGV2YW50KGEpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIiArIHNvcnRlZCArIFwiIGlzIG5vdCBpbiB0aGUgcXVlcnlcIik7XG4gICAgICB9XG4gICAgICBzbyA9IHV0aWxzLmZpbmQodGhpcy5zb3J0T3JkZXIsIGZ1bmN0aW9uKF9hcmcpIHtcbiAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgIHBhdGggPSBfYXJnLnBhdGg7XG4gICAgICAgIHJldHVybiBhID09PSBwYXRoO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gc28gIT0gbnVsbCA/IHNvLmRpcmVjdGlvbiA6IHZvaWQgMDtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmlzT3V0ZXJKb2luZWQgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgICB2YXIgZGlyLCBqcCwgX3JlZjtcbiAgICAgIHBhdGggPSB0aGlzLmFkanVzdFBhdGgocGF0aCk7XG4gICAgICBfcmVmID0gdGhpcy5qb2lucztcbiAgICAgIGZvciAoanAgaW4gX3JlZikge1xuICAgICAgICBkaXIgPSBfcmVmW2pwXTtcbiAgICAgICAgaWYgKGRpciA9PT0gJ09VVEVSJyAmJiBwYXRoLmluZGV4T2YoanApID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldE91dGVySm9pbiA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgIHZhciBqb2luUGF0aHMsIGs7XG4gICAgICBwYXRoID0gdGhpcy5hZGp1c3RQYXRoKHBhdGgpO1xuICAgICAgam9pblBhdGhzID0gKChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGsgaW4gdGhpcy5qb2lucykge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKSkuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdXRpbHMuZmluZChqb2luUGF0aHMsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5qb2luc1twXSA9PT0gJ09VVEVSJyAmJiBwYXRoLmluZGV4T2YocCkgPT09IDA7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5fcGFyc2Vfc29ydF9vcmRlciA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICB2YXIgZGlyZWN0aW9uLCBrLCBwYXRoLCBzbywgdiwgX3JlZjtcbiAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gaW5wdXQnKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNvID0ge1xuICAgICAgICAgIHBhdGg6IGlucHV0LFxuICAgICAgICAgIGRpcmVjdGlvbjogJ0FTQydcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgcGF0aCA9IGlucHV0WzBdLCBkaXJlY3Rpb24gPSBpbnB1dFsxXTtcbiAgICAgICAgc28gPSB7XG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvblxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpbnB1dC5wYXRoID09IG51bGwpIHtcbiAgICAgICAgZm9yIChrIGluIGlucHV0KSB7XG4gICAgICAgICAgdiA9IGlucHV0W2tdO1xuICAgICAgICAgIF9yZWYgPSBbaywgdl0sIHBhdGggPSBfcmVmWzBdLCBkaXJlY3Rpb24gPSBfcmVmWzFdO1xuICAgICAgICB9XG4gICAgICAgIHNvID0ge1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGggPSBpbnB1dC5wYXRoLCBkaXJlY3Rpb24gPSBpbnB1dC5kaXJlY3Rpb247XG4gICAgICAgIHNvID0ge1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNvLnBhdGggPSB0aGlzLmFkanVzdFBhdGgoc28ucGF0aCk7XG4gICAgICBpZiAoc28uZGlyZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgc28uZGlyZWN0aW9uID0gJ0FTQyc7XG4gICAgICB9XG4gICAgICBzby5kaXJlY3Rpb24gPSBzby5kaXJlY3Rpb24udG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiBzbztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFkZE9yU2V0U29ydE9yZGVyID0gZnVuY3Rpb24oc28pIHtcbiAgICAgIHZhciBjdXJyZW50RGlyZWN0aW9uLCBvZTtcbiAgICAgIHNvID0gdGhpcy5fcGFyc2Vfc29ydF9vcmRlcihzbyk7XG4gICAgICBjdXJyZW50RGlyZWN0aW9uID0gdGhpcy5nZXRTb3J0RGlyZWN0aW9uKHNvLnBhdGgpO1xuICAgICAgaWYgKGN1cnJlbnREaXJlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFkZFNvcnRPcmRlcihzbyk7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnREaXJlY3Rpb24gIT09IHNvLmRpcmVjdGlvbikge1xuICAgICAgICBvZSA9IHV0aWxzLmZpbmQodGhpcy5zb3J0T3JkZXIsIGZ1bmN0aW9uKF9hcmcpIHtcbiAgICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgICBwYXRoID0gX2FyZy5wYXRoO1xuICAgICAgICAgIHJldHVybiBwYXRoID09PSBzby5wYXRoO1xuICAgICAgICB9KTtcbiAgICAgICAgb2UuZGlyZWN0aW9uID0gc28uZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpzb3J0b3JkZXInLCB0aGlzLnNvcnRPcmRlcik7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFkZFNvcnRPcmRlciA9IGZ1bmN0aW9uKHNvLCBfYXJnKSB7XG4gICAgICB2YXIgc2lsZW50O1xuICAgICAgc2lsZW50ID0gKF9hcmcgIT0gbnVsbCA/IF9hcmcgOiB7fSkuc2lsZW50O1xuICAgICAgdGhpcy5zb3J0T3JkZXIucHVzaCh0aGlzLl9wYXJzZV9zb3J0X29yZGVyKHNvKSk7XG4gICAgICBpZiAoIXNpbGVudCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2FkZDpzb3J0b3JkZXInLCBzbyk7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOnNvcnRvcmRlcicsIHRoaXMuc29ydE9yZGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5vcmRlckJ5ID0gZnVuY3Rpb24ob2VzLCBvcHRzKSB7XG4gICAgICB2YXIgY29weSwgZGlyZWN0aW9uLCBvZSwgb2xkU08sIHBhdGgsIF9pLCBfbGVuLCBfcmVmO1xuICAgICAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG4gICAgICBvbGRTTyA9IHRoaXMuc29ydE9yZGVyLnNsaWNlKCk7XG4gICAgICB0aGlzLnNvcnRPcmRlciA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBvZXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgb2UgPSBvZXNbX2ldO1xuICAgICAgICB0aGlzLmFkZFNvcnRPcmRlcih0aGlzLl9wYXJzZV9zb3J0X29yZGVyKG9lKSwge1xuICAgICAgICAgIHNpbGVudDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvcHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZWYsIF9yZWYxLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMuc29ydE9yZGVyO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9qID0gMCwgX2xlbjEgPSBfcmVmLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgICAgICAgIF9yZWYxID0gX3JlZltfal0sIHBhdGggPSBfcmVmMS5wYXRoLCBkaXJlY3Rpb24gPSBfcmVmMS5kaXJlY3Rpb247XG4gICAgICAgICAgX3Jlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpO1xuICAgICAgdGhpcy50cmlnZ2VyKCdzZXQ6c29ydG9yZGVyJywgY29weSk7XG4gICAgICBpZiAoKHN0cmluZ2lmeVNvcnRPcmRlcihvbGRTTykpICE9PSB0aGlzLmdldFNvcnRpbmcoKSkge1xuICAgICAgICBpZiAob3B0cy5zaWxlbnQpIHtcbiAgICAgICAgICBvcHRzLmV2ZW50cyA9ICgoX3JlZiA9IG9wdHMuZXZlbnRzKSAhPSBudWxsID8gX3JlZiA6IFtdKS5jb25jYXQoWydjaGFuZ2UnLCAnY2hhbmdlOnNvcnRvcmRlciddKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpzb3J0b3JkZXInLCBjb3B5KTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmFkZEpvaW5zID0gZnVuY3Rpb24oam9pbnMpIHtcbiAgICAgIHZhciBqLCBrLCB2LCBfaSwgX2xlbiwgX3Jlc3VsdHMsIF9yZXN1bHRzMTtcbiAgICAgIGlmICh1dGlscy5pc0FycmF5KGpvaW5zKSkge1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IGpvaW5zLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgaiA9IGpvaW5zW19pXTtcbiAgICAgICAgICBfcmVzdWx0cy5wdXNoKHRoaXMuYWRkSm9pbihqKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3Jlc3VsdHMxID0gW107XG4gICAgICAgIGZvciAoayBpbiBqb2lucykge1xuICAgICAgICAgIHYgPSBqb2luc1trXTtcbiAgICAgICAgICBfcmVzdWx0czEucHVzaCh0aGlzLmFkZEpvaW4oe1xuICAgICAgICAgICAgcGF0aDogayxcbiAgICAgICAgICAgIHN0eWxlOiB2XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5hZGRKb2luID0gZnVuY3Rpb24oam9pbikge1xuICAgICAgaWYgKHR5cGVvZiBqb2luID09PSAnc3RyaW5nJykge1xuICAgICAgICBqb2luID0ge1xuICAgICAgICAgIHBhdGg6IGpvaW4sXG4gICAgICAgICAgc3R5bGU6ICdPVVRFUidcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNldEpvaW5TdHlsZShqb2luLnBhdGgsIGpvaW4uc3R5bGUpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuc2V0Sm9pblN0eWxlID0gZnVuY3Rpb24ocGF0aCwgc3R5bGUpIHtcbiAgICAgIGlmIChzdHlsZSA9PSBudWxsKSB7XG4gICAgICAgIHN0eWxlID0gJ09VVEVSJztcbiAgICAgIH1cbiAgICAgIHBhdGggPSB0aGlzLmFkanVzdFBhdGgocGF0aCk7XG4gICAgICBzdHlsZSA9IHN0eWxlLnRvVXBwZXJDYXNlKCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoUXVlcnkuSk9JTl9TVFlMRVMsIHN0eWxlKSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBqb2luIHN0eWxlOiBcIiArIHN0eWxlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmpvaW5zW3BhdGhdICE9PSBzdHlsZSkge1xuICAgICAgICB0aGlzLmpvaW5zW3BhdGhdID0gc3R5bGU7XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOmpvaW5zJywge1xuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5hZGRDb25zdHJhaW50cyA9IGZ1bmN0aW9uKGNvbnN0cmFpbnRzLCBjb25qKSB7XG4gICAgICB2YXIgYywgY29uLCBvbGRMb2dpYywgcGF0aCwgX2ZuLCBfaSwgX2xlbjtcbiAgICAgIGlmIChjb25qID09IG51bGwpIHtcbiAgICAgICAgY29uaiA9ICdhbmQnO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3NpbGVudF9fID0gdHJ1ZTtcbiAgICAgIG9sZExvZ2ljID0gdGhpcy5jb25zdHJhaW50TG9naWM7XG4gICAgICBpZiAodXRpbHMuaXNBcnJheShjb25zdHJhaW50cykpIHtcbiAgICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBjb25zdHJhaW50cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIGMgPSBjb25zdHJhaW50c1tfaV07XG4gICAgICAgICAgdGhpcy5hZGRDb25zdHJhaW50KGMsIGNvbmopO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZm4gPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCwgY29uKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuYWRkQ29uc3RyYWludChpbnRlcnByZXRDb25zdHJhaW50KHBhdGgsIGNvbiksIGNvbmopO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpO1xuICAgICAgICBmb3IgKHBhdGggaW4gY29uc3RyYWludHMpIHtcbiAgICAgICAgICBjb24gPSBjb25zdHJhaW50c1twYXRoXTtcbiAgICAgICAgICBfZm4ocGF0aCwgY29uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fX3NpbGVudF9fID0gZmFsc2U7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2FkZDpjb25zdHJhaW50Jyk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpjb25zdHJhaW50cycpO1xuICAgICAgaWYgKG9sZExvZ2ljICE9PSB0aGlzLmNvbnN0cmFpbnRMb2dpYykge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2NoYW5nZTpsb2dpYycsIHRoaXMuY29uc3RyYWludExvZ2ljKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRyaWdnZXIoJ2NoYW5nZScpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuYWRkQ29uc3RyYWludCA9IGZ1bmN0aW9uKGNvbnN0cmFpbnQsIGNvbmopIHtcbiAgICAgIHZhciBpLCBsb2dpYywgbmVlZHNMb2dpY0NsYXVzZSwgbmV3Q29uTGVuLCBuZXdMb2dpYywgb2xkTG9naWMsIF9yZWY7XG4gICAgICBpZiAoY29uaiA9PSBudWxsKSB7XG4gICAgICAgIGNvbmogPSAnYW5kJztcbiAgICAgIH1cbiAgICAgIGlmIChjb25qICE9PSAnYW5kJyAmJiBjb25qICE9PSAnb3InKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsb2dpY2FsIGNvbmp1bmN0aW9uOiAnICsgY29uaik7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNBcnJheShjb25zdHJhaW50KSkge1xuICAgICAgICBjb25zdHJhaW50ID0gaW50ZXJwcmV0Q29uQXJyYXkoY29uc3RyYWludCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdHJhaW50ID0gY29weUNvbihjb25zdHJhaW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25zdHJhaW50LnN3aXRjaGVkID09PSAnT0ZGJykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGNvbnN0cmFpbnQucGF0aCA9IHRoaXMuYWRqdXN0UGF0aChjb25zdHJhaW50LnBhdGgpO1xuICAgICAgaWYgKGNvbnN0cmFpbnQudHlwZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0cmFpbnQub3AgPSBnZXRfY2Fub25pY2FsX29wKGNvbnN0cmFpbnQub3ApO1xuICAgICAgfVxuICAgICAgdGhpcy5jb25zdHJhaW50cy5wdXNoKGNvbnN0cmFpbnQpO1xuICAgICAgbmVlZHNMb2dpY0NsYXVzZSA9IChjb25qID09PSAnb3InKSB8fCAoKChfcmVmID0gdGhpcy5jb25zdHJhaW50TG9naWMpICE9IG51bGwgPyBfcmVmLmxlbmd0aCA6IHZvaWQgMCkgPiAwKTtcbiAgICAgIG5ld0NvbkxlbiA9IHRoaXMuY29uc3RyYWludHMubGVuZ3RoO1xuICAgICAgb2xkTG9naWMgPSB0aGlzLmNvbnN0cmFpbnRMb2dpYztcbiAgICAgIGlmIChuZWVkc0xvZ2ljQ2xhdXNlKSB7XG4gICAgICAgIG5ld0xvZ2ljID0gbmV3Q29uTGVuID09PSAyID8gXCJcIiArIENPREVTWzBdICsgXCIgXCIgKyBjb25qICsgXCIgXCIgKyBDT0RFU1sxXSA6IChsb2dpYyA9IHRoaXMuY29uc3RyYWludExvZ2ljLCBsb2dpYyB8fCAobG9naWMgPSAoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaSwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChpID0gX2kgPSAwLCBfcmVmMSA9IG5ld0NvbkxlbiAtIDI7IDAgPD0gX3JlZjEgPyBfaSA8PSBfcmVmMSA6IF9pID49IF9yZWYxOyBpID0gMCA8PSBfcmVmMSA/ICsrX2kgOiAtLV9pKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKENPREVTW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KSgpKS5qb2luKCcgYW5kICcpKSwgXCIoXCIgKyBsb2dpYyArIFwiKSBcIiArIGNvbmogKyBcIiBcIiArIENPREVTW25ld0NvbkxlbiAtIDFdKTtcbiAgICAgICAgdGhpcy5jb25zdHJhaW50TG9naWMgPSBuZXdMb2dpYztcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fX3NpbGVudF9fKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignYWRkOmNvbnN0cmFpbnQnLCBjb25zdHJhaW50KTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2U6Y29uc3RyYWludHMnKTtcbiAgICAgICAgaWYgKG9sZExvZ2ljICE9PSB0aGlzLmNvbnN0cmFpbnRMb2dpYykge1xuICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOmxvZ2ljJywgdGhpcy5jb25zdHJhaW50TG9naWMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldFNvcnRpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdHJpbmdpZnlTb3J0T3JkZXIodGhpcy5zb3J0T3JkZXIpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0Q29uc3RyYWludFhNTCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGMsIHRvU2VyaWFsaXNlO1xuICAgICAgdG9TZXJpYWxpc2UgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLmNvbnN0cmFpbnRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBjID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKChjLnR5cGUgPT0gbnVsbCkgfHwgdGhpcy5pc0luUXVlcnkoYy5wYXRoKSkge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIGlmICh0b1NlcmlhbGlzZS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdE1hcChjb25TdHIpKGNvbmNhdE1hcChpZCkocGFydGl0aW9uKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICByZXR1cm4gYy50eXBlICE9IG51bGw7XG4gICAgICAgIH0pKHRvU2VyaWFsaXNlKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZ2V0Sm9pblhNTCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAsIHMsIHN0cnM7XG4gICAgICBzdHJzID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLmpvaW5zO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKHAgaW4gX3JlZikge1xuICAgICAgICAgIHMgPSBfcmVmW3BdO1xuICAgICAgICAgIGlmICh0aGlzLmlzSW5RdWVyeShwKSAmJiBzID09PSAnT1VURVInKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKFwiPGpvaW4gcGF0aD1cXFwiXCIgKyBwICsgXCJcXFwiIHN0eWxlPVxcXCJPVVRFUlxcXCIvPlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKTtcbiAgICAgIHJldHVybiBzdHJzLmpvaW4oJycpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUudG9YTUwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhdHRycywgaGVhZEF0dHJzLCBrLCB2O1xuICAgICAgYXR0cnMgPSB7XG4gICAgICAgIG1vZGVsOiB0aGlzLm1vZGVsLm5hbWUsXG4gICAgICAgIHZpZXc6IHRoaXMudmlld3Muam9pbignICcpLFxuICAgICAgICBzb3J0T3JkZXI6IHRoaXMuZ2V0U29ydGluZygpLFxuICAgICAgICBjb25zdHJhaW50TG9naWM6IHRoaXMuY29uc3RyYWludExvZ2ljXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGF0dHJzLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICB9XG4gICAgICBoZWFkQXR0cnMgPSAoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgX3Jlc3VsdHM7XG4gICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoayBpbiBhdHRycykge1xuICAgICAgICAgIHYgPSBhdHRyc1trXTtcbiAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChrICsgJz1cIicgKyB2ICsgJ1wiJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgIH0pKCkpLmpvaW4oJyAnKTtcbiAgICAgIHJldHVybiBcIjxxdWVyeSBcIiArIGhlYWRBdHRycyArIFwiID5cIiArICh0aGlzLmdldEpvaW5YTUwoKSkgKyAodGhpcy5nZXRDb25zdHJhaW50WE1MKCkpICsgXCI8L3F1ZXJ5PlwiO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYywgZGlyZWN0aW9uLCBwYXRoLCBzdHlsZSwgdjtcbiAgICAgIHJldHVybiBub1VuZGVmVmFscyh7XG4gICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgdGl0bGU6IHRoaXMudGl0bGUsXG4gICAgICAgIGNvbW1lbnQ6IHRoaXMuY29tbWVudCxcbiAgICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICAgIGNvbnN0cmFpbnRMb2dpYzogdGhpcy5jb25zdHJhaW50TG9naWMsXG4gICAgICAgIGZyb206IHRoaXMucm9vdCxcbiAgICAgICAgc2VsZWN0OiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVmID0gdGhpcy52aWV3cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgdiA9IF9yZWZbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChoZWFkTGVzcyh2KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgfSkuY2FsbCh0aGlzKSxcbiAgICAgICAgb3JkZXJCeTogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZWYgPSB0aGlzLnNvcnRPcmRlcjtcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgICAgX3JlZjEgPSBfcmVmW19pXSwgcGF0aCA9IF9yZWYxLnBhdGgsIGRpcmVjdGlvbiA9IF9yZWYxLmRpcmVjdGlvbjtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICBwYXRoOiBoZWFkTGVzcyhwYXRoKSxcbiAgICAgICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb25cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcyksXG4gICAgICAgIGpvaW5zOiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9yZWYsIF9yZXN1bHRzO1xuICAgICAgICAgIF9yZWYgPSB0aGlzLmpvaW5zO1xuICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgZm9yIChwYXRoIGluIF9yZWYpIHtcbiAgICAgICAgICAgIHN0eWxlID0gX3JlZltwYXRoXTtcbiAgICAgICAgICAgIGlmIChzdHlsZSA9PT0gJ09VVEVSJykge1xuICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKGhlYWRMZXNzKHBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpLFxuICAgICAgICB3aGVyZTogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZiA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgIGMgPSBfcmVmW19pXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goY29uVG9KU09OKGMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9KS5jYWxsKHRoaXMpXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmZldGNoQ29kZSA9IGZ1bmN0aW9uKGxhbmcsIGNiKSB7XG4gICAgICB2YXIgcmVxO1xuICAgICAgcmVxID0ge1xuICAgICAgICBxdWVyeTogdGhpcy50b1hNTCgpLFxuICAgICAgICBsYW5nOiBsYW5nXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLnBvc3QoJ3F1ZXJ5L2NvZGUnLCByZXEpLnRoZW4odGhpcy5zZXJ2aWNlLlZFUklGSUVSKS50aGVuKGdldCgnY29kZScpKSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5zZXROYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbihuYW1lLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcy5zZXJ2aWNlLCAxNiwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcmVxLCBfcmVmO1xuICAgICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKG5hbWUpKSB7XG4gICAgICAgICAgICBfcmVmID0gW251bGwsIG5hbWVdLCBuYW1lID0gX3JlZlswXSwgY2IgPSBfcmVmWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXROYW1lKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXEgPSB7XG4gICAgICAgICAgICB0eXBlOiAnUFVUJyxcbiAgICAgICAgICAgIHBhdGg6ICd1c2VyL3F1ZXJpZXMnLFxuICAgICAgICAgICAgZGF0YTogX3RoaXMudG9YTUwoKSxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24veG1sJyxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLnNlcnZpY2UuYXV0aG9yaXNlKHJlcSkpLnRoZW4oZnVuY3Rpb24oYXV0aGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VydmljZS5kb1JlcShhdXRoZWQpO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3AucXVlcmllcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnN0b3JlID0gZnVuY3Rpb24obmFtZSwgY2IpIHtcbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMuc2VydmljZSwgMTYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGdldE5hbWUsIHJlcSwgdXBkYXRlTmFtZSwgX3JlZjtcbiAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICAgICAgX3JlZiA9IFtudWxsLCBuYW1lXSwgbmFtZSA9IF9yZWZbMF0sIGNiID0gX3JlZlsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0TmFtZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlTmFtZSA9IGZ1bmN0aW9uKGVyciwgbmFtZSkge1xuICAgICAgICAgICAgaWYgKGVyciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXROYW1lKG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZ2V0TmFtZSA9IHV0aWxzLmNvbXBvc2UoZ2V0KF90aGlzLm5hbWUpLCBnZXQoJ3F1ZXJpZXMnKSk7XG4gICAgICAgICAgcmVxID0ge1xuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgcGF0aDogJ3VzZXIvcXVlcmllcycsXG4gICAgICAgICAgICBkYXRhOiBfdGhpcy50b1hNTCgpLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgICAgICAgICAgZGF0YVR5cGU6ICdqc29uJ1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdXBkYXRlTmFtZSwgX3RoaXMuc2VydmljZS5hdXRob3Jpc2UocmVxKSkudGhlbihmdW5jdGlvbihhdXRoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zZXJ2aWNlLmRvUmVxKGF1dGhlZCk7XG4gICAgICAgICAgfSkudGhlbihnZXROYW1lKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLnNhdmVBc1RlbXBsYXRlID0gZnVuY3Rpb24obmFtZSwgY2IpIHtcbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMuc2VydmljZSwgMTYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHJlcSwgX3JlZjtcbiAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihuYW1lKSkge1xuICAgICAgICAgICAgX3JlZiA9IFtudWxsLCBuYW1lXSwgbmFtZSA9IF9yZWZbMF0sIGNiID0gX3JlZlsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0TmFtZShuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUZW1wbGF0ZXMgbXVzdCBoYXZlIGEgbmFtZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxID0ge1xuICAgICAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICAgICAgcGF0aDogJ3RlbXBsYXRlcycsXG4gICAgICAgICAgICBkYXRhOiBcIjx0ZW1wbGF0ZSBcIiArIChjb25BdHRycyhfdGhpcywgWyduYW1lJywgJ3RpdGxlJywgJ2NvbW1lbnQnXSkpICsgXCI+XCIgKyAoX3RoaXMudG9YTUwoKSkgKyBcIjwvdGVtcGxhdGU+XCIsXG4gICAgICAgICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3htbCcsXG4gICAgICAgICAgICBkYXRhVHlwZTogJ2pzb24nXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5zZXJ2aWNlLmF1dGhvcmlzZShyZXEpLnRoZW4oZnVuY3Rpb24oYXV0aGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VydmljZS5kb1JlcShhdXRoZWQpO1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldENvZGVVUkkgPSBmdW5jdGlvbihsYW5nKSB7XG4gICAgICB2YXIgcmVxLCBfcmVmO1xuICAgICAgcmVxID0ge1xuICAgICAgICBxdWVyeTogdGhpcy50b1hNTCgpLFxuICAgICAgICBsYW5nOiBsYW5nLFxuICAgICAgICBmb3JtYXQ6ICd0ZXh0J1xuICAgICAgfTtcbiAgICAgIGlmICgoKF9yZWYgPSB0aGlzLnNlcnZpY2UpICE9IG51bGwgPyBfcmVmLnRva2VuIDogdm9pZCAwKSAhPSBudWxsKSB7XG4gICAgICAgIHJlcS50b2tlbiA9IHRoaXMuc2VydmljZS50b2tlbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIlwiICsgdGhpcy5zZXJ2aWNlLnJvb3QgKyBcInF1ZXJ5L2NvZGU/XCIgKyAodG9RdWVyeVN0cmluZyhyZXEpKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLmdldEV4cG9ydFVSSSA9IGZ1bmN0aW9uKGZvcm1hdCwgb3B0aW9ucykge1xuICAgICAgdmFyIHJlcSwgX3JlZjtcbiAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICBmb3JtYXQgPSAndGFiJztcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKF9faW5kZXhPZi5jYWxsKFF1ZXJ5LkJJT19GT1JNQVRTLCBmb3JtYXQpID49IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbXCJnZXRcIiArIChmb3JtYXQudG9VcHBlckNhc2UoKSkgKyBcIlVSSVwiXShvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJlcSA9IG1lcmdlKG9wdGlvbnMsIHtcbiAgICAgICAgcXVlcnk6IHRoaXMudG9YTUwoKSxcbiAgICAgICAgZm9ybWF0OiBmb3JtYXRcbiAgICAgIH0pO1xuICAgICAgaWYgKCgoX3JlZiA9IHRoaXMuc2VydmljZSkgIT0gbnVsbCA/IF9yZWYudG9rZW4gOiB2b2lkIDApICE9IG51bGwpIHtcbiAgICAgICAgcmVxLnRva2VuID0gdGhpcy5zZXJ2aWNlLnRva2VuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLnNlcnZpY2Uucm9vdCArIFwicXVlcnkvcmVzdWx0cz9cIiArICh0b1F1ZXJ5U3RyaW5nKHJlcSkpO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUubmVlZHNBdXRoZW50aWNhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHV0aWxzLmFueSh0aGlzLmNvbnN0cmFpbnRzLCBmdW5jdGlvbihjKSB7XG4gICAgICAgIHZhciBfcmVmO1xuICAgICAgICByZXR1cm4gKF9yZWYgPSBjLm9wKSA9PT0gJ05PVCBJTicgfHwgX3JlZiA9PT0gJ0lOJztcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBRdWVyeS5wcm90b3R5cGUuZmV0Y2hRSUQgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5zZXJ2aWNlLnBvc3QoJ3F1ZXJpZXMnLCB7XG4gICAgICAgIHF1ZXJ5OiB0aGlzLnRvWE1MKClcbiAgICAgIH0pLnRoZW4oZ2V0KCdpZCcpKSk7XG4gICAgfTtcblxuICAgIGFkZFBJID0gZnVuY3Rpb24ocCkge1xuICAgICAgcmV0dXJuIHAuYXBwZW5kKCdwcmltYXJ5SWRlbnRpZmllcicpLnRvU3RyaW5nKCk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5fX2Jpb19yZXEgPSBmdW5jdGlvbih0eXBlcywgbikge1xuICAgICAgdmFyIGlzU3VpdGFibGUsIHRvUnVuO1xuICAgICAgdG9SdW4gPSB0aGlzLm1ha2VMaXN0UXVlcnkoKTtcbiAgICAgIGlzU3VpdGFibGUgPSBmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiB1dGlscy5hbnkodHlwZXMsIGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgICByZXR1cm4gcC5pc2EodCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRvUnVuLnZpZXdzID0gdXRpbHMudGFrZShuKSgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfaSwgX2xlbiwgX3JlZiwgX3Jlc3VsdHM7XG4gICAgICAgIF9yZWYgPSB0aGlzLmdldFZpZXdOb2RlcygpO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBuID0gX3JlZltfaV07XG4gICAgICAgICAgaWYgKGlzU3VpdGFibGUobikpIHtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goYWRkUEkobikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KS5jYWxsKHRoaXMpKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHF1ZXJ5OiB0b1J1bi50b1hNTCgpLFxuICAgICAgICBmb3JtYXQ6ICd0ZXh0J1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLl9mYXN0YV9yZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fYmlvX3JlcShbXCJTZXF1ZW5jZUZlYXR1cmVcIiwgJ1Byb3RlaW4nXSwgMSk7XG4gICAgfTtcblxuICAgIFF1ZXJ5LnByb3RvdHlwZS5fZ2ZmM19yZXEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fYmlvX3JlcShbJ1NlcXVlbmNlRmVhdHVyZSddKTtcbiAgICB9O1xuXG4gICAgUXVlcnkucHJvdG90eXBlLl9iZWRfcmVxID0gUXVlcnkucHJvdG90eXBlLl9nZmYzX3JlcTtcblxuICAgIHJldHVybiBRdWVyeTtcblxuICB9KSgpO1xuXG4gIHVuaW9uID0gZm9sZChmdW5jdGlvbih4cywgeXMpIHtcbiAgICByZXR1cm4geHMuY29uY2F0KHlzKTtcbiAgfSk7XG5cbiAgUXVlcnkucHJvdG90eXBlLnRvU3RyaW5nID0gUXVlcnkucHJvdG90eXBlLnRvWE1MO1xuXG4gIFF1ZXJ5LkFUVFJJQlVURV9PUFMgPSB1bmlvbihbUXVlcnkuQVRUUklCVVRFX1ZBTFVFX09QUywgUXVlcnkuTVVMVElWQUxVRV9PUFMsIFF1ZXJ5Lk5VTExfT1BTXSk7XG5cbiAgUXVlcnkuUkVGRVJFTkNFX09QUyA9IHVuaW9uKFtRdWVyeS5URVJOQVJZX09QUywgUXVlcnkuTE9PUF9PUFMsIFF1ZXJ5LkxJU1RfT1BTXSk7XG5cbiAgYmlvVXJpQXJncyA9IGZ1bmN0aW9uKHJlcU1ldGgsIGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob3B0cywgY2IpIHtcbiAgICAgIHZhciBlbnN1cmVBdHRyLCBvYmosIHJlcSwgdiwgX3JlZjtcbiAgICAgIGlmIChvcHRzID09IG51bGwpIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKGNiID09IG51bGwpIHtcbiAgICAgICAgY2IgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgfVxuICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ob3B0cykpIHtcbiAgICAgICAgX3JlZiA9IFt7fSwgb3B0c10sIG9wdHMgPSBfcmVmWzBdLCBjYiA9IF9yZWZbMV07XG4gICAgICB9XG4gICAgICBlbnN1cmVBdHRyID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihwKSB7XG4gICAgICAgICAgdmFyIHBhdGg7XG4gICAgICAgICAgcGF0aCA9IF90aGlzLmdldFBhdGhJbmZvKHApO1xuICAgICAgICAgIGlmIChwYXRoLmlzQXR0cmlidXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5hcHBlbmQoJ2lkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICBpZiAoKG9wdHMgIT0gbnVsbCA/IG9wdHMudmlldyA6IHZvaWQgMCkgIT0gbnVsbCkge1xuICAgICAgICBvcHRzLnZpZXcgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgICAgICAgX3JlZjEgPSBvcHRzLnZpZXc7XG4gICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYxLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgICAgICB2ID0gX3JlZjFbX2ldO1xuICAgICAgICAgICAgX3Jlc3VsdHMucHVzaCh0aGlzLmdldFBhdGhJbmZvKHYpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgIH0pLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgICBvYmogPSBvcHRzW1wiZXhwb3J0XCJdICE9IG51bGwgPyB0aGlzLnNlbGVjdFByZXNlcnZpbmdJbXBsaWVkQ29uc3RyYWludHMob3B0c1tcImV4cG9ydFwiXS5tYXAoZW5zdXJlQXR0cikpIDogdGhpcztcbiAgICAgIHJlcSA9IG1lcmdlKG9ialtyZXFNZXRoXSgpLCBvcHRzKTtcbiAgICAgIHJldHVybiBmLmNhbGwob2JqLCByZXEsIGNiKTtcbiAgICB9O1xuICB9O1xuXG4gIF9yZWYgPSBRdWVyeS5CSU9fRk9STUFUUztcbiAgX2ZuID0gZnVuY3Rpb24oZikge1xuICAgIHZhciBnZXRNZXRoLCByZXFNZXRoLCB1cmlNZXRoO1xuICAgIHJlcU1ldGggPSBcIl9cIiArIGYgKyBcIl9yZXFcIjtcbiAgICBnZXRNZXRoID0gXCJnZXRcIiArIChmLnRvVXBwZXJDYXNlKCkpO1xuICAgIHVyaU1ldGggPSBnZXRNZXRoICsgXCJVUklcIjtcbiAgICBRdWVyeS5wcm90b3R5cGVbZ2V0TWV0aF0gPSBiaW9VcmlBcmdzKHJlcU1ldGgsIGZ1bmN0aW9uKHJlcSwgY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5wb3N0KCdxdWVyeS9yZXN1bHRzLycgKyBmLCByZXEpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUXVlcnkucHJvdG90eXBlW3VyaU1ldGhdID0gYmlvVXJpQXJncyhyZXFNZXRoLCBmdW5jdGlvbihyZXEsIGNiKSB7XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlLnRva2VuICE9IG51bGwpIHtcbiAgICAgICAgcmVxLnRva2VuID0gdGhpcy5zZXJ2aWNlLnRva2VuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCIgKyB0aGlzLnNlcnZpY2Uucm9vdCArIFwicXVlcnkvcmVzdWx0cy9cIiArIGYgKyBcIj9cIiArICh0b1F1ZXJ5U3RyaW5nKHJlcSkpO1xuICAgIH0pO1xuICB9O1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBmID0gX3JlZltfaV07XG4gICAgX2ZuKGYpO1xuICB9XG5cbiAgX2dldF9kYXRhX2ZldGNoZXIgPSBmdW5jdGlvbihzZXJ2ZXJfZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2JzLCBwYWdlLCB4LCBfcmVmMTtcbiAgICAgIHBhZ2UgPSBhcmd1bWVudHNbMF0sIGNicyA9IDIgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgICBpZiAodGhpcy5zZXJ2aWNlW3NlcnZlcl9mbl0pIHtcbiAgICAgICAgaWYgKHBhZ2UgPT0gbnVsbCkge1xuICAgICAgICAgIHBhZ2UgPSB7fTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc0Z1bmN0aW9uKHBhZ2UpKSB7XG4gICAgICAgICAgcGFnZSA9IHt9O1xuICAgICAgICAgIGNicyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfaiwgX2xlbjEsIF9yZXN1bHRzO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2ogPSAwLCBfbGVuMSA9IGFyZ3VtZW50cy5sZW5ndGg7IF9qIDwgX2xlbjE7IF9qKyspIHtcbiAgICAgICAgICAgICAgeCA9IGFyZ3VtZW50c1tfal07XG4gICAgICAgICAgICAgIF9yZXN1bHRzLnB1c2goeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgICAgfSkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBwYWdlID0gbm9VbmRlZlZhbHMobWVyZ2Uoe1xuICAgICAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0LFxuICAgICAgICAgIHNpemU6IHRoaXMubWF4Um93c1xuICAgICAgICB9LCBwYWdlKSk7XG4gICAgICAgIHJldHVybiAoX3JlZjEgPSB0aGlzLnNlcnZpY2UpW3NlcnZlcl9mbl0uYXBwbHkoX3JlZjEsIFt0aGlzLCBwYWdlXS5jb25jYXQoX19zbGljZS5jYWxsKGNicykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlcnZpY2UgZG9lcyBub3QgcHJvdmlkZSAnXCIgKyBzZXJ2ZXJfZm4gKyBcIicuXCIpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgZm9yIChfaiA9IDAsIF9sZW4xID0gUkVTVUxUU19NRVRIT0RTLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgIG10aCA9IFJFU1VMVFNfTUVUSE9EU1tfal07XG4gICAgUXVlcnkucHJvdG90eXBlW210aF0gPSBfZ2V0X2RhdGFfZmV0Y2hlcihtdGgpO1xuICB9XG5cbiAgRXZlbnRzLm1peGluKFF1ZXJ5LnByb3RvdHlwZSk7XG5cbiAgUXVlcnkucHJvdG90eXBlLmVtaXQgPSBRdWVyeS5wcm90b3R5cGUudHJpZ2dlcjtcblxuICBRdWVyeS5wcm90b3R5cGUuYmluZCA9IFF1ZXJ5LnByb3RvdHlwZS5vbjtcblxuICBpbnRlcm1pbmUuUXVlcnkgPSBRdWVyeTtcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCIuL3V0aWxcIjoxNSxcIi4veG1sXCI6MTcsXCJiYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZVwiOjIxfV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgQUxXQVlTX0FVVEgsIENMQVNTS0VZUywgQ0xBU1NLRVlfUEFUSCwgREVGQVVMVF9FUlJPUl9IQU5ETEVSLCBERUZBVUxUX1BST1RPQ09MLCBFTlJJQ0hNRU5UX1BBVEgsIEhBU19QUk9UT0NPTCwgSEFTX1NVRkZJWCwgSURSZXNvbHV0aW9uSm9iLCBJRF9SRVNPTFVUSU9OX1BBVEgsIExJU1RTX1BBVEgsIExJU1RfT1BFUkFUSU9OX1BBVEhTLCBMSVNUX1BJUEUsIExpc3QsIE1PREVMUywgTU9ERUxfUEFUSCwgTW9kZWwsIE5FRURTX0FVVEgsIE5PX0FVVEgsIFBBVEhfVkFMVUVTX1BBVEgsIFBSRUZfUEFUSCwgUHJvbWlzZSwgUVVFUllfUkVTVUxUU19QQVRILCBRVUlDS1NFQVJDSF9QQVRILCBRdWVyeSwgUkVMRUFTRVMsIFJFTEVBU0VfUEFUSCwgUkVRVUlSRVNfVkVSU0lPTiwgU1VCVFJBQ1RfUEFUSCwgU1VGRklYLCBTVU1NQVJZRklFTERTX1BBVEgsIFNVTU1BUllfRklFTERTLCBTZXJ2aWNlLCBUQUJMRV9ST1dfUEFUSCwgVEVNUExBVEVTX1BBVEgsIFRPX05BTUVTLCBVU0VSX1RPS0VOUywgVXNlciwgVkVSU0lPTlMsIFZFUlNJT05fUEFUSCwgV0hPQU1JX1BBVEgsIFdJREdFVFMsIFdJREdFVFNfUEFUSCwgV0lUSF9PQkpfUEFUSCwgZGVqb2luLCBlcnJvciwgZ2V0LCBnZXRMaXN0RmluZGVyLCBodHRwLCBpbnZva2UsIG1hcCwgbWVyZ2UsIHAsIHNldCwgc3VjY2VzcywgdG9fcXVlcnlfc3RyaW5nLCB1dGlscywgdmVyc2lvbiwgd2l0aENCLCBfZ2V0X29yX2ZldGNoLCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmLCBfcmVmMSxcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9LFxuICAgIF9faGFzUHJvcCA9IHt9Lmhhc093blByb3BlcnR5LFxuICAgIF9fc2xpY2UgPSBbXS5zbGljZTtcblxuICBQcm9taXNlID0gX2RlcmVxXygnLi9wcm9taXNlJyk7XG5cbiAgTW9kZWwgPSBfZGVyZXFfKCcuL21vZGVsJykuTW9kZWw7XG5cbiAgUXVlcnkgPSBfZGVyZXFfKCcuL3F1ZXJ5JykuUXVlcnk7XG5cbiAgTGlzdCA9IF9kZXJlcV8oJy4vbGlzdHMnKS5MaXN0O1xuXG4gIFVzZXIgPSBfZGVyZXFfKCcuL3VzZXInKS5Vc2VyO1xuXG4gIElEUmVzb2x1dGlvbkpvYiA9IF9kZXJlcV8oJy4vaWQtcmVzb2x1dGlvbi1qb2InKS5JRFJlc29sdXRpb25Kb2I7XG5cbiAgdmVyc2lvbiA9IF9kZXJlcV8oJy4vdmVyc2lvbicpO1xuXG4gIHV0aWxzID0gX2RlcmVxXygnLi91dGlsJyk7XG5cbiAgaHR0cCA9IF9kZXJlcV8oJy4vaHR0cCcpO1xuXG4gIHRvX3F1ZXJ5X3N0cmluZyA9IHV0aWxzLnF1ZXJ5c3RyaW5nO1xuXG4gIHdpdGhDQiA9IHV0aWxzLndpdGhDQiwgbWFwID0gdXRpbHMubWFwLCBtZXJnZSA9IHV0aWxzLm1lcmdlLCBnZXQgPSB1dGlscy5nZXQsIHNldCA9IHV0aWxzLnNldCwgaW52b2tlID0gdXRpbHMuaW52b2tlLCBzdWNjZXNzID0gdXRpbHMuc3VjY2VzcywgZXJyb3IgPSB1dGlscy5lcnJvciwgUkVRVUlSRVNfVkVSU0lPTiA9IHV0aWxzLlJFUVVJUkVTX1ZFUlNJT04sIGRlam9pbiA9IHV0aWxzLmRlam9pbjtcblxuICBWRVJTSU9OUyA9IHt9O1xuXG4gIENMQVNTS0VZUyA9IHt9O1xuXG4gIFJFTEVBU0VTID0ge307XG5cbiAgTU9ERUxTID0ge307XG5cbiAgU1VNTUFSWV9GSUVMRFMgPSB7fTtcblxuICBXSURHRVRTID0ge307XG5cbiAgREVGQVVMVF9QUk9UT0NPTCA9IFwiaHR0cDovL1wiO1xuXG4gIFZFUlNJT05fUEFUSCA9IFwidmVyc2lvblwiO1xuXG4gIFRFTVBMQVRFU19QQVRIID0gXCJ0ZW1wbGF0ZXNcIjtcblxuICBSRUxFQVNFX1BBVEggPSBcInZlcnNpb24vcmVsZWFzZVwiO1xuXG4gIENMQVNTS0VZX1BBVEggPSBcImNsYXNza2V5c1wiO1xuXG4gIExJU1RTX1BBVEggPSBcImxpc3RzXCI7XG5cbiAgTU9ERUxfUEFUSCA9IFwibW9kZWxcIjtcblxuICBTVU1NQVJZRklFTERTX1BBVEggPSBcInN1bW1hcnlmaWVsZHNcIjtcblxuICBRVUVSWV9SRVNVTFRTX1BBVEggPSBcInF1ZXJ5L3Jlc3VsdHNcIjtcblxuICBRVUlDS1NFQVJDSF9QQVRIID0gXCJzZWFyY2hcIjtcblxuICBXSURHRVRTX1BBVEggPSBcIndpZGdldHNcIjtcblxuICBFTlJJQ0hNRU5UX1BBVEggPSBcImxpc3QvZW5yaWNobWVudFwiO1xuXG4gIFdJVEhfT0JKX1BBVEggPSBcImxpc3Rzd2l0aG9iamVjdFwiO1xuXG4gIExJU1RfT1BFUkFUSU9OX1BBVEhTID0ge1xuICAgIHVuaW9uOiBcImxpc3RzL3VuaW9uXCIsXG4gICAgaW50ZXJzZWN0aW9uOiBcImxpc3RzL2ludGVyc2VjdFwiLFxuICAgIGRpZmZlcmVuY2U6IFwibGlzdHMvZGlmZlwiXG4gIH07XG5cbiAgU1VCVFJBQ1RfUEFUSCA9ICdsaXN0cy9zdWJ0cmFjdCc7XG5cbiAgV0hPQU1JX1BBVEggPSBcInVzZXIvd2hvYW1pXCI7XG5cbiAgVEFCTEVfUk9XX1BBVEggPSBRVUVSWV9SRVNVTFRTX1BBVEggKyAnL3RhYmxlcm93cyc7XG5cbiAgUFJFRl9QQVRIID0gJ3VzZXIvcHJlZmVyZW5jZXMnO1xuXG4gIFBBVEhfVkFMVUVTX1BBVEggPSAncGF0aC92YWx1ZXMnO1xuXG4gIFVTRVJfVE9LRU5TID0gJ3VzZXIvdG9rZW5zJztcblxuICBJRF9SRVNPTFVUSU9OX1BBVEggPSAnaWRzJztcblxuICBOT19BVVRIID0ge307XG5cbiAgX3JlZiA9IFtWRVJTSU9OX1BBVEgsIFJFTEVBU0VfUEFUSCwgQ0xBU1NLRVlfUEFUSCwgV0lER0VUU19QQVRILCBNT0RFTF9QQVRILCBTVU1NQVJZRklFTERTX1BBVEgsIFFVSUNLU0VBUkNIX1BBVEgsIFBBVEhfVkFMVUVTX1BBVEhdO1xuICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICBwID0gX3JlZltfaV07XG4gICAgTk9fQVVUSFtwXSA9IHRydWU7XG4gIH1cblxuICBBTFdBWVNfQVVUSCA9IHt9O1xuXG4gIF9yZWYxID0gW1dIT0FNSV9QQVRILCBQUkVGX1BBVEgsIExJU1RfT1BFUkFUSU9OX1BBVEhTLCBTVUJUUkFDVF9QQVRILCBXSVRIX09CSl9QQVRILCBFTlJJQ0hNRU5UX1BBVEgsIFRFTVBMQVRFU19QQVRILCBVU0VSX1RPS0VOU107XG4gIGZvciAoX2ogPSAwLCBfbGVuMSA9IF9yZWYxLmxlbmd0aDsgX2ogPCBfbGVuMTsgX2orKykge1xuICAgIHAgPSBfcmVmMVtfal07XG4gICAgQUxXQVlTX0FVVEhbcF0gPSB0cnVlO1xuICB9XG5cbiAgTkVFRFNfQVVUSCA9IGZ1bmN0aW9uKHBhdGgsIHEpIHtcbiAgICBpZiAoTk9fQVVUSFtwYXRoXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoQUxXQVlTX0FVVEhbcGF0aF0pIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIShxICE9IG51bGwgPyBxLm5lZWRzQXV0aGVudGljYXRpb24gOiB2b2lkIDApKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHEubmVlZHNBdXRoZW50aWNhdGlvbigpO1xuICAgIH1cbiAgfTtcblxuICBIQVNfUFJPVE9DT0wgPSAvXmh0dHBzPzpcXC9cXC8vaTtcblxuICBIQVNfU1VGRklYID0gL3NlcnZpY2VcXC8/JC9pO1xuXG4gIFNVRkZJWCA9IFwiL3NlcnZpY2UvXCI7XG5cbiAgREVGQVVMVF9FUlJPUl9IQU5ETEVSID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBmLCBfcmVmMjtcbiAgICBmID0gKF9yZWYyID0gY29uc29sZS5lcnJvcikgIT0gbnVsbCA/IF9yZWYyIDogY29uc29sZS5sb2c7XG4gICAgcmV0dXJuIGYoZSk7XG4gIH07XG5cbiAgX2dldF9vcl9mZXRjaCA9IGZ1bmN0aW9uKHByb3BOYW1lLCBzdG9yZSwgcGF0aCwga2V5LCBjYikge1xuICAgIHZhciBvcHRzLCBwcm9taXNlLCByb290LCB1c2VDYWNoZSwgdmFsdWU7XG4gICAgcm9vdCA9IHRoaXMucm9vdCwgdXNlQ2FjaGUgPSB0aGlzLnVzZUNhY2hlO1xuICAgIHByb21pc2UgPSB0aGlzW3Byb3BOYW1lXSAhPSBudWxsID8gdGhpc1twcm9wTmFtZV0gOiB0aGlzW3Byb3BOYW1lXSA9IHVzZUNhY2hlICYmICh2YWx1ZSA9IHN0b3JlW3Jvb3RdKSA/IHN1Y2Nlc3ModmFsdWUpIDogKG9wdHMgPSB7XG4gICAgICB0eXBlOiAnR0VUJyxcbiAgICAgIGRhdGFUeXBlOiAnanNvbicsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGZvcm1hdDogJ2pzb24nXG4gICAgICB9XG4gICAgfSwgdGhpcy5kb1JlcShtZXJnZShvcHRzLCB7XG4gICAgICB1cmw6IHRoaXMucm9vdCArIHBhdGhcbiAgICB9KSkudGhlbihmdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gc3RvcmVbcm9vdF0gPSB4W2tleV07XG4gICAgfSkpO1xuICAgIHJldHVybiB3aXRoQ0IoY2IsIHByb21pc2UpO1xuICB9O1xuXG4gIGdldExpc3RGaW5kZXIgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGxpc3RzKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBsaXN0O1xuICAgICAgICBpZiAobGlzdCA9IHV0aWxzLmZpbmQobGlzdHMsIGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICByZXR1cm4gbC5uYW1lID09PSBuYW1lO1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlKGxpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiByZWplY3QoXCJMaXN0IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgbm90IGZvdW5kIGFtb25nOiBcIiArIChsaXN0cy5tYXAoZ2V0KCduYW1lJykpKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH07XG5cbiAgTElTVF9QSVBFID0gZnVuY3Rpb24oc2VydmljZSwgcHJvcCkge1xuICAgIGlmIChwcm9wID09IG51bGwpIHtcbiAgICAgIHByb3AgPSAnbGlzdE5hbWUnO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuY29tcG9zZShzZXJ2aWNlLmZldGNoTGlzdCwgZ2V0KHByb3ApKTtcbiAgfTtcblxuICBUT19OQU1FUyA9IGZ1bmN0aW9uKHhzKSB7XG4gICAgdmFyIHgsIF9rLCBfbGVuMiwgX3JlZjIsIF9yZWYzLCBfcmVzdWx0cztcbiAgICBpZiAoeHMgPT0gbnVsbCkge1xuICAgICAgeHMgPSBbXTtcbiAgICB9XG4gICAgX3JlZjIgPSAodXRpbHMuaXNBcnJheSh4cykgPyB4cyA6IFt4c10pO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfayA9IDAsIF9sZW4yID0gX3JlZjIubGVuZ3RoOyBfayA8IF9sZW4yOyBfaysrKSB7XG4gICAgICB4ID0gX3JlZjJbX2tdO1xuICAgICAgX3Jlc3VsdHMucHVzaCgoX3JlZjMgPSB4Lm5hbWUpICE9IG51bGwgPyBfcmVmMyA6IHgpO1xuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgU2VydmljZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgRklWRV9NSU4sIGNoZWNrTmFtZVBhcmFtLCBnZXROZXdVc2VyVG9rZW4sIGxvYWRRLCBwYXRoVmFsdWVzUmVxLCB0b01hcEJ5TmFtZTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmRvUmVxID0gaHR0cC5kb1JlcTtcblxuICAgIGZ1bmN0aW9uIFNlcnZpY2UoX2FyZykge1xuICAgICAgdmFyIG5vQ2FjaGU7XG4gICAgICB0aGlzLnJvb3QgPSBfYXJnLnJvb3QsIHRoaXMudG9rZW4gPSBfYXJnLnRva2VuLCB0aGlzLmVycm9ySGFuZGxlciA9IF9hcmcuZXJyb3JIYW5kbGVyLCB0aGlzLkRFQlVHID0gX2FyZy5ERUJVRywgdGhpcy5oZWxwID0gX2FyZy5oZWxwLCBub0NhY2hlID0gX2FyZy5ub0NhY2hlO1xuICAgICAgdGhpcy5jb25uZWN0QXMgPSBfX2JpbmQodGhpcy5jb25uZWN0QXMsIHRoaXMpO1xuICAgICAgdGhpcy5jcmVhdGVMaXN0ID0gX19iaW5kKHRoaXMuY3JlYXRlTGlzdCwgdGhpcyk7XG4gICAgICB0aGlzLnJlc29sdmVJZHMgPSBfX2JpbmQodGhpcy5yZXNvbHZlSWRzLCB0aGlzKTtcbiAgICAgIHRoaXMudGVtcGxhdGVRdWVyeSA9IF9fYmluZCh0aGlzLnRlbXBsYXRlUXVlcnksIHRoaXMpO1xuICAgICAgdGhpcy5zYXZlZFF1ZXJ5ID0gX19iaW5kKHRoaXMuc2F2ZWRRdWVyeSwgdGhpcyk7XG4gICAgICB0aGlzLnF1ZXJ5ID0gX19iaW5kKHRoaXMucXVlcnksIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaFJlbGVhc2UgPSBfX2JpbmQodGhpcy5mZXRjaFJlbGVhc2UsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaENsYXNzS2V5cyA9IF9fYmluZCh0aGlzLmZldGNoQ2xhc3NLZXlzLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hWZXJzaW9uID0gX19iaW5kKHRoaXMuZmV0Y2hWZXJzaW9uLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hTdW1tYXJ5RmllbGRzID0gX19iaW5kKHRoaXMuZmV0Y2hTdW1tYXJ5RmllbGRzLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hNb2RlbCA9IF9fYmluZCh0aGlzLmZldGNoTW9kZWwsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaFdpZGdldE1hcCA9IF9fYmluZCh0aGlzLmZldGNoV2lkZ2V0TWFwLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hXaWRnZXRzID0gX19iaW5kKHRoaXMuZmV0Y2hXaWRnZXRzLCB0aGlzKTtcbiAgICAgIHRoaXMuY29tcGxlbWVudCA9IF9fYmluZCh0aGlzLmNvbXBsZW1lbnQsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaExpc3RzQ29udGFpbmluZyA9IF9fYmluZCh0aGlzLmZldGNoTGlzdHNDb250YWluaW5nLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hMaXN0ID0gX19iaW5kKHRoaXMuZmV0Y2hMaXN0LCB0aGlzKTtcbiAgICAgIHRoaXMuZmluZExpc3RzID0gX19iaW5kKHRoaXMuZmluZExpc3RzLCB0aGlzKTtcbiAgICAgIHRoaXMuZmV0Y2hMaXN0cyA9IF9fYmluZCh0aGlzLmZldGNoTGlzdHMsIHRoaXMpO1xuICAgICAgdGhpcy5mZXRjaFRlbXBsYXRlcyA9IF9fYmluZCh0aGlzLmZldGNoVGVtcGxhdGVzLCB0aGlzKTtcbiAgICAgIHRoaXMudGFibGVSb3dzID0gX19iaW5kKHRoaXMudGFibGVSb3dzLCB0aGlzKTtcbiAgICAgIHRoaXMudmFsdWVzID0gX19iaW5kKHRoaXMudmFsdWVzLCB0aGlzKTtcbiAgICAgIHRoaXMucm93cyA9IF9fYmluZCh0aGlzLnJvd3MsIHRoaXMpO1xuICAgICAgdGhpcy5yZWNvcmRzID0gX19iaW5kKHRoaXMucmVjb3JkcywgdGhpcyk7XG4gICAgICB0aGlzLnRhYmxlID0gX19iaW5kKHRoaXMudGFibGUsIHRoaXMpO1xuICAgICAgdGhpcy5wYXRoVmFsdWVzID0gX19iaW5kKHRoaXMucGF0aFZhbHVlcywgdGhpcyk7XG4gICAgICB0aGlzLmZldGNoVXNlciA9IF9fYmluZCh0aGlzLmZldGNoVXNlciwgdGhpcyk7XG4gICAgICB0aGlzLndob2FtaSA9IF9fYmluZCh0aGlzLndob2FtaSwgdGhpcyk7XG4gICAgICB0aGlzLmZpbmRCeUlkID0gX19iaW5kKHRoaXMuZmluZEJ5SWQsIHRoaXMpO1xuICAgICAgdGhpcy5jb3VudCA9IF9fYmluZCh0aGlzLmNvdW50LCB0aGlzKTtcbiAgICAgIHRoaXMuZW5yaWNobWVudCA9IF9fYmluZCh0aGlzLmVucmljaG1lbnQsIHRoaXMpO1xuICAgICAgaWYgKHRoaXMucm9vdCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNlcnZpY2Ugcm9vdCBwcm92aWRlZC4gVGhpcyBpcyByZXF1aXJlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghSEFTX1BST1RPQ09MLnRlc3QodGhpcy5yb290KSkge1xuICAgICAgICB0aGlzLnJvb3QgPSBERUZBVUxUX1BST1RPQ09MICsgdGhpcy5yb290O1xuICAgICAgfVxuICAgICAgaWYgKCFIQVNfU1VGRklYLnRlc3QodGhpcy5yb290KSkge1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnJvb3QgKyBTVUZGSVg7XG4gICAgICB9XG4gICAgICB0aGlzLnJvb3QgPSB0aGlzLnJvb3QucmVwbGFjZSgvaWNlJC8sIFwiaWNlL1wiKTtcbiAgICAgIGlmICh0aGlzLmVycm9ySGFuZGxlciA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZXJyb3JIYW5kbGVyID0gREVGQVVMVF9FUlJPUl9IQU5ETEVSO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGVscCA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaGVscCA9ICduby5oZWxwLmF2YWlsYWJsZUBkZXYubnVsbCc7XG4gICAgICB9XG4gICAgICB0aGlzLnVzZUNhY2hlID0gIW5vQ2FjaGU7XG4gICAgICB0aGlzLmdldEZvcm1hdCA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaW50ZW5kZWQpIHtcbiAgICAgICAgICBpZiAoaW50ZW5kZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgaW50ZW5kZWQgPSAnanNvbic7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnRlbmRlZDtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpO1xuICAgIH1cblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnBvc3QgPSBmdW5jdGlvbihwYXRoLCBkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCgnUE9TVCcsIHBhdGgsIGRhdGEpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXRoLCBkYXRhKSB7XG4gICAgICByZXR1cm4gdGhpcy5tYWtlUmVxdWVzdCgnR0VUJywgcGF0aCwgZGF0YSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLm1ha2VSZXF1ZXN0ID0gZnVuY3Rpb24obWV0aG9kLCBwYXRoLCBkYXRhLCBjYiwgaW5kaXYpIHtcbiAgICAgIHZhciBkYXRhVHlwZSwgZXJyQmFjaywgb3B0cywgdGltZW91dCwgX3JlZjIsIF9yZWYzLCBfcmVmNDtcbiAgICAgIGlmIChtZXRob2QgPT0gbnVsbCkge1xuICAgICAgICBtZXRob2QgPSAnR0VUJztcbiAgICAgIH1cbiAgICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgcGF0aCA9ICcnO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEgPT0gbnVsbCkge1xuICAgICAgICBkYXRhID0ge307XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRpdiA9PSBudWxsKSB7XG4gICAgICAgIGluZGl2ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuaXNBcnJheShjYikpIHtcbiAgICAgICAgX3JlZjIgPSBjYiwgY2IgPSBfcmVmMlswXSwgZXJyQmFjayA9IF9yZWYyWzFdO1xuICAgICAgfVxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IHV0aWxzLnBhaXJzVG9PYmooZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoZXJyQmFjayA9PSBudWxsKSB7XG4gICAgICAgIGVyckJhY2sgPSB0aGlzLmVycm9ySGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGRhdGEgPSB1dGlscy5jb3B5KGRhdGEpO1xuICAgICAgZGF0YVR5cGUgPSB0aGlzLmdldEZvcm1hdChkYXRhLmZvcm1hdCk7XG4gICAgICBpZiAoIWh0dHAuc3VwcG9ydHMobWV0aG9kKSkge1xuICAgICAgICBfcmVmMyA9IFttZXRob2QsIGh0dHAuZ2V0TWV0aG9kKG1ldGhvZCldLCBkYXRhLm1ldGhvZCA9IF9yZWYzWzBdLCBtZXRob2QgPSBfcmVmM1sxXTtcbiAgICAgIH1cbiAgICAgIG9wdHMgPSB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGRhdGFUeXBlOiBkYXRhVHlwZSxcbiAgICAgICAgc3VjY2VzczogY2IsXG4gICAgICAgIGVycm9yOiBlcnJCYWNrLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICB0eXBlOiBtZXRob2RcbiAgICAgIH07XG4gICAgICBpZiAoZGF0YS5hdXRoICE9IG51bGwpIHtcbiAgICAgICAgb3B0cy5hdXRoID0gZGF0YS5hdXRoO1xuICAgICAgICBkZWxldGUgb3B0cy5kYXRhLmF1dGg7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5oZWFkZXJzICE9IG51bGwpIHtcbiAgICAgICAgb3B0cy5oZWFkZXJzID0gdXRpbHMuY29weShkYXRhLmhlYWRlcnMpO1xuICAgICAgICBkZWxldGUgb3B0cy5kYXRhLmhlYWRlcnM7XG4gICAgICB9XG4gICAgICBpZiAodGltZW91dCA9IChfcmVmNCA9IGRhdGEudGltZW91dCkgIT0gbnVsbCA/IF9yZWY0IDogdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIG9wdHMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIGRlbGV0ZSBkYXRhLnRpbWVvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hdXRob3Jpc2Uob3B0cykudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGF1dGhlZCkge1xuICAgICAgICAgIHJldHVybiBfdGhpcy5kb1JlcShhdXRoZWQsIGluZGl2KTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuYXV0aG9yaXNlID0gZnVuY3Rpb24ocmVxKSB7XG4gICAgICByZXR1cm4gdGhpcy5mZXRjaFZlcnNpb24oKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24odmVyc2lvbikge1xuICAgICAgICAgIHZhciBvcHRzLCBwYXRoQWRkaXRpb25zLCBfcmVmMjtcbiAgICAgICAgICBvcHRzID0gdXRpbHMuY29weShyZXEpO1xuICAgICAgICAgIGlmIChvcHRzLmhlYWRlcnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0cy5oZWFkZXJzID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wdHMudXJsID0gX3RoaXMucm9vdCArIG9wdHMucGF0aDtcbiAgICAgICAgICBwYXRoQWRkaXRpb25zID0gW107XG4gICAgICAgICAgaWYgKHZlcnNpb24gPCAxNCkge1xuICAgICAgICAgICAgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygb3B0cy5kYXRhKSB7XG4gICAgICAgICAgICAgIHBhdGhBZGRpdGlvbnMucHVzaChbJ2Zvcm1hdCcsIG9wdHMuZGF0YVR5cGVdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wdHMuZGF0YS5mb3JtYXQgPSBvcHRzLmRhdGFUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoKF90aGlzLnRva2VuICE9IG51bGwpICYmIE5FRURTX0FVVEgocmVxLnBhdGgsIChfcmVmMiA9IG9wdHMuZGF0YSkgIT0gbnVsbCA/IF9yZWYyLnF1ZXJ5IDogdm9pZCAwKSkge1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gPj0gMTQpIHtcbiAgICAgICAgICAgICAgb3B0cy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBcIlRva2VuIFwiICsgX3RoaXMudG9rZW47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2Ygb3B0cy5kYXRhKSB7XG4gICAgICAgICAgICAgIHBhdGhBZGRpdGlvbnMucHVzaChbJ3Rva2VuJywgX3RoaXMudG9rZW5dKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG9wdHMuZGF0YS50b2tlbiA9IF90aGlzLnRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGF0aEFkZGl0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG9wdHMudXJsICs9ICc/JyArIHRvX3F1ZXJ5X3N0cmluZyhwYXRoQWRkaXRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9wdHM7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmVucmljaG1lbnQgPSBmdW5jdGlvbihvcHRzLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgOCwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcmVxO1xuICAgICAgICAgIHJlcSA9IG1lcmdlKHtcbiAgICAgICAgICAgIG1heHA6IDAuMDUsXG4gICAgICAgICAgICBjb3JyZWN0aW9uOiAnSG9sbS1Cb25mZXJyb25pJ1xuICAgICAgICAgIH0sIG9wdHMpO1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLmdldChFTlJJQ0hNRU5UX1BBVEgsIHJlcSkudGhlbihnZXQoJ3Jlc3VsdHMnKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbihvcHRpb25zLCBjYikge1xuICAgICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMsIDksIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGssIHJlcSwgdiwgX3JlZjI7XG4gICAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgICAgICAgIF9yZWYyID0gW29wdGlvbnMsIHt9XSwgY2IgPSBfcmVmMlswXSwgb3B0aW9ucyA9IF9yZWYyWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXEgPSB7XG4gICAgICAgICAgICAgIHE6IG9wdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcSA9IHtcbiAgICAgICAgICAgICAgcTogb3B0aW9ucy5xXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChrIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChvcHRpb25zLCBrKSkgY29udGludWU7XG4gICAgICAgICAgICAgIHYgPSBvcHRpb25zW2tdO1xuICAgICAgICAgICAgICBpZiAoayAhPT0gJ3EnKSB7XG4gICAgICAgICAgICAgICAgcmVxW1wiZmFjZXRfXCIgKyBrXSA9IHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgX3RoaXMucG9zdChRVUlDS1NFQVJDSF9QQVRILCByZXEpKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUubWFrZVBhdGggPSBmdW5jdGlvbihwYXRoLCBzdWJjbGFzc2VzLCBjYikge1xuICAgICAgaWYgKHN1YmNsYXNzZXMgPT0gbnVsbCkge1xuICAgICAgICBzdWJjbGFzc2VzID0ge307XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuZmV0Y2hNb2RlbCgpLnRoZW4oZnVuY3Rpb24obSkge1xuICAgICAgICByZXR1cm4gbS5tYWtlUGF0aChwYXRoLCBzdWJjbGFzc2VzKTtcbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbihxLCBjYikge1xuICAgICAgdmFyIHByb21pc2UsIHJlcTtcbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgcHJvbWlzZSA9ICFxID8gZXJyb3IoXCJOb3QgZW5vdWdoIGFyZ3VtZW50c1wiKSA6IHEudG9QYXRoU3RyaW5nICE9IG51bGwgPyAocCA9IHEuaXNDbGFzcygpID8gcS5hcHBlbmQoJ2lkJykgOiBxLCB0aGlzLnBhdGhWYWx1ZXMocCwgJ2NvdW50JykpIDogcS50b1hNTCAhPSBudWxsID8gKHJlcSA9IHtcbiAgICAgICAgcXVlcnk6IHEsXG4gICAgICAgIGZvcm1hdDogJ2pzb25jb3VudCdcbiAgICAgIH0sIHRoaXMucG9zdChRVUVSWV9SRVNVTFRTX1BBVEgsIHJlcSkudGhlbihnZXQoJ2NvdW50JykpKSA6IHR5cGVvZiBxID09PSAnc3RyaW5nJyA/IHRoaXMuZmV0Y2hNb2RlbCgpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgdmFyIGU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb3VudChtLm1ha2VQYXRoKHEpKTtcbiAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgIGUgPSBfZXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucXVlcnkoe1xuICAgICAgICAgICAgICBzZWxlY3Q6IFtxXVxuICAgICAgICAgICAgfSkudGhlbihfdGhpcy5jb3VudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpIDogdGhpcy5xdWVyeShxKS50aGVuKHRoaXMuY291bnQpO1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgcHJvbWlzZSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmZpbmRCeUlkID0gZnVuY3Rpb24odHlwZSwgaWQsIGZpZWxkcywgY2IpIHtcbiAgICAgIHZhciBwcm9taXNlLCBfcmVmMjtcbiAgICAgIGlmIChmaWVsZHMgPT0gbnVsbCkge1xuICAgICAgICBmaWVsZHMgPSBbJyoqJ107XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGZpZWxkcykpIHtcbiAgICAgICAgX3JlZjIgPSBbWycqKiddLCBmaWVsZHNdLCBmaWVsZHMgPSBfcmVmMlswXSwgY2IgPSBfcmVmMlsxXTtcbiAgICAgIH1cbiAgICAgIHByb21pc2UgPSB0aGlzLnF1ZXJ5KHtcbiAgICAgICAgZnJvbTogdHlwZSxcbiAgICAgICAgc2VsZWN0OiBmaWVsZHMsXG4gICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgaWQ6IGlkXG4gICAgICAgIH1cbiAgICAgIH0pLnRoZW4oZGVqb2luKS50aGVuKGludm9rZSgncmVjb3JkcycpKS50aGVuKGdldCgwKSk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCBwcm9taXNlKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24odHlwZSwgdGVybSwgY29udGV4dCwgY2IpIHtcbiAgICAgIHZhciBwcm9taXNlLCBfcmVmMjtcbiAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGNvbnRleHQpKSB7XG4gICAgICAgIF9yZWYyID0gW251bGwsIGNvbnRleHRdLCBjb250ZXh0ID0gX3JlZjJbMF0sIGNiID0gX3JlZjJbMV07XG4gICAgICB9XG4gICAgICBwcm9taXNlID0gdGhpcy5xdWVyeSh7XG4gICAgICAgIGZyb206IHR5cGUsXG4gICAgICAgIHNlbGVjdDogWycqKiddLFxuICAgICAgICB3aGVyZTogW1t0eXBlLCAnTE9PS1VQJywgdGVybSwgY29udGV4dF1dXG4gICAgICB9KS50aGVuKGRlam9pbikudGhlbihpbnZva2UoJ3JlY29yZHMnKSk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCBwcm9taXNlKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHR5cGUsIHRlcm0sIGNvbnRleHQsIGNiKSB7XG4gICAgICB2YXIgX3JlZjI7XG4gICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihjb250ZXh0KSkge1xuICAgICAgICBfcmVmMiA9IFtudWxsLCBjb250ZXh0XSwgY29udGV4dCA9IF9yZWYyWzBdLCBjYiA9IF9yZWYyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5sb29rdXAodHlwZSwgdGVybSwgY29udGV4dCkudGhlbihmdW5jdGlvbihmb3VuZCkge1xuICAgICAgICBpZiAoKGZvdW5kID09IG51bGwpIHx8IGZvdW5kLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcIk5vdGhpbmcgZm91bmRcIik7XG4gICAgICAgIH0gZWxzZSBpZiAoZm91bmQubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcIk11bHRpcGxlIGl0ZW1zIGZvdW5kOiBcIiArIChmb3VuZC5zbGljZSgwLCAzKSkgKyBcIi4uLlwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gc3VjY2Vzcyhmb3VuZFswXSk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUud2hvYW1pID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMsIDksIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgX3RoaXMuZ2V0KFdIT0FNSV9QQVRIKS50aGVuKGdldCgndXNlcicpKS50aGVuKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVXNlcihfdGhpcywgeCk7XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaFVzZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzO1xuICAgICAgYXJncyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgICByZXR1cm4gdGhpcy53aG9hbWkuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcblxuICAgIHBhdGhWYWx1ZXNSZXEgPSBmdW5jdGlvbihmb3JtYXQsIHBhdGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvcm1hdDogZm9ybWF0LFxuICAgICAgICBwYXRoOiBTdHJpbmcocGF0aCksXG4gICAgICAgIHR5cGVDb25zdHJhaW50czogSlNPTi5zdHJpbmdpZnkocGF0aC5zdWJjbGFzc2VzKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUucGF0aFZhbHVlcyA9IGZ1bmN0aW9uKHBhdGgsIHR5cGVDb25zdHJhaW50cywgY2IpIHtcbiAgICAgIGlmICh0eXBlQ29uc3RyYWludHMgPT0gbnVsbCkge1xuICAgICAgICB0eXBlQ29uc3RyYWludHMgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMsIDYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGUsIGZvcm1hdCwgcHJvbWlzZSwgd2FudGVkLCBfcmVmMjtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVDb25zdHJhaW50cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHdhbnRlZCA9IHR5cGVDb25zdHJhaW50cztcbiAgICAgICAgICAgIHR5cGVDb25zdHJhaW50cyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbih0eXBlQ29uc3RyYWludHMpKSB7XG4gICAgICAgICAgICBfcmVmMiA9IFtjYiwgdHlwZUNvbnN0cmFpbnRzXSwgdHlwZUNvbnN0cmFpbnRzID0gX3JlZjJbMF0sIGNiID0gX3JlZjJbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3YW50ZWQgIT09ICdjb3VudCcpIHtcbiAgICAgICAgICAgIHdhbnRlZCA9ICdyZXN1bHRzJztcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9ybWF0ID0gd2FudGVkID09PSAnY291bnQnID8gJ2pzb25jb3VudCcgOiAnanNvbic7XG4gICAgICAgICAgcHJvbWlzZSA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBfcmVmMztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoTW9kZWwoKS50aGVuKGludm9rZSgnbWFrZVBhdGgnLCBwYXRoLCAoX3JlZjMgPSBwYXRoLnN1YmNsYXNzZXMpICE9IG51bGwgPyBfcmVmMyA6IHR5cGVDb25zdHJhaW50cykpLnRoZW4oZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRoVmFsdWVzUmVxKGZvcm1hdCwgcGF0aCk7XG4gICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlcSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnBvc3QoUEFUSF9WQUxVRVNfUEFUSCwgcmVxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KSh0aGlzKSkudGhlbihnZXQod2FudGVkKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChfZXJyb3IpIHtcbiAgICAgICAgICAgICAgZSA9IF9lcnJvcjtcbiAgICAgICAgICAgICAgcmV0dXJuIGVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLmNhbGwoX3RoaXMpO1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHByb21pc2UpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5kb1BhZ2VkUmVxdWVzdCA9IGZ1bmN0aW9uKHEsIHBhdGgsIHBhZ2UsIGZvcm1hdCwgY2IpIHtcbiAgICAgIHZhciByZXEsIF9yZWYyO1xuICAgICAgaWYgKHBhZ2UgPT0gbnVsbCkge1xuICAgICAgICBwYWdlID0ge307XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IChmdW5jdGlvbigpIHt9KTtcbiAgICAgIH1cbiAgICAgIGlmIChxLnRvWE1MICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24ocGFnZSkpIHtcbiAgICAgICAgICBfcmVmMiA9IFtwYWdlLCB7fV0sIGNiID0gX3JlZjJbMF0sIHBhZ2UgPSBfcmVmMlsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXEgPSBtZXJnZShwYWdlLCB7XG4gICAgICAgICAgcXVlcnk6IHEsXG4gICAgICAgICAgZm9ybWF0OiBmb3JtYXRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMucG9zdChwYXRoLCByZXEpLnRoZW4oZ2V0KCdyZXN1bHRzJykpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5KHEpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZG9QYWdlZFJlcXVlc3QocXVlcnksIHBhdGgsIHBhZ2UsIGZvcm1hdCwgY2IpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pKHRoaXMpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUudGFibGUgPSBmdW5jdGlvbihxLCBwYWdlLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuZG9QYWdlZFJlcXVlc3QocSwgUVVFUllfUkVTVUxUU19QQVRILCBwYWdlLCAnanNvbnRhYmxlJywgY2IpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5yZWNvcmRzID0gZnVuY3Rpb24ocSwgcGFnZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvUGFnZWRSZXF1ZXN0KHEsIFFVRVJZX1JFU1VMVFNfUEFUSCwgcGFnZSwgJ2pzb25vYmplY3RzJywgY2IpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5yb3dzID0gZnVuY3Rpb24ocSwgcGFnZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmRvUGFnZWRSZXF1ZXN0KHEsIFFVRVJZX1JFU1VMVFNfUEFUSCwgcGFnZSwgJ2pzb24nLCBjYik7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uKHEsIG9wdHMsIGNiKSB7XG4gICAgICB2YXIgcmVzcCwgX3JlZjI7XG4gICAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihvcHRzKSkge1xuICAgICAgICBfcmVmMiA9IFtvcHRzLCBjYl0sIGNiID0gX3JlZjJbMF0sIG9wdHMgPSBfcmVmMlsxXTtcbiAgICAgIH1cbiAgICAgIHJlc3AgPSBxID09IG51bGwgPyBlcnJvcihcIk5vIHF1ZXJ5IHRlcm0gc3VwcGxpZWRcIikgOiAocS5kZXNjcmlwdG9ycyAhPSBudWxsKSB8fCB0eXBlb2YgcSA9PT0gJ3N0cmluZycgPyB0aGlzLnBhdGhWYWx1ZXMocSwgb3B0cykudGhlbihtYXAoZ2V0KCd2YWx1ZScpKSkgOiBxLnRvWE1MICE9IG51bGwgPyBxLnZpZXdzLmxlbmd0aCAhPT0gMSA/IGVycm9yKFwiRXhwZWN0ZWQgb25lIGNvbHVtbiwgZ290IFwiICsgcS52aWV3cy5sZW5ndGgpIDogdGhpcy5yb3dzKHEsIG9wdHMpLnRoZW4obWFwKGdldCgwKSkpIDogdGhpcy5xdWVyeShxKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMudmFsdWVzKHF1ZXJ5LCBvcHRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHJlc3ApO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS50YWJsZVJvd3MgPSBmdW5jdGlvbihxLCBwYWdlLCBjYikge1xuICAgICAgcmV0dXJuIHRoaXMuZG9QYWdlZFJlcXVlc3QocSwgVEFCTEVfUk9XX1BBVEgsIHBhZ2UsICdqc29uJywgY2IpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaFRlbXBsYXRlcyA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLmdldChURU1QTEFURVNfUEFUSCkudGhlbihnZXQoJ3RlbXBsYXRlcycpKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmZldGNoTGlzdHMgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIHRoaXMuZmluZExpc3RzKCcnLCBjYik7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmZpbmRMaXN0cyA9IGZ1bmN0aW9uKG5hbWUsIGNiKSB7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIG5hbWUgPSAnJztcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gKGZ1bmN0aW9uKCkge30pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hWZXJzaW9uKCkudGhlbigoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICB2YXIgZm47XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgbmFtZSAmJiB2IDwgMTMgPyBlcnJvcihcIkZpbmRpbmcgbGlzdHMgYnkgbmFtZSBvbiB0aGUgc2VydmVyIHJlcXVpcmVzIHZlcnNpb24gMTMuIFRoaXMgaXMgb25seSBcIiArIHYpIDogKGZuID0gZnVuY3Rpb24obHMpIHtcbiAgICAgICAgICAgIHZhciBkYXRhLCBfaywgX2xlbjIsIF9yZXN1bHRzO1xuICAgICAgICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IGxzLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgICAgICBkYXRhID0gbHNbX2tdO1xuICAgICAgICAgICAgICBfcmVzdWx0cy5wdXNoKG5ldyBMaXN0KGRhdGEsIF90aGlzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICAgICAgfSwgX3RoaXMuZ2V0KExJU1RTX1BBVEgsIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICB9KS50aGVuKGdldCgnbGlzdHMnKSkudGhlbihmbikpKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hMaXN0ID0gZnVuY3Rpb24obmFtZSwgY2IpIHtcbiAgICAgIHJldHVybiB0aGlzLmZldGNoVmVyc2lvbigpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdiA8IDEzID8gX3RoaXMuZmluZExpc3RzKCkudGhlbihnZXRMaXN0RmluZGVyKG5hbWUpKSA6IF90aGlzLmZpbmRMaXN0cyhuYW1lKS50aGVuKGdldCgwKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaExpc3RzQ29udGFpbmluZyA9IGZ1bmN0aW9uKG9wdHMsIGNiKSB7XG4gICAgICB2YXIgZm47XG4gICAgICBmbiA9IChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgICAgICB2YXIgeCwgX2ssIF9sZW4yLCBfcmVzdWx0cztcbiAgICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIGZvciAoX2sgPSAwLCBfbGVuMiA9IHhzLmxlbmd0aDsgX2sgPCBfbGVuMjsgX2srKykge1xuICAgICAgICAgICAgeCA9IHhzW19rXTtcbiAgICAgICAgICAgIF9yZXN1bHRzLnB1c2gobmV3IExpc3QoeCwgX3RoaXMpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLmdldChXSVRIX09CSl9QQVRILCBvcHRzKS50aGVuKGdldCgnbGlzdHMnKSkudGhlbihmbikpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5jb21iaW5lTGlzdHMgPSBmdW5jdGlvbihvcGVyYXRpb24sIG9wdGlvbnMsIGNiKSB7XG4gICAgICB2YXIgZGVzY3JpcHRpb24sIGxpc3RzLCBuYW1lLCByZXEsIHRhZ3MsIF9yZWYyO1xuICAgICAgX3JlZjIgPSBtZXJnZSh7XG4gICAgICAgIGxpc3RzOiBbXSxcbiAgICAgICAgdGFnczogW11cbiAgICAgIH0sIG9wdGlvbnMpLCBuYW1lID0gX3JlZjIubmFtZSwgbGlzdHMgPSBfcmVmMi5saXN0cywgdGFncyA9IF9yZWYyLnRhZ3MsIGRlc2NyaXB0aW9uID0gX3JlZjIuZGVzY3JpcHRpb247XG4gICAgICByZXEgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvblxuICAgICAgfTtcbiAgICAgIGlmIChyZXEuZGVzY3JpcHRpb24gPT0gbnVsbCkge1xuICAgICAgICByZXEuZGVzY3JpcHRpb24gPSBcIlwiICsgb3BlcmF0aW9uICsgXCIgb2YgXCIgKyAobGlzdHMuam9pbignLCAnKSk7XG4gICAgICB9XG4gICAgICByZXEudGFncyA9IHRhZ3Muam9pbignOycpO1xuICAgICAgcmVxLmxpc3RzID0gbGlzdHMuam9pbignOycpO1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5nZXQoTElTVF9PUEVSQVRJT05fUEFUSFNbb3BlcmF0aW9uXSwgcmVxKS50aGVuKExJU1RfUElQRSh0aGlzKSkpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tYmluZUxpc3RzLmFwcGx5KHRoaXMsIFsndW5pb24nXS5jb25jYXQoX19zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuaW50ZXJzZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21iaW5lTGlzdHMuYXBwbHkodGhpcywgWydpbnRlcnNlY3Rpb24nXS5jb25jYXQoX19zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZGlmZiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tYmluZUxpc3RzLmFwcGx5KHRoaXMsIFsnZGlmZmVyZW5jZSddLmNvbmNhdChfX3NsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5jb21wbGVtZW50ID0gZnVuY3Rpb24ob3B0aW9ucywgY2IpIHtcbiAgICAgIHZhciBkZWZhdWx0RGVzYywgZGVzY3JpcHRpb24sIGV4Y2x1ZGUsIGZyb20sIGxpc3RzLCBuYW1lLCByZWZlcmVuY2VzLCByZXEsIHRhZ3M7XG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChjYiA9PSBudWxsKSB7XG4gICAgICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgIH1cbiAgICAgIGZyb20gPSBvcHRpb25zLmZyb20sIGV4Y2x1ZGUgPSBvcHRpb25zLmV4Y2x1ZGUsIG5hbWUgPSBvcHRpb25zLm5hbWUsIGRlc2NyaXB0aW9uID0gb3B0aW9ucy5kZXNjcmlwdGlvbiwgdGFncyA9IG9wdGlvbnMudGFncztcbiAgICAgIGRlZmF1bHREZXNjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBcIlJlbGF0aXZlIGNvbXBsZW1lbnQgb2YgXCIgKyAobGlzdHMuam9pbignIGFuZCAnKSkgKyBcIiBpbiBcIiArIChyZWZlcmVuY2VzLmpvaW4oJyBhbmQgJykpO1xuICAgICAgfTtcbiAgICAgIHJlZmVyZW5jZXMgPSBUT19OQU1FUyhmcm9tKTtcbiAgICAgIGxpc3RzID0gVE9fTkFNRVMoZXhjbHVkZSk7XG4gICAgICBpZiAobmFtZSA9PSBudWxsKSB7XG4gICAgICAgIG5hbWUgPSBkZWZhdWx0RGVzYygpO1xuICAgICAgfVxuICAgICAgaWYgKGRlc2NyaXB0aW9uID09IG51bGwpIHtcbiAgICAgICAgZGVzY3JpcHRpb24gPSBkZWZhdWx0RGVzYygpO1xuICAgICAgfVxuICAgICAgaWYgKHRhZ3MgPT0gbnVsbCkge1xuICAgICAgICB0YWdzID0gW107XG4gICAgICB9XG4gICAgICByZXEgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgdGFnczogdGFncyxcbiAgICAgICAgbGlzdHM6IGxpc3RzLFxuICAgICAgICByZWZlcmVuY2VzOiByZWZlcmVuY2VzXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5wb3N0KFNVQlRSQUNUX1BBVEgsIHJlcSkudGhlbihMSVNUX1BJUEUodGhpcykpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hXaWRnZXRzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBSRVFVSVJFU19WRVJTSU9OKHRoaXMsIDgsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIF9nZXRfb3JfZmV0Y2guY2FsbChfdGhpcywgJ3dpZGdldHMnLCBXSURHRVRTLCBXSURHRVRTX1BBVEgsICd3aWRnZXRzJywgY2IpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICB0b01hcEJ5TmFtZSA9IHV0aWxzLm9tYXAoZnVuY3Rpb24odykge1xuICAgICAgcmV0dXJuIFt3Lm5hbWUsIHddO1xuICAgIH0pO1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hXaWRnZXRNYXAgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgOCwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCAoX3RoaXMuX193bWFwX18gIT0gbnVsbCA/IF90aGlzLl9fd21hcF9fIDogX3RoaXMuX193bWFwX18gPSBfdGhpcy5mZXRjaFdpZGdldHMoKS50aGVuKHRvTWFwQnlOYW1lKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5mZXRjaE1vZGVsID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHZhciByZXQ7XG4gICAgICByZXQgPSBfZ2V0X29yX2ZldGNoLmNhbGwodGhpcywgJ21vZGVsJywgTU9ERUxTLCBNT0RFTF9QQVRILCAnbW9kZWwnKS50aGVuKE1vZGVsLmxvYWQpLnRoZW4oc2V0KHtcbiAgICAgICAgc2VydmljZTogdGhpc1xuICAgICAgfSkpO1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgcmV0KTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hTdW1tYXJ5RmllbGRzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBfZ2V0X29yX2ZldGNoLmNhbGwodGhpcywgJ3N1bW1hcnlGaWVsZHMnLCBTVU1NQVJZX0ZJRUxEUywgU1VNTUFSWUZJRUxEU19QQVRILCAnY2xhc3NlcycsIGNiKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hWZXJzaW9uID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBfZ2V0X29yX2ZldGNoLmNhbGwodGhpcywgJ3ZlcnNpb24nLCBWRVJTSU9OUywgVkVSU0lPTl9QQVRILCAndmVyc2lvbicsIGNiKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hDbGFzc0tleXMgPSBmdW5jdGlvbihjYikge1xuICAgICAgcmV0dXJuIF9nZXRfb3JfZmV0Y2guY2FsbCh0aGlzLCAnY2xhc3NrZXlzJywgQ0xBU1NLRVlTLCBDTEFTU0tFWV9QQVRILCAnY2xhc3NlcycsIGNiKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZmV0Y2hSZWxlYXNlID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBfZ2V0X29yX2ZldGNoLmNhbGwodGhpcywgJ3JlbGVhc2UnLCBSRUxFQVNFUywgUkVMRUFTRV9QQVRILCAndmVyc2lvbicsIGNiKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbihvcHRpb25zLCBjYikge1xuICAgICAgdmFyIGJ1aWxkUXVlcnk7XG4gICAgICBidWlsZFF1ZXJ5ID0gKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihfYXJnKSB7XG4gICAgICAgICAgdmFyIG1vZGVsLCBzdW1tYXJ5RmllbGRzO1xuICAgICAgICAgIG1vZGVsID0gX2FyZ1swXSwgc3VtbWFyeUZpZWxkcyA9IF9hcmdbMV07XG4gICAgICAgICAgcmV0dXJuIG5ldyBRdWVyeShvcHRpb25zLCBfdGhpcywge1xuICAgICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgICAgc3VtbWFyeUZpZWxkczogc3VtbWFyeUZpZWxkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcyk7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB1dGlscy5wYXJhbGxlbCh0aGlzLmZldGNoTW9kZWwoKSwgdGhpcy5mZXRjaFN1bW1hcnlGaWVsZHMoKSkudGhlbihidWlsZFF1ZXJ5KSk7XG4gICAgfTtcblxuICAgIGxvYWRRID0gZnVuY3Rpb24oc2VydmljZSwgbmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgaWYgKCFxKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yKFwiTm8gcXVlcnkgZm91bmQgY2FsbGVkIFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcnZpY2UucXVlcnkocSk7XG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjaGVja05hbWVQYXJhbSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIG5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gc3VjY2VzcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcIk5hbWUgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGVycm9yKFwiTmFtZSBub3QgcHJvdmlkZWRcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnNhdmVkUXVlcnkgPSBmdW5jdGlvbihuYW1lLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgMTYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGNoZWNrTmFtZVBhcmFtKG5hbWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5nZXQoJ3VzZXIvcXVlcmllcycsIHtcbiAgICAgICAgICAgICAgZmlsdGVyOiBuYW1lXG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHIucXVlcmllc1tuYW1lXTtcbiAgICAgICAgICAgIH0pLnRoZW4obG9hZFEoX3RoaXMsIG5hbWUpKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnRlbXBsYXRlUXVlcnkgPSBmdW5jdGlvbihuYW1lLCBjYikge1xuICAgICAgcmV0dXJuIGNoZWNrTmFtZVBhcmFtKG5hbWUpLnRoZW4oKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5mZXRjaFRlbXBsYXRlcygpLnRoZW4oZ2V0KG5hbWUpKS50aGVuKHNldCgndHlwZScsICdURU1QTEFURScpKS50aGVuKGxvYWRRKF90aGlzLCBuYW1lKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5tYW5hZ2VVc2VyUHJlZmVyZW5jZXMgPSBmdW5jdGlvbihtZXRob2QsIGRhdGEsIGNiKSB7XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLCAxMSwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5tYWtlUmVxdWVzdChtZXRob2QsIFBSRUZfUEFUSCwgZGF0YSkudGhlbihnZXQoJ3ByZWZlcmVuY2VzJykpKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUucmVzb2x2ZUlkcyA9IGZ1bmN0aW9uKG9wdHMsIGNiKSB7XG4gICAgICByZXR1cm4gUkVRVUlSRVNfVkVSU0lPTih0aGlzLCAxMCwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcmVxO1xuICAgICAgICAgIHJlcSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdQT1NUJyxcbiAgICAgICAgICAgIHVybDogX3RoaXMucm9vdCArIElEX1JFU09MVVRJT05fUEFUSCxcbiAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeShvcHRzKSxcbiAgICAgICAgICAgIGRhdGFUeXBlOiAnanNvbidcbiAgICAgICAgICB9O1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLmRvUmVxKHJlcSkudGhlbihnZXQoJ3VpZCcpKS50aGVuKElEUmVzb2x1dGlvbkpvYi5jcmVhdGUoX3RoaXMpKSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKSk7XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLnJlc29sdXRpb25Kb2IgPSBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIElEUmVzb2x1dGlvbkpvYi5jcmVhdGUodGhpcykoaWQpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5jcmVhdGVMaXN0ID0gZnVuY3Rpb24ob3B0cywgaWRzLCBjYikge1xuICAgICAgdmFyIGFkanVzdCwgcmVxO1xuICAgICAgaWYgKG9wdHMgPT0gbnVsbCkge1xuICAgICAgICBvcHRzID0ge307XG4gICAgICB9XG4gICAgICBpZiAoaWRzID09IG51bGwpIHtcbiAgICAgICAgaWRzID0gJyc7XG4gICAgICB9XG4gICAgICBpZiAoY2IgPT0gbnVsbCkge1xuICAgICAgICBjYiA9IGZ1bmN0aW9uKCkge307XG4gICAgICB9XG4gICAgICBhZGp1c3QgPSAoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICByZXR1cm4gbWVyZ2UoeCwge1xuICAgICAgICAgICAgdG9rZW46IF90aGlzLnRva2VuLFxuICAgICAgICAgICAgdGFnczogb3B0cy50YWdzIHx8IFtdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9KSh0aGlzKTtcbiAgICAgIHJlcSA9IHtcbiAgICAgICAgZGF0YTogdXRpbHMuaXNBcnJheShpZHMpID8gaWRzLm1hcChmdW5jdGlvbih4KSB7XG4gICAgICAgICAgcmV0dXJuIFwiXFxcIlwiICsgeCArIFwiXFxcIlwiO1xuICAgICAgICB9KS5qb2luKFwiXFxuXCIpIDogaWRzLFxuICAgICAgICBkYXRhVHlwZTogJ2pzb24nLFxuICAgICAgICB1cmw6IFwiXCIgKyB0aGlzLnJvb3QgKyBcImxpc3RzP1wiICsgKHRvX3F1ZXJ5X3N0cmluZyhhZGp1c3Qob3B0cykpKSxcbiAgICAgICAgdHlwZTogJ1BPU1QnLFxuICAgICAgICBjb250ZW50VHlwZTogJ3RleHQvcGxhaW4nXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHdpdGhDQihjYiwgdGhpcy5kb1JlcShyZXEpLnRoZW4oTElTVF9QSVBFKHRoaXMpKSk7XG4gICAgfTtcblxuICAgIGdldE5ld1VzZXJUb2tlbiA9IGZ1bmN0aW9uKHJlc3ApIHtcbiAgICAgIHJldHVybiByZXNwLnVzZXIudGVtcG9yYXJ5VG9rZW47XG4gICAgfTtcblxuICAgIFNlcnZpY2UucHJvdG90eXBlLmNvbm5lY3RBcyA9IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgICByZXR1cm4gU2VydmljZS5jb25uZWN0KG1lcmdlKHRoaXMsIHtcbiAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICBub0NhY2hlOiAhdGhpcy51c2VDYWNoZVxuICAgICAgfSkpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uKG5hbWUsIHBhc3N3b3JkLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgOSwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBfdGhpcy5wb3N0KCd1c2VycycsIHtcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmRcbiAgICAgICAgICB9KS50aGVuKGdldE5ld1VzZXJUb2tlbikudGhlbihfdGhpcy5jb25uZWN0QXMpKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgRklWRV9NSU4gPSA1ICogNjA7XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5nZXREZXJlZ2lzdHJhdGlvblRva2VuID0gZnVuY3Rpb24odmFsaWRpdHksIGNiKSB7XG4gICAgICBpZiAodmFsaWRpdHkgPT0gbnVsbCkge1xuICAgICAgICB2YWxpZGl0eSA9IEZJVkVfTUlOO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgMTYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHByb21pc2U7XG4gICAgICAgICAgcHJvbWlzZSA9IF90aGlzLnRva2VuICE9IG51bGwgPyBfdGhpcy5wb3N0KCd1c2VyL2RlcmVnaXN0cmF0aW9uJywge1xuICAgICAgICAgICAgdmFsaWRpdHk6IHZhbGlkaXR5XG4gICAgICAgICAgfSkudGhlbihnZXQoJ3Rva2VuJykpIDogZXJyb3IoXCJOb3QgcmVnaXN0ZXJlZFwiKTtcbiAgICAgICAgICByZXR1cm4gd2l0aENCKGNiLCBwcm9taXNlKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUuZGVyZWdpc3RlciA9IGZ1bmN0aW9uKHRva2VuLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgMTYsIChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHdpdGhDQihjYiwgX3RoaXMubWFrZVJlcXVlc3QoJ0RFTEVURScsICd1c2VyJywge1xuICAgICAgICAgICAgZGVyZWdpc3RyYXRpb25Ub2tlbjogdG9rZW4sXG4gICAgICAgICAgICBmb3JtYXQ6ICd4bWwnXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH07XG5cbiAgICBTZXJ2aWNlLnByb3RvdHlwZS5sb2dpbiA9IGZ1bmN0aW9uKG5hbWUsIHBhc3N3b3JkLCBjYikge1xuICAgICAgcmV0dXJuIFJFUVVJUkVTX1ZFUlNJT04odGhpcywgOSwgKGZ1bmN0aW9uKF90aGlzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXV0aDtcbiAgICAgICAgICBhdXRoID0gXCJcIiArIG5hbWUgKyBcIjpcIiArIHBhc3N3b3JkO1xuICAgICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIF90aGlzLmxvZ291dCgpLnRoZW4oZnVuY3Rpb24oc2VydmljZSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcnZpY2UuZ2V0KCd1c2VyL3Rva2VuJywge1xuICAgICAgICAgICAgICBhdXRoOiBhdXRoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSkudGhlbihnZXQoJ3Rva2VuJykpLnRoZW4oX3RoaXMuY29ubmVjdEFzKTtcbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgU2VydmljZS5wcm90b3R5cGUubG9nb3V0ID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHN1Y2Nlc3ModGhpcy5jb25uZWN0QXMoKSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2VydmljZTtcblxuICB9KSgpO1xuXG4gIFNlcnZpY2UucHJvdG90eXBlLnJvd0J5Um93ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MsIGYsIHE7XG4gICAgcSA9IGFyZ3VtZW50c1swXSwgYXJncyA9IDIgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpIDogW107XG4gICAgZiA9IGh0dHAuaXRlclJlcSgnUE9TVCcsIFFVRVJZX1JFU1VMVFNfUEFUSCwgJ2pzb24nKTtcbiAgICBpZiAocS50b1hNTCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeShxKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucm93QnlSb3cuYXBwbHkoX3RoaXMsIFtxdWVyeV0uY29uY2F0KF9fc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICBTZXJ2aWNlLnByb3RvdHlwZS5lYWNoUm93ID0gU2VydmljZS5wcm90b3R5cGUucm93QnlSb3c7XG5cbiAgU2VydmljZS5wcm90b3R5cGUucmVjb3JkQnlSZWNvcmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncywgZiwgcTtcbiAgICBxID0gYXJndW1lbnRzWzBdLCBhcmdzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICBmID0gaHR0cC5pdGVyUmVxKCdQT1NUJywgUVVFUllfUkVTVUxUU19QQVRILCAnanNvbm9iamVjdHMnKTtcbiAgICBpZiAocS50b1hNTCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeShxKS50aGVuKChmdW5jdGlvbihfdGhpcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ocXVlcnkpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMucmVjb3JkQnlSZWNvcmQuYXBwbHkoX3RoaXMsIFtxdWVyeV0uY29uY2F0KF9fc2xpY2UuY2FsbChhcmdzKSkpO1xuICAgICAgICB9O1xuICAgICAgfSkodGhpcykpO1xuICAgIH1cbiAgfTtcblxuICBTZXJ2aWNlLnByb3RvdHlwZS5lYWNoUmVjb3JkID0gU2VydmljZS5wcm90b3R5cGUucmVjb3JkQnlSZWNvcmQ7XG5cbiAgU2VydmljZS5wcm90b3R5cGUudW5pb24gPSBTZXJ2aWNlLnByb3RvdHlwZS5tZXJnZTtcblxuICBTZXJ2aWNlLnByb3RvdHlwZS5kaWZmZXJlbmNlID0gU2VydmljZS5wcm90b3R5cGUuZGlmZjtcblxuICBTZXJ2aWNlLnByb3RvdHlwZS5zeW1tZXRyaWNEaWZmZXJlbmNlID0gU2VydmljZS5wcm90b3R5cGUuZGlmZjtcblxuICBTZXJ2aWNlLnByb3RvdHlwZS5yZWxhdGl2ZUNvbXBsZW1lbnQgPSBTZXJ2aWNlLnByb3RvdHlwZS5jb21wbGVtZW50O1xuXG4gIFNlcnZpY2UucHJvdG90eXBlLnN1YnRyYWN0ID0gU2VydmljZS5wcm90b3R5cGUuY29tcGxlbWVudDtcblxuICBTZXJ2aWNlLmZsdXNoQ2FjaGVzID0gZnVuY3Rpb24oKSB7XG4gICAgTU9ERUxTID0ge307XG4gICAgVkVSU0lPTlMgPSB7fTtcbiAgICBSRUxFQVNFUyA9IHt9O1xuICAgIENMQVNTS0VZUyA9IHt9O1xuICAgIFNVTU1BUllfRklFTERTID0ge307XG4gICAgcmV0dXJuIFdJREdFVFMgPSB7fTtcbiAgfTtcblxuICBTZXJ2aWNlLmNvbm5lY3QgPSBmdW5jdGlvbihvcHRzKSB7XG4gICAgaWYgKChvcHRzICE9IG51bGwgPyBvcHRzLnJvb3QgOiB2b2lkIDApID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3B0aW9ucyBwcm92aWRlZDogXCIgKyAoSlNPTi5zdHJpbmdpZnkob3B0cykpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBTZXJ2aWNlKG9wdHMpO1xuICB9O1xuXG4gIGV4cG9ydHMuU2VydmljZSA9IFNlcnZpY2U7XG5cbiAgZXhwb3J0cy5Nb2RlbCA9IE1vZGVsO1xuXG4gIGV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcblxuICBleHBvcnRzLnV0aWxzID0gdXRpbHM7XG5cbiAgZXhwb3J0cy5WRVJTSU9OID0gdmVyc2lvbi5WRVJTSU9OO1xuXG4gIGV4cG9ydHMuaW1qcyA9IHZlcnNpb247XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi9odHRwXCI6MyxcIi4vaWQtcmVzb2x1dGlvbi1qb2JcIjo0LFwiLi9saXN0c1wiOjUsXCIuL21vZGVsXCI6NixcIi4vcHJvbWlzZVwiOjgsXCIuL3F1ZXJ5XCI6OSxcIi4vdXNlclwiOjE0LFwiLi91dGlsXCI6MTUsXCIuL3ZlcnNpb25cIjoxNn1dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIEZha2VEb21QYXJzZXI7XG5cbiAgZXhwb3J0cy5ET01QYXJzZXIgPSBnbG9iYWwuRE9NUGFyc2VyICE9IG51bGwgPyBnbG9iYWwuRE9NUGFyc2VyIDogRmFrZURvbVBhcnNlciA9IChmdW5jdGlvbigpIHtcbiAgICBmdW5jdGlvbiBGYWtlRG9tUGFyc2VyKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRE9NUGFyc2VyIGlzIG5vdCBhdmFpbGFibGVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIEZha2VEb21QYXJzZXI7XG5cbiAgfSkoKTtcblxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBIQVNfQ09OU09MRSwgSEFTX0pTT04sIE5PVF9FTlVNLCBoYXNEb250RW51bUJ1ZywgaGFzT3duUHJvcGVydHksIGhlYWQsIG0sIHNjcmlwdCwgX2ZuLCBfaSwgX2xlbiwgX3JlZjtcblxuICBIQVNfQ09OU09MRSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcblxuICBIQVNfSlNPTiA9IHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJztcblxuICBOT1RfRU5VTSA9IFsndG9TdHJpbmcnLCAndG9Mb2NhbGVTdHJpbmcnLCAndmFsdWVPZicsICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2NvbnN0cnVjdG9yJ107XG5cbiAgaWYgKCFIQVNfSlNPTikge1xuICAgIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC5zcmMgPSAnaHR0cDovL2Nkbi5pbnRlcm1pbmUub3JnL2pzL2pzb24zLzMuMi4yL2pzb24zLm1pbi5qcyc7XG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmtleXMgPT0gbnVsbCkge1xuICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICBoYXNEb250RW51bUJ1ZyA9ICF7XG4gICAgICB0b1N0cmluZzogbnVsbFxuICAgIH0ucHJvcGVydHlJc0VudW1lcmFibGUoXCJ0b1N0cmluZ1wiKTtcbiAgICBPYmplY3Qua2V5cyA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHZhciBrZXlzLCBuYW1lLCBub25FbnVtLCBfaSwgX2xlbjtcbiAgICAgIGlmICh0eXBlb2YgbyAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbyAhPT0gXCJcIiB8fCBvID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3Qua2V5cyBjYWxsZWQgb24gYSBub24tb2JqZWN0XCIpO1xuICAgICAgfVxuICAgICAga2V5cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIF9yZXN1bHRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG5hbWUgaW4gbykge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIG5hbWUpKSB7XG4gICAgICAgICAgICBfcmVzdWx0cy5wdXNoKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgICB9KSgpO1xuICAgICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gTk9UX0VOVU0ubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICBub25FbnVtID0gTk9UX0VOVU1bX2ldO1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIG5vbkVudW0pKSB7XG4gICAgICAgICAgICBrZXlzLnB1c2gobm9uRW51bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFycmF5LnByb3RvdHlwZS5tYXAgPT0gbnVsbCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihmKSB7XG4gICAgICB2YXIgeCwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gdGhpcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB4ID0gdGhpc1tfaV07XG4gICAgICAgIF9yZXN1bHRzLnB1c2goZih4KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmlsdGVyID09IG51bGwpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24oZikge1xuICAgICAgdmFyIHgsIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHRoaXMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgeCA9IHRoaXNbX2ldO1xuICAgICAgICBpZiAoZih4KSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPT0gbnVsbCkge1xuICAgIEFycmF5LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbihmLCBpbml0VmFsdWUpIHtcbiAgICAgIHZhciByZXQsIHgsIHhzLCBfaSwgX2xlbjtcbiAgICAgIHhzID0gdGhpcy5zbGljZSgpO1xuICAgICAgcmV0ID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyB4cy5wb3AoKSA6IGluaXRWYWx1ZTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0geHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgeCA9IHhzW19pXTtcbiAgICAgICAgcmV0ID0gZihyZXQsIHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9O1xuICB9XG5cbiAgaWYgKEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID09IG51bGwpIHtcbiAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGYsIGN0eCkge1xuICAgICAgdmFyIGksIHgsIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgIGlmICghZikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmdW5jdGlvbiBwcm92aWRlZFwiKTtcbiAgICAgIH1cbiAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICBmb3IgKGkgPSBfaSA9IDAsIF9sZW4gPSB0aGlzLmxlbmd0aDsgX2kgPCBfbGVuOyBpID0gKytfaSkge1xuICAgICAgICB4ID0gdGhpc1tpXTtcbiAgICAgICAgX3Jlc3VsdHMucHVzaChmLmNhbGwoY3R4ICE9IG51bGwgPyBjdHggOiB0aGlzLCB4LCBpLCB0aGlzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3Jlc3VsdHM7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghSEFTX0NPTlNPTEUpIHtcbiAgICB0aGlzLmNvbnNvbGUgPSB7XG4gICAgICBsb2c6IChmdW5jdGlvbigpIHt9KSxcbiAgICAgIGVycm9yOiAoZnVuY3Rpb24oKSB7fSksXG4gICAgICBkZWJ1ZzogKGZ1bmN0aW9uKCkge30pXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cgIT09IG51bGwpIHtcbiAgICAgIHdpbmRvdy5jb25zb2xlID0gdGhpcy5jb25zb2xlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjb25zb2xlLmxvZyA9PSBudWxsKSB7XG4gICAgY29uc29sZS5sb2cgPSBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgaWYgKGNvbnNvbGUuZXJyb3IgPT0gbnVsbCkge1xuICAgIGNvbnNvbGUuZXJyb3IgPSBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgaWYgKGNvbnNvbGUuZGVidWcgPT0gbnVsbCkge1xuICAgIGNvbnNvbGUuZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuICB9XG5cbiAgaWYgKGNvbnNvbGUubG9nLmFwcGx5ID09IG51bGwpIHtcbiAgICBjb25zb2xlLmxvZyhcIllvdXIgY29uc29sZSBuZWVkcyBwYXRjaGluZy5cIik7XG4gICAgX3JlZiA9IFsnbG9nJywgJ2Vycm9yJywgJ2RlYnVnJ107XG4gICAgX2ZuID0gZnVuY3Rpb24obSkge1xuICAgICAgdmFyIG9sZE07XG4gICAgICBvbGRNID0gY29uc29sZVttXTtcbiAgICAgIHJldHVybiBjb25zb2xlW21dID0gZnVuY3Rpb24oYXJncykge1xuICAgICAgICByZXR1cm4gb2xkTShhcmdzKTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IF9yZWYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIG0gPSBfcmVmW19pXTtcbiAgICAgIF9mbihtKTtcbiAgICB9XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcblxufSx7fV0sMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uKCkge1xuICB2YXIgUHJvbWlzZSwgbWVyZ2UsIHByb3BlcnRpZXMsXG4gICAgX19iaW5kID0gZnVuY3Rpb24oZm4sIG1lKXsgcmV0dXJuIGZ1bmN0aW9uKCl7IHJldHVybiBmbi5hcHBseShtZSwgYXJndW1lbnRzKTsgfTsgfTtcblxuICBtZXJnZSA9IGZ1bmN0aW9uKHNyYywgZGVzdCkge1xuICAgIHZhciBrLCB2LCBfcmVzdWx0cztcbiAgICBfcmVzdWx0cyA9IFtdO1xuICAgIGZvciAoayBpbiBzcmMpIHtcbiAgICAgIHYgPSBzcmNba107XG4gICAgICBfcmVzdWx0cy5wdXNoKGRlc3Rba10gPSB2KTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIFByb21pc2UgPSBfZGVyZXFfKCcuL3Byb21pc2UnKTtcblxuICBwcm9wZXJ0aWVzID0gWydhdHRyaWJ1dGVzJywgJ3JlZmVyZW5jZXMnLCAnY29sbGVjdGlvbnMnXTtcblxuICBleHBvcnRzLlRhYmxlID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFRhYmxlKG9wdHMsIG1vZGVsKSB7XG4gICAgICB2YXIgYywgcHJvcCwgXywgX2ksIF9sZW4sIF9yZWYsIF9yZWYxO1xuICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xuICAgICAgdGhpcy5nZXREaXNwbGF5TmFtZSA9IF9fYmluZCh0aGlzLmdldERpc3BsYXlOYW1lLCB0aGlzKTtcbiAgICAgIHRoaXMubmFtZSA9IG9wdHMubmFtZSwgdGhpcy50YWdzID0gb3B0cy50YWdzLCB0aGlzLmRpc3BsYXlOYW1lID0gb3B0cy5kaXNwbGF5TmFtZSwgdGhpcy5hdHRyaWJ1dGVzID0gb3B0cy5hdHRyaWJ1dGVzLCB0aGlzLnJlZmVyZW5jZXMgPSBvcHRzLnJlZmVyZW5jZXMsIHRoaXMuY29sbGVjdGlvbnMgPSBvcHRzLmNvbGxlY3Rpb25zO1xuICAgICAgdGhpcy5maWVsZHMgPSB7fTtcbiAgICAgIHRoaXMuX19wYXJlbnRzX18gPSAoX3JlZiA9IG9wdHNbJ2V4dGVuZHMnXSkgIT0gbnVsbCA/IF9yZWYgOiBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcHJvcGVydGllcy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwcm9wID0gcHJvcGVydGllc1tfaV07XG4gICAgICAgIGlmICh0aGlzW3Byb3BdID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgbW9kZWwgZGF0YTogbWlzc2luZyBcIiArIHByb3ApO1xuICAgICAgICB9XG4gICAgICAgIG1lcmdlKHRoaXNbcHJvcF0sIHRoaXMuZmllbGRzKTtcbiAgICAgIH1cbiAgICAgIF9yZWYxID0gdGhpcy5jb2xsZWN0aW9ucztcbiAgICAgIGZvciAoXyBpbiBfcmVmMSkge1xuICAgICAgICBjID0gX3JlZjFbX107XG4gICAgICAgIGMuaXNDb2xsZWN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBUYWJsZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBuLCBfO1xuICAgICAgcmV0dXJuIFwiW1RhYmxlIG5hbWU9XCIgKyB0aGlzLm5hbWUgKyBcIiwgZmllbGRzPVtcIiArICgoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfcmVmLCBfcmVzdWx0cztcbiAgICAgICAgX3JlZiA9IHRoaXMuZmllbGRzO1xuICAgICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKG4gaW4gX3JlZikge1xuICAgICAgICAgIF8gPSBfcmVmW25dO1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gobik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZXN1bHRzO1xuICAgICAgfSkuY2FsbCh0aGlzKSkgKyBcIl1dXCI7XG4gICAgfTtcblxuICAgIFRhYmxlLnByb3RvdHlwZS5wYXJlbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3JlZjtcbiAgICAgIHJldHVybiAoKF9yZWYgPSB0aGlzLl9fcGFyZW50c19fKSAhPSBudWxsID8gX3JlZiA6IFtdKS5zbGljZSgpO1xuICAgIH07XG5cbiAgICBUYWJsZS5wcm90b3R5cGUuZ2V0RGlzcGxheU5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oX3RoaXMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGlmIChfdGhpcy5tb2RlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShfdGhpcy5tb2RlbC5tYWtlUGF0aChfdGhpcy5uYW1lKS5nZXREaXNwbGF5TmFtZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ21vZGVsIG5vdCBzZXQgLSBjYW5ub3QgbWFrZSBwYXRoJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRhYmxlO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi9wcm9taXNlXCI6OH1dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIGFueSwgZG9fcHJlZl9yZXEsIGVycm9yLCBnZXQsIGlzRnVuY3Rpb24sIHdpdGhDQiwgX3JlZixcbiAgICBfX2JpbmQgPSBmdW5jdGlvbihmbiwgbWUpeyByZXR1cm4gZnVuY3Rpb24oKXsgcmV0dXJuIGZuLmFwcGx5KG1lLCBhcmd1bWVudHMpOyB9OyB9O1xuXG4gIF9yZWYgPSBfZGVyZXFfKCcuL3V0aWwnKSwgd2l0aENCID0gX3JlZi53aXRoQ0IsIGdldCA9IF9yZWYuZ2V0LCBpc0Z1bmN0aW9uID0gX3JlZi5pc0Z1bmN0aW9uLCBhbnkgPSBfcmVmLmFueSwgZXJyb3IgPSBfcmVmLmVycm9yO1xuXG4gIGRvX3ByZWZfcmVxID0gZnVuY3Rpb24odXNlciwgZGF0YSwgbWV0aG9kLCBjYikge1xuICAgIHJldHVybiB1c2VyLnNlcnZpY2UubWFuYWdlVXNlclByZWZlcmVuY2VzKG1ldGhvZCwgZGF0YSwgY2IpLnRoZW4oZnVuY3Rpb24ocHJlZnMpIHtcbiAgICAgIHJldHVybiB1c2VyLnByZWZlcmVuY2VzID0gcHJlZnM7XG4gICAgfSk7XG4gIH07XG5cbiAgZXhwb3J0cy5Vc2VyID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIFVzZXIoc2VydmljZSwgX2FyZykge1xuICAgICAgdGhpcy5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgIHRoaXMudXNlcm5hbWUgPSBfYXJnLnVzZXJuYW1lLCB0aGlzLnByZWZlcmVuY2VzID0gX2FyZy5wcmVmZXJlbmNlcztcbiAgICAgIHRoaXMucmVmcmVzaCA9IF9fYmluZCh0aGlzLnJlZnJlc2gsIHRoaXMpO1xuICAgICAgdGhpcy5jbGVhclByZWZlcmVuY2VzID0gX19iaW5kKHRoaXMuY2xlYXJQcmVmZXJlbmNlcywgdGhpcyk7XG4gICAgICB0aGlzLmNsZWFyUHJlZmVyZW5jZSA9IF9fYmluZCh0aGlzLmNsZWFyUHJlZmVyZW5jZSwgdGhpcyk7XG4gICAgICB0aGlzLnNldFByZWZlcmVuY2VzID0gX19iaW5kKHRoaXMuc2V0UHJlZmVyZW5jZXMsIHRoaXMpO1xuICAgICAgdGhpcy5zZXRQcmVmZXJlbmNlID0gX19iaW5kKHRoaXMuc2V0UHJlZmVyZW5jZSwgdGhpcyk7XG4gICAgICB0aGlzLmhhc1ByZWZlcmVuY2VzID0gdGhpcy5wcmVmZXJlbmNlcyAhPSBudWxsO1xuICAgICAgaWYgKHRoaXMucHJlZmVyZW5jZXMgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnByZWZlcmVuY2VzID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgVXNlci5wcm90b3R5cGUuc2V0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKGtleSwgdmFsdWUsIGNiKSB7XG4gICAgICB2YXIgZGF0YSwgX3JlZjE7XG4gICAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgX3JlZjEgPSBbbnVsbCwgdmFsdWVdLCB2YWx1ZSA9IF9yZWYxWzBdLCBjYiA9IF9yZWYxWzFdO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgZGF0YVtrZXldID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGF0YSA9IGtleTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB3aXRoQ0IoY2IsIGVycm9yKFwiSW5jb3JyZWN0IGFyZ3VtZW50cyB0byBzZXRQcmVmZXJlbmNlXCIpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnNldFByZWZlcmVuY2VzKGRhdGEsIGNiKTtcbiAgICB9O1xuXG4gICAgVXNlci5wcm90b3R5cGUuc2V0UHJlZmVyZW5jZXMgPSBmdW5jdGlvbihwcmVmcywgY2IpIHtcbiAgICAgIHJldHVybiBkb19wcmVmX3JlcSh0aGlzLCBwcmVmcywgJ1BPU1QnLCBjYik7XG4gICAgfTtcblxuICAgIFVzZXIucHJvdG90eXBlLmNsZWFyUHJlZmVyZW5jZSA9IGZ1bmN0aW9uKGtleSwgY2IpIHtcbiAgICAgIHJldHVybiBkb19wcmVmX3JlcSh0aGlzLCB7XG4gICAgICAgIGtleToga2V5XG4gICAgICB9LCAnREVMRVRFJywgY2IpO1xuICAgIH07XG5cbiAgICBVc2VyLnByb3RvdHlwZS5jbGVhclByZWZlcmVuY2VzID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiBkb19wcmVmX3JlcSh0aGlzLCB7fSwgJ0RFTEVURScsIGNiKTtcbiAgICB9O1xuXG4gICAgVXNlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gZG9fcHJlZl9yZXEodGhpcywge30sICdHRVQnLCBjYik7XG4gICAgfTtcblxuICAgIFVzZXIucHJvdG90eXBlLmNyZWF0ZVRva2VuID0gZnVuY3Rpb24odHlwZSwgbWVzc2FnZSwgY2IpIHtcbiAgICAgIHZhciBfcmVmMSwgX3JlZjI7XG4gICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHR5cGUgPSAnZGF5JztcbiAgICAgIH1cbiAgICAgIGlmICgoY2IgPT0gbnVsbCkgJiYgYW55KFt0eXBlLCBtZXNzYWdlXSwgaXNGdW5jdGlvbikpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odHlwZSkpIHtcbiAgICAgICAgICBfcmVmMSA9IFtudWxsLCBudWxsLCB0eXBlXSwgdHlwZSA9IF9yZWYxWzBdLCBtZXNzYWdlID0gX3JlZjFbMV0sIGNiID0gX3JlZjFbMl07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihtZXNzYWdlKSkge1xuICAgICAgICAgIF9yZWYyID0gW251bGwsIG1lc3NhZ2VdLCBtZXNzYWdlID0gX3JlZjJbMF0sIGNiID0gX3JlZjJbMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5wb3N0KCd1c2VyL3Rva2VucycsIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgfSkudGhlbihnZXQoJ3Rva2VuJykpKTtcbiAgICB9O1xuXG4gICAgVXNlci5wcm90b3R5cGUuZmV0Y2hDdXJyZW50VG9rZW5zID0gZnVuY3Rpb24oY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5nZXQoJ3VzZXIvdG9rZW5zJykudGhlbihnZXQoJ3Rva2VucycpKSk7XG4gICAgfTtcblxuICAgIFVzZXIucHJvdG90eXBlLnJldm9rZUFsbFRva2VucyA9IGZ1bmN0aW9uKGNiKSB7XG4gICAgICByZXR1cm4gd2l0aENCKGNiLCB0aGlzLnNlcnZpY2UubWFrZVJlcXVlc3QoJ0RFTEVURScsICd1c2VyL3Rva2VucycpKTtcbiAgICB9O1xuXG4gICAgVXNlci5wcm90b3R5cGUucmV2b2tlVG9rZW4gPSBmdW5jdGlvbih0b2tlbiwgY2IpIHtcbiAgICAgIHJldHVybiB3aXRoQ0IoY2IsIHRoaXMuc2VydmljZS5tYWtlUmVxdWVzdCgnREVMRVRFJywgXCJ1c2VyL3Rva2Vucy9cIiArIHRva2VuKSk7XG4gICAgfTtcblxuICAgIHJldHVybiBVc2VyO1xuXG4gIH0pKCk7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi91dGlsXCI6MTV9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24oKSB7XG4gIHZhciBQcm9taXNlLCBSRVFVSVJFUywgY29tcCwgY3VycnksIGVuY29kZSwgZW50aXRpZXMsIGVycm9yLCBmbGF0dGVuLCBmb2xkLCBpZCwgaW52b2tlLCBpbnZva2VXaXRoLCBpc0FycmF5LCBtZXJnZSwgcGFpckZvbGQsIHFzRnJvbUxpc3QsIHJvb3QsIHN1Y2Nlc3MsIHRoZW5Gb2xkLCBfcmVmLFxuICAgIF9fc2xpY2UgPSBbXS5zbGljZSxcbiAgICBfX2luZGV4T2YgPSBbXS5pbmRleE9mIHx8IGZ1bmN0aW9uKGl0ZW0pIHsgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykgeyBpZiAoaSBpbiB0aGlzICYmIHRoaXNbaV0gPT09IGl0ZW0pIHJldHVybiBpOyB9IHJldHVybiAtMTsgfSxcbiAgICBfX2hhc1Byb3AgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxuICBQcm9taXNlID0gX2RlcmVxXygnLi9wcm9taXNlJyk7XG5cbiAgcm9vdCA9IGV4cG9ydHM7XG5cbiAgcm9vdC5kZWZlciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBkZWZlcnJlZDtcbiAgICBkZWZlcnJlZCA9IHt9O1xuICAgIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcmV0dXJuIGRlZmVycmVkLnJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcbiAgICByZXR1cm4gZGVmZXJyZWQ7XG4gIH07XG5cbiAgZW5jb2RlID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHgpKTtcbiAgfTtcblxuICBxc0Zyb21MaXN0ID0gZnVuY3Rpb24ocGFpcnMpIHtcbiAgICB2YXIgcGFpcjtcbiAgICByZXR1cm4gKChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBwYWlycy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICBwYWlyID0gcGFpcnNbX2ldO1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHBhaXIubWFwKGVuY29kZSkuam9pbignPScpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpKS5qb2luKCcmJyk7XG4gIH07XG5cbiAgcm9vdC5xdWVyeXN0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrLCBwLCBwYWlycywgc3ViTGlzdCwgc3YsIHY7XG4gICAgaWYgKCFvYmopIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgcGFpcnMgPSBvYmouc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAoayBpbiBvYmopIHtcbiAgICAgICAgdiA9IG9ialtrXTtcbiAgICAgICAgaWYgKGlzQXJyYXkodikpIHtcbiAgICAgICAgICBzdWJMaXN0ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9pLCBfbGVuLCBfcmVzdWx0cztcbiAgICAgICAgICAgIF9yZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHYubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgICAgICAgc3YgPSB2W19pXTtcbiAgICAgICAgICAgICAgX3Jlc3VsdHMucHVzaChbaywgc3ZdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICAgICAgICB9KSgpO1xuICAgICAgICAgIHBhaXJzID0gcGFpcnMuY29uY2F0KHN1Ykxpc3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2ssIHZdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXNGcm9tTGlzdCgoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgICAgX3Jlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAoX2kgPSAwLCBfbGVuID0gcGFpcnMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgICAgcCA9IHBhaXJzW19pXTtcbiAgICAgICAgaWYgKHBbMV0gIT0gbnVsbCkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9KSgpKTtcbiAgfTtcblxuICByb290LmN1cnJ5ID0gY3VycnkgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncywgZjtcbiAgICBmID0gYXJndW1lbnRzWzBdLCBhcmdzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdDtcbiAgICAgIHJlc3QgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgICAgcmV0dXJuIGYuYXBwbHkobnVsbCwgYXJncy5jb25jYXQocmVzdCkpO1xuICAgIH07XG4gIH07XG5cbiAgcm9vdC5lcnJvciA9IGVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihfLCByZWplY3QpIHtcbiAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGUpKTtcbiAgICB9KTtcbiAgfTtcblxuICByb290LnN1Y2Nlc3MgPSBzdWNjZXNzID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCBfKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZSh4KTtcbiAgICB9KTtcbiAgfTtcblxuICByb290LnBhcmFsbGVsID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByb21pc2VzO1xuICAgIHByb21pc2VzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICBpZiAocHJvbWlzZXMubGVuZ3RoID09PSAxICYmICghcHJvbWlzZXNbMF0udGhlbikgJiYgcHJvbWlzZXNbMF0ubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgfTtcblxuICByb290LndpdGhDQiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmLCBmcywgb25FcnIsIG9uU3VjYywgcCwgX2ksIF9qLCBfbGVuO1xuICAgIGZzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCwgX2kgPSBhcmd1bWVudHMubGVuZ3RoIC0gMSkgOiAoX2kgPSAwLCBbXSksIHAgPSBhcmd1bWVudHNbX2krK107XG4gICAgZm9yIChfaiA9IDAsIF9sZW4gPSBmcy5sZW5ndGg7IF9qIDwgX2xlbjsgX2orKykge1xuICAgICAgZiA9IGZzW19qXTtcbiAgICAgIGlmICghKGYgIT0gbnVsbCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBvblN1Y2MgPSBjdXJyeShmLCBudWxsKTtcbiAgICAgIG9uRXJyID0gZjtcbiAgICAgIHAudGhlbihvblN1Y2MsIG9uRXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgcm9vdC5mb2xkID0gZm9sZCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oaW5pdCwgeHMpIHtcbiAgICAgIHZhciBrLCByZXQsIHY7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB4cyA9IChpbml0ICE9IG51bGwgPyBpbml0LnNsaWNlKCkgOiB2b2lkIDApIHx8IGluaXQ7XG4gICAgICAgIGluaXQgPSAoeHMgIT0gbnVsbCA/IHhzLnNoaWZ0KCkgOiB2b2lkIDApIHx8IHt9O1xuICAgICAgfVxuICAgICAgaWYgKHhzID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwieHMgaXMgbnVsbFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh4cy5yZWR1Y2UgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4geHMucmVkdWNlKGYsIGluaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gaW5pdDtcbiAgICAgICAgZm9yIChrIGluIHhzKSB7XG4gICAgICAgICAgdiA9IHhzW2tdO1xuICAgICAgICAgIHJldCA9IHJldCAhPSBudWxsID8gZihyZXQsIGssIHYpIDoge1xuICAgICAgICAgICAgazogdlxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHJvb3QudGFrZSA9IGZ1bmN0aW9uKG4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIGlmIChuICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHhzLnNsaWNlKDAsICsobiAtIDEpICsgMSB8fCA5ZTkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHhzLnNsaWNlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICByb290LmZpbHRlciA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIHZhciB4LCBfaSwgX2xlbiwgX3Jlc3VsdHM7XG4gICAgICBfcmVzdWx0cyA9IFtdO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB4ID0geHNbX2ldO1xuICAgICAgICBpZiAoZih4KSkge1xuICAgICAgICAgIF9yZXN1bHRzLnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBfcmVzdWx0cztcbiAgICB9O1xuICB9O1xuXG4gIHJvb3QudW5pcUJ5ID0gZnVuY3Rpb24oZiwgeHMpIHtcbiAgICB2YXIgaywga2V5cywgdmFsdWVzLCB4LCBfaSwgX2xlbjtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGN1cnJ5KHJvb3QudW5pcUJ5LCBmKTtcbiAgICB9XG4gICAga2V5cyA9IFtdO1xuICAgIHZhbHVlcyA9IFtdO1xuICAgIGlmICh4cyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IHhzLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICB4ID0geHNbX2ldO1xuICAgICAgayA9IGYoeCk7XG4gICAgICBpZiAoX19pbmRleE9mLmNhbGwoa2V5cywgaykgPCAwKSB7XG4gICAgICAgIGtleXMucHVzaChrKTtcbiAgICAgICAgdmFsdWVzLnB1c2goeCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgcm9vdC5maW5kID0gZnVuY3Rpb24oeHMsIGYpIHtcbiAgICB2YXIgeCwgX2ksIF9sZW47XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGYgPSB4cztcbiAgICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgICByZXR1cm4gcm9vdC5maW5kKHhzLCBmKTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZvciAoX2kgPSAwLCBfbGVuID0geHMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIHggPSB4c1tfaV07XG4gICAgICBpZiAoZih4KSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgaXNBcnJheSA9IChfcmVmID0gQXJyYXkuaXNBcnJheSkgIT0gbnVsbCA/IF9yZWYgOiBmdW5jdGlvbih4cykge1xuICAgIHJldHVybiAoKHhzICE9IG51bGwgPyB4cy5zcGxpY2UgOiB2b2lkIDApICE9IG51bGwpICYmICgoeHMgIT0gbnVsbCA/IHhzLnB1c2ggOiB2b2lkIDApICE9IG51bGwpICYmICgoeHMgIT0gbnVsbCA/IHhzLnBvcCA6IHZvaWQgMCkgIT0gbnVsbCkgJiYgKCh4cyAhPSBudWxsID8geHMuc2xpY2UgOiB2b2lkIDApICE9IG51bGwpO1xuICB9O1xuXG4gIHJvb3QuaXNBcnJheSA9IGlzQXJyYXk7XG5cbiAgcm9vdC5pc0Z1bmN0aW9uID0gdHlwZW9mIC8uLyAhPT0gJ2Z1bmN0aW9uJyA/IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdHlwZW9mIGYgPT09ICdmdW5jdGlvbic7XG4gIH0gOiBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIChmICE9IG51bGwpICYmIChmLmNhbGwgIT0gbnVsbCkgJiYgKGYuYXBwbHkgIT0gbnVsbCkgJiYgZi50b1N0cmluZygpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICB9O1xuXG4gIGVudGl0aWVzID0ge1xuICAgICcmJzogJyZhbXA7JyxcbiAgICAnPCc6ICcmbHQ7JyxcbiAgICAnPic6ICcmZ3Q7JyxcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyZhcG9zOydcbiAgfTtcblxuICByb290LmVzY2FwZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBjb2RlLCBpLCByZXQsIHdpdGhFbnRpdGllcywgX2ksIF9yZWYxO1xuICAgIGlmIChzdHIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICB3aXRoRW50aXRpZXMgPSBTdHJpbmcoc3RyKS5yZXBsYWNlKC9bJjw+XCInXS9nLCBmdW5jdGlvbihlbnRpdHkpIHtcbiAgICAgIHJldHVybiBlbnRpdGllc1tlbnRpdHldO1xuICAgIH0pO1xuICAgIHJldCA9IFtdO1xuICAgIGZvciAoaSA9IF9pID0gMCwgX3JlZjEgPSB3aXRoRW50aXRpZXMubGVuZ3RoOyAwIDw9IF9yZWYxID8gX2kgPD0gX3JlZjEgOiBfaSA+PSBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19pIDogLS1faSkge1xuICAgICAgY29kZSA9IHdpdGhFbnRpdGllcy5jaGFyQ29kZUF0KGkpO1xuICAgICAgaWYgKGNvZGUgPiAyNTYpIHtcbiAgICAgICAgcmV0LnB1c2goXCImI1wiICsgY29kZSArIFwiO1wiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldC5wdXNoKHdpdGhFbnRpdGllcy5jaGFyQXQoaSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9O1xuXG4gIHJvb3Qub21hcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICB2YXIgbWVyZ2VyO1xuICAgIG1lcmdlciA9IGZvbGQoZnVuY3Rpb24oYSwgb2xkaywgb2xkdikge1xuICAgICAgdmFyIG5ld2ssIG5ld3YsIF9yZWYxO1xuICAgICAgX3JlZjEgPSBmKG9sZGssIG9sZHYpLCBuZXdrID0gX3JlZjFbMF0sIG5ld3YgPSBfcmVmMVsxXTtcbiAgICAgIGlmIChpc0FycmF5KG5ld3YpKSB7XG4gICAgICAgIG5ld3YgPSBuZXd2LnNsaWNlKCk7XG4gICAgICB9XG4gICAgICBhW25ld2tdID0gbmV3djtcbiAgICAgIHJldHVybiBhO1xuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgcmV0dXJuIG1lcmdlcih7fSwgeHMpO1xuICAgIH07XG4gIH07XG5cbiAgcm9vdC5jb3B5ID0gcm9vdC5vbWFwKGZ1bmN0aW9uKGssIHYpIHtcbiAgICByZXR1cm4gW2ssIHZdO1xuICB9KTtcblxuICByb290LnBhcnRpdGlvbiA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oeHMpIHtcbiAgICAgIHZhciBkaXZpZGU7XG4gICAgICBkaXZpZGUgPSBmb2xkKGZ1bmN0aW9uKF9hcmcsIHgpIHtcbiAgICAgICAgdmFyIGZhbHNlcywgdHJ1ZXM7XG4gICAgICAgIHRydWVzID0gX2FyZ1swXSwgZmFsc2VzID0gX2FyZ1sxXTtcbiAgICAgICAgaWYgKGYoeCkpIHtcbiAgICAgICAgICByZXR1cm4gW3RydWVzLmNvbmNhdChbeF0pLCBmYWxzZXNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBbdHJ1ZXMsIGZhbHNlcy5jb25jYXQoW3hdKV07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRpdmlkZShbW10sIFtdXSwgeHMpO1xuICAgIH07XG4gIH07XG5cbiAgcm9vdC5pZCA9IGlkID0gZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiB4O1xuICB9O1xuXG4gIHJvb3QuY29uY2F0TWFwID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiBmdW5jdGlvbih4cykge1xuICAgICAgdmFyIGZ4LCByZXQsIHgsIF9pLCBfbGVuO1xuICAgICAgcmV0ID0gdm9pZCAwO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICB4ID0geHNbX2ldO1xuICAgICAgICBmeCA9IGYoeCk7XG4gICAgICAgIHJldCA9IHJldCA9PT0gdm9pZCAwID8gZnggOiB0eXBlb2YgcmV0ID09PSAnbnVtYmVyJyA/IHJldCArIGZ4IDogcmV0LmNvbmNhdCAhPSBudWxsID8gcmV0LmNvbmNhdChmeCkgOiBtZXJnZShyZXQsIGZ4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfTtcbiAgfTtcblxuICByb290Lm1hcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gaW52b2tlKCdtYXAnLCBmKTtcbiAgfTtcblxuICBjb21wID0gZm9sZChmdW5jdGlvbihmLCBnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3M7XG4gICAgICBhcmdzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICAgIHJldHVybiBmKGcuYXBwbHkobnVsbCwgYXJncykpO1xuICAgIH07XG4gIH0pO1xuXG4gIHJvb3QuY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmcztcbiAgICBmcyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgcmV0dXJuIGNvbXAoZnMpO1xuICB9O1xuXG4gIHJvb3QuZmxhdE1hcCA9IHJvb3QuY29uY2F0TWFwO1xuXG4gIHJvb3QuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKHhzLCByZW1vdmUpIHtcbiAgICB2YXIgeCwgX2ksIF9sZW4sIF9yZXN1bHRzO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgeCA9IHhzW19pXTtcbiAgICAgIGlmIChfX2luZGV4T2YuY2FsbChyZW1vdmUsIHgpIDwgMCkge1xuICAgICAgICBfcmVzdWx0cy5wdXNoKHgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3Jlc3VsdHM7XG4gIH07XG5cbiAgcm9vdC5zdHJpbmdMaXN0ID0gZnVuY3Rpb24oeCkge1xuICAgIGlmICh0eXBlb2YgeCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBbeF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfTtcblxuICByb290LmZsYXR0ZW4gPSBmbGF0dGVuID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJldCwgeCwgeHMsIHh4LCBfaSwgX2osIF9sZW4sIF9sZW4xLCBfcmVmMTtcbiAgICB4cyA9IDEgPD0gYXJndW1lbnRzLmxlbmd0aCA/IF9fc2xpY2UuY2FsbChhcmd1bWVudHMsIDApIDogW107XG4gICAgcmV0ID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgeCA9IHhzW19pXTtcbiAgICAgIGlmIChpc0FycmF5KHgpKSB7XG4gICAgICAgIF9yZWYxID0gZmxhdHRlbi5hcHBseShudWxsLCB4KTtcbiAgICAgICAgZm9yIChfaiA9IDAsIF9sZW4xID0gX3JlZjEubGVuZ3RoOyBfaiA8IF9sZW4xOyBfaisrKSB7XG4gICAgICAgICAgeHggPSBfcmVmMVtfal07XG4gICAgICAgICAgcmV0LnB1c2goeHgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQucHVzaCh4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByb290LnN1bSA9IHJvb3QuY29uY2F0TWFwKGlkKTtcblxuICByb290Lm1lcmdlID0gbWVyZ2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaywgbmV3T2JqLCBvLCBvYmpzLCB2LCBfaSwgX2xlbjtcbiAgICBvYmpzID0gMSA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMCkgOiBbXTtcbiAgICBuZXdPYmogPSB7fTtcbiAgICBmb3IgKF9pID0gMCwgX2xlbiA9IG9ianMubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIG8gPSBvYmpzW19pXTtcbiAgICAgIGZvciAoayBpbiBvKSB7XG4gICAgICAgIGlmICghX19oYXNQcm9wLmNhbGwobywgaykpIGNvbnRpbnVlO1xuICAgICAgICB2ID0gb1trXTtcbiAgICAgICAgbmV3T2JqW2tdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld09iajtcbiAgfTtcblxuICByb290LmFueSA9IGZ1bmN0aW9uKHhzLCBmKSB7XG4gICAgdmFyIHgsIF9pLCBfbGVuO1xuICAgIGlmIChmID09IG51bGwpIHtcbiAgICAgIGYgPSBpZDtcbiAgICB9XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSB4cy5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgeCA9IHhzW19pXTtcbiAgICAgIGlmIChmKHgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgcm9vdC5pbnZva2UgPSBpbnZva2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncywgbmFtZTtcbiAgICBuYW1lID0gYXJndW1lbnRzWzBdLCBhcmdzID0gMiA8PSBhcmd1bWVudHMubGVuZ3RoID8gX19zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkgOiBbXTtcbiAgICByZXR1cm4gaW52b2tlV2l0aChuYW1lLCBhcmdzKTtcbiAgfTtcblxuICByb290Lmludm9rZVdpdGggPSBpbnZva2VXaXRoID0gZnVuY3Rpb24obmFtZSwgYXJncywgY3R4KSB7XG4gICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgYXJncyA9IFtdO1xuICAgIH1cbiAgICBpZiAoY3R4ID09IG51bGwpIHtcbiAgICAgIGN0eCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjYWxsIG1ldGhvZCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIG9mIG51bGxcIik7XG4gICAgICB9XG4gICAgICBpZiAoIW9bbmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNhbGwgdW5kZWZpbmVkIG1ldGhvZCBcXFwiXCIgKyBuYW1lICsgXCIgb2YgXCIgKyBvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvW25hbWVdLmFwcGx5KGN0eCB8fCBvLCBhcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHJvb3QuZ2V0ID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBvYmpbbmFtZV07XG4gICAgfTtcbiAgfTtcblxuICByb290LnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgdmFyIGssIHY7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBvYmpbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoayBpbiBuYW1lKSB7XG4gICAgICAgICAgaWYgKCFfX2hhc1Byb3AuY2FsbChuYW1lLCBrKSkgY29udGludWU7XG4gICAgICAgICAgdiA9IG5hbWVba107XG4gICAgICAgICAgb2JqW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICB9O1xuXG4gIFJFUVVJUkVTID0gZnVuY3Rpb24ocmVxdWlyZWQsIGdvdCkge1xuICAgIHJldHVybiBcIlRoaXMgc2VydmljZSByZXF1aXJlcyBhIHNlcnZpY2UgYXQgdmVyc2lvbiBcIiArIHJlcXVpcmVkICsgXCIgb3IgYWJvdmUuIFRoaXMgb25lIGlzIGF0IFwiICsgZ290O1xuICB9O1xuXG4gIHJvb3QuUkVRVUlSRVNfVkVSU0lPTiA9IGZ1bmN0aW9uKHMsIG4sIGYpIHtcbiAgICByZXR1cm4gcy5mZXRjaFZlcnNpb24oKS50aGVuKGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmICh2ID49IG4pIHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBlcnJvcihSRVFVSVJFUyhuLCB2KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcm9vdC5kZWpvaW4gPSBmdW5jdGlvbihxKSB7XG4gICAgdmFyIHBhcnRzLCB2aWV3LCBfaSwgX2xlbiwgX3JlZjE7XG4gICAgX3JlZjEgPSBxLnZpZXdzO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZjEubGVuZ3RoOyBfaSA8IF9sZW47IF9pKyspIHtcbiAgICAgIHZpZXcgPSBfcmVmMVtfaV07XG4gICAgICBwYXJ0cyA9IHZpZXcuc3BsaXQoJy4nKTtcbiAgICAgIGlmIChwYXJ0cy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHEuYWRkSm9pbihwYXJ0cy5zbGljZSgxLCAtMSkuam9pbignLicpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHE7XG4gIH07XG5cbiAgdGhlbkZvbGQgPSBmb2xkKGZ1bmN0aW9uKHAsIGYpIHtcbiAgICByZXR1cm4gcC50aGVuKGYpO1xuICB9KTtcblxuICByb290LnNlcXVlbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZucztcbiAgICBmbnMgPSAxIDw9IGFyZ3VtZW50cy5sZW5ndGggPyBfX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAwKSA6IFtdO1xuICAgIHJldHVybiB0aGVuRm9sZChzdWNjZXNzKCksIGZucyk7XG4gIH07XG5cbiAgcGFpckZvbGQgPSBmb2xkKGZ1bmN0aW9uKG8sIF9hcmcpIHtcbiAgICB2YXIgaywgdjtcbiAgICBrID0gX2FyZ1swXSwgdiA9IF9hcmdbMV07XG4gICAgaWYgKG9ba10gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGtleTogXCIgKyBrKTtcbiAgICB9XG4gICAgb1trXSA9IHY7XG4gICAgcmV0dXJuIG87XG4gIH0pO1xuXG4gIHJvb3QucGFpcnNUb09iaiA9IGZ1bmN0aW9uKHBhaXJzKSB7XG4gICAgcmV0dXJuIHBhaXJGb2xkKHt9LCBwYWlycyk7XG4gIH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se1wiLi9wcm9taXNlXCI6OH1dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgZXhwb3J0cy5WRVJTSU9OID0gJzMuMTMuMCc7XG5cbn0pLmNhbGwodGhpcyk7XG5cbn0se31dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbigpIHtcbiAgdmFyIERPTVBhcnNlciwgc2FuaXRpemU7XG5cbiAgRE9NUGFyc2VyID0gX2RlcmVxXygneG1sZG9tJykuRE9NUGFyc2VyO1xuXG4gIHNhbml0aXplID0gZnVuY3Rpb24oeG1sKSB7XG4gICAgeG1sID0geG1sLnJlcGxhY2UoL15cXHMqL2csICcnKTtcbiAgICB4bWwgPSB4bWwucmVwbGFjZSgvXFxzJC9nLCAnJyk7XG4gICAgaWYgKHhtbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB4bWw7XG4gICAgfSBlbHNlIGlmICh4bWxbeG1sLmxlbmd0aCAtIDFdICE9PSAnPicpIHtcbiAgICAgIHJldHVybiB4bWwgKyAnPic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB4bWw7XG4gICAgfVxuICB9O1xuXG4gIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbih4bWwpIHtcbiAgICB2YXIgZG9tLCBwYXJzZXI7XG4gICAgaWYgKHR5cGVvZiB4bWwgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZyAtIGdvdCBcIiArIHhtbCk7XG4gICAgfVxuICAgIHhtbCA9IHNhbml0aXplKHhtbCk7XG4gICAgaWYgKCF4bWwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGNvbnRlbnQgLSBnb3QgZW1wdHkgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBkb20gPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHhtbCwgJ3RleHQveG1sJyk7XG4gICAgICB9IGNhdGNoIChfZXJyb3IpIHt9XG4gICAgfSkoKTtcbiAgICBpZiAoKCFkb20pIHx8ICghZG9tLmRvY3VtZW50RWxlbWVudCkgfHwgZG9tLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBYTUw6IFwiICsgeG1sKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvbTtcbiAgfTtcblxufSkuY2FsbCh0aGlzKTtcblxufSx7XCJ4bWxkb21cIjoxMX1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxCdWZmZXIpe1xuXG5cbnZhciBQYXJzZXIgPSBfZGVyZXFfKCdqc29ucGFyc2UnKVxuICAsIHRocm91Z2ggPSBfZGVyZXFfKCd0aHJvdWdoJylcblxuLypcblxuICB0aGUgdmFsdWUgb2YgdGhpcy5zdGFjayB0aGF0IGNyZWF0aW9uaXgncyBqc29ucGFyc2UgaGFzIGlzIHdlaXJkLlxuXG4gIGl0IG1ha2VzIHRoaXMgY29kZSB1Z2x5LCBidXQgaGlzIHByb2JsZW0gaXMgd2F5IGhhcmRlciB0aGF0IG1pbmUsXG4gIHNvIGknbGwgZm9yZ2l2ZSBoaW0uXG5cbiovXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAocGF0aCwgbWFwKSB7XG5cbiAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIoKVxuICB2YXIgc3RyZWFtID0gdGhyb3VnaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBpZignc3RyaW5nJyA9PT0gdHlwZW9mIGNodW5rKVxuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rKVxuICAgIHBhcnNlci53cml0ZShjaHVuaylcbiAgfSxcbiAgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihkYXRhKVxuICAgICAgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgc3RyZWFtLnF1ZXVlKG51bGwpXG4gIH0pXG5cbiAgaWYoJ3N0cmluZycgPT09IHR5cGVvZiBwYXRoKVxuICAgIHBhdGggPSBwYXRoLnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoZSA9PT0gJyonKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgZWxzZSBpZiAoZSA9PT0gJycpIC8vICcuLicuc3BsaXQoJy4nKSByZXR1cm5zIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgICByZXR1cm4ge3JlY3Vyc2U6IHRydWV9XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBlXG4gICAgfSlcblxuXG4gIHZhciBjb3VudCA9IDAsIF9rZXlcbiAgaWYoIXBhdGggfHwgIXBhdGgubGVuZ3RoKVxuICAgIHBhdGggPSBudWxsXG5cbiAgcGFyc2VyLm9uVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIXRoaXMucm9vdClcbiAgICAgIHN0cmVhbS5yb290ID0gdmFsdWVcblxuICAgIGlmKCEgcGF0aCkgcmV0dXJuXG5cbiAgICB2YXIgaSA9IDAgLy8gaXRlcmF0ZXMgb24gcGF0aFxuICAgIHZhciBqICA9IDAgLy8gaXRlcmF0ZXMgb24gc3RhY2tcbiAgICB3aGlsZSAoaSA8IHBhdGgubGVuZ3RoKSB7XG4gICAgICB2YXIga2V5ID0gcGF0aFtpXVxuICAgICAgdmFyIGNcbiAgICAgIGorK1xuXG4gICAgICBpZiAoa2V5ICYmICFrZXkucmVjdXJzZSkge1xuICAgICAgICBjID0gKGogPT09IHRoaXMuc3RhY2subGVuZ3RoKSA/IHRoaXMgOiB0aGlzLnN0YWNrW2pdXG4gICAgICAgIGlmICghYykgcmV0dXJuXG4gICAgICAgIGlmICghIGNoZWNrKGtleSwgYy5rZXkpKSByZXR1cm5cbiAgICAgICAgaSsrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKytcbiAgICAgICAgdmFyIG5leHRLZXkgPSBwYXRoW2ldXG4gICAgICAgIGlmICghIG5leHRLZXkpIHJldHVyblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGMgPSAoaiA9PT0gdGhpcy5zdGFjay5sZW5ndGgpID8gdGhpcyA6IHRoaXMuc3RhY2tbal1cbiAgICAgICAgICBpZiAoIWMpIHJldHVyblxuICAgICAgICAgIGlmIChjaGVjayhuZXh0S2V5LCBjLmtleSkpIHsgaSsrOyBicmVha31cbiAgICAgICAgICBqKytcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaiAhPT0gdGhpcy5zdGFjay5sZW5ndGgpIHJldHVyblxuXG4gICAgY291bnQgKytcbiAgICB2YXIgYWN0dWFsUGF0aCA9IHRoaXMuc3RhY2suc2xpY2UoMSkubWFwKGZ1bmN0aW9uKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnQua2V5IH0pLmNvbmNhdChbdGhpcy5rZXldKVxuICAgIHZhciBkYXRhID0gdGhpcy52YWx1ZVt0aGlzLmtleV1cbiAgICBpZihudWxsICE9IGRhdGEpXG4gICAgICBpZihudWxsICE9IChkYXRhID0gbWFwID8gbWFwKGRhdGEsIGFjdHVhbFBhdGgpIDogZGF0YSkpXG4gICAgICAgIHN0cmVhbS5xdWV1ZShkYXRhKVxuICAgIGRlbGV0ZSB0aGlzLnZhbHVlW3RoaXMua2V5XVxuICB9XG4gIHBhcnNlci5fb25Ub2tlbiA9IHBhcnNlci5vblRva2VuO1xuXG4gIHBhcnNlci5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuLCB2YWx1ZSkge1xuICAgIHBhcnNlci5fb25Ub2tlbih0b2tlbiwgdmFsdWUpO1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHN0cmVhbS5yb290KSB7XG4gICAgICAgIGlmKCFwYXRoKVxuICAgICAgICAgIHN0cmVhbS5xdWV1ZShzdHJlYW0ucm9vdClcbiAgICAgICAgc3RyZWFtLmVtaXQoJ3Jvb3QnLCBzdHJlYW0ucm9vdCwgY291bnQpXG4gICAgICAgIGNvdW50ID0gMDtcbiAgICAgICAgc3RyZWFtLnJvb3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHBhcnNlci5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycilcbiAgfVxuXG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5mdW5jdGlvbiBjaGVjayAoeCwgeSkge1xuICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB4KVxuICAgIHJldHVybiB5ID09IHhcbiAgZWxzZSBpZiAoeCAmJiAnZnVuY3Rpb24nID09PSB0eXBlb2YgeC5leGVjKVxuICAgIHJldHVybiB4LmV4ZWMoeSlcbiAgZWxzZSBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgeClcbiAgICByZXR1cm4geFxuICBlbHNlIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgeClcbiAgICByZXR1cm4geCh5KVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob3AsIHNlcCwgY2wsIGluZGVudCkge1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgMFxuICBpZiAob3AgPT09IGZhbHNlKXtcbiAgICBvcCA9ICcnXG4gICAgc2VwID0gJ1xcbidcbiAgICBjbCA9ICcnXG4gIH0gZWxzZSBpZiAob3AgPT0gbnVsbCkge1xuXG4gICAgb3AgPSAnW1xcbidcbiAgICBzZXAgPSAnXFxuLFxcbidcbiAgICBjbCA9ICdcXG5dXFxuJ1xuXG4gIH1cblxuICAvL2Vsc2UsIHdoYXQgZXZlciB5b3UgbGlrZVxuXG4gIHZhciBzdHJlYW1cbiAgICAsIGZpcnN0ID0gdHJ1ZVxuICAgICwgYW55RGF0YSA9IGZhbHNlXG4gIHN0cmVhbSA9IHRocm91Z2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBhbnlEYXRhID0gdHJ1ZVxuICAgIHZhciBqc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSwgbnVsbCwgaW5kZW50KVxuICAgIGlmKGZpcnN0KSB7IGZpcnN0ID0gZmFsc2UgOyBzdHJlYW0ucXVldWUob3AgKyBqc29uKX1cbiAgICBlbHNlIHN0cmVhbS5xdWV1ZShzZXAgKyBqc29uKVxuICB9LFxuICBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmKCFhbnlEYXRhKVxuICAgICAgc3RyZWFtLnF1ZXVlKG9wKVxuICAgIHN0cmVhbS5xdWV1ZShjbClcbiAgICBzdHJlYW0ucXVldWUobnVsbClcbiAgfSlcblxuICByZXR1cm4gc3RyZWFtXG59XG5cbmV4cG9ydHMuc3RyaW5naWZ5T2JqZWN0ID0gZnVuY3Rpb24gKG9wLCBzZXAsIGNsLCBpbmRlbnQpIHtcbiAgaW5kZW50ID0gaW5kZW50IHx8IDBcbiAgaWYgKG9wID09PSBmYWxzZSl7XG4gICAgb3AgPSAnJ1xuICAgIHNlcCA9ICdcXG4nXG4gICAgY2wgPSAnJ1xuICB9IGVsc2UgaWYgKG9wID09IG51bGwpIHtcblxuICAgIG9wID0gJ3tcXG4nXG4gICAgc2VwID0gJ1xcbixcXG4nXG4gICAgY2wgPSAnXFxufVxcbidcblxuICB9XG5cbiAgLy9lbHNlLCB3aGF0IGV2ZXIgeW91IGxpa2VcblxuICB2YXIgZmlyc3QgPSB0cnVlXG4gICAgLCBhbnlEYXRhID0gZmFsc2VcbiAgc3RyZWFtID0gdGhyb3VnaChmdW5jdGlvbiAoZGF0YSkge1xuICAgIGFueURhdGEgPSB0cnVlXG4gICAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeShkYXRhWzBdKSArICc6JyArIEpTT04uc3RyaW5naWZ5KGRhdGFbMV0sIG51bGwsIGluZGVudClcbiAgICBpZihmaXJzdCkgeyBmaXJzdCA9IGZhbHNlIDsgdGhpcy5xdWV1ZShvcCArIGpzb24pfVxuICAgIGVsc2UgdGhpcy5xdWV1ZShzZXAgKyBqc29uKVxuICB9LFxuICBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmKCFhbnlEYXRhKSB0aGlzLnF1ZXVlKG9wKVxuICAgIHRoaXMucXVldWUoY2wpXG5cbiAgICB0aGlzLnF1ZXVlKG51bGwpXG4gIH0pXG5cbiAgcmV0dXJuIHN0cmVhbVxufVxuXG5pZighbW9kdWxlLnBhcmVudCAmJiBwcm9jZXNzLnRpdGxlICE9PSAnYnJvd3NlcicpIHtcbiAgcHJvY2Vzcy5zdGRpblxuICAgIC5waXBlKGV4cG9ydHMucGFyc2UocHJvY2Vzcy5hcmd2WzJdKSlcbiAgICAucGlwZShleHBvcnRzLnN0cmluZ2lmeSgnWycsICcsXFxuJywgJ11cXG4nLCAyKSlcbiAgICAucGlwZShwcm9jZXNzLnN0ZG91dClcbn1cblxufSkuY2FsbCh0aGlzLF9kZXJlcV8oXCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIiksX2RlcmVxXyhcImJ1ZmZlclwiKS5CdWZmZXIpXG59LHtcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjU1LFwiYnVmZmVyXCI6MjMsXCJqc29ucGFyc2VcIjoxOSxcInRocm91Z2hcIjo1Nn1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoQnVmZmVyKXtcbi8qZ2xvYmFsIEJ1ZmZlciovXG4vLyBOYW1lZCBjb25zdGFudHMgd2l0aCB1bmlxdWUgaW50ZWdlciB2YWx1ZXNcbnZhciBDID0ge307XG4vLyBUb2tlbnNcbnZhciBMRUZUX0JSQUNFICAgID0gQy5MRUZUX0JSQUNFICAgID0gMHgxO1xudmFyIFJJR0hUX0JSQUNFICAgPSBDLlJJR0hUX0JSQUNFICAgPSAweDI7XG52YXIgTEVGVF9CUkFDS0VUICA9IEMuTEVGVF9CUkFDS0VUICA9IDB4MztcbnZhciBSSUdIVF9CUkFDS0VUID0gQy5SSUdIVF9CUkFDS0VUID0gMHg0O1xudmFyIENPTE9OICAgICAgICAgPSBDLkNPTE9OICAgICAgICAgPSAweDU7XG52YXIgQ09NTUEgICAgICAgICA9IEMuQ09NTUEgICAgICAgICA9IDB4NjtcbnZhciBUUlVFICAgICAgICAgID0gQy5UUlVFICAgICAgICAgID0gMHg3O1xudmFyIEZBTFNFICAgICAgICAgPSBDLkZBTFNFICAgICAgICAgPSAweDg7XG52YXIgTlVMTCAgICAgICAgICA9IEMuTlVMTCAgICAgICAgICA9IDB4OTtcbnZhciBTVFJJTkcgICAgICAgID0gQy5TVFJJTkcgICAgICAgID0gMHhhO1xudmFyIE5VTUJFUiAgICAgICAgPSBDLk5VTUJFUiAgICAgICAgPSAweGI7XG4vLyBUb2tlbml6ZXIgU3RhdGVzXG52YXIgU1RBUlQgICA9IEMuU1RBUlQgICA9IDB4MTE7XG52YXIgVFJVRTEgICA9IEMuVFJVRTEgICA9IDB4MjE7XG52YXIgVFJVRTIgICA9IEMuVFJVRTIgICA9IDB4MjI7XG52YXIgVFJVRTMgICA9IEMuVFJVRTMgICA9IDB4MjM7XG52YXIgRkFMU0UxICA9IEMuRkFMU0UxICA9IDB4MzE7XG52YXIgRkFMU0UyICA9IEMuRkFMU0UyICA9IDB4MzI7XG52YXIgRkFMU0UzICA9IEMuRkFMU0UzICA9IDB4MzM7XG52YXIgRkFMU0U0ICA9IEMuRkFMU0U0ICA9IDB4MzQ7XG52YXIgTlVMTDEgICA9IEMuTlVMTDEgICA9IDB4NDE7XG52YXIgTlVMTDIgICA9IEMuTlVMTDMgICA9IDB4NDI7XG52YXIgTlVMTDMgICA9IEMuTlVMTDIgICA9IDB4NDM7XG52YXIgTlVNQkVSMSA9IEMuTlVNQkVSMSA9IDB4NTE7XG52YXIgTlVNQkVSMiA9IEMuTlVNQkVSMiA9IDB4NTI7XG52YXIgTlVNQkVSMyA9IEMuTlVNQkVSMyA9IDB4NTM7XG52YXIgTlVNQkVSNCA9IEMuTlVNQkVSNCA9IDB4NTQ7XG52YXIgTlVNQkVSNSA9IEMuTlVNQkVSNSA9IDB4NTU7XG52YXIgTlVNQkVSNiA9IEMuTlVNQkVSNiA9IDB4NTY7XG52YXIgTlVNQkVSNyA9IEMuTlVNQkVSNyA9IDB4NTc7XG52YXIgTlVNQkVSOCA9IEMuTlVNQkVSOCA9IDB4NTg7XG52YXIgU1RSSU5HMSA9IEMuU1RSSU5HMSA9IDB4NjE7XG52YXIgU1RSSU5HMiA9IEMuU1RSSU5HMiA9IDB4NjI7XG52YXIgU1RSSU5HMyA9IEMuU1RSSU5HMyA9IDB4NjM7XG52YXIgU1RSSU5HNCA9IEMuU1RSSU5HNCA9IDB4NjQ7XG52YXIgU1RSSU5HNSA9IEMuU1RSSU5HNSA9IDB4NjU7XG52YXIgU1RSSU5HNiA9IEMuU1RSSU5HNiA9IDB4NjY7XG4vLyBQYXJzZXIgU3RhdGVzXG52YXIgVkFMVUUgICA9IEMuVkFMVUUgICA9IDB4NzE7XG52YXIgS0VZICAgICA9IEMuS0VZICAgICA9IDB4NzI7XG4vLyBQYXJzZXIgTW9kZXNcbnZhciBPQkpFQ1QgID0gQy5PQkpFQ1QgID0gMHg4MTtcbnZhciBBUlJBWSAgID0gQy5BUlJBWSAgID0gMHg4MjtcblxuLy8gU2xvdyBjb2RlIHRvIHN0cmluZyBjb252ZXJ0ZXIgKG9ubHkgdXNlZCB3aGVuIHRocm93aW5nIHN5bnRheCBlcnJvcnMpXG5mdW5jdGlvbiB0b2tuYW0oY29kZSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKEMpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKENba2V5XSA9PT0gY29kZSkgeyByZXR1cm4ga2V5OyB9XG4gIH1cbiAgcmV0dXJuIGNvZGUgJiYgKFwiMHhcIiArIGNvZGUudG9TdHJpbmcoMTYpKTtcbn1cblxuXG5mdW5jdGlvbiBQYXJzZXIoKSB7XG4gIHRoaXMudFN0YXRlID0gU1RBUlQ7XG4gIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgdGhpcy5zdHJpbmcgPSB1bmRlZmluZWQ7IC8vIHN0cmluZyBkYXRhXG4gIHRoaXMudW5pY29kZSA9IHVuZGVmaW5lZDsgLy8gdW5pY29kZSBlc2NhcGVzXG5cbiAgLy8gRm9yIG51bWJlciBwYXJzaW5nXG4gIHRoaXMubmVnYXRpdmUgPSB1bmRlZmluZWQ7XG4gIHRoaXMubWFnbmF0dWRlID0gdW5kZWZpbmVkO1xuICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICB0aGlzLmV4cG9uZW50ID0gdW5kZWZpbmVkO1xuICB0aGlzLm5lZ2F0aXZlRXhwb25lbnQgPSB1bmRlZmluZWQ7XG4gIFxuICB0aGlzLmtleSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5tb2RlID0gdW5kZWZpbmVkO1xuICB0aGlzLnN0YWNrID0gW107XG4gIHRoaXMuc3RhdGUgPSBWQUxVRTtcbiAgdGhpcy5ieXRlc19yZW1haW5pbmcgPSAwOyAvLyBudW1iZXIgb2YgYnl0ZXMgcmVtYWluaW5nIGluIG11bHRpIGJ5dGUgdXRmOCBjaGFyIHRvIHJlYWQgYWZ0ZXIgc3BsaXQgYm91bmRhcnlcbiAgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSA9IDA7IC8vIGJ5dGVzIGluIG11bHRpIGJ5dGUgdXRmOCBjaGFyIHRvIHJlYWRcbiAgdGhpcy50ZW1wX2J1ZmZzID0geyBcIjJcIjogbmV3IEJ1ZmZlcigyKSwgXCIzXCI6IG5ldyBCdWZmZXIoMyksIFwiNFwiOiBuZXcgQnVmZmVyKDQpIH07IC8vIGZvciByZWJ1aWxkaW5nIGNoYXJzIHNwbGl0IGJlZm9yZSBib3VuZGFyeSBpcyByZWFjaGVkXG59XG52YXIgcHJvdG8gPSBQYXJzZXIucHJvdG90eXBlO1xucHJvdG8uY2hhckVycm9yID0gZnVuY3Rpb24gKGJ1ZmZlciwgaSkge1xuICB0aGlzLm9uRXJyb3IobmV3IEVycm9yKFwiVW5leHBlY3RlZCBcIiArIEpTT04uc3RyaW5naWZ5KFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyW2ldKSkgKyBcIiBhdCBwb3NpdGlvbiBcIiArIGkgKyBcIiBpbiBzdGF0ZSBcIiArIHRva25hbSh0aGlzLnRTdGF0ZSkpKTtcbn07XG5wcm90by5vbkVycm9yID0gZnVuY3Rpb24gKGVycikgeyB0aHJvdyBlcnI7IH07XG5wcm90by53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgaWYgKHR5cGVvZiBidWZmZXIgPT09IFwic3RyaW5nXCIpIGJ1ZmZlciA9IG5ldyBCdWZmZXIoYnVmZmVyKTtcbiAgLy9wcm9jZXNzLnN0ZG91dC53cml0ZShcIklucHV0OiBcIik7XG4gIC8vY29uc29sZS5kaXIoYnVmZmVyLnRvU3RyaW5nKCkpO1xuICB2YXIgbjtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBidWZmZXIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHRoaXMudFN0YXRlID09PSBTVEFSVCl7XG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgaWYobiA9PT0gMHg3Yil7IHRoaXMub25Ub2tlbihMRUZUX0JSQUNFLCBcIntcIik7IC8vIHtcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4N2QpeyB0aGlzLm9uVG9rZW4oUklHSFRfQlJBQ0UsIFwifVwiKTsgLy8gfVxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg1Yil7IHRoaXMub25Ub2tlbihMRUZUX0JSQUNLRVQsIFwiW1wiKTsgLy8gW1xuICAgICAgfWVsc2UgaWYobiA9PT0gMHg1ZCl7IHRoaXMub25Ub2tlbihSSUdIVF9CUkFDS0VULCBcIl1cIik7IC8vIF1cbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4M2EpeyB0aGlzLm9uVG9rZW4oQ09MT04sIFwiOlwiKTsgIC8vIDpcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4MmMpeyB0aGlzLm9uVG9rZW4oQ09NTUEsIFwiLFwiKTsgLy8gLFxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg3NCl7IHRoaXMudFN0YXRlID0gVFJVRTE7ICAvLyB0XG4gICAgICB9ZWxzZSBpZihuID09PSAweDY2KXsgdGhpcy50U3RhdGUgPSBGQUxTRTE7ICAvLyBmXG4gICAgICB9ZWxzZSBpZihuID09PSAweDZlKXsgdGhpcy50U3RhdGUgPSBOVUxMMTsgLy8gblxuICAgICAgfWVsc2UgaWYobiA9PT0gMHgyMil7IHRoaXMuc3RyaW5nID0gXCJcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyAvLyBcIlxuICAgICAgfWVsc2UgaWYobiA9PT0gMHgyZCl7IHRoaXMubmVnYXRpdmUgPSB0cnVlOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjE7IC8vIC1cbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4MzApeyB0aGlzLm1hZ25hdHVkZSA9IDA7IHRoaXMudFN0YXRlID0gTlVNQkVSMjsgLy8gMFxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmIChuID4gMHgzMCAmJiBuIDwgMHg0MCkgeyAvLyAxLTlcbiAgICAgICAgICB0aGlzLm1hZ25hdHVkZSA9IG4gLSAweDMwOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjM7XG4gICAgICAgIH0gZWxzZSBpZiAobiA9PT0gMHgyMCB8fCBuID09PSAweDA5IHx8IG4gPT09IDB4MGEgfHwgbiA9PT0gMHgwZCkge1xuICAgICAgICAgIC8vIHdoaXRlc3BhY2VcbiAgICAgICAgfSBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gU1RSSU5HMSl7IC8vIEFmdGVyIG9wZW4gcXVvdGVcbiAgICAgIG4gPSBidWZmZXJbaV07IC8vIGdldCBjdXJyZW50IGJ5dGUgZnJvbSBidWZmZXJcbiAgICAgIC8vIGNoZWNrIGZvciBjYXJyeSBvdmVyIG9mIGEgbXVsdGkgYnl0ZSBjaGFyIHNwbGl0IGJldHdlZW4gZGF0YSBjaHVua3NcbiAgICAgIC8vICYgZmlsbCB0ZW1wIGJ1ZmZlciBpdCB3aXRoIHN0YXJ0IG9mIHRoaXMgZGF0YSBjaHVuayB1cCB0byB0aGUgYm91bmRhcnkgbGltaXQgc2V0IGluIHRoZSBsYXN0IGl0ZXJhdGlvblxuICAgICAgaWYgKHRoaXMuYnl0ZXNfcmVtYWluaW5nID4gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuYnl0ZXNfcmVtYWluaW5nOyBqKyspIHtcbiAgICAgICAgICB0aGlzLnRlbXBfYnVmZnNbdGhpcy5ieXRlc19pbl9zZXF1ZW5jZV1bdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSAtIHRoaXMuYnl0ZXNfcmVtYWluaW5nICsgal0gPSBidWZmZXJbal07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdHJpbmcgKz0gdGhpcy50ZW1wX2J1ZmZzW3RoaXMuYnl0ZXNfaW5fc2VxdWVuY2VdLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgPSB0aGlzLmJ5dGVzX3JlbWFpbmluZyA9IDA7XG4gICAgICAgIGkgPSBpICsgaiAtIDE7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYnl0ZXNfcmVtYWluaW5nID09PSAwICYmIG4gPj0gMTI4KSB7IC8vIGVsc2UgaWYgbm8gcmVtYWluZGVyIGJ5dGVzIGNhcnJpZWQgb3ZlciwgcGFyc2UgbXVsdGkgYnl0ZSAoPj0xMjgpIGNoYXJzIG9uZSBhdCBhIHRpbWVcbiAgICAgICAgaWYgKChuID49IDE5NCkgJiYgKG4gPD0gMjIzKSkgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSA9IDI7XG4gICAgICAgIGlmICgobiA+PSAyMjQpICYmIChuIDw9IDIzOSkpIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UgPSAzO1xuICAgICAgICBpZiAoKG4gPj0gMjQwKSAmJiAobiA8PSAyNDQpKSB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlID0gNDtcbiAgICAgICAgaWYgKCh0aGlzLmJ5dGVzX2luX3NlcXVlbmNlICsgaSkgPiBidWZmZXIubGVuZ3RoKSB7IC8vIGlmIGJ5dGVzIG5lZWRlZCB0byBjb21wbGV0ZSBjaGFyIGZhbGwgb3V0c2lkZSBidWZmZXIgbGVuZ3RoLCB3ZSBoYXZlIGEgYm91bmRhcnkgc3BsaXRcbiAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8PSAoYnVmZmVyLmxlbmd0aCAtIDEgLSBpKTsgaysrKSB7XG4gICAgICAgICAgICB0aGlzLnRlbXBfYnVmZnNbdGhpcy5ieXRlc19pbl9zZXF1ZW5jZV1ba10gPSBidWZmZXJbaSArIGtdOyAvLyBmaWxsIHRlbXAgYnVmZmVyIG9mIGNvcnJlY3Qgc2l6ZSB3aXRoIGJ5dGVzIGF2YWlsYWJsZSBpbiB0aGlzIGNodW5rXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYnl0ZXNfcmVtYWluaW5nID0gKGkgKyB0aGlzLmJ5dGVzX2luX3NlcXVlbmNlKSAtIGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgaSA9IGJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3RyaW5nICs9IGJ1ZmZlci5zbGljZShpLCAoaSArIHRoaXMuYnl0ZXNfaW5fc2VxdWVuY2UpKS50b1N0cmluZygpO1xuICAgICAgICAgIGkgPSBpICsgdGhpcy5ieXRlc19pbl9zZXF1ZW5jZSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobiA9PT0gMHgyMikgeyB0aGlzLnRTdGF0ZSA9IFNUQVJUOyB0aGlzLm9uVG9rZW4oU1RSSU5HLCB0aGlzLnN0cmluZyk7IHRoaXMuc3RyaW5nID0gdW5kZWZpbmVkOyB9XG4gICAgICBlbHNlIGlmIChuID09PSAweDVjKSB7IHRoaXMudFN0YXRlID0gU1RSSU5HMjsgfVxuICAgICAgZWxzZSBpZiAobiA+PSAweDIwKSB7IHRoaXMuc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobik7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBTVFJJTkcyKXsgLy8gQWZ0ZXIgYmFja3NsYXNoXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgaWYobiA9PT0gMHgyMil7IHRoaXMuc3RyaW5nICs9IFwiXFxcIlwiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7XG4gICAgICB9ZWxzZSBpZihuID09PSAweDVjKXsgdGhpcy5zdHJpbmcgKz0gXCJcXFxcXCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICB9ZWxzZSBpZihuID09PSAweDJmKXsgdGhpcy5zdHJpbmcgKz0gXCJcXC9cIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyBcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NjIpeyB0aGlzLnN0cmluZyArPSBcIlxcYlwiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7IFxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg2Nil7IHRoaXMuc3RyaW5nICs9IFwiXFxmXCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICB9ZWxzZSBpZihuID09PSAweDZlKXsgdGhpcy5zdHJpbmcgKz0gXCJcXG5cIjsgdGhpcy50U3RhdGUgPSBTVFJJTkcxOyBcbiAgICAgIH1lbHNlIGlmKG4gPT09IDB4NzIpeyB0aGlzLnN0cmluZyArPSBcIlxcclwiOyB0aGlzLnRTdGF0ZSA9IFNUUklORzE7IFxuICAgICAgfWVsc2UgaWYobiA9PT0gMHg3NCl7IHRoaXMuc3RyaW5nICs9IFwiXFx0XCI7IHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICB9ZWxzZSBpZihuID09PSAweDc1KXsgdGhpcy51bmljb2RlID0gXCJcIjsgdGhpcy50U3RhdGUgPSBTVFJJTkczO1xuICAgICAgfWVsc2V7IFxuICAgICAgICB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyBcbiAgICAgIH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFNUUklORzMgfHwgdGhpcy50U3RhdGUgPT09IFNUUklORzQgfHwgdGhpcy50U3RhdGUgPT09IFNUUklORzUgfHwgdGhpcy50U3RhdGUgPT09IFNUUklORzYpeyAvLyB1bmljb2RlIGhleCBjb2Rlc1xuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIC8vIDAtOSBBLUYgYS1mXG4gICAgICBpZiAoKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkgfHwgKG4gPiAweDQwICYmIG4gPD0gMHg0NikgfHwgKG4gPiAweDYwICYmIG4gPD0gMHg2NikpIHtcbiAgICAgICAgdGhpcy51bmljb2RlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobik7XG4gICAgICAgIGlmICh0aGlzLnRTdGF0ZSsrID09PSBTVFJJTkc2KSB7XG4gICAgICAgICAgdGhpcy5zdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCh0aGlzLnVuaWNvZGUsIDE2KSk7XG4gICAgICAgICAgdGhpcy51bmljb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHRoaXMudFN0YXRlID0gU1RSSU5HMTsgXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7XG4gICAgICB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVIxKXsgLy8gYWZ0ZXIgbWludXNcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICBpZiAobiA9PT0gMHgzMCkgeyB0aGlzLm1hZ25hdHVkZSA9IDA7IHRoaXMudFN0YXRlID0gTlVNQkVSMjsgfVxuICAgICAgZWxzZSBpZiAobiA+IDB4MzAgJiYgbiA8IDB4NDApIHsgdGhpcy5tYWduYXR1ZGUgPSBuIC0gMHgzMDsgdGhpcy50U3RhdGUgPSBOVU1CRVIzOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSMil7IC8vICogQWZ0ZXIgaW5pdGlhbCB6ZXJvXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgaWYobiA9PT0gMHgyZSl7IC8vIC5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDAuMTsgdGhpcy50U3RhdGUgPSBOVU1CRVI0O1xuICAgICAgfWVsc2UgaWYobiA9PT0gMHg2NSB8fCAgbiA9PT0gMHg0NSl7IC8vIGUvRVxuICAgICAgICB0aGlzLmV4cG9uZW50ID0gMDsgdGhpcy50U3RhdGUgPSBOVU1CRVI2O1xuICAgICAgfWVsc2V7XG4gICAgICAgIHRoaXMudFN0YXRlID0gU1RBUlQ7XG4gICAgICAgIHRoaXMub25Ub2tlbihOVU1CRVIsIDApO1xuICAgICAgICB0aGlzLm1hZ25hdHVkZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSMyl7IC8vICogQWZ0ZXIgZGlnaXQgKGJlZm9yZSBwZXJpb2QpXG4gICAgICBuID0gYnVmZmVyW2ldO1xuICAgICAgaWYobiA9PT0gMHgyZSl7IC8vIC5cbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IDAuMTsgdGhpcy50U3RhdGUgPSBOVU1CRVI0O1xuICAgICAgfWVsc2UgaWYobiA9PT0gMHg2NSB8fCBuID09PSAweDQ1KXsgLy8gZS9FXG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSAwOyB0aGlzLnRTdGF0ZSA9IE5VTUJFUjY7XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYgKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkgeyB0aGlzLm1hZ25hdHVkZSA9IHRoaXMubWFnbmF0dWRlICogMTAgKyBuIC0gMHgzMDsgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRTdGF0ZSA9IFNUQVJUOyBcbiAgICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSAtdGhpcy5tYWduYXR1ZGU7XG4gICAgICAgICAgICB0aGlzLm5lZ2F0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm9uVG9rZW4oTlVNQkVSLCB0aGlzLm1hZ25hdHVkZSk7IFxuICAgICAgICAgIHRoaXMubWFnbmF0dWRlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSNCl7IC8vIEFmdGVyIHBlcmlvZFxuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIGlmIChuID49IDB4MzAgJiYgbiA8IDB4NDApIHsgLy8gMC05XG4gICAgICAgIHRoaXMubWFnbmF0dWRlICs9IHRoaXMucG9zaXRpb24gKiAobiAtIDB4MzApO1xuICAgICAgICB0aGlzLnBvc2l0aW9uIC89IDEwO1xuICAgICAgICB0aGlzLnRTdGF0ZSA9IE5VTUJFUjU7IFxuICAgICAgfSBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSNSl7IC8vICogQWZ0ZXIgZGlnaXQgKGFmdGVyIHBlcmlvZClcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICBpZiAobiA+PSAweDMwICYmIG4gPCAweDQwKSB7IC8vIDAtOVxuICAgICAgICB0aGlzLm1hZ25hdHVkZSArPSB0aGlzLnBvc2l0aW9uICogKG4gLSAweDMwKTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiAvPSAxMDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG4gPT09IDB4NjUgfHwgbiA9PT0gMHg0NSkgeyB0aGlzLmV4cG9uZW50ID0gMDsgdGhpcy50U3RhdGUgPSBOVU1CRVI2OyB9IC8vIEUvZVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMudFN0YXRlID0gU1RBUlQ7IFxuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSkge1xuICAgICAgICAgIHRoaXMubWFnbmF0dWRlID0gLXRoaXMubWFnbmF0dWRlO1xuICAgICAgICAgIHRoaXMubmVnYXRpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vblRva2VuKE5VTUJFUiwgdGhpcy5uZWdhdGl2ZSA/IC10aGlzLm1hZ25hdHVkZSA6IHRoaXMubWFnbmF0dWRlKTsgXG4gICAgICAgIHRoaXMubWFnbmF0dWRlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBpLS07IFxuICAgICAgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSNil7IC8vIEFmdGVyIEVcbiAgICAgIG4gPSBidWZmZXJbaV07XG4gICAgICBpZiAobiA9PT0gMHgyYiB8fCBuID09PSAweDJkKSB7IC8vICsvLVxuICAgICAgICBpZiAobiA9PT0gMHgyZCkgeyB0aGlzLm5lZ2F0aXZlRXhwb25lbnQgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMudFN0YXRlID0gTlVNQkVSNztcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG4gPj0gMHgzMCAmJiBuIDwgMHg0MCkge1xuICAgICAgICB0aGlzLmV4cG9uZW50ID0gdGhpcy5leHBvbmVudCAqIDEwICsgKG4gLSAweDMwKTtcbiAgICAgICAgdGhpcy50U3RhdGUgPSBOVU1CRVI4O1xuICAgICAgfVxuICAgICAgZWxzZSB7IHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH0gIFxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVNQkVSNyl7IC8vIEFmdGVyICsvLVxuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIGlmIChuID49IDB4MzAgJiYgbiA8IDB4NDApIHsgLy8gMC05XG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50ICogMTAgKyAobiAtIDB4MzApO1xuICAgICAgICB0aGlzLnRTdGF0ZSA9IE5VTUJFUjg7XG4gICAgICB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfSAgXG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVU1CRVI4KXsgLy8gKiBBZnRlciBkaWdpdCAoYWZ0ZXIgKy8tKVxuICAgICAgbiA9IGJ1ZmZlcltpXTtcbiAgICAgIGlmIChuID49IDB4MzAgJiYgbiA8IDB4NDApIHsgLy8gMC05XG4gICAgICAgIHRoaXMuZXhwb25lbnQgPSB0aGlzLmV4cG9uZW50ICogMTAgKyAobiAtIDB4MzApO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlRXhwb25lbnQpIHtcbiAgICAgICAgICB0aGlzLmV4cG9uZW50ID0gLXRoaXMuZXhwb25lbnQ7XG4gICAgICAgICAgdGhpcy5uZWdhdGl2ZUV4cG9uZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFnbmF0dWRlICo9IE1hdGgucG93KDEwLCB0aGlzLmV4cG9uZW50KTtcbiAgICAgICAgdGhpcy5leHBvbmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUpIHsgXG4gICAgICAgICAgdGhpcy5tYWduYXR1ZGUgPSAtdGhpcy5tYWduYXR1ZGU7XG4gICAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRTdGF0ZSA9IFNUQVJUO1xuICAgICAgICB0aGlzLm9uVG9rZW4oTlVNQkVSLCB0aGlzLm1hZ25hdHVkZSk7XG4gICAgICAgIHRoaXMubWFnbmF0dWRlID0gdW5kZWZpbmVkO1xuICAgICAgICBpLS07IFxuICAgICAgfSBcbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IFRSVUUxKXsgLy8gclxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg3MikgeyB0aGlzLnRTdGF0ZSA9IFRSVUUyOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gVFJVRTIpeyAvLyB1XG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDc1KSB7IHRoaXMudFN0YXRlID0gVFJVRTM7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBUUlVFMyl7IC8vIGVcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NjUpIHsgdGhpcy50U3RhdGUgPSBTVEFSVDsgdGhpcy5vblRva2VuKFRSVUUsIHRydWUpOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gRkFMU0UxKXsgLy8gYVxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg2MSkgeyB0aGlzLnRTdGF0ZSA9IEZBTFNFMjsgfVxuICAgICAgZWxzZSB7IHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IEZBTFNFMil7IC8vIGxcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NmMpIHsgdGhpcy50U3RhdGUgPSBGQUxTRTM7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBGQUxTRTMpeyAvLyBzXG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDczKSB7IHRoaXMudFN0YXRlID0gRkFMU0U0OyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gRkFMU0U0KXsgLy8gZVxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg2NSkgeyB0aGlzLnRTdGF0ZSA9IFNUQVJUOyB0aGlzLm9uVG9rZW4oRkFMU0UsIGZhbHNlKTsgfVxuICAgICAgZWxzZSB7IHRoaXMuY2hhckVycm9yKGJ1ZmZlciwgaSk7IH1cbiAgICB9ZWxzZSBpZiAodGhpcy50U3RhdGUgPT09IE5VTEwxKXsgLy8gdVxuICAgICAgaWYgKGJ1ZmZlcltpXSA9PT0gMHg3NSkgeyB0aGlzLnRTdGF0ZSA9IE5VTEwyOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1lbHNlIGlmICh0aGlzLnRTdGF0ZSA9PT0gTlVMTDIpeyAvLyBsXG4gICAgICBpZiAoYnVmZmVyW2ldID09PSAweDZjKSB7IHRoaXMudFN0YXRlID0gTlVMTDM7IH1cbiAgICAgIGVsc2UgeyB0aGlzLmNoYXJFcnJvcihidWZmZXIsIGkpOyB9XG4gICAgfWVsc2UgaWYgKHRoaXMudFN0YXRlID09PSBOVUxMMyl7IC8vIGxcbiAgICAgIGlmIChidWZmZXJbaV0gPT09IDB4NmMpIHsgdGhpcy50U3RhdGUgPSBTVEFSVDsgdGhpcy5vblRva2VuKE5VTEwsIG51bGwpOyB9XG4gICAgICBlbHNlIHsgdGhpcy5jaGFyRXJyb3IoYnVmZmVyLCBpKTsgfVxuICAgIH1cbiAgfVxufTtcbnByb3RvLm9uVG9rZW4gPSBmdW5jdGlvbiAodG9rZW4sIHZhbHVlKSB7XG4gIC8vIE92ZXJyaWRlIHRoaXMgdG8gZ2V0IGV2ZW50c1xufTtcblxucHJvdG8ucGFyc2VFcnJvciA9IGZ1bmN0aW9uICh0b2tlbiwgdmFsdWUpIHtcbiAgdGhpcy5vbkVycm9yKG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgXCIgKyB0b2tuYW0odG9rZW4pICsgKHZhbHVlID8gKFwiKFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgXCIpXCIpIDogXCJcIikgKyBcIiBpbiBzdGF0ZSBcIiArIHRva25hbSh0aGlzLnN0YXRlKSkpO1xufTtcbnByb3RvLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHRocm93IGVycjsgfTtcbnByb3RvLnB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc3RhY2sucHVzaCh7dmFsdWU6IHRoaXMudmFsdWUsIGtleTogdGhpcy5rZXksIG1vZGU6IHRoaXMubW9kZX0pO1xufTtcbnByb3RvLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZhbHVlID0gdGhpcy52YWx1ZTtcbiAgdmFyIHBhcmVudCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gIHRoaXMudmFsdWUgPSBwYXJlbnQudmFsdWU7XG4gIHRoaXMua2V5ID0gcGFyZW50LmtleTtcbiAgdGhpcy5tb2RlID0gcGFyZW50Lm1vZGU7XG4gIHRoaXMuZW1pdCh2YWx1ZSk7XG4gIGlmICghdGhpcy5tb2RlKSB7IHRoaXMuc3RhdGUgPSBWQUxVRTsgfVxufTtcbnByb3RvLmVtaXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHRoaXMubW9kZSkgeyB0aGlzLnN0YXRlID0gQ09NTUE7IH1cbiAgdGhpcy5vblZhbHVlKHZhbHVlKTtcbn07XG5wcm90by5vblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIC8vIE92ZXJyaWRlIG1lXG59OyAgXG5wcm90by5vblRva2VuID0gZnVuY3Rpb24gKHRva2VuLCB2YWx1ZSkge1xuICAvL2NvbnNvbGUubG9nKFwiT25Ub2tlbjogc3RhdGU9JXMgdG9rZW49JXMgJXNcIiwgdG9rbmFtKHRoaXMuc3RhdGUpLCB0b2tuYW0odG9rZW4pLCB2YWx1ZT9KU09OLnN0cmluZ2lmeSh2YWx1ZSk6XCJcIik7XG4gIGlmKHRoaXMuc3RhdGUgPT09IFZBTFVFKXtcbiAgICBpZih0b2tlbiA9PT0gU1RSSU5HIHx8IHRva2VuID09PSBOVU1CRVIgfHwgdG9rZW4gPT09IFRSVUUgfHwgdG9rZW4gPT09IEZBTFNFIHx8IHRva2VuID09PSBOVUxMKXtcbiAgICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFsdWVbdGhpcy5rZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQodmFsdWUpOyAgXG4gICAgfWVsc2UgaWYodG9rZW4gPT09IExFRlRfQlJBQ0Upe1xuICAgICAgdGhpcy5wdXNoKCk7XG4gICAgICBpZiAodGhpcy52YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVt0aGlzLmtleV0gPSB7fTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB7fTtcbiAgICAgIH1cbiAgICAgIHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5zdGF0ZSA9IEtFWTtcbiAgICAgIHRoaXMubW9kZSA9IE9CSkVDVDtcbiAgICB9ZWxzZSBpZih0b2tlbiA9PT0gTEVGVF9CUkFDS0VUKXtcbiAgICAgIHRoaXMucHVzaCgpO1xuICAgICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWVbdGhpcy5rZXldID0gW107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmtleSA9IDA7XG4gICAgICB0aGlzLm1vZGUgPSBBUlJBWTtcbiAgICAgIHRoaXMuc3RhdGUgPSBWQUxVRTtcbiAgICB9ZWxzZSBpZih0b2tlbiA9PT0gUklHSFRfQlJBQ0Upe1xuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gT0JKRUNUKSB7XG4gICAgICAgIHRoaXMucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9ZWxzZSBpZih0b2tlbiA9PT0gUklHSFRfQlJBQ0tFVCl7XG4gICAgICBpZiAodGhpcy5tb2RlID09PSBBUlJBWSkge1xuICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yKHRva2VuLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWVsc2V7XG4gICAgICB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICB9XG4gIH1lbHNlIGlmKHRoaXMuc3RhdGUgPT09IEtFWSl7XG4gICAgaWYgKHRva2VuID09PSBTVFJJTkcpIHtcbiAgICAgIHRoaXMua2V5ID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YXRlID0gQ09MT047XG4gICAgfSBlbHNlIGlmICh0b2tlbiA9PT0gUklHSFRfQlJBQ0UpIHtcbiAgICAgIHRoaXMucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpO1xuICAgIH1cbiAgfWVsc2UgaWYodGhpcy5zdGF0ZSA9PT0gQ09MT04pe1xuICAgIGlmICh0b2tlbiA9PT0gQ09MT04pIHsgdGhpcy5zdGF0ZSA9IFZBTFVFOyB9XG4gICAgZWxzZSB7IHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpOyB9XG4gIH1lbHNlIGlmKHRoaXMuc3RhdGUgPT09IENPTU1BKXtcbiAgICBpZiAodG9rZW4gPT09IENPTU1BKSB7IFxuICAgICAgaWYgKHRoaXMubW9kZSA9PT0gQVJSQVkpIHsgdGhpcy5rZXkrKzsgdGhpcy5zdGF0ZSA9IFZBTFVFOyB9XG4gICAgICBlbHNlIGlmICh0aGlzLm1vZGUgPT09IE9CSkVDVCkgeyB0aGlzLnN0YXRlID0gS0VZOyB9XG5cbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSBSSUdIVF9CUkFDS0VUICYmIHRoaXMubW9kZSA9PT0gQVJSQVkgfHwgdG9rZW4gPT09IFJJR0hUX0JSQUNFICYmIHRoaXMubW9kZSA9PT0gT0JKRUNUKSB7XG4gICAgICB0aGlzLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhcnNlRXJyb3IodG9rZW4sIHZhbHVlKTtcbiAgICB9XG4gIH1lbHNle1xuICAgIHRoaXMucGFyc2VFcnJvcih0b2tlbiwgdmFsdWUpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlcjtcblxufSkuY2FsbCh0aGlzLF9kZXJlcV8oXCJidWZmZXJcIikuQnVmZmVyKVxufSx7XCJidWZmZXJcIjoyM31dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogU3RhbmRhbG9uZSBleHRyYWN0aW9uIG9mIEJhY2tib25lLkV2ZW50cywgbm8gZXh0ZXJuYWwgZGVwZW5kZW5jeSByZXF1aXJlZC5cbiAqIERlZ3JhZGVzIG5pY2VseSB3aGVuIEJhY2tvbmUvdW5kZXJzY29yZSBhcmUgYWxyZWFkeSBhdmFpbGFibGUgaW4gdGhlIGN1cnJlbnRcbiAqIGdsb2JhbCBjb250ZXh0LlxuICpcbiAqIE5vdGUgdGhhdCBkb2NzIHN1Z2dlc3QgdG8gdXNlIHVuZGVyc2NvcmUncyBgXy5leHRlbmQoKWAgbWV0aG9kIHRvIGFkZCBFdmVudHNcbiAqIHN1cHBvcnQgdG8gc29tZSBnaXZlbiBvYmplY3QuIEEgYG1peGluKClgIG1ldGhvZCBoYXMgYmVlbiBhZGRlZCB0byB0aGUgRXZlbnRzXG4gKiBwcm90b3R5cGUgdG8gYXZvaWQgdXNpbmcgdW5kZXJzY29yZSBmb3IgdGhhdCBzb2xlIHB1cnBvc2U6XG4gKlxuICogICAgIHZhciBteUV2ZW50RW1pdHRlciA9IEJhY2tib25lRXZlbnRzLm1peGluKHt9KTtcbiAqXG4gKiBPciBmb3IgYSBmdW5jdGlvbiBjb25zdHJ1Y3RvcjpcbiAqXG4gKiAgICAgZnVuY3Rpb24gTXlDb25zdHJ1Y3Rvcigpe31cbiAqICAgICBNeUNvbnN0cnVjdG9yLnByb3RvdHlwZS5mb28gPSBmdW5jdGlvbigpe31cbiAqICAgICBCYWNrYm9uZUV2ZW50cy5taXhpbihNeUNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gKlxuICogKGMpIDIwMDktMjAxMyBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgSW5jLlxuICogKGMpIDIwMTMgTmljb2xhcyBQZXJyaWF1bHRcbiAqL1xuLyogZ2xvYmFsIGV4cG9ydHM6dHJ1ZSwgZGVmaW5lLCBtb2R1bGUgKi9cbihmdW5jdGlvbigpIHtcbiAgdmFyIHJvb3QgPSB0aGlzLFxuICAgICAgYnJlYWtlciA9IHt9LFxuICAgICAgbmF0aXZlRm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLFxuICAgICAgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgICAgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG4gICAgICBpZENvdW50ZXIgPSAwO1xuXG4gIC8vIFJldHVybnMgYSBwYXJ0aWFsIGltcGxlbWVudGF0aW9uIG1hdGNoaW5nIHRoZSBtaW5pbWFsIEFQSSBzdWJzZXQgcmVxdWlyZWRcbiAgLy8gYnkgQmFja2JvbmUuRXZlbnRzXG4gIGZ1bmN0aW9uIG1pbmlzY29yZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImtleXMoKSBjYWxsZWQgb24gYSBub24tb2JqZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXksIGtleXMgPSBbXTtcbiAgICAgICAgZm9yIChrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICBrZXlzW2tleXMubGVuZ3RoXSA9IGtleTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9LFxuXG4gICAgICB1bmlxdWVJZDogZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICAgICAgfSxcblxuICAgICAgaGFzOiBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gICAgICB9LFxuXG4gICAgICBlYWNoOiBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuO1xuICAgICAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgb25jZTogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICB2YXIgcmFuID0gZmFsc2UsIG1lbW87XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAocmFuKSByZXR1cm4gbWVtbztcbiAgICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZnVuYyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBfID0gbWluaXNjb3JlKCksIEV2ZW50cztcblxuICAvLyBCYWNrYm9uZS5FdmVudHNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gQSBtb2R1bGUgdGhhdCBjYW4gYmUgbWl4ZWQgaW4gdG8gKmFueSBvYmplY3QqIGluIG9yZGVyIHRvIHByb3ZpZGUgaXQgd2l0aFxuICAvLyBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgd2l0aCBgb25gIG9yIHJlbW92ZSB3aXRoIGBvZmZgIGNhbGxiYWNrXG4gIC8vIGZ1bmN0aW9ucyB0byBhbiBldmVudDsgYHRyaWdnZXJgLWluZyBhbiBldmVudCBmaXJlcyBhbGwgY2FsbGJhY2tzIGluXG4gIC8vIHN1Y2Nlc3Npb24uXG4gIC8vXG4gIC8vICAgICB2YXIgb2JqZWN0ID0ge307XG4gIC8vICAgICBfLmV4dGVuZChvYmplY3QsIEJhY2tib25lLkV2ZW50cyk7XG4gIC8vICAgICBvYmplY3Qub24oJ2V4cGFuZCcsIGZ1bmN0aW9uKCl7IGFsZXJ0KCdleHBhbmRlZCcpOyB9KTtcbiAgLy8gICAgIG9iamVjdC50cmlnZ2VyKCdleHBhbmQnKTtcbiAgLy9cbiAgRXZlbnRzID0ge1xuXG4gICAgLy8gQmluZCBhbiBldmVudCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uIFBhc3NpbmcgYFwiYWxsXCJgIHdpbGwgYmluZFxuICAgIC8vIHRoZSBjYWxsYmFjayB0byBhbGwgZXZlbnRzIGZpcmVkLlxuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkgfHwgIWNhbGxiYWNrKSByZXR1cm4gdGhpcztcbiAgICAgIHRoaXMuX2V2ZW50cyB8fCAodGhpcy5fZXZlbnRzID0ge30pO1xuICAgICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1tuYW1lXSB8fCAodGhpcy5fZXZlbnRzW25hbWVdID0gW10pO1xuICAgICAgZXZlbnRzLnB1c2goe2NhbGxiYWNrOiBjYWxsYmFjaywgY29udGV4dDogY29udGV4dCwgY3R4OiBjb250ZXh0IHx8IHRoaXN9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBCaW5kIGFuIGV2ZW50IHRvIG9ubHkgYmUgdHJpZ2dlcmVkIGEgc2luZ2xlIHRpbWUuIEFmdGVyIHRoZSBmaXJzdCB0aW1lXG4gICAgLy8gdGhlIGNhbGxiYWNrIGlzIGludm9rZWQsIGl0IHdpbGwgYmUgcmVtb3ZlZC5cbiAgICBvbmNlOiBmdW5jdGlvbihuYW1lLCBjYWxsYmFjaywgY29udGV4dCkge1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ29uY2UnLCBuYW1lLCBbY2FsbGJhY2ssIGNvbnRleHRdKSB8fCAhY2FsbGJhY2spIHJldHVybiB0aGlzO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIG9uY2UgPSBfLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYub2ZmKG5hbWUsIG9uY2UpO1xuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG4gICAgICBvbmNlLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgcmV0dXJuIHRoaXMub24obmFtZSwgb25jZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8vIFJlbW92ZSBvbmUgb3IgbWFueSBjYWxsYmFja3MuIElmIGBjb250ZXh0YCBpcyBudWxsLCByZW1vdmVzIGFsbFxuICAgIC8vIGNhbGxiYWNrcyB3aXRoIHRoYXQgZnVuY3Rpb24uIElmIGBjYWxsYmFja2AgaXMgbnVsbCwgcmVtb3ZlcyBhbGxcbiAgICAvLyBjYWxsYmFja3MgZm9yIHRoZSBldmVudC4gSWYgYG5hbWVgIGlzIG51bGwsIHJlbW92ZXMgYWxsIGJvdW5kXG4gICAgLy8gY2FsbGJhY2tzIGZvciBhbGwgZXZlbnRzLlxuICAgIG9mZjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXRhaW4sIGV2LCBldmVudHMsIG5hbWVzLCBpLCBsLCBqLCBrO1xuICAgICAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIWV2ZW50c0FwaSh0aGlzLCAnb2ZmJywgbmFtZSwgW2NhbGxiYWNrLCBjb250ZXh0XSkpIHJldHVybiB0aGlzO1xuICAgICAgaWYgKCFuYW1lICYmICFjYWxsYmFjayAmJiAhY29udGV4dCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzID0gbmFtZSA/IFtuYW1lXSA6IF8ua2V5cyh0aGlzLl9ldmVudHMpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IG5hbWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIGlmIChldmVudHMgPSB0aGlzLl9ldmVudHNbbmFtZV0pIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHNbbmFtZV0gPSByZXRhaW4gPSBbXTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2sgfHwgY29udGV4dCkge1xuICAgICAgICAgICAgZm9yIChqID0gMCwgayA9IGV2ZW50cy5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgICAgZXYgPSBldmVudHNbal07XG4gICAgICAgICAgICAgIGlmICgoY2FsbGJhY2sgJiYgY2FsbGJhY2sgIT09IGV2LmNhbGxiYWNrICYmIGNhbGxiYWNrICE9PSBldi5jYWxsYmFjay5fY2FsbGJhY2spIHx8XG4gICAgICAgICAgICAgICAgICAoY29udGV4dCAmJiBjb250ZXh0ICE9PSBldi5jb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIHJldGFpbi5wdXNoKGV2KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJldGFpbi5sZW5ndGgpIGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgIC8vIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgLy8gKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gICAgLy8gcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgaWYgKCFldmVudHNBcGkodGhpcywgJ3RyaWdnZXInLCBuYW1lLCBhcmdzKSkgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzW25hbWVdO1xuICAgICAgdmFyIGFsbEV2ZW50cyA9IHRoaXMuX2V2ZW50cy5hbGw7XG4gICAgICBpZiAoZXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGV2ZW50cywgYXJncyk7XG4gICAgICBpZiAoYWxsRXZlbnRzKSB0cmlnZ2VyRXZlbnRzKGFsbEV2ZW50cywgYXJndW1lbnRzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZWxsIHRoaXMgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGVpdGhlciBzcGVjaWZpYyBldmVudHMgLi4uIG9yXG4gICAgLy8gdG8gZXZlcnkgb2JqZWN0IGl0J3MgY3VycmVudGx5IGxpc3RlbmluZyB0by5cbiAgICBzdG9wTGlzdGVuaW5nOiBmdW5jdGlvbihvYmosIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzO1xuICAgICAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiB0aGlzO1xuICAgICAgdmFyIGRlbGV0ZUxpc3RlbmVyID0gIW5hbWUgJiYgIWNhbGxiYWNrO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JykgY2FsbGJhY2sgPSB0aGlzO1xuICAgICAgaWYgKG9iaikgKGxpc3RlbmVycyA9IHt9KVtvYmouX2xpc3RlbmVySWRdID0gb2JqO1xuICAgICAgZm9yICh2YXIgaWQgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpZF0ub2ZmKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgICAgaWYgKGRlbGV0ZUxpc3RlbmVyKSBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW2lkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICB9O1xuXG4gIC8vIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIHRvIHNwbGl0IGV2ZW50IHN0cmluZ3MuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuXG4gIC8vIEltcGxlbWVudCBmYW5jeSBmZWF0dXJlcyBvZiB0aGUgRXZlbnRzIEFQSSBzdWNoIGFzIG11bHRpcGxlIGV2ZW50XG4gIC8vIG5hbWVzIGBcImNoYW5nZSBibHVyXCJgIGFuZCBqUXVlcnktc3R5bGUgZXZlbnQgbWFwcyBge2NoYW5nZTogYWN0aW9ufWBcbiAgLy8gaW4gdGVybXMgb2YgdGhlIGV4aXN0aW5nIEFQSS5cbiAgdmFyIGV2ZW50c0FwaSA9IGZ1bmN0aW9uKG9iaiwgYWN0aW9uLCBuYW1lLCByZXN0KSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIEhhbmRsZSBldmVudCBtYXBzLlxuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW2tleSwgbmFtZVtrZXldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBzcGFjZSBzZXBhcmF0ZWQgZXZlbnQgbmFtZXMuXG4gICAgaWYgKGV2ZW50U3BsaXR0ZXIudGVzdChuYW1lKSkge1xuICAgICAgdmFyIG5hbWVzID0gbmFtZS5zcGxpdChldmVudFNwbGl0dGVyKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG9ialthY3Rpb25dLmFwcGx5KG9iaiwgW25hbWVzW2ldXS5jb25jYXQocmVzdCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIEEgZGlmZmljdWx0LXRvLWJlbGlldmUsIGJ1dCBvcHRpbWl6ZWQgaW50ZXJuYWwgZGlzcGF0Y2ggZnVuY3Rpb24gZm9yXG4gIC8vIHRyaWdnZXJpbmcgZXZlbnRzLiBUcmllcyB0byBrZWVwIHRoZSB1c3VhbCBjYXNlcyBzcGVlZHkgKG1vc3QgaW50ZXJuYWxcbiAgLy8gQmFja2JvbmUgZXZlbnRzIGhhdmUgMyBhcmd1bWVudHMpLlxuICB2YXIgdHJpZ2dlckV2ZW50cyA9IGZ1bmN0aW9uKGV2ZW50cywgYXJncykge1xuICAgIHZhciBldiwgaSA9IC0xLCBsID0gZXZlbnRzLmxlbmd0aCwgYTEgPSBhcmdzWzBdLCBhMiA9IGFyZ3NbMV0sIGEzID0gYXJnc1syXTtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4KTsgcmV0dXJuO1xuICAgICAgY2FzZSAxOiB3aGlsZSAoKytpIDwgbCkgKGV2ID0gZXZlbnRzW2ldKS5jYWxsYmFjay5jYWxsKGV2LmN0eCwgYTEpOyByZXR1cm47XG4gICAgICBjYXNlIDI6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIpOyByZXR1cm47XG4gICAgICBjYXNlIDM6IHdoaWxlICgrK2kgPCBsKSAoZXYgPSBldmVudHNbaV0pLmNhbGxiYWNrLmNhbGwoZXYuY3R4LCBhMSwgYTIsIGEzKTsgcmV0dXJuO1xuICAgICAgZGVmYXVsdDogd2hpbGUgKCsraSA8IGwpIChldiA9IGV2ZW50c1tpXSkuY2FsbGJhY2suYXBwbHkoZXYuY3R4LCBhcmdzKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGxpc3Rlbk1ldGhvZHMgPSB7bGlzdGVuVG86ICdvbicsIGxpc3RlblRvT25jZTogJ29uY2UnfTtcblxuICAvLyBJbnZlcnNpb24tb2YtY29udHJvbCB2ZXJzaW9ucyBvZiBgb25gIGFuZCBgb25jZWAuIFRlbGwgKnRoaXMqIG9iamVjdCB0b1xuICAvLyBsaXN0ZW4gdG8gYW4gZXZlbnQgaW4gYW5vdGhlciBvYmplY3QgLi4uIGtlZXBpbmcgdHJhY2sgb2Ygd2hhdCBpdCdzXG4gIC8vIGxpc3RlbmluZyB0by5cbiAgXy5lYWNoKGxpc3Rlbk1ldGhvZHMsIGZ1bmN0aW9uKGltcGxlbWVudGF0aW9uLCBtZXRob2QpIHtcbiAgICBFdmVudHNbbWV0aG9kXSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IHt9KTtcbiAgICAgIHZhciBpZCA9IG9iai5fbGlzdGVuZXJJZCB8fCAob2JqLl9saXN0ZW5lcklkID0gXy51bmlxdWVJZCgnbCcpKTtcbiAgICAgIGxpc3RlbmVyc1tpZF0gPSBvYmo7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSBjYWxsYmFjayA9IHRoaXM7XG4gICAgICBvYmpbaW1wbGVtZW50YXRpb25dKG5hbWUsIGNhbGxiYWNrLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFsaWFzZXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBFdmVudHMuYmluZCAgID0gRXZlbnRzLm9uO1xuICBFdmVudHMudW5iaW5kID0gRXZlbnRzLm9mZjtcblxuICAvLyBNaXhpbiB1dGlsaXR5XG4gIEV2ZW50cy5taXhpbiA9IGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgdmFyIGV4cG9ydHMgPSBbJ29uJywgJ29uY2UnLCAnb2ZmJywgJ3RyaWdnZXInLCAnc3RvcExpc3RlbmluZycsICdsaXN0ZW5UbycsXG4gICAgICAgICAgICAgICAgICAgJ2xpc3RlblRvT25jZScsICdiaW5kJywgJ3VuYmluZCddO1xuICAgIF8uZWFjaChleHBvcnRzLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICBwcm90b1tuYW1lXSA9IHRoaXNbbmFtZV07XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHByb3RvO1xuICB9O1xuXG4gIC8vIEV4cG9ydCBFdmVudHMgYXMgQmFja2JvbmVFdmVudHMgZGVwZW5kaW5nIG9uIGN1cnJlbnQgY29udGV4dFxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEV2ZW50cztcbiAgICB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50cztcbiAgICB9XG4gICAgZXhwb3J0cy5CYWNrYm9uZUV2ZW50cyA9IEV2ZW50cztcbiAgfSBlbHNlIHtcbiAgICByb290LkJhY2tib25lRXZlbnRzID0gRXZlbnRzO1xuICB9XG59KSh0aGlzKTtcblxufSx7fV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSBfZGVyZXFfKCcuL2JhY2tib25lLWV2ZW50cy1zdGFuZGFsb25lJyk7XG5cbn0se1wiLi9iYWNrYm9uZS1ldmVudHMtc3RhbmRhbG9uZVwiOjIwfV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4vKiFcbiAqIEBvdmVydmlldyBlczYtcHJvbWlzZSAtIGEgdGlueSBpbXBsZW1lbnRhdGlvbiBvZiBQcm9taXNlcy9BKy5cbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IChjKSAyMDE0IFllaHVkYSBLYXR6LCBUb20gRGFsZSwgU3RlZmFuIFBlbm5lciBhbmQgY29udHJpYnV0b3JzIChDb252ZXJzaW9uIHRvIEVTNiBBUEkgYnkgSmFrZSBBcmNoaWJhbGQpXG4gKiBAbGljZW5zZSAgIExpY2Vuc2VkIHVuZGVyIE1JVCBsaWNlbnNlXG4gKiAgICAgICAgICAgIFNlZSBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vamFrZWFyY2hpYmFsZC9lczYtcHJvbWlzZS9tYXN0ZXIvTElDRU5TRVxuICogQHZlcnNpb24gICAyLjAuMVxuICovXG5cbihmdW5jdGlvbigpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGZ1bmN0aW9uICQkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCR1dGlscyQkaXNGdW5jdGlvbih4KSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCR1dGlscyQkaXNNYXliZVRoZW5hYmxlKHgpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgJCR1dGlscyQkX2lzQXJyYXk7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkpIHtcbiAgICAgICQkdXRpbHMkJF9pc0FycmF5ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICQkdXRpbHMkJF9pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbiAgICB9XG5cbiAgICB2YXIgJCR1dGlscyQkaXNBcnJheSA9ICQkdXRpbHMkJF9pc0FycmF5O1xuICAgIHZhciAkJHV0aWxzJCRub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpOyB9O1xuICAgIGZ1bmN0aW9uICQkdXRpbHMkJEYoKSB7IH1cblxuICAgIHZhciAkJHV0aWxzJCRvX2NyZWF0ZSA9IChPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZWNvbmQgYXJndW1lbnQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgfVxuICAgICAgJCR1dGlscyQkRi5wcm90b3R5cGUgPSBvO1xuICAgICAgcmV0dXJuIG5ldyAkJHV0aWxzJCRGKCk7XG4gICAgfSk7XG5cbiAgICB2YXIgJCRhc2FwJCRsZW4gPSAwO1xuXG4gICAgdmFyICQkYXNhcCQkZGVmYXVsdCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICAgICAgJCRhc2FwJCRxdWV1ZVskJGFzYXAkJGxlbl0gPSBjYWxsYmFjaztcbiAgICAgICQkYXNhcCQkcXVldWVbJCRhc2FwJCRsZW4gKyAxXSA9IGFyZztcbiAgICAgICQkYXNhcCQkbGVuICs9IDI7XG4gICAgICBpZiAoJCRhc2FwJCRsZW4gPT09IDIpIHtcbiAgICAgICAgLy8gSWYgbGVuIGlzIDEsIHRoYXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGFzeW5jIGZsdXNoLlxuICAgICAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgICAgICAvLyB3aWxsIGJlIHByb2Nlc3NlZCBieSB0aGlzIGZsdXNoIHRoYXQgd2UgYXJlIHNjaGVkdWxpbmcuXG4gICAgICAgICQkYXNhcCQkc2NoZWR1bGVGbHVzaCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgJCRhc2FwJCRicm93c2VyR2xvYmFsID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSA/IHdpbmRvdyA6IHt9O1xuICAgIHZhciAkJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gJCRhc2FwJCRicm93c2VyR2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgJCRhc2FwJCRicm93c2VyR2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbiAgICAvLyB0ZXN0IGZvciB3ZWIgd29ya2VyIGJ1dCBub3QgaW4gSUUxMFxuICAgIHZhciAkJGFzYXAkJGlzV29ya2VyID0gdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgLy8gbm9kZVxuICAgIGZ1bmN0aW9uICQkYXNhcCQkdXNlTmV4dFRpY2soKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soJCRhc2FwJCRmbHVzaCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkYXNhcCQkdXNlTXV0YXRpb25PYnNlcnZlcigpIHtcbiAgICAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgICAgIHZhciBvYnNlcnZlciA9IG5ldyAkJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKCQkYXNhcCQkZmx1c2gpO1xuICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHsgY2hhcmFjdGVyRGF0YTogdHJ1ZSB9KTtcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBub2RlLmRhdGEgPSAoaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDIpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyB3ZWIgd29ya2VyXG4gICAgZnVuY3Rpb24gJCRhc2FwJCR1c2VNZXNzYWdlQ2hhbm5lbCgpIHtcbiAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9ICQkYXNhcCQkZmx1c2g7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJGFzYXAkJHVzZVNldFRpbWVvdXQoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRpbWVvdXQoJCRhc2FwJCRmbHVzaCwgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciAkJGFzYXAkJHF1ZXVlID0gbmV3IEFycmF5KDEwMDApO1xuXG4gICAgZnVuY3Rpb24gJCRhc2FwJCRmbHVzaCgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJCRhc2FwJCRsZW47IGkrPTIpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gJCRhc2FwJCRxdWV1ZVtpXTtcbiAgICAgICAgdmFyIGFyZyA9ICQkYXNhcCQkcXVldWVbaSsxXTtcblxuICAgICAgICBjYWxsYmFjayhhcmcpO1xuXG4gICAgICAgICQkYXNhcCQkcXVldWVbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICQkYXNhcCQkcXVldWVbaSsxXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgJCRhc2FwJCRsZW4gPSAwO1xuICAgIH1cblxuICAgIHZhciAkJGFzYXAkJHNjaGVkdWxlRmx1c2g7XG5cbiAgICAvLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuICAgIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYge30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgICAkJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSAkJGFzYXAkJHVzZU5leHRUaWNrKCk7XG4gICAgfSBlbHNlIGlmICgkJGFzYXAkJEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICAkJGFzYXAkJHNjaGVkdWxlRmx1c2ggPSAkJGFzYXAkJHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbiAgICB9IGVsc2UgaWYgKCQkYXNhcCQkaXNXb3JrZXIpIHtcbiAgICAgICQkYXNhcCQkc2NoZWR1bGVGbHVzaCA9ICQkYXNhcCQkdXNlTWVzc2FnZUNoYW5uZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCRhc2FwJCRzY2hlZHVsZUZsdXNoID0gJCRhc2FwJCR1c2VTZXRUaW1lb3V0KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJG5vb3AoKSB7fVxuICAgIHZhciAkJCRpbnRlcm5hbCQkUEVORElORyAgID0gdm9pZCAwO1xuICAgIHZhciAkJCRpbnRlcm5hbCQkRlVMRklMTEVEID0gMTtcbiAgICB2YXIgJCQkaW50ZXJuYWwkJFJFSkVDVEVEICA9IDI7XG4gICAgdmFyICQkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUiA9IG5ldyAkJCRpbnRlcm5hbCQkRXJyb3JPYmplY3QoKTtcblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRzZWxmRnVsbGZpbGxtZW50KCkge1xuICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRjYW5ub3RSZXR1cm5Pd24oKSB7XG4gICAgICByZXR1cm4gbmV3IFR5cGVFcnJvcignQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLicpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJGdldFRoZW4ocHJvbWlzZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudGhlbjtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJEdFVF9USEVOX0VSUk9SLmVycm9yID0gZXJyb3I7XG4gICAgICAgIHJldHVybiAkJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1I7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJHRyeVRoZW4odGhlbiwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhlbi5jYWxsKHZhbHVlLCBmdWxmaWxsbWVudEhhbmRsZXIsIHJlamVjdGlvbkhhbmRsZXIpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgdGhlbmFibGUsIHRoZW4pIHtcbiAgICAgICAkJGFzYXAkJGRlZmF1bHQoZnVuY3Rpb24ocHJvbWlzZSkge1xuICAgICAgICB2YXIgc2VhbGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBlcnJvciA9ICQkJGludGVybmFsJCR0cnlUaGVuKHRoZW4sIHRoZW5hYmxlLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhlbmFibGUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAkJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAgIGlmIChzZWFsZWQpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgICAgICBpZiAoIXNlYWxlZCAmJiBlcnJvcikge1xuICAgICAgICAgIHNlYWxlZCA9IHRydWU7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH0sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICAgICAgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gJCQkaW50ZXJuYWwkJEZVTEZJTExFRCkge1xuICAgICAgICAkJCRpbnRlcm5hbCQkZnVsZmlsbChwcm9taXNlLCB0aGVuYWJsZS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAocHJvbWlzZS5fc3RhdGUgPT09ICQkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHN1YnNjcmliZSh0aGVuYWJsZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICQkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBtYXliZVRoZW5hYmxlKSB7XG4gICAgICBpZiAobWF5YmVUaGVuYWJsZS5jb25zdHJ1Y3RvciA9PT0gcHJvbWlzZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAkJCRpbnRlcm5hbCQkaGFuZGxlT3duVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdGhlbiA9ICQkJGludGVybmFsJCRnZXRUaGVuKG1heWJlVGhlbmFibGUpO1xuXG4gICAgICAgIGlmICh0aGVuID09PSAkJCRpbnRlcm5hbCQkR0VUX1RIRU5fRVJST1IpIHtcbiAgICAgICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsICQkJGludGVybmFsJCRHRVRfVEhFTl9FUlJPUi5lcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAodGhlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoJCR1dGlscyQkaXNGdW5jdGlvbih0aGVuKSkge1xuICAgICAgICAgICQkJGludGVybmFsJCRoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSkge1xuICAgICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgJCQkaW50ZXJuYWwkJHNlbGZGdWxsZmlsbG1lbnQoKSk7XG4gICAgICB9IGVsc2UgaWYgKCQkdXRpbHMkJG9iamVjdE9yRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgICQkJGludGVybmFsJCRoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICQkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fb25lcnJvcikge1xuICAgICAgICBwcm9taXNlLl9vbmVycm9yKHByb21pc2UuX3Jlc3VsdCk7XG4gICAgICB9XG5cbiAgICAgICQkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHZhbHVlKSB7XG4gICAgICBpZiAocHJvbWlzZS5fc3RhdGUgIT09ICQkJGludGVybmFsJCRQRU5ESU5HKSB7IHJldHVybjsgfVxuXG4gICAgICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgICAgIHByb21pc2UuX3N0YXRlID0gJCQkaW50ZXJuYWwkJEZVTEZJTExFRDtcblxuICAgICAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCRhc2FwJCRkZWZhdWx0KCQkJGludGVybmFsJCRwdWJsaXNoLCBwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICAgICAgaWYgKHByb21pc2UuX3N0YXRlICE9PSAkJCRpbnRlcm5hbCQkUEVORElORykgeyByZXR1cm47IH1cbiAgICAgIHByb21pc2UuX3N0YXRlID0gJCQkaW50ZXJuYWwkJFJFSkVDVEVEO1xuICAgICAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gICAgICAkJGFzYXAkJGRlZmF1bHQoJCQkaW50ZXJuYWwkJHB1Ymxpc2hSZWplY3Rpb24sIHByb21pc2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRzdWJzY3JpYmUocGFyZW50LCBjaGlsZCwgb25GdWxmaWxsbWVudCwgb25SZWplY3Rpb24pIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHBhcmVudC5fc3Vic2NyaWJlcnM7XG4gICAgICB2YXIgbGVuZ3RoID0gc3Vic2NyaWJlcnMubGVuZ3RoO1xuXG4gICAgICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyAkJCRpbnRlcm5hbCQkRlVMRklMTEVEXSA9IG9uRnVsZmlsbG1lbnQ7XG4gICAgICBzdWJzY3JpYmVyc1tsZW5ndGggKyAkJCRpbnRlcm5hbCQkUkVKRUNURURdICA9IG9uUmVqZWN0aW9uO1xuXG4gICAgICBpZiAobGVuZ3RoID09PSAwICYmIHBhcmVudC5fc3RhdGUpIHtcbiAgICAgICAgJCRhc2FwJCRkZWZhdWx0KCQkJGludGVybmFsJCRwdWJsaXNoLCBwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRwdWJsaXNoKHByb21pc2UpIHtcbiAgICAgIHZhciBzdWJzY3JpYmVycyA9IHByb21pc2UuX3N1YnNjcmliZXJzO1xuICAgICAgdmFyIHNldHRsZWQgPSBwcm9taXNlLl9zdGF0ZTtcblxuICAgICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm47IH1cblxuICAgICAgdmFyIGNoaWxkLCBjYWxsYmFjaywgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIGNoaWxkID0gc3Vic2NyaWJlcnNbaV07XG4gICAgICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgICAgIGlmIChjaGlsZCkge1xuICAgICAgICAgICQkJGludGVybmFsJCRpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FsbGJhY2soZGV0YWlsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcm9taXNlLl9zdWJzY3JpYmVycy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uICQkJGludGVybmFsJCRFcnJvck9iamVjdCgpIHtcbiAgICAgIHRoaXMuZXJyb3IgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciAkJCRpbnRlcm5hbCQkVFJZX0NBVENIX0VSUk9SID0gbmV3ICQkJGludGVybmFsJCRFcnJvck9iamVjdCgpO1xuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhkZXRhaWwpO1xuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICQkJGludGVybmFsJCRUUllfQ0FUQ0hfRVJST1IuZXJyb3IgPSBlO1xuICAgICAgICByZXR1cm4gJCQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICAgICAgdmFyIGhhc0NhbGxiYWNrID0gJCR1dGlscyQkaXNGdW5jdGlvbihjYWxsYmFjayksXG4gICAgICAgICAgdmFsdWUsIGVycm9yLCBzdWNjZWVkZWQsIGZhaWxlZDtcblxuICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgIHZhbHVlID0gJCQkaW50ZXJuYWwkJHRyeUNhdGNoKGNhbGxiYWNrLCBkZXRhaWwpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJCQkaW50ZXJuYWwkJFRSWV9DQVRDSF9FUlJPUikge1xuICAgICAgICAgIGZhaWxlZCA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSB2YWx1ZS5lcnJvcjtcbiAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3VjY2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgJCQkaW50ZXJuYWwkJGNhbm5vdFJldHVybk93bigpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBkZXRhaWw7XG4gICAgICAgIHN1Y2NlZWRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gJCQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgICAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChmYWlsZWQpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKHNldHRsZWQgPT09ICQkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChzZXR0bGVkID09PSAkJCRpbnRlcm5hbCQkUkVKRUNURUQpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCQkaW50ZXJuYWwkJGluaXRpYWxpemVQcm9taXNlKHByb21pc2UsIHJlc29sdmVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSl7XG4gICAgICAgICAgJCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbiByZWplY3RQcm9taXNlKHJlYXNvbikge1xuICAgICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRlbnVtZXJhdG9yJCRtYWtlU2V0dGxlZFJlc3VsdChzdGF0ZSwgcG9zaXRpb24sIHZhbHVlKSB7XG4gICAgICBpZiAoc3RhdGUgPT09ICQkJGludGVybmFsJCRGVUxGSUxMRUQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdGF0ZTogJ2Z1bGZpbGxlZCcsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXRlOiAncmVqZWN0ZWQnLFxuICAgICAgICAgIHJlYXNvbjogdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiAkJCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yKENvbnN0cnVjdG9yLCBpbnB1dCwgYWJvcnRPblJlamVjdCwgbGFiZWwpIHtcbiAgICAgIHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcjtcbiAgICAgIHRoaXMucHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcigkJCRpbnRlcm5hbCQkbm9vcCwgbGFiZWwpO1xuICAgICAgdGhpcy5fYWJvcnRPblJlamVjdCA9IGFib3J0T25SZWplY3Q7XG5cbiAgICAgIGlmICh0aGlzLl92YWxpZGF0ZUlucHV0KGlucHV0KSkge1xuICAgICAgICB0aGlzLl9pbnB1dCAgICAgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5sZW5ndGggICAgID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICB0aGlzLl9yZW1haW5pbmcgPSBpbnB1dC5sZW5ndGg7XG5cbiAgICAgICAgdGhpcy5faW5pdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICQkJGludGVybmFsJCRmdWxmaWxsKHRoaXMucHJvbWlzZSwgdGhpcy5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IHRoaXMubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgdGhpcy5fZW51bWVyYXRlKCk7XG4gICAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgICAgJCQkaW50ZXJuYWwkJGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdCh0aGlzLnByb21pc2UsIHRoaXMuX3ZhbGlkYXRpb25FcnJvcigpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkJCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5fdmFsaWRhdGVJbnB1dCA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICByZXR1cm4gJCR1dGlscyQkaXNBcnJheShpbnB1dCk7XG4gICAgfTtcblxuICAgICQkJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl92YWxpZGF0aW9uRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xuICAgIH07XG5cbiAgICAkJCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICB9O1xuXG4gICAgdmFyICQkJGVudW1lcmF0b3IkJGRlZmF1bHQgPSAkJCRlbnVtZXJhdG9yJCRFbnVtZXJhdG9yO1xuXG4gICAgJCQkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VudW1lcmF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxlbmd0aCAgPSB0aGlzLmxlbmd0aDtcbiAgICAgIHZhciBwcm9taXNlID0gdGhpcy5wcm9taXNlO1xuICAgICAgdmFyIGlucHV0ICAgPSB0aGlzLl9pbnB1dDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSAkJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJCQkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5LCBpKSB7XG4gICAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgICBpZiAoJCR1dGlscyQkaXNNYXliZVRoZW5hYmxlKGVudHJ5KSkge1xuICAgICAgICBpZiAoZW50cnkuY29uc3RydWN0b3IgPT09IGMgJiYgZW50cnkuX3N0YXRlICE9PSAkJCRpbnRlcm5hbCQkUEVORElORykge1xuICAgICAgICAgIGVudHJ5Ll9vbmVycm9yID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl93aWxsU2V0dGxlQXQoYy5yZXNvbHZlKGVudHJ5KSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB0aGlzLl9tYWtlUmVzdWx0KCQkJGludGVybmFsJCRGVUxGSUxMRUQsIGksIGVudHJ5KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJCQkZW51bWVyYXRvciQkRW51bWVyYXRvci5wcm90b3R5cGUuX3NldHRsZWRBdCA9IGZ1bmN0aW9uKHN0YXRlLCBpLCB2YWx1ZSkge1xuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLnByb21pc2U7XG5cbiAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gJCQkaW50ZXJuYWwkJFBFTkRJTkcpIHtcbiAgICAgICAgdGhpcy5fcmVtYWluaW5nLS07XG5cbiAgICAgICAgaWYgKHRoaXMuX2Fib3J0T25SZWplY3QgJiYgc3RhdGUgPT09ICQkJGludGVybmFsJCRSRUpFQ1RFRCkge1xuICAgICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3Jlc3VsdFtpXSA9IHRoaXMuX21ha2VSZXN1bHQoc3RhdGUsIGksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICQkJGludGVybmFsJCRmdWxmaWxsKHByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgICQkJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl9tYWtlUmVzdWx0ID0gZnVuY3Rpb24oc3RhdGUsIGksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcblxuICAgICQkJGVudW1lcmF0b3IkJEVudW1lcmF0b3IucHJvdG90eXBlLl93aWxsU2V0dGxlQXQgPSBmdW5jdGlvbihwcm9taXNlLCBpKSB7XG4gICAgICB2YXIgZW51bWVyYXRvciA9IHRoaXM7XG5cbiAgICAgICQkJGludGVybmFsJCRzdWJzY3JpYmUocHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoJCQkaW50ZXJuYWwkJEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGVudW1lcmF0b3IuX3NldHRsZWRBdCgkJCRpbnRlcm5hbCQkUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgdmFyICQkcHJvbWlzZSRhbGwkJGRlZmF1bHQgPSBmdW5jdGlvbiBhbGwoZW50cmllcywgbGFiZWwpIHtcbiAgICAgIHJldHVybiBuZXcgJCQkZW51bWVyYXRvciQkZGVmYXVsdCh0aGlzLCBlbnRyaWVzLCB0cnVlIC8qIGFib3J0IG9uIHJlamVjdCAqLywgbGFiZWwpLnByb21pc2U7XG4gICAgfTtcblxuICAgIHZhciAkJHByb21pc2UkcmFjZSQkZGVmYXVsdCA9IGZ1bmN0aW9uIHJhY2UoZW50cmllcywgbGFiZWwpIHtcbiAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcigkJCRpbnRlcm5hbCQkbm9vcCwgbGFiZWwpO1xuXG4gICAgICBpZiAoISQkdXRpbHMkJGlzQXJyYXkoZW50cmllcykpIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHJlamVjdChwcm9taXNlLCBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuJykpO1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbmd0aCA9IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICBmdW5jdGlvbiBvbkZ1bGZpbGxtZW50KHZhbHVlKSB7XG4gICAgICAgICQkJGludGVybmFsJCRyZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gb25SZWplY3Rpb24ocmVhc29uKSB7XG4gICAgICAgICQkJGludGVybmFsJCRyZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IHByb21pc2UuX3N0YXRlID09PSAkJCRpbnRlcm5hbCQkUEVORElORyAmJiBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgJCQkaW50ZXJuYWwkJHN1YnNjcmliZShDb25zdHJ1Y3Rvci5yZXNvbHZlKGVudHJpZXNbaV0pLCB1bmRlZmluZWQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcblxuICAgIHZhciAkJHByb21pc2UkcmVzb2x2ZSQkZGVmYXVsdCA9IGZ1bmN0aW9uIHJlc29sdmUob2JqZWN0LCBsYWJlbCkge1xuICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAgIGlmIChvYmplY3QgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0LmNvbnN0cnVjdG9yID09PSBDb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBDb25zdHJ1Y3RvcigkJCRpbnRlcm5hbCQkbm9vcCwgbGFiZWwpO1xuICAgICAgJCQkaW50ZXJuYWwkJHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH07XG5cbiAgICB2YXIgJCRwcm9taXNlJHJlamVjdCQkZGVmYXVsdCA9IGZ1bmN0aW9uIHJlamVjdChyZWFzb24sIGxhYmVsKSB7XG4gICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcbiAgICAgIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKCQkJGludGVybmFsJCRub29wLCBsYWJlbCk7XG4gICAgICAkJCRpbnRlcm5hbCQkcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9O1xuXG4gICAgdmFyICQkZXM2JHByb21pc2UkcHJvbWlzZSQkY291bnRlciA9IDA7XG5cbiAgICBmdW5jdGlvbiAkJGVzNiRwcm9taXNlJHByb21pc2UkJG5lZWRzUmVzb2x2ZXIoKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gJCRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc05ldygpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdmFyICQkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdCA9ICQkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZTtcblxuICAgIC8qKlxuICAgICAgUHJvbWlzZSBvYmplY3RzIHJlcHJlc2VudCB0aGUgZXZlbnR1YWwgcmVzdWx0IG9mIGFuIGFzeW5jaHJvbm91cyBvcGVyYXRpb24uIFRoZVxuICAgICAgcHJpbWFyeSB3YXkgb2YgaW50ZXJhY3Rpbmcgd2l0aCBhIHByb21pc2UgaXMgdGhyb3VnaCBpdHMgYHRoZW5gIG1ldGhvZCwgd2hpY2hcbiAgICAgIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNl4oCZcyBldmVudHVhbCB2YWx1ZSBvciB0aGUgcmVhc29uXG4gICAgICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgVGVybWlub2xvZ3lcbiAgICAgIC0tLS0tLS0tLS0tXG5cbiAgICAgIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gICAgICAtIGB0aGVuYWJsZWAgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgZGVmaW5lcyBhIGB0aGVuYCBtZXRob2QuXG4gICAgICAtIGB2YWx1ZWAgaXMgYW55IGxlZ2FsIEphdmFTY3JpcHQgdmFsdWUgKGluY2x1ZGluZyB1bmRlZmluZWQsIGEgdGhlbmFibGUsIG9yIGEgcHJvbWlzZSkuXG4gICAgICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgICAgIC0gYHJlYXNvbmAgaXMgYSB2YWx1ZSB0aGF0IGluZGljYXRlcyB3aHkgYSBwcm9taXNlIHdhcyByZWplY3RlZC5cbiAgICAgIC0gYHNldHRsZWRgIHRoZSBmaW5hbCByZXN0aW5nIHN0YXRlIG9mIGEgcHJvbWlzZSwgZnVsZmlsbGVkIG9yIHJlamVjdGVkLlxuXG4gICAgICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgICAgIFByb21pc2VzIHRoYXQgYXJlIGZ1bGZpbGxlZCBoYXZlIGEgZnVsZmlsbG1lbnQgdmFsdWUgYW5kIGFyZSBpbiB0aGUgZnVsZmlsbGVkXG4gICAgICBzdGF0ZS4gIFByb21pc2VzIHRoYXQgYXJlIHJlamVjdGVkIGhhdmUgYSByZWplY3Rpb24gcmVhc29uIGFuZCBhcmUgaW4gdGhlXG4gICAgICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICAgICAgUHJvbWlzZXMgY2FuIGFsc28gYmUgc2FpZCB0byAqcmVzb2x2ZSogYSB2YWx1ZS4gIElmIHRoaXMgdmFsdWUgaXMgYWxzbyBhXG4gICAgICBwcm9taXNlLCB0aGVuIHRoZSBvcmlnaW5hbCBwcm9taXNlJ3Mgc2V0dGxlZCBzdGF0ZSB3aWxsIG1hdGNoIHRoZSB2YWx1ZSdzXG4gICAgICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgICAgIGl0c2VsZiByZWplY3QsIGFuZCBhIHByb21pc2UgdGhhdCAqcmVzb2x2ZXMqIGEgcHJvbWlzZSB0aGF0IGZ1bGZpbGxzIHdpbGxcbiAgICAgIGl0c2VsZiBmdWxmaWxsLlxuXG5cbiAgICAgIEJhc2ljIFVzYWdlOlxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIGBgYGpzXG4gICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAvLyBvbiBzdWNjZXNzXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuXG4gICAgICAgIC8vIG9uIGZhaWx1cmVcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9KTtcblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIG9uIGZ1bGZpbGxtZW50XG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgLy8gb24gcmVqZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBVc2FnZTpcbiAgICAgIC0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICBQcm9taXNlcyBzaGluZSB3aGVuIGFic3RyYWN0aW5nIGF3YXkgYXN5bmNocm9ub3VzIGludGVyYWN0aW9ucyBzdWNoIGFzXG4gICAgICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICAgICAgYGBganNcbiAgICAgIGZ1bmN0aW9uIGdldEpTT04odXJsKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCB1cmwpO1xuICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnanNvbic7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZXIoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSB0aGlzLkRPTkUpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAgICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICAvLyBvbiByZWplY3Rpb25cbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgICAgIGBgYGpzXG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgICAgICBnZXRKU09OKCcvY29tbWVudHMnKVxuICAgICAgXSkudGhlbihmdW5jdGlvbih2YWx1ZXMpe1xuICAgICAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgICAgIHZhbHVlc1sxXSAvLyA9PiBjb21tZW50c0pTT05cblxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgQGNsYXNzIFByb21pc2VcbiAgICAgIEBwYXJhbSB7ZnVuY3Rpb259IHJlc29sdmVyXG4gICAgICBVc2VmdWwgZm9yIHRvb2xpbmcuXG4gICAgICBAY29uc3RydWN0b3JcbiAgICAqL1xuICAgIGZ1bmN0aW9uICQkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZShyZXNvbHZlcikge1xuICAgICAgdGhpcy5faWQgPSAkJGVzNiRwcm9taXNlJHByb21pc2UkJGNvdW50ZXIrKztcbiAgICAgIHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fc3Vic2NyaWJlcnMgPSBbXTtcblxuICAgICAgaWYgKCQkJGludGVybmFsJCRub29wICE9PSByZXNvbHZlcikge1xuICAgICAgICBpZiAoISQkdXRpbHMkJGlzRnVuY3Rpb24ocmVzb2x2ZXIpKSB7XG4gICAgICAgICAgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRuZWVkc1Jlc29sdmVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlKSkge1xuICAgICAgICAgICQkZXM2JHByb21pc2UkcHJvbWlzZSQkbmVlZHNOZXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgICQkJGludGVybmFsJCRpbml0aWFsaXplUHJvbWlzZSh0aGlzLCByZXNvbHZlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLmFsbCA9ICQkcHJvbWlzZSRhbGwkJGRlZmF1bHQ7XG4gICAgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnJhY2UgPSAkJHByb21pc2UkcmFjZSQkZGVmYXVsdDtcbiAgICAkJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UucmVzb2x2ZSA9ICQkcHJvbWlzZSRyZXNvbHZlJCRkZWZhdWx0O1xuICAgICQkZXM2JHByb21pc2UkcHJvbWlzZSQkUHJvbWlzZS5yZWplY3QgPSAkJHByb21pc2UkcmVqZWN0JCRkZWZhdWx0O1xuXG4gICAgJCRlczYkcHJvbWlzZSRwcm9taXNlJCRQcm9taXNlLnByb3RvdHlwZSA9IHtcbiAgICAgIGNvbnN0cnVjdG9yOiAkJGVzNiRwcm9taXNlJHByb21pc2UkJFByb21pc2UsXG5cbiAgICAvKipcbiAgICAgIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICAgICAgd2hpY2ggcmVnaXN0ZXJzIGNhbGxiYWNrcyB0byByZWNlaXZlIGVpdGhlciBhIHByb21pc2UncyBldmVudHVhbCB2YWx1ZSBvciB0aGVcbiAgICAgIHJlYXNvbiB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICAgICAgYGBganNcbiAgICAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbih1c2VyKXtcbiAgICAgICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgICAgIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHVzZXIgaXMgdW5hdmFpbGFibGUsIGFuZCB5b3UgYXJlIGdpdmVuIHRoZSByZWFzb24gd2h5XG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBDaGFpbmluZ1xuICAgICAgLS0tLS0tLS1cblxuICAgICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgICAgIHByb21pc2UgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmaXJzdCBwcm9taXNlJ3MgZnVsZmlsbG1lbnRcbiAgICAgIG9yIHJlamVjdGlvbiBoYW5kbGVyLCBvciByZWplY3RlZCBpZiB0aGUgaGFuZGxlciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHJldHVybiB1c2VyLm5hbWU7XG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHJldHVybiAnZGVmYXVsdCBuYW1lJztcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgdXNlck5hbWVgIHdpbGwgYmUgdGhlIHVzZXIncyBuYW1lLCBvdGhlcndpc2UgaXRcbiAgICAgICAgLy8gd2lsbCBiZSBgJ2RlZmF1bHQgbmFtZSdgXG4gICAgICB9KTtcblxuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgZmluZFVzZXJgIHJlamVjdGVkIGFuZCB3ZSdyZSB1bmhhcHB5Jyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBuZXZlciByZWFjaGVkXG4gICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgICAgIC8vIElmIGBmaW5kVXNlcmAgcmVqZWN0ZWQsIGByZWFzb25gIHdpbGwgYmUgJ2BmaW5kVXNlcmAgcmVqZWN0ZWQgYW5kIHdlJ3JlIHVuaGFwcHknLlxuICAgICAgfSk7XG4gICAgICBgYGBcbiAgICAgIElmIHRoZSBkb3duc3RyZWFtIHByb21pc2UgZG9lcyBub3Qgc3BlY2lmeSBhIHJlamVjdGlvbiBoYW5kbGVyLCByZWplY3Rpb24gcmVhc29ucyB3aWxsIGJlIHByb3BhZ2F0ZWQgZnVydGhlciBkb3duc3RyZWFtLlxuXG4gICAgICBgYGBqc1xuICAgICAgZmluZFVzZXIoKS50aGVuKGZ1bmN0aW9uICh1c2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBQZWRhZ29naWNhbEV4Y2VwdGlvbignVXBzdHJlYW0gZXJyb3InKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgLy8gVGhlIGBQZWRnYWdvY2lhbEV4Y2VwdGlvbmAgaXMgcHJvcGFnYXRlZCBhbGwgdGhlIHdheSBkb3duIHRvIGhlcmVcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEFzc2ltaWxhdGlvblxuICAgICAgLS0tLS0tLS0tLS0tXG5cbiAgICAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gICAgICByZXRyaWV2ZWQgYXN5bmNocm9ub3VzbHkuIFRoaXMgY2FuIGJlIGFjaGlldmVkIGJ5IHJldHVybmluZyBhIHByb21pc2UgaW4gdGhlXG4gICAgICBmdWxmaWxsbWVudCBvciByZWplY3Rpb24gaGFuZGxlci4gVGhlIGRvd25zdHJlYW0gcHJvbWlzZSB3aWxsIHRoZW4gYmUgcGVuZGluZ1xuICAgICAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgSWYgdGhlIGFzc2ltbGlhdGVkIHByb21pc2UgcmVqZWN0cywgdGhlbiB0aGUgZG93bnN0cmVhbSBwcm9taXNlIHdpbGwgYWxzbyByZWplY3QuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICAgICAgcmV0dXJuIGZpbmRDb21tZW50c0J5QXV0aG9yKHVzZXIpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAgICAgLy8gSWYgYGZpbmRDb21tZW50c0J5QXV0aG9yYCBmdWxmaWxscywgd2UnbGwgaGF2ZSB0aGUgdmFsdWUgaGVyZVxuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBTaW1wbGUgRXhhbXBsZVxuICAgICAgLS0tLS0tLS0tLS0tLS1cblxuICAgICAgU3luY2hyb25vdXMgRXhhbXBsZVxuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICB2YXIgcmVzdWx0O1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXN1bHQgPSBmaW5kUmVzdWx0KCk7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcbiAgICAgIGZpbmRSZXN1bHQoZnVuY3Rpb24ocmVzdWx0LCBlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kUmVzdWx0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAvLyBzdWNjZXNzXG4gICAgICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgICAgICAvLyBmYWlsdXJlXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBBZHZhbmNlZCBFeGFtcGxlXG4gICAgICAtLS0tLS0tLS0tLS0tLVxuXG4gICAgICBTeW5jaHJvbm91cyBFeGFtcGxlXG5cbiAgICAgIGBgYGphdmFzY3JpcHRcbiAgICAgIHZhciBhdXRob3IsIGJvb2tzO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgICAgIGJvb2tzICA9IGZpbmRCb29rc0J5QXV0aG9yKGF1dGhvcik7XG4gICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgIC8vIGZhaWx1cmVcbiAgICAgIH1cbiAgICAgIGBgYFxuXG4gICAgICBFcnJiYWNrIEV4YW1wbGVcblxuICAgICAgYGBganNcblxuICAgICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGZhaWx1cmUocmVhc29uKSB7XG5cbiAgICAgIH1cblxuICAgICAgZmluZEF1dGhvcihmdW5jdGlvbihhdXRob3IsIGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgLy8gZmFpbHVyZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5kQm9vb2tzQnlBdXRob3IoYXV0aG9yLCBmdW5jdGlvbihib29rcywgZXJyKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGZvdW5kQm9va3MoYm9va3MpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGNhdGNoKGVycm9yKSB7XG4gICAgICAgICAgICBmYWlsdXJlKGVycik7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHN1Y2Nlc3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBgYGBcblxuICAgICAgUHJvbWlzZSBFeGFtcGxlO1xuXG4gICAgICBgYGBqYXZhc2NyaXB0XG4gICAgICBmaW5kQXV0aG9yKCkuXG4gICAgICAgIHRoZW4oZmluZEJvb2tzQnlBdXRob3IpLlxuICAgICAgICB0aGVuKGZ1bmN0aW9uKGJvb2tzKXtcbiAgICAgICAgICAvLyBmb3VuZCBib29rc1xuICAgICAgfSkuY2F0Y2goZnVuY3Rpb24ocmVhc29uKXtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH0pO1xuICAgICAgYGBgXG5cbiAgICAgIEBtZXRob2QgdGhlblxuICAgICAgQHBhcmFtIHtGdW5jdGlvbn0gb25GdWxmaWxsZWRcbiAgICAgIEBwYXJhbSB7RnVuY3Rpb259IG9uUmVqZWN0ZWRcbiAgICAgIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICAgKi9cbiAgICAgIHRoZW46IGZ1bmN0aW9uKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBwYXJlbnQuX3N0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJCQkaW50ZXJuYWwkJEZVTEZJTExFRCAmJiAhb25GdWxmaWxsbWVudCB8fCBzdGF0ZSA9PT0gJCQkaW50ZXJuYWwkJFJFSkVDVEVEICYmICFvblJlamVjdGlvbikge1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoaWxkID0gbmV3IHRoaXMuY29uc3RydWN0b3IoJCQkaW50ZXJuYWwkJG5vb3ApO1xuICAgICAgICB2YXIgcmVzdWx0ID0gcGFyZW50Ll9yZXN1bHQ7XG5cbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW3N0YXRlIC0gMV07XG4gICAgICAgICAgJCRhc2FwJCRkZWZhdWx0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAkJCRpbnRlcm5hbCQkaW52b2tlQ2FsbGJhY2soc3RhdGUsIGNoaWxkLCBjYWxsYmFjaywgcmVzdWx0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAkJCRpbnRlcm5hbCQkc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgIH0sXG5cbiAgICAvKipcbiAgICAgIGBjYXRjaGAgaXMgc2ltcGx5IHN1Z2FyIGZvciBgdGhlbih1bmRlZmluZWQsIG9uUmVqZWN0aW9uKWAgd2hpY2ggbWFrZXMgaXQgdGhlIHNhbWVcbiAgICAgIGFzIHRoZSBjYXRjaCBibG9jayBvZiBhIHRyeS9jYXRjaCBzdGF0ZW1lbnQuXG5cbiAgICAgIGBgYGpzXG4gICAgICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICAgICAgfVxuXG4gICAgICAvLyBzeW5jaHJvbm91c1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEF1dGhvcigpO1xuICAgICAgfSBjYXRjaChyZWFzb24pIHtcbiAgICAgICAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgICAgIH1cblxuICAgICAgLy8gYXN5bmMgd2l0aCBwcm9taXNlc1xuICAgICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gICAgICB9KTtcbiAgICAgIGBgYFxuXG4gICAgICBAbWV0aG9kIGNhdGNoXG4gICAgICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGlvblxuICAgICAgVXNlZnVsIGZvciB0b29saW5nLlxuICAgICAgQHJldHVybiB7UHJvbWlzZX1cbiAgICAqL1xuICAgICAgJ2NhdGNoJzogZnVuY3Rpb24ob25SZWplY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGlvbik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciAkJGVzNiRwcm9taXNlJHBvbHlmaWxsJCRkZWZhdWx0ID0gZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gICAgICB2YXIgbG9jYWw7XG5cbiAgICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsb2NhbCA9IGdsb2JhbDtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50KSB7XG4gICAgICAgIGxvY2FsID0gd2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9jYWwgPSBzZWxmO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXM2UHJvbWlzZVN1cHBvcnQgPVxuICAgICAgICBcIlByb21pc2VcIiBpbiBsb2NhbCAmJlxuICAgICAgICAvLyBTb21lIG9mIHRoZXNlIG1ldGhvZHMgYXJlIG1pc3NpbmcgZnJvbVxuICAgICAgICAvLyBGaXJlZm94L0Nocm9tZSBleHBlcmltZW50YWwgaW1wbGVtZW50YXRpb25zXG4gICAgICAgIFwicmVzb2x2ZVwiIGluIGxvY2FsLlByb21pc2UgJiZcbiAgICAgICAgXCJyZWplY3RcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgICAgIFwiYWxsXCIgaW4gbG9jYWwuUHJvbWlzZSAmJlxuICAgICAgICBcInJhY2VcIiBpbiBsb2NhbC5Qcm9taXNlICYmXG4gICAgICAgIC8vIE9sZGVyIHZlcnNpb24gb2YgdGhlIHNwZWMgaGFkIGEgcmVzb2x2ZXIgb2JqZWN0XG4gICAgICAgIC8vIGFzIHRoZSBhcmcgcmF0aGVyIHRoYW4gYSBmdW5jdGlvblxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHJlc29sdmU7XG4gICAgICAgICAgbmV3IGxvY2FsLlByb21pc2UoZnVuY3Rpb24ocikgeyByZXNvbHZlID0gcjsgfSk7XG4gICAgICAgICAgcmV0dXJuICQkdXRpbHMkJGlzRnVuY3Rpb24ocmVzb2x2ZSk7XG4gICAgICAgIH0oKSk7XG5cbiAgICAgIGlmICghZXM2UHJvbWlzZVN1cHBvcnQpIHtcbiAgICAgICAgbG9jYWwuUHJvbWlzZSA9ICQkZXM2JHByb21pc2UkcHJvbWlzZSQkZGVmYXVsdDtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZSA9IHtcbiAgICAgICdQcm9taXNlJzogJCRlczYkcHJvbWlzZSRwcm9taXNlJCRkZWZhdWx0LFxuICAgICAgJ3BvbHlmaWxsJzogJCRlczYkcHJvbWlzZSRwb2x5ZmlsbCQkZGVmYXVsdFxuICAgIH07XG5cbiAgICAvKiBnbG9iYWwgZGVmaW5lOnRydWUgbW9kdWxlOnRydWUgd2luZG93OiB0cnVlICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lWydhbWQnXSkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlOyB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZVsnZXhwb3J0cyddKSB7XG4gICAgICBtb2R1bGVbJ2V4cG9ydHMnXSA9IGVzNiRwcm9taXNlJHVtZCQkRVM2UHJvbWlzZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGlzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1snRVM2UHJvbWlzZSddID0gZXM2JHByb21pc2UkdW1kJCRFUzZQcm9taXNlO1xuICAgIH1cbn0pLmNhbGwodGhpcyk7XG59KS5jYWxsKHRoaXMsX2RlcmVxXyhcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjo1NX1dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IF9kZXJlcV8oJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IF9kZXJlcV8oJ2llZWU3NTQnKVxudmFyIGlzQXJyYXkgPSBfZGVyZXFfKCdpcy1hcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciBrTWF4TGVuZ3RoID0gMHgzZmZmZmZmZlxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IHN1YmplY3QgPiAwID8gc3ViamVjdCA+Pj4gMCA6IDBcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgc3ViamVjdCA9IGJhc2U2NGNsZWFuKHN1YmplY3QpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkgeyAvLyBhc3N1bWUgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgICBpZiAoc3ViamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KHN1YmplY3QuZGF0YSkpXG4gICAgICBzdWJqZWN0ID0gc3ViamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gK3N1YmplY3QubGVuZ3RoID4gMCA/IE1hdGguZmxvb3IoK3N1YmplY3QubGVuZ3RoKSA6IDBcbiAgfSBlbHNlXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbXVzdCBzdGFydCB3aXRoIG51bWJlciwgYnVmZmVyLCBhcnJheSBvciBzdHJpbmcnKVxuXG4gIGlmICh0aGlzLmxlbmd0aCA+IGtNYXhMZW5ndGgpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcblxuICB2YXIgYnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9ICgoc3ViamVjdFtpXSAlIDI1NikgKyAyNTYpICUgMjU2XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIgKyAnJ1xuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoICogMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCA+Pj4gMVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICB9XG4gIHJldHVybiByZXRcbn1cblxuLy8gcHJlLXNldCBmb3IgdmFsdWVzIHRoYXQgbWF5IGV4aXN0IGluIHRoZSBmdXR1cmVcbkJ1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gdW5kZWZpbmVkXG5CdWZmZXIucHJvdG90eXBlLnBhcmVudCA9IHVuZGVmaW5lZFxuXG4vLyB0b1N0cmluZyhlbmNvZGluZywgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoZW5kIDw9IHN0YXJ0KSByZXR1cm4gJydcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBiaW5hcnlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChiKSB7XG4gIGlmKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KVxuICAgICAgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYnl0ZSA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4oYnl0ZSkpIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYmluYXJ5V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIDIpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBTdXBwb3J0IGJvdGggKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKVxuICAvLyBhbmQgdGhlIGxlZ2FjeSAoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpXG4gIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgaWYgKCFpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2UgeyAgLy8gbGVnYWN5XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoXG4gICAgbGVuZ3RoID0gc3dhcFxuICB9XG5cbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZyB8fCAndXRmOCcpLnRvTG93ZXJDYXNlKClcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKVxuICAgICAgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApXG4gICAgICBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpXG4gICAgZW5kID0gc3RhcnRcblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aClcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKVxuICAgIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbHVlIGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7IGkrKykge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydClcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Ugb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KVxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBpZiAodGFyZ2V0X3N0YXJ0IDwgMCB8fCB0YXJnZXRfc3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aClcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSBzb3VyY2UubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDAgfHwgZW5kID4gc291cmNlLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG4vLyBmaWxsKHZhbHVlLCBzdGFydD0wLCBlbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXZhbHVlKSB2YWx1ZSA9IDBcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kKSBlbmQgPSB0aGlzLmxlbmd0aFxuXG4gIGlmIChlbmQgPCBzdGFydCkgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gdXRmOFRvQnl0ZXModmFsdWUudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gaXNBcnJheWlzaCAoc3ViamVjdCkge1xuICByZXR1cm4gaXNBcnJheShzdWJqZWN0KSB8fCBCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkgfHxcbiAgICAgIHN1YmplY3QgJiYgdHlwZW9mIHN1YmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICB0eXBlb2Ygc3ViamVjdC5sZW5ndGggPT09ICdudW1iZXInXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYiA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaWYgKGIgPD0gMHg3Rikge1xuICAgICAgYnl0ZUFycmF5LnB1c2goYilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YXJ0ID0gaVxuICAgICAgaWYgKGIgPj0gMHhEODAwICYmIGIgPD0gMHhERkZGKSBpKytcbiAgICAgIHZhciBoID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0ci5zbGljZShzdGFydCwgaSsxKSkuc3Vic3RyKDEpLnNwbGl0KCclJylcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaC5sZW5ndGg7IGorKykge1xuICAgICAgICBieXRlQXJyYXkucHVzaChwYXJzZUludChoW2pdLCAxNikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KHN0cilcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoLCB1bml0U2l6ZSkge1xuICBpZiAodW5pdFNpemUpIGxlbmd0aCAtPSBsZW5ndGggJSB1bml0U2l6ZTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbn0se1wiYmFzZTY0LWpzXCI6MjQsXCJpZWVlNzU0XCI6MjUsXCJpcy1hcnJheVwiOjI2fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUylcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0gpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcblxufSx7fV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG5cbn0se31dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuXG59LHt9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5cbn0se31dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG59LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbn0se31dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBodHRwOi8vbXRocy5iZS9wdW55Y29kZSB2MS4yLjQgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXiAtfl0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvXFx4MkV8XFx1MzAwMnxcXHVGRjBFfFxcdUZGNjEvZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRhcnJheVtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3MuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0cmV0dXJuIG1hcChzdHJpbmcuc3BsaXQocmVnZXhTZXBhcmF0b3JzKSwgZm4pLmpvaW4oJy4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyB0byBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5XG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSB0byBVbmljb2RlLiBPbmx5IHRoZVxuXHQgKiBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLCBpLmUuIGl0IGRvZXNuJ3Rcblx0ICogbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgdG9cblx0ICogVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIFB1bnljb2RlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShkb21haW4pIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGRvbWFpbiwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgdG8gUHVueWNvZGUuIE9ubHkgdGhlXG5cdCAqIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS4gaXQgZG9lc24ndFxuXHQgKiBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpbiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQsIGFzIGEgVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGRvbWFpbikge1xuXHRcdHJldHVybiBtYXBEb21haW4oZG9tYWluLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4yLjQnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG59LHt9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxufSx7fV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSBfZGVyZXFfKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IF9kZXJlcV8oJy4vZW5jb2RlJyk7XG5cbn0se1wiLi9kZWNvZGVcIjozMSxcIi4vZW5jb2RlXCI6MzJ9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiKVxuXG59LHtcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCI6MzV9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IF9kZXJlcV8oJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gX2RlcmVxXygnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSBfZGVyZXFfKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSksIGZ1bmN0aW9uKG1ldGhvZCkge1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn0pO1xuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSlcbiAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZClcbiAgICByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVuZC5iaW5kKHRoaXMpKTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG59KS5jYWxsKHRoaXMsX2RlcmVxXyhcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSlcbn0se1wiLi9fc3RyZWFtX3JlYWRhYmxlXCI6MzcsXCIuL19zdHJlYW1fd3JpdGFibGVcIjozOSxcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjU1LFwiY29yZS11dGlsLWlzXCI6NDAsXCJpbmhlcml0c1wiOjI4fV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gX2RlcmVxXygnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSlcbiAgICByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTtcblxufSx7XCIuL19zdHJlYW1fdHJhbnNmb3JtXCI6MzgsXCJjb3JlLXV0aWwtaXNcIjo0MCxcImluaGVyaXRzXCI6Mjh9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IF9kZXJlcV8oJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gX2RlcmVxXygnYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuXG52YXIgRUUgPSBfZGVyZXFfKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5pZiAoIUVFLmxpc3RlbmVyQ291bnQpIEVFLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSBfZGVyZXFfKCdzdHJlYW0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiAxNiAqIDEwMjQ7XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSB+fnRoaXMuaGlnaFdhdGVyTWFyaztcblxuICB0aGlzLmJ1ZmZlciA9IFtdO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBmYWxzZTtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gSW4gc3RyZWFtcyB0aGF0IG5ldmVyIGhhdmUgYW55IGRhdGEsIGFuZCBkbyBwdXNoKG51bGwpIHJpZ2h0IGF3YXksXG4gIC8vIHRoZSBjb25zdW1lciBjYW4gbWlzcyB0aGUgJ2VuZCcgZXZlbnQgaWYgdGhleSBkbyBzb21lIEkvTyBiZWZvcmVcbiAgLy8gY29uc3VtaW5nIHRoZSBzdHJlYW0uICBTbywgd2UgZG9uJ3QgZW1pdCgnZW5kJykgdW50aWwgc29tZSByZWFkaW5nXG4gIC8vIGhhcHBlbnMuXG4gIHRoaXMuY2FsbGVkUmVhZCA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG5cblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gX2RlcmVxXygnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIGlmICghc3RhdGUuZW5kZWQpXG4gICAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpXG4gICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIChzdGF0ZS5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbihlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgIFN0cmluZ0RlY29kZXIgPSBfZGVyZXFfKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDEyOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gcm91bmRVcFRvTmV4dFBvd2VyT2YyKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDJcbiAgICBuLS07XG4gICAgZm9yICh2YXIgcCA9IDE7IHAgPCAzMjsgcCA8PD0gMSkgbiB8PSBuID4+IHA7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuIDA7XG5cbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpXG4gICAgcmV0dXJuIG4gPT09IDAgPyAwIDogMTtcblxuICBpZiAobiA9PT0gbnVsbCB8fCBpc05hTihuKSkge1xuICAgIC8vIG9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICByZXR1cm4gc3RhdGUuYnVmZmVyWzBdLmxlbmd0aDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG4gPD0gMClcbiAgICByZXR1cm4gMDtcblxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgdGFyZ2V0IGJ1ZmZlciBsZXZlbCxcbiAgLy8gdGhlbiByYWlzZSB0aGUgd2F0ZXIgbWFyay4gIEJ1bXAgdXAgdG8gdGhlIG5leHQgaGlnaGVzdFxuICAvLyBwb3dlciBvZiAyLCB0byBwcmV2ZW50IGluY3JlYXNpbmcgaXQgZXhjZXNzaXZlbHkgaW4gdGlueVxuICAvLyBhbW91bnRzLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgc3RhdGUuaGlnaFdhdGVyTWFyayA9IHJvdW5kVXBUb05leHRQb3dlck9mMihuKTtcblxuICAvLyBkb24ndCBoYXZlIHRoYXQgbXVjaC4gIHJldHVybiBudWxsLCB1bmxlc3Mgd2UndmUgZW5kZWQuXG4gIGlmIChuID4gc3RhdGUubGVuZ3RoKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIHJldHVybiBuO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLmNhbGxlZFJlYWQgPSB0cnVlO1xuICB2YXIgbk9yaWcgPSBuO1xuICB2YXIgcmV0O1xuXG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICByZXQgPSBudWxsO1xuXG4gICAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIGRlY29kZXIgZGlkIG5vdCByZWNlaXZlIGVub3VnaCBkYXRhXG4gICAgLy8gdG8gcHJvZHVjZSBhIGZ1bGwgY2h1bmssIHRoZW4gaW1tZWRpYXRlbHkgcmVjZWl2ZWQgYW5cbiAgICAvLyBFT0YsIHN0YXRlLmJ1ZmZlciB3aWxsIGNvbnRhaW4gWzxCdWZmZXIgPiwgPEJ1ZmZlciAwMCAuLi4+XS5cbiAgICAvLyBob3dNdWNoVG9SZWFkIHdpbGwgc2VlIHRoaXMgYW5kIGNvZXJjZSB0aGUgYW1vdW50IHRvXG4gICAgLy8gcmVhZCB0byB6ZXJvIChiZWNhdXNlIGl0J3MgbG9va2luZyBhdCB0aGUgbGVuZ3RoIG9mIHRoZVxuICAgIC8vIGZpcnN0IDxCdWZmZXIgPiBpbiBzdGF0ZS5idWZmZXIpLCBhbmQgd2UnbGwgZW5kIHVwIGhlcmUuXG4gICAgLy9cbiAgICAvLyBUaGlzIGNhbiBvbmx5IGhhcHBlbiB2aWEgc3RhdGUuZGVjb2RlciAtLSBubyBvdGhlciB2ZW51ZVxuICAgIC8vIGV4aXN0cyBmb3IgcHVzaGluZyBhIHplcm8tbGVuZ3RoIGNodW5rIGludG8gc3RhdGUuYnVmZmVyXG4gICAgLy8gYW5kIHRyaWdnZXJpbmcgdGhpcyBiZWhhdmlvci4gSW4gdGhpcyBjYXNlLCB3ZSByZXR1cm4gb3VyXG4gICAgLy8gcmVtYWluaW5nIGRhdGEgYW5kIGVuZCB0aGUgc3RyZWFtLCBpZiBhcHByb3ByaWF0ZS5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID4gMCAmJiBzdGF0ZS5kZWNvZGVyKSB7XG4gICAgICByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5sZW5ndGggLT0gcmV0Lmxlbmd0aDtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgZW5kUmVhZGFibGUodGhpcyk7XG5cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggLSBuIDw9IHN0YXRlLmhpZ2hXYXRlck1hcmspXG4gICAgZG9SZWFkID0gdHJ1ZTtcblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKVxuICAgIGRvUmVhZCA9IGZhbHNlO1xuXG4gIGlmIChkb1JlYWQpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIElmIF9yZWFkIGNhbGxlZCBpdHMgY2FsbGJhY2sgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2BcbiAgLy8gd2lsbCBiZSBmYWxzZSwgYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZVxuICAvLyBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICBpZiAoZG9SZWFkICYmICFzdGF0ZS5yZWFkaW5nKVxuICAgIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG5cbiAgaWYgKG4gPiAwKVxuICAgIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtcbiAgZWxzZVxuICAgIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH1cblxuICBzdGF0ZS5sZW5ndGggLT0gbjtcblxuICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5lbmRlZClcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIElmIHdlIGhhcHBlbmVkIHRvIHJlYWQoKSBleGFjdGx5IHRoZSByZW1haW5pbmcgYW1vdW50IGluIHRoZVxuICAvLyBidWZmZXIsIGFuZCB0aGUgRU9GIGhhcyBiZWVuIHNlZW4gYXQgdGhpcyBwb2ludCwgdGhlbiBtYWtlIHN1cmVcbiAgLy8gdGhhdCB3ZSBlbWl0ICdlbmQnIG9uIHRoZSB2ZXJ5IG5leHQgdGljay5cbiAgaWYgKHN0YXRlLmVuZGVkICYmICFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMClcbiAgICBlbmRSZWFkYWJsZSh0aGlzKTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiZcbiAgICAgICdzdHJpbmcnICE9PSB0eXBlb2YgY2h1bmsgJiZcbiAgICAgIGNodW5rICE9PSBudWxsICYmXG4gICAgICBjaHVuayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCBhbmQgd2UgaGF2ZSBzb21lIGRhdGEgbGVmdCwgdGhlbiBlbWl0XG4gIC8vICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIGVsc2VcbiAgICBlbmRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoc3RhdGUuZW1pdHRlZFJlYWRhYmxlKVxuICAgIHJldHVybjtcblxuICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICBpZiAoc3RhdGUuc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICAgIH0pO1xuICBlbHNlXG4gICAgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbn1cblxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO1xuICBlbHNlXG4gICAgc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlKSB7XG4gICAgaWYgKHJlYWRhYmxlICE9PSBzcmMpIHJldHVybjtcbiAgICBjbGVhbnVwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbilcbiAgICAgIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKVxuICAgICAgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuICAvLyBUaGlzIGlzIGEgYnJ1dGFsbHkgdWdseSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyXG4gIC8vIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnkgdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuXG4gIGlmICghZGVzdC5fZXZlbnRzIHx8ICFkZXN0Ll9ldmVudHMuZXJyb3IpXG4gICAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZWxzZSBpZiAoaXNBcnJheShkZXN0Ll9ldmVudHMuZXJyb3IpKVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvci51bnNoaWZ0KG9uZXJyb3IpO1xuICBlbHNlXG4gICAgZGVzdC5fZXZlbnRzLmVycm9yID0gW29uZXJyb3IsIGRlc3QuX2V2ZW50cy5lcnJvcl07XG5cblxuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICAvLyB0aGUgaGFuZGxlciB0aGF0IHdhaXRzIGZvciByZWFkYWJsZSBldmVudHMgYWZ0ZXIgYWxsXG4gICAgLy8gdGhlIGRhdGEgZ2V0cyBzdWNrZWQgb3V0IGluIGZsb3cuXG4gICAgLy8gVGhpcyB3b3VsZCBiZSBlYXNpZXIgdG8gZm9sbG93IHdpdGggYSAub25jZSgpIGhhbmRsZXJcbiAgICAvLyBpbiBmbG93KCksIGJ1dCB0aGF0IGlzIHRvbyBzbG93LlxuICAgIHRoaXMub24oJ3JlYWRhYmxlJywgcGlwZU9uUmVhZGFibGUpO1xuXG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGVzdCA9IHRoaXM7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMClcbiAgICAgIGZsb3coc3JjKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmxvdyhzcmMpIHtcbiAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgY2h1bms7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuXG4gIGZ1bmN0aW9uIHdyaXRlKGRlc3QsIGksIGxpc3QpIHtcbiAgICB2YXIgd3JpdHRlbiA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gd3JpdHRlbikge1xuICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgIH1cbiAgfVxuXG4gIHdoaWxlIChzdGF0ZS5waXBlc0NvdW50ICYmIG51bGwgIT09IChjaHVuayA9IHNyYy5yZWFkKCkpKSB7XG5cbiAgICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICAgIHdyaXRlKHN0YXRlLnBpcGVzLCAwLCBudWxsKTtcbiAgICBlbHNlXG4gICAgICBmb3JFYWNoKHN0YXRlLnBpcGVzLCB3cml0ZSk7XG5cbiAgICBzcmMuZW1pdCgnZGF0YScsIGNodW5rKTtcblxuICAgIC8vIGlmIGFueW9uZSBuZWVkcyBhIGRyYWluLCB0aGVuIHdlIGhhdmUgdG8gd2FpdCBmb3IgdGhhdC5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA+IDApXG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBpZiBldmVyeSBkZXN0aW5hdGlvbiB3YXMgdW5waXBlZCwgZWl0aGVyIGJlZm9yZSBlbnRlcmluZyB0aGlzXG4gIC8vIGZ1bmN0aW9uLCBvciBpbiB0aGUgd2hpbGUgbG9vcCwgdGhlbiBzdG9wIGZsb3dpbmcuXG4gIC8vXG4gIC8vIE5COiBUaGlzIGlzIGEgcHJldHR5IHJhcmUgZWRnZSBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkge1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIC8vIGlmIHRoZXJlIHdlcmUgZGF0YSBldmVudCBsaXN0ZW5lcnMgYWRkZWQsIHRoZW4gc3dpdGNoIHRvIG9sZCBtb2RlLlxuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSA+IDApXG4gICAgICBlbWl0RGF0YUV2ZW50cyhzcmMpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIG5vIG9uZSBuZWVkZWQgYSBkcmFpbiwgc28gd2UganVzdCByYW4gb3V0IG9mIGRhdGFcbiAgLy8gb24gdGhlIG5leHQgcmVhZGFibGUgZXZlbnQsIHN0YXJ0IGl0IG92ZXIgYWdhaW4uXG4gIHN0YXRlLnJhbk91dCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHBpcGVPblJlYWRhYmxlKCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5yYW5PdXQpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJhbk91dCA9IGZhbHNlO1xuICAgIGZsb3codGhpcyk7XG4gIH1cbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBwaXBlT25SZWFkYWJsZSk7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKVxuICAgIGVtaXREYXRhRXZlbnRzKHRoaXMpO1xuXG4gIGlmIChldiA9PT0gJ3JlYWRhYmxlJyAmJiB0aGlzLnJlYWRhYmxlKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5yZWFkKDApO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMsIHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICBlbWl0RGF0YUV2ZW50cyh0aGlzKTtcbiAgdGhpcy5yZWFkKDApO1xuICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGVtaXREYXRhRXZlbnRzKHRoaXMsIHRydWUpO1xuICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG59O1xuXG5mdW5jdGlvbiBlbWl0RGF0YUV2ZW50cyhzdHJlYW0sIHN0YXJ0UGF1c2VkKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuZmxvd2luZykge1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvcmVhZGFibGUtc3RyZWFtL2lzc3Vlcy8xNlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3aXRjaCB0byBvbGQgbW9kZSBub3cuJyk7XG4gIH1cblxuICB2YXIgcGF1c2VkID0gc3RhcnRQYXVzZWQgfHwgZmFsc2U7XG4gIHZhciByZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGNvbnZlcnQgdG8gYW4gb2xkLXN0eWxlIHN0cmVhbS5cbiAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgc3RyZWFtLnBpcGUgPSBTdHJlYW0ucHJvdG90eXBlLnBpcGU7XG4gIHN0cmVhbS5vbiA9IHN0cmVhbS5hZGRMaXN0ZW5lciA9IFN0cmVhbS5wcm90b3R5cGUub247XG5cbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uKCkge1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIHZhciBjO1xuICAgIHdoaWxlICghcGF1c2VkICYmIChudWxsICE9PSAoYyA9IHN0cmVhbS5yZWFkKCkpKSlcbiAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgYyk7XG5cbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH07XG5cbiAgc3RyZWFtLnJlc3VtZSA9IGZ1bmN0aW9uKCkge1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGlmIChyZWFkYWJsZSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5yZWFkKDApO1xuICAgIHRoaXMuZW1pdCgncmVzdW1lJyk7XG4gIH07XG5cbiAgLy8gbm93IG1ha2UgaXQgc3RhcnQsIGp1c3QgaW4gY2FzZSBpdCBoYWRuJ3QgYWxyZWFkeS5cbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpXG4gICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgLy9pZiAoc3RhdGUub2JqZWN0TW9kZSAmJiB1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKGNodW5rKSlcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpXG4gICAgICByZXR1cm47XG4gICAgZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSlcbiAgICAgIHJldHVybjtcblxuICAgIHZhciByZXQgPSBzZWxmLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiB0aGlzW2ldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uKG1ldGhvZCkgeyByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICB9fShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIHZhciBldmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG4gIGZvckVhY2goZXZlbnRzLCBmdW5jdGlvbihldikge1xuICAgIHN0cmVhbS5vbihldiwgc2VsZi5lbWl0LmJpbmQoc2VsZiwgZXYpKTtcbiAgfSk7XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uKG4pIHtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmNhbGxlZFJlYWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICAgIC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuICAgICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKVxufSx7XCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjo1NSxcImJ1ZmZlclwiOjIzLFwiY29yZS11dGlsLWlzXCI6NDAsXCJldmVudHNcIjoyNyxcImluaGVyaXRzXCI6MjgsXCJpc2FycmF5XCI6MjksXCJzdHJlYW1cIjo0NSxcInN0cmluZ19kZWNvZGVyL1wiOjQ2fV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IF9kZXJlcV8oJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gX2RlcmVxXygnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdubyB3cml0ZWNiIGluIFRyYW5zZm9ybSBjbGFzcycpKTtcblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKVxuICAgIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGlmIChjYilcbiAgICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKVxuICAgIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlID0gbmV3IFRyYW5zZm9ybVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIHdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZmluaXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiB0aGlzLl9mbHVzaClcbiAgICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uKGVyKSB7XG4gICAgICAgIGRvbmUoc3RyZWFtLCBlcik7XG4gICAgICB9KTtcbiAgICBlbHNlXG4gICAgICBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fFxuICAgICAgICBycy5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaylcbiAgICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyKSB7XG4gIGlmIChlcilcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh3cy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn1cblxufSx7XCIuL19zdHJlYW1fZHVwbGV4XCI6MzUsXCJjb3JlLXV0aWwtaXNcIjo0MCxcImluaGVyaXRzXCI6Mjh9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IF9kZXJlcV8oJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBfZGVyZXFfKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJlYW0gPSBfZGVyZXFfKCdzdHJlYW0nKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aGlzLmNodW5rID0gY2h1bms7XG4gIHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gKGh3bSB8fCBod20gPT09IDApID8gaHdtIDogMTYgKiAxMDI0O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWN1YXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcblxuICAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuICB0aGlzLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSBfZGVyZXFfKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0aG91Z2ggdGhleSdyZSBub3RcbiAgLy8gaW5zdGFuY2VvZiBXcml0YWJsZSwgdGhleSdyZSBpbnN0YW5jZW9mIFJlYWRhYmxlLlxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgV3JpdGFibGUpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUuIE5vdCByZWFkYWJsZS4nKSk7XG59O1xuXG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIGNiKGVyKTtcbiAgfSk7XG59XG5cbi8vIElmIHdlIGdldCBzb21ldGhpbmcgdGhhdCBpcyBub3QgYSBidWZmZXIsIHN0cmluZywgbnVsbCwgb3IgdW5kZWZpbmVkLFxuLy8gYW5kIHdlJ3JlIG5vdCBpbiBvYmplY3RNb2RlLCB0aGVuIHRoYXQncyBhbiBlcnJvci5cbi8vIE90aGVyd2lzZSBzdHJlYW0gY2h1bmtzIGFyZSBhbGwgY29uc2lkZXJlZCB0byBiZSBvZiBsZW5ndGg9MSwgYW5kIHRoZVxuLy8gd2F0ZXJtYXJrcyBkZXRlcm1pbmUgaG93IG1hbnkgb2JqZWN0cyB0byBrZWVwIGluIHRoZSBidWZmZXIsIHJhdGhlciB0aGFuXG4vLyBob3cgbWFueSBieXRlcyBvciBjaGFyYWN0ZXJzLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmXG4gICAgICAnc3RyaW5nJyAhPT0gdHlwZW9mIGNodW5rICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24oKSB7XG4gICAgICBjYihlcik7XG4gICAgfSk7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspKVxuICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gIGVsc2UgaWYgKCFlbmNvZGluZylcbiAgICBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gZnVuY3Rpb24oKSB7fTtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBzdGF0ZSwgY2IpO1xuICBlbHNlIGlmICh2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKVxuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpXG4gICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldClcbiAgICBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nKVxuICAgIHN0YXRlLmJ1ZmZlci5wdXNoKG5ldyBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSk7XG4gIGVsc2VcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICBpZiAoc3luYylcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgY2IoZXIpO1xuICAgIH0pO1xuICBlbHNlXG4gICAgY2IoZXIpO1xuXG4gIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKVxuICAgIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO1xuICBlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlci5sZW5ndGgpXG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKVxuICAgIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgY2IoKTtcbiAgaWYgKGZpbmlzaGVkKVxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuXG4vLyBpZiB0aGVyZSdzIHNvbWV0aGluZyBpbiB0aGUgYnVmZmVyIHdhaXRpbmcsIHRoZW4gcHJvY2VzcyBpdFxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcblxuICBmb3IgKHZhciBjID0gMDsgYyA8IHN0YXRlLmJ1ZmZlci5sZW5ndGg7IGMrKykge1xuICAgIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcltjXTtcbiAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG5cbiAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICBjKys7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG4gIGlmIChjIDwgc3RhdGUuYnVmZmVyLmxlbmd0aClcbiAgICBzdGF0ZS5idWZmZXIgPSBzdGF0ZS5idWZmZXIuc2xpY2UoYyk7XG4gIGVsc2VcbiAgICBzdGF0ZS5idWZmZXIubGVuZ3RoID0gMDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIGNodW5rICE9PSAndW5kZWZpbmVkJyAmJiBjaHVuayAhPT0gbnVsbClcbiAgICB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpXG4gICAgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYik7XG4gICAgZWxzZVxuICAgICAgc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG59XG5cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2luc2VydC1tb2R1bGUtZ2xvYmFscy9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXCIpKVxufSx7XCIuL19zdHJlYW1fZHVwbGV4XCI6MzUsXCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIjo1NSxcImJ1ZmZlclwiOjIzLFwiY29yZS11dGlsLWlzXCI6NDAsXCJpbmhlcml0c1wiOjI4LFwic3RyZWFtXCI6NDV9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKEJ1ZmZlcil7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKGFyZyk7XG59XG5leHBvcnRzLmlzQnVmZmVyID0gaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbn0pLmNhbGwodGhpcyxfZGVyZXFfKFwiYnVmZmVyXCIpLkJ1ZmZlcilcbn0se1wiYnVmZmVyXCI6MjN9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG5cbn0se1wiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiOjM2fV0sNDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFN0cmVhbSA9IF9kZXJlcV8oJ3N0cmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBTdHJlYW07XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSBfZGVyZXFfKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IF9kZXJlcV8oJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gX2RlcmVxXygnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuXG59LHtcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCI6MzUsXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCI6MzYsXCIuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXCI6MzcsXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiOjM4LFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1wiOjM5LFwic3RyZWFtXCI6NDV9XSw0MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKVxuXG59LHtcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCI6Mzh9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZXJlcV8oXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG5cbn0se1wiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1wiOjM5fV0sNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSBfZGVyZXFfKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSBfZGVyZXFfKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gX2RlcmVxXygncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IF9kZXJlcV8oJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG5cbn0se1wiZXZlbnRzXCI6MjcsXCJpbmhlcml0c1wiOjI4LFwicmVhZGFibGUtc3RyZWFtL2R1cGxleC5qc1wiOjM0LFwicmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzXCI6NDEsXCJyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanNcIjo0MixcInJlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanNcIjo0MyxcInJlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qc1wiOjQ0fV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBCdWZmZXIgPSBfZGVyZXFfKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0J1ZmZlckVuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmdcbiAgfHwgZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgICAgICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgIGNhc2UgJ2hleCc6IGNhc2UgJ3V0ZjgnOiBjYXNlICd1dGYtOCc6IGNhc2UgJ2FzY2lpJzogY2FzZSAnYmluYXJ5JzogY2FzZSAnYmFzZTY0JzogY2FzZSAndWNzMic6IGNhc2UgJ3Vjcy0yJzogY2FzZSAndXRmMTZsZSc6IGNhc2UgJ3V0Zi0xNmxlJzogY2FzZSAncmF3JzogcmV0dXJuIHRydWU7XG4gICAgICAgICBkZWZhdWx0OiByZXR1cm4gZmFsc2U7XG4gICAgICAgfVxuICAgICB9XG5cblxuZnVuY3Rpb24gYXNzZXJ0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgaWYgKGVuY29kaW5nICYmICFpc0J1ZmZlckVuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgfVxufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuIENFU1UtOCBpcyBoYW5kbGVkIGFzIHBhcnQgb2YgdGhlIFVURi04IGVuY29kaW5nLlxuLy9cbi8vIEBUT0RPIEhhbmRsaW5nIGFsbCBlbmNvZGluZ3MgaW5zaWRlIGEgc2luZ2xlIG9iamVjdCBtYWtlcyBpdCB2ZXJ5IGRpZmZpY3VsdFxuLy8gdG8gcmVhc29uIGFib3V0IHRoaXMgY29kZSwgc28gaXQgc2hvdWxkIGJlIHNwbGl0IHVwIGluIHRoZSBmdXR1cmUuXG4vLyBAVE9ETyBUaGVyZSBzaG91bGQgYmUgYSB1dGY4LXN0cmljdCBlbmNvZGluZyB0aGF0IHJlamVjdHMgaW52YWxpZCBVVEYtOCBjb2RlXG4vLyBwb2ludHMgYXMgdXNlZCBieSBDRVNVLTguXG52YXIgU3RyaW5nRGVjb2RlciA9IGV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSAoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1stX10vLCAnJyk7XG4gIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKTtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICAvLyBDRVNVLTggcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDMtYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIC8vIFVURi0xNiByZXByZXNlbnRzIGVhY2ggb2YgU3Vycm9nYXRlIFBhaXIgYnkgMi1ieXRlc1xuICAgICAgdGhpcy5zdXJyb2dhdGVTaXplID0gMjtcbiAgICAgIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIgPSB1dGYxNkRldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIC8vIEJhc2UtNjQgc3RvcmVzIDMgYnl0ZXMgaW4gNCBjaGFycywgYW5kIHBhZHMgdGhlIHJlbWFpbmRlci5cbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDM7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHBhc3NUaHJvdWdoV3JpdGU7XG4gICAgICByZXR1cm47XG4gIH1cblxuICAvLyBFbm91Z2ggc3BhY2UgdG8gc3RvcmUgYWxsIGJ5dGVzIG9mIGEgc2luZ2xlIGNoYXJhY3Rlci4gVVRGLTggbmVlZHMgNFxuICAvLyBieXRlcywgYnV0IENFU1UtOCBtYXkgcmVxdWlyZSB1cCB0byA2ICgzIGJ5dGVzIHBlciBzdXJyb2dhdGUpLlxuICB0aGlzLmNoYXJCdWZmZXIgPSBuZXcgQnVmZmVyKDYpO1xuICAvLyBOdW1iZXIgb2YgYnl0ZXMgcmVjZWl2ZWQgZm9yIHRoZSBjdXJyZW50IGluY29tcGxldGUgbXVsdGktYnl0ZSBjaGFyYWN0ZXIuXG4gIHRoaXMuY2hhclJlY2VpdmVkID0gMDtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIGV4cGVjdGVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJMZW5ndGggPSAwO1xufTtcblxuXG4vLyB3cml0ZSBkZWNvZGVzIHRoZSBnaXZlbiBidWZmZXIgYW5kIHJldHVybnMgaXQgYXMgSlMgc3RyaW5nIHRoYXQgaXNcbi8vIGd1YXJhbnRlZWQgdG8gbm90IGNvbnRhaW4gYW55IHBhcnRpYWwgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLiBBbnkgcGFydGlhbFxuLy8gY2hhcmFjdGVyIGZvdW5kIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBpcyBidWZmZXJlZCB1cCwgYW5kIHdpbGwgYmVcbi8vIHJldHVybmVkIHdoZW4gY2FsbGluZyB3cml0ZSBhZ2FpbiB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMuXG4vL1xuLy8gTm90ZTogQ29udmVydGluZyBhIEJ1ZmZlciBjb250YWluaW5nIGFuIG9ycGhhbiBzdXJyb2dhdGUgdG8gYSBTdHJpbmdcbi8vIGN1cnJlbnRseSB3b3JrcywgYnV0IGNvbnZlcnRpbmcgYSBTdHJpbmcgdG8gYSBCdWZmZXIgKHZpYSBgbmV3IEJ1ZmZlcmAsIG9yXG4vLyBCdWZmZXIjd3JpdGUpIHdpbGwgcmVwbGFjZSBpbmNvbXBsZXRlIHN1cnJvZ2F0ZXMgd2l0aCB0aGUgdW5pY29kZVxuLy8gcmVwbGFjZW1lbnQgY2hhcmFjdGVyLiBTZWUgaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy8xMjExNzMwMDkvIC5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciBjaGFyU3RyID0gJyc7XG4gIC8vIGlmIG91ciBsYXN0IHdyaXRlIGVuZGVkIHdpdGggYW4gaW5jb21wbGV0ZSBtdWx0aWJ5dGUgY2hhcmFjdGVyXG4gIHdoaWxlICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgcmVtYWluaW5nIGJ5dGVzIHRoaXMgYnVmZmVyIGhhcyB0byBvZmZlciBmb3IgdGhpcyBjaGFyXG4gICAgdmFyIGF2YWlsYWJsZSA9IChidWZmZXIubGVuZ3RoID49IHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkKSA/XG4gICAgICAgIHRoaXMuY2hhckxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkIDpcbiAgICAgICAgYnVmZmVyLmxlbmd0aDtcblxuICAgIC8vIGFkZCB0aGUgbmV3IGJ5dGVzIHRvIHRoZSBjaGFyIGJ1ZmZlclxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgdGhpcy5jaGFyUmVjZWl2ZWQsIDAsIGF2YWlsYWJsZSk7XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgKz0gYXZhaWxhYmxlO1xuXG4gICAgaWYgKHRoaXMuY2hhclJlY2VpdmVkIDwgdGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgICAvLyBzdGlsbCBub3QgZW5vdWdoIGNoYXJzIGluIHRoaXMgYnVmZmVyPyB3YWl0IGZvciBtb3JlIC4uLlxuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBieXRlcyBiZWxvbmdpbmcgdG8gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGZyb20gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZShhdmFpbGFibGUsIGJ1ZmZlci5sZW5ndGgpO1xuXG4gICAgLy8gZ2V0IHRoZSBjaGFyYWN0ZXIgdGhhdCB3YXMgc3BsaXRcbiAgICBjaGFyU3RyID0gdGhpcy5jaGFyQnVmZmVyLnNsaWNlKDAsIHRoaXMuY2hhckxlbmd0aCkudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG5cbiAgICAvLyBDRVNVLTg6IGxlYWQgc3Vycm9nYXRlIChEODAwLURCRkYpIGlzIGFsc28gdGhlIGluY29tcGxldGUgY2hhcmFjdGVyXG4gICAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGNoYXJTdHIubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCArPSB0aGlzLnN1cnJvZ2F0ZVNpemU7XG4gICAgICBjaGFyU3RyID0gJyc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdGhpcy5jaGFyUmVjZWl2ZWQgPSB0aGlzLmNoYXJMZW5ndGggPSAwO1xuXG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgYnl0ZXMgaW4gdGhpcyBidWZmZXIsIGp1c3QgZW1pdCBvdXIgY2hhclxuICAgIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gY2hhclN0cjtcbiAgICB9XG4gICAgYnJlYWs7XG4gIH1cblxuICAvLyBkZXRlcm1pbmUgYW5kIHNldCBjaGFyTGVuZ3RoIC8gY2hhclJlY2VpdmVkXG4gIHRoaXMuZGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKTtcblxuICB2YXIgZW5kID0gYnVmZmVyLmxlbmd0aDtcbiAgaWYgKHRoaXMuY2hhckxlbmd0aCkge1xuICAgIC8vIGJ1ZmZlciB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXIgYnl0ZXMgd2UgZ290XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoIC0gdGhpcy5jaGFyUmVjZWl2ZWQsIGVuZCk7XG4gICAgZW5kIC09IHRoaXMuY2hhclJlY2VpdmVkO1xuICB9XG5cbiAgY2hhclN0ciArPSBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgZW5kKTtcblxuICB2YXIgZW5kID0gY2hhclN0ci5sZW5ndGggLSAxO1xuICB2YXIgY2hhckNvZGUgPSBjaGFyU3RyLmNoYXJDb2RlQXQoZW5kKTtcbiAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICBpZiAoY2hhckNvZGUgPj0gMHhEODAwICYmIGNoYXJDb2RlIDw9IDB4REJGRikge1xuICAgIHZhciBzaXplID0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgIHRoaXMuY2hhckxlbmd0aCArPSBzaXplO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IHNpemU7XG4gICAgdGhpcy5jaGFyQnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCBzaXplLCAwLCBzaXplKTtcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIDAsIDAsIHNpemUpO1xuICAgIHJldHVybiBjaGFyU3RyLnN1YnN0cmluZygwLCBlbmQpO1xuICB9XG5cbiAgLy8gb3IganVzdCBlbWl0IHRoZSBjaGFyU3RyXG4gIHJldHVybiBjaGFyU3RyO1xufTtcblxuLy8gZGV0ZWN0SW5jb21wbGV0ZUNoYXIgZGV0ZXJtaW5lcyBpZiB0aGVyZSBpcyBhbiBpbmNvbXBsZXRlIFVURi04IGNoYXJhY3RlciBhdFxuLy8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYnVmZmVyLiBJZiBzbywgaXQgc2V0cyB0aGlzLmNoYXJMZW5ndGggdG8gdGhlIGJ5dGVcbi8vIGxlbmd0aCB0aGF0IGNoYXJhY3RlciwgYW5kIHNldHMgdGhpcy5jaGFyUmVjZWl2ZWQgdG8gdGhlIG51bWJlciBvZiBieXRlc1xuLy8gdGhhdCBhcmUgYXZhaWxhYmxlIGZvciB0aGlzIGNoYXJhY3Rlci5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmRldGVjdEluY29tcGxldGVDaGFyID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIC8vIGRldGVybWluZSBob3cgbWFueSBieXRlcyB3ZSBoYXZlIHRvIGNoZWNrIGF0IHRoZSBlbmQgb2YgdGhpcyBidWZmZXJcbiAgdmFyIGkgPSAoYnVmZmVyLmxlbmd0aCA+PSAzKSA/IDMgOiBidWZmZXIubGVuZ3RoO1xuXG4gIC8vIEZpZ3VyZSBvdXQgaWYgb25lIG9mIHRoZSBsYXN0IGkgYnl0ZXMgb2Ygb3VyIGJ1ZmZlciBhbm5vdW5jZXMgYW5cbiAgLy8gaW5jb21wbGV0ZSBjaGFyLlxuICBmb3IgKDsgaSA+IDA7IGktLSkge1xuICAgIHZhciBjID0gYnVmZmVyW2J1ZmZlci5sZW5ndGggLSBpXTtcblxuICAgIC8vIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VURi04I0Rlc2NyaXB0aW9uXG5cbiAgICAvLyAxMTBYWFhYWFxuICAgIGlmIChpID09IDEgJiYgYyA+PiA1ID09IDB4MDYpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDI7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTEwWFhYWFxuICAgIGlmIChpIDw9IDIgJiYgYyA+PiA0ID09IDB4MEUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDM7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyAxMTExMFhYWFxuICAgIGlmIChpIDw9IDMgJiYgYyA+PiAzID09IDB4MUUpIHtcbiAgICAgIHRoaXMuY2hhckxlbmd0aCA9IDQ7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBpO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKGJ1ZmZlciAmJiBidWZmZXIubGVuZ3RoKVxuICAgIHJlcyA9IHRoaXMud3JpdGUoYnVmZmVyKTtcblxuICBpZiAodGhpcy5jaGFyUmVjZWl2ZWQpIHtcbiAgICB2YXIgY3IgPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgICB2YXIgYnVmID0gdGhpcy5jaGFyQnVmZmVyO1xuICAgIHZhciBlbmMgPSB0aGlzLmVuY29kaW5nO1xuICAgIHJlcyArPSBidWYuc2xpY2UoMCwgY3IpLnRvU3RyaW5nKGVuYyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gcGFzc1Rocm91Z2hXcml0ZShidWZmZXIpIHtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcihidWZmZXIpIHtcbiAgdGhpcy5jaGFyUmVjZWl2ZWQgPSBidWZmZXIubGVuZ3RoICUgMjtcbiAgdGhpcy5jaGFyTGVuZ3RoID0gdGhpcy5jaGFyUmVjZWl2ZWQgPyAyIDogMDtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDM7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMyA6IDA7XG59XG5cbn0se1wiYnVmZmVyXCI6MjN9XSw0NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHB1bnljb2RlID0gX2RlcmVxXygncHVueWNvZGUnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlthLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFthLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gX2RlcmVxXygncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIGlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueSBjb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyB0aGUgcGFydCBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGFzIG5vbiBBU0NJSSBjaGFyYWN0ZXJzLiBJLmUuIGl0IGRvc2VudCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIGluIEFTQ0lJLlxuICAgICAgdmFyIGRvbWFpbkFycmF5ID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgICAgdmFyIG5ld091dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21haW5BcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcyA9IGRvbWFpbkFycmF5W2ldO1xuICAgICAgICBuZXdPdXQucHVzaChzLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID9cbiAgICAgICAgICAgICd4bi0tJyArIHB1bnljb2RlLmVuY29kZShzKSA6IHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5ob3N0bmFtZSA9IG5ld091dC5qb2luKCcuJyk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmIChpc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICBpc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAoaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIE9iamVjdC5rZXlzKHRoaXMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHJlc3VsdFtrXSA9IHRoaXNba107XG4gIH0sIHRoaXMpO1xuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgIH0pO1xuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QpICYmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHxcbiAgICAgIGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuICBhcmcgPT0gbnVsbDtcbn1cblxufSx7XCJwdW55Y29kZVwiOjMwLFwicXVlcnlzdHJpbmdcIjozM31dLDQ4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn1cbn0se31dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gX2RlcmVxXygnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IF9kZXJlcV8oJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG59KS5jYWxsKHRoaXMsX2RlcmVxXyhcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL3N1cHBvcnQvaXNCdWZmZXJcIjo0OCxcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjU1LFwiaW5oZXJpdHNcIjoyOH1dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBodHRwID0gbW9kdWxlLmV4cG9ydHM7XG52YXIgRXZlbnRFbWl0dGVyID0gX2RlcmVxXygnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIFJlcXVlc3QgPSBfZGVyZXFfKCcuL2xpYi9yZXF1ZXN0Jyk7XG52YXIgdXJsID0gX2RlcmVxXygndXJsJylcblxuaHR0cC5yZXF1ZXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyYW1zID0gdXJsLnBhcnNlKHBhcmFtcylcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMpIHBhcmFtcyA9IHt9O1xuICAgIGlmICghcGFyYW1zLmhvc3QgJiYgIXBhcmFtcy5wb3J0KSB7XG4gICAgICAgIHBhcmFtcy5wb3J0ID0gcGFyc2VJbnQod2luZG93LmxvY2F0aW9uLnBvcnQsIDEwKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbXMuaG9zdCAmJiBwYXJhbXMuaG9zdG5hbWUpIHtcbiAgICAgICAgcGFyYW1zLmhvc3QgPSBwYXJhbXMuaG9zdG5hbWU7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMucHJvdG9jb2wpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5zY2hlbWUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wcm90b2NvbCA9IHBhcmFtcy5zY2hlbWUgKyAnOic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMucHJvdG9jb2wgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2w7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5ob3N0KSB7XG4gICAgICAgIHBhcmFtcy5ob3N0ID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lIHx8IHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuICAgIH1cbiAgICBpZiAoLzovLnRlc3QocGFyYW1zLmhvc3QpKSB7XG4gICAgICAgIGlmICghcGFyYW1zLnBvcnQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5wb3J0ID0gcGFyYW1zLmhvc3Quc3BsaXQoJzonKVsxXTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMuaG9zdCA9IHBhcmFtcy5ob3N0LnNwbGl0KCc6JylbMF07XG4gICAgfVxuICAgIGlmICghcGFyYW1zLnBvcnQpIHBhcmFtcy5wb3J0ID0gcGFyYW1zLnByb3RvY29sID09ICdodHRwczonID8gNDQzIDogODA7XG4gICAgXG4gICAgdmFyIHJlcSA9IG5ldyBSZXF1ZXN0KG5ldyB4aHJIdHRwLCBwYXJhbXMpO1xuICAgIGlmIChjYikgcmVxLm9uKCdyZXNwb25zZScsIGNiKTtcbiAgICByZXR1cm4gcmVxO1xufTtcblxuaHR0cC5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICAgIHBhcmFtcy5tZXRob2QgPSAnR0VUJztcbiAgICB2YXIgcmVxID0gaHR0cC5yZXF1ZXN0KHBhcmFtcywgY2IpO1xuICAgIHJlcS5lbmQoKTtcbiAgICByZXR1cm4gcmVxO1xufTtcblxuaHR0cC5BZ2VudCA9IGZ1bmN0aW9uICgpIHt9O1xuaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cyA9IDQ7XG5cbnZhciB4aHJIdHRwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyB3aW5kb3cgb2JqZWN0IHByZXNlbnQnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAod2luZG93LlhNTEh0dHBSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuWE1MSHR0cFJlcXVlc3Q7XG4gICAgfVxuICAgIGVsc2UgaWYgKHdpbmRvdy5BY3RpdmVYT2JqZWN0KSB7XG4gICAgICAgIHZhciBheHMgPSBbXG4gICAgICAgICAgICAnTXN4bWwyLlhNTEhUVFAuNi4wJyxcbiAgICAgICAgICAgICdNc3htbDIuWE1MSFRUUC4zLjAnLFxuICAgICAgICAgICAgJ01pY3Jvc29mdC5YTUxIVFRQJ1xuICAgICAgICBdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgYXggPSBuZXcod2luZG93LkFjdGl2ZVhPYmplY3QpKGF4c1tpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXhfID0gYXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBheCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXhfO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyh3aW5kb3cuQWN0aXZlWE9iamVjdCkoYXhzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FqYXggbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhamF4IG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyk7XG4gICAgfVxufSkoKTtcblxuaHR0cC5TVEFUVVNfQ09ERVMgPSB7XG4gICAgMTAwIDogJ0NvbnRpbnVlJyxcbiAgICAxMDEgOiAnU3dpdGNoaW5nIFByb3RvY29scycsXG4gICAgMTAyIDogJ1Byb2Nlc3NpbmcnLCAgICAgICAgICAgICAgICAgLy8gUkZDIDI1MTgsIG9ic29sZXRlZCBieSBSRkMgNDkxOFxuICAgIDIwMCA6ICdPSycsXG4gICAgMjAxIDogJ0NyZWF0ZWQnLFxuICAgIDIwMiA6ICdBY2NlcHRlZCcsXG4gICAgMjAzIDogJ05vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uJyxcbiAgICAyMDQgOiAnTm8gQ29udGVudCcsXG4gICAgMjA1IDogJ1Jlc2V0IENvbnRlbnQnLFxuICAgIDIwNiA6ICdQYXJ0aWFsIENvbnRlbnQnLFxuICAgIDIwNyA6ICdNdWx0aS1TdGF0dXMnLCAgICAgICAgICAgICAgIC8vIFJGQyA0OTE4XG4gICAgMzAwIDogJ011bHRpcGxlIENob2ljZXMnLFxuICAgIDMwMSA6ICdNb3ZlZCBQZXJtYW5lbnRseScsXG4gICAgMzAyIDogJ01vdmVkIFRlbXBvcmFyaWx5JyxcbiAgICAzMDMgOiAnU2VlIE90aGVyJyxcbiAgICAzMDQgOiAnTm90IE1vZGlmaWVkJyxcbiAgICAzMDUgOiAnVXNlIFByb3h5JyxcbiAgICAzMDcgOiAnVGVtcG9yYXJ5IFJlZGlyZWN0JyxcbiAgICA0MDAgOiAnQmFkIFJlcXVlc3QnLFxuICAgIDQwMSA6ICdVbmF1dGhvcml6ZWQnLFxuICAgIDQwMiA6ICdQYXltZW50IFJlcXVpcmVkJyxcbiAgICA0MDMgOiAnRm9yYmlkZGVuJyxcbiAgICA0MDQgOiAnTm90IEZvdW5kJyxcbiAgICA0MDUgOiAnTWV0aG9kIE5vdCBBbGxvd2VkJyxcbiAgICA0MDYgOiAnTm90IEFjY2VwdGFibGUnLFxuICAgIDQwNyA6ICdQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZCcsXG4gICAgNDA4IDogJ1JlcXVlc3QgVGltZS1vdXQnLFxuICAgIDQwOSA6ICdDb25mbGljdCcsXG4gICAgNDEwIDogJ0dvbmUnLFxuICAgIDQxMSA6ICdMZW5ndGggUmVxdWlyZWQnLFxuICAgIDQxMiA6ICdQcmVjb25kaXRpb24gRmFpbGVkJyxcbiAgICA0MTMgOiAnUmVxdWVzdCBFbnRpdHkgVG9vIExhcmdlJyxcbiAgICA0MTQgOiAnUmVxdWVzdC1VUkkgVG9vIExhcmdlJyxcbiAgICA0MTUgOiAnVW5zdXBwb3J0ZWQgTWVkaWEgVHlwZScsXG4gICAgNDE2IDogJ1JlcXVlc3RlZCBSYW5nZSBOb3QgU2F0aXNmaWFibGUnLFxuICAgIDQxNyA6ICdFeHBlY3RhdGlvbiBGYWlsZWQnLFxuICAgIDQxOCA6ICdJXFwnbSBhIHRlYXBvdCcsICAgICAgICAgICAgICAvLyBSRkMgMjMyNFxuICAgIDQyMiA6ICdVbnByb2Nlc3NhYmxlIEVudGl0eScsICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNDIzIDogJ0xvY2tlZCcsICAgICAgICAgICAgICAgICAgICAgLy8gUkZDIDQ5MThcbiAgICA0MjQgOiAnRmFpbGVkIERlcGVuZGVuY3knLCAgICAgICAgICAvLyBSRkMgNDkxOFxuICAgIDQyNSA6ICdVbm9yZGVyZWQgQ29sbGVjdGlvbicsICAgICAgIC8vIFJGQyA0OTE4XG4gICAgNDI2IDogJ1VwZ3JhZGUgUmVxdWlyZWQnLCAgICAgICAgICAgLy8gUkZDIDI4MTdcbiAgICA0MjggOiAnUHJlY29uZGl0aW9uIFJlcXVpcmVkJywgICAgICAvLyBSRkMgNjU4NVxuICAgIDQyOSA6ICdUb28gTWFueSBSZXF1ZXN0cycsICAgICAgICAgIC8vIFJGQyA2NTg1XG4gICAgNDMxIDogJ1JlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2UnLC8vIFJGQyA2NTg1XG4gICAgNTAwIDogJ0ludGVybmFsIFNlcnZlciBFcnJvcicsXG4gICAgNTAxIDogJ05vdCBJbXBsZW1lbnRlZCcsXG4gICAgNTAyIDogJ0JhZCBHYXRld2F5JyxcbiAgICA1MDMgOiAnU2VydmljZSBVbmF2YWlsYWJsZScsXG4gICAgNTA0IDogJ0dhdGV3YXkgVGltZS1vdXQnLFxuICAgIDUwNSA6ICdIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZCcsXG4gICAgNTA2IDogJ1ZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzJywgICAgLy8gUkZDIDIyOTVcbiAgICA1MDcgOiAnSW5zdWZmaWNpZW50IFN0b3JhZ2UnLCAgICAgICAvLyBSRkMgNDkxOFxuICAgIDUwOSA6ICdCYW5kd2lkdGggTGltaXQgRXhjZWVkZWQnLFxuICAgIDUxMCA6ICdOb3QgRXh0ZW5kZWQnLCAgICAgICAgICAgICAgIC8vIFJGQyAyNzc0XG4gICAgNTExIDogJ05ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWQnIC8vIFJGQyA2NTg1XG59O1xufSx7XCIuL2xpYi9yZXF1ZXN0XCI6NTEsXCJldmVudHNcIjoyNyxcInVybFwiOjQ3fV0sNTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xudmFyIFN0cmVhbSA9IF9kZXJlcV8oJ3N0cmVhbScpO1xudmFyIFJlc3BvbnNlID0gX2RlcmVxXygnLi9yZXNwb25zZScpO1xudmFyIEJhc2U2NCA9IF9kZXJlcV8oJ0Jhc2U2NCcpO1xudmFyIGluaGVyaXRzID0gX2RlcmVxXygnaW5oZXJpdHMnKTtcblxudmFyIFJlcXVlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh4aHIsIHBhcmFtcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLnhociA9IHhocjtcbiAgICBzZWxmLmJvZHkgPSBbXTtcbiAgICBcbiAgICBzZWxmLnVyaSA9IChwYXJhbXMucHJvdG9jb2wgfHwgJ2h0dHA6JykgKyAnLy8nXG4gICAgICAgICsgcGFyYW1zLmhvc3RcbiAgICAgICAgKyAocGFyYW1zLnBvcnQgPyAnOicgKyBwYXJhbXMucG9ydCA6ICcnKVxuICAgICAgICArIChwYXJhbXMucGF0aCB8fCAnLycpXG4gICAgO1xuICAgIFxuICAgIGlmICh0eXBlb2YgcGFyYW1zLndpdGhDcmVkZW50aWFscyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGFyYW1zLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgdHJ5IHsgeGhyLndpdGhDcmVkZW50aWFscyA9IHBhcmFtcy53aXRoQ3JlZGVudGlhbHMgfVxuICAgIGNhdGNoIChlKSB7fVxuICAgIFxuICAgIGlmIChwYXJhbXMucmVzcG9uc2VUeXBlKSB0cnkgeyB4aHIucmVzcG9uc2VUeXBlID0gcGFyYW1zLnJlc3BvbnNlVHlwZSB9XG4gICAgY2F0Y2ggKGUpIHt9XG4gICAgXG4gICAgeGhyLm9wZW4oXG4gICAgICAgIHBhcmFtcy5tZXRob2QgfHwgJ0dFVCcsXG4gICAgICAgIHNlbGYudXJpLFxuICAgICAgICB0cnVlXG4gICAgKTtcblxuICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignTmV0d29yayBlcnJvcicpKTtcbiAgICB9O1xuXG4gICAgc2VsZi5faGVhZGVycyA9IHt9O1xuICAgIFxuICAgIGlmIChwYXJhbXMuaGVhZGVycykge1xuICAgICAgICB2YXIga2V5cyA9IG9iamVjdEtleXMocGFyYW1zLmhlYWRlcnMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCFzZWxmLmlzU2FmZVJlcXVlc3RIZWFkZXIoa2V5KSkgY29udGludWU7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBwYXJhbXMuaGVhZGVyc1trZXldO1xuICAgICAgICAgICAgc2VsZi5zZXRIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKHBhcmFtcy5hdXRoKSB7XG4gICAgICAgIC8vYmFzaWMgYXV0aFxuICAgICAgICB0aGlzLnNldEhlYWRlcignQXV0aG9yaXphdGlvbicsICdCYXNpYyAnICsgQmFzZTY0LmJ0b2EocGFyYW1zLmF1dGgpKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzID0gbmV3IFJlc3BvbnNlO1xuICAgIHJlcy5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXMub24oJ3JlYWR5JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLmVtaXQoJ3Jlc3BvbnNlJywgcmVzKTtcbiAgICB9KTtcblxuICAgIHJlcy5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuICAgIFxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZpeCBmb3IgSUU5IGJ1Z1xuICAgICAgICAvLyBTQ1JJUFQ1NzU6IENvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlxuICAgICAgICAvLyBJdCBoYXBwZW5zIHdoZW4gYSByZXF1ZXN0IGlzIGFib3J0ZWQsIGNhbGxpbmcgdGhlIHN1Y2Nlc3MgY2FsbGJhY2sgYW55d2F5IHdpdGggcmVhZHlTdGF0ZSA9PT0gNFxuICAgICAgICBpZiAoeGhyLl9fYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgICByZXMuaGFuZGxlKHhocik7XG4gICAgfTtcbn07XG5cbmluaGVyaXRzKFJlcXVlc3QsIFN0cmVhbSk7XG5cblJlcXVlc3QucHJvdG90eXBlLnNldEhlYWRlciA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5faGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUucmVtb3ZlSGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIGRlbGV0ZSB0aGlzLl9oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXVxufTtcblxuUmVxdWVzdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAocykge1xuICAgIHRoaXMuYm9keS5wdXNoKHMpO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgdGhpcy54aHIuX19hYm9ydGVkID0gdHJ1ZTtcbiAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMgIT09IHVuZGVmaW5lZCkgdGhpcy5ib2R5LnB1c2gocyk7XG5cbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXModGhpcy5faGVhZGVycyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9oZWFkZXJzW2tleV07XG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWx1ZVtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYm9keS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy54aHIuc2VuZCgnJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB0aGlzLmJvZHlbMF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMueGhyLnNlbmQodGhpcy5ib2R5LmpvaW4oJycpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNBcnJheSh0aGlzLmJvZHlbMF0pKSB7XG4gICAgICAgIHZhciBib2R5ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib2R5LnB1c2guYXBwbHkoYm9keSwgdGhpcy5ib2R5W2ldKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKGJvZHkpO1xuICAgIH1cbiAgICBlbHNlIGlmICgvQXJyYXkvLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMuYm9keVswXSkpKSB7XG4gICAgICAgIHZhciBsZW4gPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGVuICs9IHRoaXMuYm9keVtpXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSBuZXcodGhpcy5ib2R5WzBdLmNvbnN0cnVjdG9yKShsZW4pO1xuICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGIgPSB0aGlzLmJvZHlbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGIubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBib2R5W2srK10gPSBiW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMueGhyLnNlbmQoYm9keSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzWEhSMkNvbXBhdGlibGUodGhpcy5ib2R5WzBdKSkge1xuICAgICAgICB0aGlzLnhoci5zZW5kKHRoaXMuYm9keVswXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgYm9keSA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYm9keS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYm9keSArPSB0aGlzLmJvZHlbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnhoci5zZW5kKGJvZHkpO1xuICAgIH1cbn07XG5cbi8vIFRha2VuIGZyb20gaHR0cDovL2R4ci5tb3ppbGxhLm9yZy9tb3ppbGxhL21vemlsbGEtY2VudHJhbC9jb250ZW50L2Jhc2Uvc3JjL25zWE1MSHR0cFJlcXVlc3QuY3BwLmh0bWxcblJlcXVlc3QudW5zYWZlSGVhZGVycyA9IFtcbiAgICBcImFjY2VwdC1jaGFyc2V0XCIsXG4gICAgXCJhY2NlcHQtZW5jb2RpbmdcIixcbiAgICBcImFjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVyc1wiLFxuICAgIFwiYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2RcIixcbiAgICBcImNvbm5lY3Rpb25cIixcbiAgICBcImNvbnRlbnQtbGVuZ3RoXCIsXG4gICAgXCJjb29raWVcIixcbiAgICBcImNvb2tpZTJcIixcbiAgICBcImNvbnRlbnQtdHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcImRhdGVcIixcbiAgICBcImV4cGVjdFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwia2VlcC1hbGl2ZVwiLFxuICAgIFwib3JpZ2luXCIsXG4gICAgXCJyZWZlcmVyXCIsXG4gICAgXCJ0ZVwiLFxuICAgIFwidHJhaWxlclwiLFxuICAgIFwidHJhbnNmZXItZW5jb2RpbmdcIixcbiAgICBcInVwZ3JhZGVcIixcbiAgICBcInVzZXItYWdlbnRcIixcbiAgICBcInZpYVwiXG5dO1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5pc1NhZmVSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24gKGhlYWRlck5hbWUpIHtcbiAgICBpZiAoIWhlYWRlck5hbWUpIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gaW5kZXhPZihSZXF1ZXN0LnVuc2FmZUhlYWRlcnMsIGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKSkgPT09IC0xO1xufTtcblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBpbmRleE9mID0gZnVuY3Rpb24gKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxudmFyIGlzWEhSMkNvbXBhdGlibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcgJiYgb2JqIGluc3RhbmNlb2YgRm9ybURhdGEpIHJldHVybiB0cnVlO1xufTtcblxufSx7XCIuL3Jlc3BvbnNlXCI6NTIsXCJCYXNlNjRcIjo1MyxcImluaGVyaXRzXCI6NTQsXCJzdHJlYW1cIjo0NX1dLDUyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbnZhciBTdHJlYW0gPSBfZGVyZXFfKCdzdHJlYW0nKTtcbnZhciB1dGlsID0gX2RlcmVxXygndXRpbCcpO1xuXG52YXIgUmVzcG9uc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG59O1xuXG51dGlsLmluaGVyaXRzKFJlc3BvbnNlLCBTdHJlYW0pO1xuXG52YXIgY2FwYWJsZSA9IHtcbiAgICBzdHJlYW1pbmcgOiB0cnVlLFxuICAgIHN0YXR1czIgOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBwYXJzZUhlYWRlcnMgKHJlcykge1xuICAgIHZhciBsaW5lcyA9IHJlcy5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKS5zcGxpdCgvXFxyP1xcbi8pO1xuICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAobGluZSA9PT0gJycpIGNvbnRpbnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIG0gPSBsaW5lLm1hdGNoKC9eKFteOl0rKTpcXHMqKC4qKS8pO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IG1bMV0udG9Mb3dlckNhc2UoKSwgdmFsdWUgPSBtWzJdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGhlYWRlcnNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gWyBoZWFkZXJzW2tleV0sIHZhbHVlIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkZXJzW2xpbmVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuUmVzcG9uc2UucHJvdG90eXBlLmdldFJlc3BvbnNlID0gZnVuY3Rpb24gKHhocikge1xuICAgIHZhciByZXNwVHlwZSA9IFN0cmluZyh4aHIucmVzcG9uc2VUeXBlKS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChyZXNwVHlwZSA9PT0gJ2Jsb2InKSByZXR1cm4geGhyLnJlc3BvbnNlQmxvYiB8fCB4aHIucmVzcG9uc2U7XG4gICAgaWYgKHJlc3BUeXBlID09PSAnYXJyYXlidWZmZXInKSByZXR1cm4geGhyLnJlc3BvbnNlO1xuICAgIHJldHVybiB4aHIucmVzcG9uc2VUZXh0O1xufVxuXG5SZXNwb25zZS5wcm90b3R5cGUuZ2V0SGVhZGVyID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldO1xufTtcblxuUmVzcG9uc2UucHJvdG90eXBlLmhhbmRsZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICBpZiAocmVzLnJlYWR5U3RhdGUgPT09IDIgJiYgY2FwYWJsZS5zdGF0dXMyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdGF0dXMyID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChjYXBhYmxlLnN0YXR1czIpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjYXBhYmxlLnN0cmVhbWluZyAmJiByZXMucmVhZHlTdGF0ZSA9PT0gMykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NvZGUgPSByZXMuc3RhdHVzO1xuICAgICAgICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhyZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7fVxuICAgICAgICBcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXREYXRhKHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2FwYWJsZS5zdHJlYW1pbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChyZXMucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXNDb2RlID0gcmVzLnN0YXR1cztcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbWl0RGF0YShyZXMpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHJlcy5lcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHRoaXMuZ2V0UmVzcG9uc2UocmVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB0aGlzLmVtaXQoJ2VuZCcpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIH1cbn07XG5cblJlc3BvbnNlLnByb3RvdHlwZS5fZW1pdERhdGEgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgdmFyIHJlc3BCb2R5ID0gdGhpcy5nZXRSZXNwb25zZShyZXMpO1xuICAgIGlmIChyZXNwQm9keS50b1N0cmluZygpLm1hdGNoKC9BcnJheUJ1ZmZlci8pKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIG5ldyBVaW50OEFycmF5KHJlc3BCb2R5LCB0aGlzLm9mZnNldCkpO1xuICAgICAgICB0aGlzLm9mZnNldCA9IHJlc3BCb2R5LmJ5dGVMZW5ndGg7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlc3BCb2R5Lmxlbmd0aCA+IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHJlc3BCb2R5LnNsaWNlKHRoaXMub2Zmc2V0KSk7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gcmVzcEJvZHkubGVuZ3RoO1xuICAgIH1cbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbn0se1wic3RyZWFtXCI6NDUsXCJ1dGlsXCI6NDl9XSw1MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7XG47KGZ1bmN0aW9uICgpIHtcblxuICB2YXIgb2JqZWN0ID0gdHlwZW9mIGV4cG9ydHMgIT0gJ3VuZGVmaW5lZCcgPyBleHBvcnRzIDogdGhpczsgLy8gIzg6IHdlYiB3b3JrZXJzXG4gIHZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbiAgZnVuY3Rpb24gSW52YWxpZENoYXJhY3RlckVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG4gIEludmFsaWRDaGFyYWN0ZXJFcnJvci5wcm90b3R5cGUubmFtZSA9ICdJbnZhbGlkQ2hhcmFjdGVyRXJyb3InO1xuXG4gIC8vIGVuY29kZXJcbiAgLy8gW2h0dHBzOi8vZ2lzdC5naXRodWIuY29tLzk5OTE2Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9uaWduYWddXG4gIG9iamVjdC5idG9hIHx8IChcbiAgb2JqZWN0LmJ0b2EgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBmb3IgKFxuICAgICAgLy8gaW5pdGlhbGl6ZSByZXN1bHQgYW5kIGNvdW50ZXJcbiAgICAgIHZhciBibG9jaywgY2hhckNvZGUsIGlkeCA9IDAsIG1hcCA9IGNoYXJzLCBvdXRwdXQgPSAnJztcbiAgICAgIC8vIGlmIHRoZSBuZXh0IGlucHV0IGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgICAgLy8gICBjaGFuZ2UgdGhlIG1hcHBpbmcgdGFibGUgdG8gXCI9XCJcbiAgICAgIC8vICAgY2hlY2sgaWYgZCBoYXMgbm8gZnJhY3Rpb25hbCBkaWdpdHNcbiAgICAgIGlucHV0LmNoYXJBdChpZHggfCAwKSB8fCAobWFwID0gJz0nLCBpZHggJSAxKTtcbiAgICAgIC8vIFwiOCAtIGlkeCAlIDEgKiA4XCIgZ2VuZXJhdGVzIHRoZSBzZXF1ZW5jZSAyLCA0LCA2LCA4XG4gICAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgICApIHtcbiAgICAgIGNoYXJDb2RlID0gaW5wdXQuY2hhckNvZGVBdChpZHggKz0gMy80KTtcbiAgICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDaGFyYWN0ZXJFcnJvcihcIididG9hJyBmYWlsZWQ6IFRoZSBzdHJpbmcgdG8gYmUgZW5jb2RlZCBjb250YWlucyBjaGFyYWN0ZXJzIG91dHNpZGUgb2YgdGhlIExhdGluMSByYW5nZS5cIik7XG4gICAgICB9XG4gICAgICBibG9jayA9IGJsb2NrIDw8IDggfCBjaGFyQ29kZTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSk7XG5cbiAgLy8gZGVjb2RlclxuICAvLyBbaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTAyMDM5Nl0gYnkgW2h0dHBzOi8vZ2l0aHViLmNvbS9hdGtdXG4gIG9iamVjdC5hdG9iIHx8IChcbiAgb2JqZWN0LmF0b2IgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLz0rJC8sICcnKTtcbiAgICBpZiAoaW5wdXQubGVuZ3RoICUgNCA9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZENoYXJhY3RlckVycm9yKFwiJ2F0b2InIGZhaWxlZDogVGhlIHN0cmluZyB0byBiZSBkZWNvZGVkIGlzIG5vdCBjb3JyZWN0bHkgZW5jb2RlZC5cIik7XG4gICAgfVxuICAgIGZvciAoXG4gICAgICAvLyBpbml0aWFsaXplIHJlc3VsdCBhbmQgY291bnRlcnNcbiAgICAgIHZhciBiYyA9IDAsIGJzLCBidWZmZXIsIGlkeCA9IDAsIG91dHB1dCA9ICcnO1xuICAgICAgLy8gZ2V0IG5leHQgY2hhcmFjdGVyXG4gICAgICBidWZmZXIgPSBpbnB1dC5jaGFyQXQoaWR4KyspO1xuICAgICAgLy8gY2hhcmFjdGVyIGZvdW5kIGluIHRhYmxlPyBpbml0aWFsaXplIGJpdCBzdG9yYWdlIGFuZCBhZGQgaXRzIGFzY2lpIHZhbHVlO1xuICAgICAgfmJ1ZmZlciAmJiAoYnMgPSBiYyAlIDQgPyBicyAqIDY0ICsgYnVmZmVyIDogYnVmZmVyLFxuICAgICAgICAvLyBhbmQgaWYgbm90IGZpcnN0IG9mIGVhY2ggNCBjaGFyYWN0ZXJzLFxuICAgICAgICAvLyBjb252ZXJ0IHRoZSBmaXJzdCA4IGJpdHMgdG8gb25lIGFzY2lpIGNoYXJhY3RlclxuICAgICAgICBiYysrICUgNCkgPyBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgyNTUgJiBicyA+PiAoLTIgKiBiYyAmIDYpKSA6IDBcbiAgICApIHtcbiAgICAgIC8vIHRyeSB0byBmaW5kIGNoYXJhY3RlciBpbiB0YWJsZSAoMC02Mywgbm90IGZvdW5kID0+IC0xKVxuICAgICAgYnVmZmVyID0gY2hhcnMuaW5kZXhPZihidWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9KTtcblxufSgpKTtcblxufSx7fV0sNTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9X2RlcmVxXygyOClcbn0se1wiL2hvbWUvYWxleC9wcm9qZWN0cy9qYXZhc2NyaXB0L2ltanMvbm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcIjoyOH1dLDU1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbn0se31dLDU2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG52YXIgU3RyZWFtID0gX2RlcmVxXygnc3RyZWFtJylcblxuLy8gdGhyb3VnaFxuLy9cbi8vIGEgc3RyZWFtIHRoYXQgZG9lcyBub3RoaW5nIGJ1dCByZS1lbWl0IHRoZSBpbnB1dC5cbi8vIHVzZWZ1bCBmb3IgYWdncmVnYXRpbmcgYSBzZXJpZXMgb2YgY2hhbmdpbmcgYnV0IG5vdCBlbmRpbmcgc3RyZWFtcyBpbnRvIG9uZSBzdHJlYW0pXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHRocm91Z2hcbnRocm91Z2gudGhyb3VnaCA9IHRocm91Z2hcblxuLy9jcmVhdGUgYSByZWFkYWJsZSB3cml0YWJsZSBzdHJlYW0uXG5cbmZ1bmN0aW9uIHRocm91Z2ggKHdyaXRlLCBlbmQsIG9wdHMpIHtcbiAgd3JpdGUgPSB3cml0ZSB8fCBmdW5jdGlvbiAoZGF0YSkgeyB0aGlzLnF1ZXVlKGRhdGEpIH1cbiAgZW5kID0gZW5kIHx8IGZ1bmN0aW9uICgpIHsgdGhpcy5xdWV1ZShudWxsKSB9XG5cbiAgdmFyIGVuZGVkID0gZmFsc2UsIGRlc3Ryb3llZCA9IGZhbHNlLCBidWZmZXIgPSBbXSwgX2VuZGVkID0gZmFsc2VcbiAgdmFyIHN0cmVhbSA9IG5ldyBTdHJlYW0oKVxuICBzdHJlYW0ucmVhZGFibGUgPSBzdHJlYW0ud3JpdGFibGUgPSB0cnVlXG4gIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuXG4vLyAgc3RyZWFtLmF1dG9QYXVzZSAgID0gIShvcHRzICYmIG9wdHMuYXV0b1BhdXNlICAgPT09IGZhbHNlKVxuICBzdHJlYW0uYXV0b0Rlc3Ryb3kgPSAhKG9wdHMgJiYgb3B0cy5hdXRvRGVzdHJveSA9PT0gZmFsc2UpXG5cbiAgc3RyZWFtLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB3cml0ZS5jYWxsKHRoaXMsIGRhdGEpXG4gICAgcmV0dXJuICFzdHJlYW0ucGF1c2VkXG4gIH1cblxuICBmdW5jdGlvbiBkcmFpbigpIHtcbiAgICB3aGlsZShidWZmZXIubGVuZ3RoICYmICFzdHJlYW0ucGF1c2VkKSB7XG4gICAgICB2YXIgZGF0YSA9IGJ1ZmZlci5zaGlmdCgpXG4gICAgICBpZihudWxsID09PSBkYXRhKVxuICAgICAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2VuZCcpXG4gICAgICBlbHNlXG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB9XG4gIH1cblxuICBzdHJlYW0ucXVldWUgPSBzdHJlYW0ucHVzaCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4vLyAgICBjb25zb2xlLmVycm9yKGVuZGVkKVxuICAgIGlmKF9lbmRlZCkgcmV0dXJuIHN0cmVhbVxuICAgIGlmKGRhdGEgPT0gbnVsbCkgX2VuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgZHJhaW4oKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIC8vdGhpcyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgdGhlIGZpcnN0ICdlbmQnIGxpc3RlbmVyXG4gIC8vbXVzdCBjYWxsIGRlc3Ryb3kgbmV4dCB0aWNrLCB0byBtYWtlIHN1cmUgd2UncmUgYWZ0ZXIgYW55XG4gIC8vc3RyZWFtIHBpcGVkIGZyb20gaGVyZS5cbiAgLy90aGlzIGlzIG9ubHkgYSBwcm9ibGVtIGlmIGVuZCBpcyBub3QgZW1pdHRlZCBzeW5jaHJvbm91c2x5LlxuICAvL2EgbmljZXIgd2F5IHRvIGRvIHRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoaXMgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yICdlbmQnXG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBpZighc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hdXRvRGVzdHJveSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIF9lbmQgKCkge1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlXG4gICAgZW5kLmNhbGwoc3RyZWFtKVxuICAgIGlmKCFzdHJlYW0ucmVhZGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgc3RyZWFtLmVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoZW5kZWQpIHJldHVyblxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHN0cmVhbS53cml0ZShkYXRhKVxuICAgIF9lbmQoKSAvLyB3aWxsIGVtaXQgb3IgcXVldWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihkZXN0cm95ZWQpIHJldHVyblxuICAgIGRlc3Ryb3llZCA9IHRydWVcbiAgICBlbmRlZCA9IHRydWVcbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICAgIHN0cmVhbS53cml0YWJsZSA9IHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkgcmV0dXJuXG4gICAgc3RyZWFtLnBhdXNlZCA9IHRydWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuICAgICAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gICAgfVxuICAgIGRyYWluKClcbiAgICAvL21heSBoYXZlIGJlY29tZSBwYXVzZWQgYWdhaW4sXG4gICAgLy9hcyBkcmFpbiBlbWl0cyAnZGF0YScuXG4gICAgaWYoIXN0cmVhbS5wYXVzZWQpXG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cblxufSkuY2FsbCh0aGlzLF9kZXJlcV8oXCIvaG9tZS9hbGV4L3Byb2plY3RzL2phdmFzY3JpcHQvaW1qcy9ub2RlX21vZHVsZXMvaW5zZXJ0LW1vZHVsZS1nbG9iYWxzL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanNcIikpXG59LHtcIi9ob21lL2FsZXgvcHJvamVjdHMvamF2YXNjcmlwdC9pbWpzL25vZGVfbW9kdWxlcy9pbnNlcnQtbW9kdWxlLWdsb2JhbHMvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiOjU1LFwic3RyZWFtXCI6NDV9XX0se30sWzJdKSgyKVxufSk7XG59KSh3aW5kb3cuaW50ZXJtaW5lKTsiLCJ2YXIgY3ltaW5lID0ge1xuICB0b05vZGVzQW5kRWRnZXMgOiBmdW5jdGlvbihyZWNvcmRzLCBwYXJlbnROb2RlKXtcbiAgICB2YXIgZCA9IHtcbiAgICAgIG5vZGVzIDogW10sXG4gICAgICBlZGdlcyA6IFtdXG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgaW4gcmVjb3Jkcykge1xuICAgICAgdmFyIHRoaXNOb2RlLCByb3cgPSByZWNvcmRzW2ldO1xuICAgICAgdGhpc05vZGUgPSB0aGlzLnJlY29yZFRvTm9kZShyb3cpO1xuXG4gICAgICBpZihyb3cuaW50ZXJhY3Rpb25zKSB7XG4gICAgICAgIC8vcmVjdXJzaXZlbHkgbWFrZSB0aGUgaW50ZXJhY3Rpb25zIGludG8gbm9kZXMsXG4gICAgICAgIC8vYmVjYXVzZSBub2RlIGVudGl0aWVzIGFyZSBuZXN0ZWQgYXQgdHdvIGxldmVscy5cbiAgICAgICAgZCA9IHRoaXMubWVyZ2VPYmplY3RzKGQsIHRoaXMudG9Ob2Rlc0FuZEVkZ2VzKHJvdy5pbnRlcmFjdGlvbnMsIHRoaXNOb2RlKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2lmIGl0IGRvZXNuJ3QgaGF2ZSBhbiBpbnRlcmFjdGlvbiBsaXN0LCBpdCBwcm9iYWJseSAqaXMqIGFuIGludGVyYWN0aW9uXG4gICAgICAgIC8vYW5kIHRodXMgbmVlZHMgdG8gYmUgYW4gZWRnZVxuICAgICAgICBkLmVkZ2VzLnB1c2godGhpcy5pbnRlcmFjdGlvblRvRWRnZShwYXJlbnROb2RlLCB0aGlzTm9kZSkpO1xuXG4gICAgICB9XG4gICAgICBkLm5vZGVzLnB1c2godGhpc05vZGUpO1xuXG4gICAgfVxuXG4gICAgcmV0dXJuIGQ7XG4gIH0sXG4gIHJlY29yZFRvTm9kZSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgcmV0O1xuICAgIHJldCA9IG9iai5nZW5lMiA/IG9iai5nZW5lMiA6IG9iajtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSA6IHtcbiAgICAgICAgZGV0YWlscyA6IHRoaXMuYWRkRGV0YWlscyhvYmopLFxuICAgICAgICBsYWJlbCAgIDogdGhpcy5uYW1lTm9kZShvYmopLFxuICAgICAgICBjbGFzcyAgIDogcmV0LmNsYXNzLFxuICAgICAgICBzeW1ib2wgIDogcmV0LnN5bWJvbCxcbiAgICAgICAgaWQgOiByZXQub2JqZWN0SWQudG9TdHJpbmcoKSAvL2N5dG9zY2FwZSBuZWVkcyBzdHJpbmdzLCBub3QgaW50c1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYWRkRGV0YWlscyA6IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmouZGV0YWlscyA/IG9iai5kZXRhaWxzWzBdIDoge307XG4gIH0sXG4gIG5hbWVOb2RlIDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5nZW5lMiAmJiBvYmouZ2VuZTIuc3ltYm9sKSB7XG4gICAgICByZXR1cm4gb2JqLmdlbmUyLnN5bWJvbDtcbiAgICB9IGVsc2UgaWYgKG9iai5zeW1ib2wpIHtcbiAgICAgIHJldHVybiBvYmouc3ltYm9sO1xuICAgIH0gZWxzZSBpZiAob2JqLmRldGFpbHMpIHtcbiAgICAgIHJldHVybiBvYmouZGV0YWlsc1swXS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJOQU1FIE1JU1NJTkdcIlxuICAgIH1cbiAgfSxcbiAgaW50ZXJhY3Rpb25Ub0VkZ2UgOiBmdW5jdGlvbihub2RlLCBub2RlMikge1xuICAgIC8vdG9kbzogd2UgYWxtb3N0IGNlcnRhaW5seSB3YW50IHRvIGFkZCBtb3JlIGNvbXBsZXhpdHkgdG8gdGhlIHJldHVybiBvYmplY3RcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YSA6IHtcbiAgICAgICAgc291cmNlIDogbm9kZS5kYXRhLmlkLFxuICAgICAgICB0YXJnZXQgOiBub2RlMi5kYXRhLmlkXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgLyoqXG4gICogT3ZlcndyaXRlcyBvYmoxJ3MgdmFsdWVzIHdpdGggb2JqMidzIGFuZCBhZGRzIG9iajIncyBpZiBub24gZXhpc3RlbnQgaW4gb2JqMVxuICAqIEBwYXJhbSBvYmoxXG4gICogQHBhcmFtIG9iajJcbiAgKiBAcmV0dXJucyBvYmozIGEgbmV3IG9iamVjdCBiYXNlZCBvbiBvYmoxIGFuZCBvYmoyXG4gICovXG5cbiAgLy9UT0RPOiBtYWtlIHN1cmUgd2UgaGFuZGxlIGVkZ2UgY2FzZXMgYmV0dGVyLCBlLmcuIGR1cGxpY2F0ZSB2YWx1ZXMuXG4gIG1lcmdlT2JqZWN0cyA6IGZ1bmN0aW9uKG9iajEsb2JqMil7XG4gICAgdmFyIG9iajMgPSB7fTtcbiAgICBmb3IgKHZhciBhdHRybmFtZSBpbiBvYmoxKSB7IG9iajNbYXR0cm5hbWVdID0gb2JqMVthdHRybmFtZV07IH1cbiAgICBmb3IgKHZhciBhdHRybmFtZSBpbiBvYmoyKSB7IG9iajNbYXR0cm5hbWVdID0gb2JqMlthdHRybmFtZV07IH1cbiAgICByZXR1cm4gb2JqMztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGN5bWluZTtcbiIsInZhciBjeW1pbmUgPSByZXF1aXJlKCcuL2N5bWluZScpLFxuY3l0b3NjYXBlID0gcmVxdWlyZSgnLi8uLi9ib3dlcl9jb21wb25lbnRzL2N5dG9zY2FwZS9kaXN0L2N5dG9zY2FwZScpLFxuaW1qcyA9IHJlcXVpcmUoJy4vLi4vYm93ZXJfY29tcG9uZW50cy9pbWpzL2pzL2ltLmpzJyksXG5ub2RlRGF0YURpc3BsYXkgPSByZXF1aXJlKCcuL25vZGVEYXRhRGlzcGxheScpO1xuXG4vL1RvZG86IGdlbmVyaWZ5IHF1ZXJ5LlxudmFyIGN5LCBodW1hbm1pbmUgPSBuZXcgaW1qcy5TZXJ2aWNlKHtyb290OiAnd3d3Lmh1bWFubWluZS5vcmcvaHVtYW5taW5lJ30pLFxucXVlcnkgPSB7XG4gIFwibmFtZVwiOiBcIkdlbmVfSW50ZXJhY3Rpb25zXCIsXG4gIFwidGl0bGVcIjogXCJHZW5lIC0tPiBJbnRlcmFjdGlvbnNcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIlNob3cgYWxsIGludGVyYWN0aW9ucyBmb3IgYSBnaXZlbiBnZW5lLlwiLFxuICBcImNvbnN0cmFpbnRMb2dpY1wiOiBcIkEgYW5kIEJcIixcbiAgXCJmcm9tXCI6IFwiR2VuZVwiLFxuICBcInNlbGVjdFwiOiBbXG4gICAgXCJzeW1ib2xcIixcbiAgICBcImludGVyYWN0aW9ucy5nZW5lMi5zeW1ib2xcIixcbiAgICBcImludGVyYWN0aW9ucy5kZXRhaWxzLm5hbWVcIixcbiAgICBcImludGVyYWN0aW9ucy5kZXRhaWxzLnJvbGUxXCIsXG4gICAgXCJpbnRlcmFjdGlvbnMuZGV0YWlscy5yb2xlMlwiLFxuICAgIFwiaW50ZXJhY3Rpb25zLmRldGFpbHMudHlwZVwiLFxuICAgIFwiaW50ZXJhY3Rpb25zLmRldGFpbHMuZXhwZXJpbWVudC5pbnRlcmFjdGlvbkRldGVjdGlvbk1ldGhvZHMubmFtZVwiLFxuICAgIFwiaW50ZXJhY3Rpb25zLmRldGFpbHMuZXhwZXJpbWVudC5wdWJsaWNhdGlvbi5wdWJNZWRJZFwiLFxuICAgIFwiaW50ZXJhY3Rpb25zLmRldGFpbHMucmVsYXRpb25zaGlwVHlwZS5uYW1lXCIsXG4gICAgXCJpbnRlcmFjdGlvbnMuZGV0YWlscy5kYXRhU2V0cy5uYW1lXCJcbiAgXSxcbiAgXCJvcmRlckJ5XCI6IFtcbiAgICB7XG4gICAgICBcInBhdGhcIjogXCJzeW1ib2xcIixcbiAgICAgIFwiZGlyZWN0aW9uXCI6IFwiQVNDXCJcbiAgICB9XG4gIF0sXG4gIFwid2hlcmVcIjogW1xuICAgIHtcbiAgICAgIFwicGF0aFwiOiBcIkdlbmVcIixcbiAgICAgIFwib3BcIjogXCJMT09LVVBcIixcbiAgICAgIFwidmFsdWVcIjogXCJQUEFSR1wiLFxuICAgICAgXCJleHRyYVZhbHVlXCI6IFwiSC4gc2FwaWVuc1wiLFxuICAgICAgXCJjb2RlXCI6IFwiQVwiLFxuICAgICAgXCJlZGl0YWJsZVwiOiB0cnVlLFxuICAgICAgXCJzd2l0Y2hlZFwiOiBcIkxPQ0tFRFwiLFxuICAgICAgXCJzd2l0Y2hhYmxlXCI6IGZhbHNlXG4gICAgfVxuICBdXG59O1xuXG5odW1hbm1pbmUucmVjb3JkcyhxdWVyeSkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICBpZiAocmVzcG9uc2UpIHtcbiAgICB0cnkge1xuXG4gICAgICB2YXIgZ3JhcGggPSB7fTtcbiAgICAgICAgZ3JhcGguZGF0YSA9IGN5bWluZS50b05vZGVzQW5kRWRnZXMocmVzcG9uc2UpLFxuICAgICAgICBncmFwaC50YXJnZXRFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2N5JyksXG4gICAgICAgIGdyYXBoLnN0YXR1c0JhciA9IGdyYXBoLnRhcmdldEVsZW0ucXVlcnlTZWxlY3RvcignLnN0YXR1cycpO1xuXG4gICAgICBjb25zb2xlLmRlYnVnKCdyZXNwb25zZTonLCByZXNwb25zZSwgJ2dyYXBoIGRhdGEnLCBncmFwaC5kYXRhKTtcblxuICAgICAgY3kgPSBjeXRvc2NhcGUoe1xuICAgICAgICBjb250YWluZXI6IGdyYXBoLnRhcmdldEVsZW0sXG4gICAgICAgIGxheW91dDogeyBuYW1lOiAnY29zZSd9LFxuICAgICAgICBzdHlsZTogY3l0b3NjYXBlLnN0eWxlc2hlZXQoKVxuICAgIC5zZWxlY3Rvcignbm9kZScpXG4gICAgICAuY3NzKHtcbiAgICAgICAgJ2NvbnRlbnQnOiAnZGF0YShsYWJlbCknXG4gICAgICB9KVxuICAgIC5zZWxlY3RvcignOnNlbGVjdGVkJylcbiAgICAgIC5jc3Moe1xuICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICdsaW5lLWNvbG9yJzogJ2JsYWNrJyxcbiAgICAgICAgJ3RhcmdldC1hcnJvdy1jb2xvcic6ICdibGFjaycsXG4gICAgICAgICdzb3VyY2UtYXJyb3ctY29sb3InOiAnYmxhY2snLFxuICAgICAgICAndGV4dC1vdXRsaW5lLWNvbG9yJzogJ2JsYWNrJ1xuICAgICAgfSksXG4gICAgICAgIGVsZW1lbnRzOiBncmFwaC5kYXRhLFxuICAgICAgICByZWFkeTogZnVuY3Rpb24oKXtcbiAgICAgICAgICB3aW5kb3cuY3kgPSB0aGlzO1xuICAgICAgICAgIGdyYXBoLnN0YXR1c0Jhci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGN5Lm9uKCd0YXAnLCAnbm9kZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgIG5vZGVEYXRhRGlzcGxheS5kaXNwbGF5KHRoaXMuZGF0YSgpKTtcbiAgICAgIH0pO1xuXG5cbiAgICB9IGNhdGNoKGUpIHtjb25zb2xlLmVycm9yKGUpO31cbiAgfSBlbHNlIHtcbiAgICAvL3RvZG8gbWFrZSBzdXJlIGVycm9yIGhhbmRsaW5nIHdvcmtzXG4gICAgZ3JhcGguc3RhdHVzQmFyLmNsYXNzID0gXCJzdGF0dXMgbm8tcmVzdWx0c1wiO1xuICB9XG59KTtcbiIsInZhciBub2RlSW5mbyA9IHtcbiAgZGlzcGxheSA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB0aGlzLnRhcmdldEVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbm9kZURldGFpbHMnKSxcbiAgICBjb25zb2xlLmxvZyhub2RlKTtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuc2V0VGl0bGUoKTtcbiAgICB0aGlzLmxpc3RQcm9wZXJ0aWVzKCk7XG4gIH0sXG4gIHNldFRpdGxlIDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aXRsZSA9IG5vZGVJbmZvLnRhcmdldEVsZW0ucXVlcnlTZWxlY3RvcignLm5vZGVUaXRsZScpO1xuICAgIHRpdGxlLmlubmVySFRNTCA9IHRoaXMubm9kZS5sYWJlbDtcbiAgfSxcbiAgbGlzdFByb3BlcnRpZXMgOiBmdW5jdGlvbigpIHtcbiAgICAvL3RvZG86IG1ha2UgdGhpcyBtb3JlIHNhbmVcbiAgICB2YXIgZGlzcGxheSA9IHRoaXMuZXhwYW5kUHJvcGVydHlWYWxzKHRoaXMubm9kZSk7XG4gICAgbm9kZUluZm8udGFyZ2V0RWxlbS5xdWVyeVNlbGVjdG9yKCcubm9kZUluZm8nKS5pbm5lckhUTUwgPSBkaXNwbGF5O1xuICB9LFxuICBhZGRQcm9wZXJ0eSA6IGZ1bmN0aW9uKHByb3AsIGtleSkge1xuICAgIHJldHVybiAnPGI+ICcgKyBrZXkgKyAnPC9iPjogJyArIHByb3Bba2V5XSArIFwiPGJyIC8+XCI7XG4gIH0sXG4gIGV4cGFuZFByb3BlcnR5VmFscyA6IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBkaXNwbGF5ID0gXCJcIjtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgaWYodHlwZW9mIG9ialtwcm9wXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkaXNwbGF5ICs9IHRoaXMuYWRkUHJvcGVydHkodGhpcy5leHBhbmRQcm9wZXJ0eVZhbHMob2JqW3Byb3BdKSwgcHJvcCk7XG4gICAgICAgIGNvbnNvbGUubG9nKCdvYmplY3Q6Jywgb2JqW3Byb3BdLCAncHJvcDonLCBwcm9wKTtcbiAgICAgIH0gZWxzZXtcbiAgICAgICAgZGlzcGxheSArPSB0aGlzLmFkZFByb3BlcnR5KG9iaiwgcHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXNwbGF5O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVJbmZvO1xuIl19
